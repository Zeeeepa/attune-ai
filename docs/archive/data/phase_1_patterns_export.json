{
  "version": "1.0.0",
  "phase": "Phase 1 Complete - Ready for Phase 2",
  "patterns": [
    {
      "id": "pattern_1_string_id_validation",
      "type": "input_validation",
      "name": "String ID Validation",
      "description": "Validate string ID parameters are non-empty and non-whitespace",
      "context": {
        "trigger": "Method with parameter like agent_id: str, user_id: str, pattern_id: str",
        "applicable_to": [
          "Library",
          "API",
          "CLI"
        ],
        "priority": "MEDIUM",
        "discovered_in": "pattern_library.py",
        "auto_fixable": true
      },
      "tags": [
        "validation",
        "input",
        "string",
        "id"
      ],
      "code": "# Check for empty or whitespace-only strings\nif not agent_id or not agent_id.strip():\n    raise ValueError(\"agent_id cannot be empty\")",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_2_duplicate_key_prevention",
      "type": "data_integrity",
      "name": "Duplicate Key Prevention",
      "description": "Prevent duplicate keys when adding to dictionaries",
      "context": {
        "trigger": "Adding to dictionary without checking if key exists",
        "applicable_to": [
          "Library",
          "API"
        ],
        "priority": "MEDIUM",
        "discovered_in": "pattern_library.py",
        "auto_fixable": true
      },
      "tags": [
        "dictionary",
        "duplicate",
        "data-integrity"
      ],
      "code": "# Check for duplicates before adding\nif pattern.id in self.patterns:\n    raise ValueError(\n        f\"Pattern '{pattern.id}' already exists. \"\n        f\"Use a different ID or remove the existing pattern first.\"\n    )\nself.patterns[pattern.id] = pattern",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_3_cycle_safe_recursion",
      "type": "algorithm_correctness",
      "name": "Cycle-Safe Recursion",
      "description": "Add cycle detection to recursive graph/tree traversal",
      "context": {
        "trigger": "Recursive method traversing graph structures without cycle detection",
        "applicable_to": [
          "Library"
        ],
        "priority": "MEDIUM",
        "discovered_in": "pattern_library.py",
        "auto_fixable": false,
        "risk": "Infinite recursion if cycles exist"
      },
      "tags": [
        "recursion",
        "graph",
        "cycle-detection",
        "algorithm"
      ],
      "code": "def get_related_patterns(\n    self,\n    pattern_id: str,\n    depth: int = 1,\n    _visited: set[str] | None = None\n) -> list[Pattern]:\n    # Initialize visited set on first call\n    if _visited is None:\n        _visited = {pattern_id}\n\n    if depth <= 0 or pattern_id not in self.pattern_graph:\n        return []\n\n    related_ids = set(self.pattern_graph[pattern_id])\n\n    if depth > 1:\n        for related_id in list(related_ids):\n            # Check visited BEFORE recursing\n            if related_id not in _visited:\n                _visited.add(related_id)\n                deeper = self.get_related_patterns(related_id, depth - 1, _visited)\n                related_ids.update(p.id for p in deeper)\n\n    return [self.patterns[pid] for pid in related_ids if pid in self.patterns]",
      "confidence": 0.9,
      "success_rate": 0.0
    },
    {
      "id": "pattern_4_range_validation",
      "type": "input_validation",
      "name": "Range Validation",
      "description": "Validate float parameters are within expected range (0-1 for probabilities)",
      "context": {
        "trigger": "Float parameter representing probability, confidence, or percentage",
        "applicable_to": [
          "Library",
          "API",
          "CLI"
        ],
        "priority": "MEDIUM",
        "discovered_in": "pattern_library.py",
        "auto_fixable": true
      },
      "tags": [
        "validation",
        "range",
        "probability",
        "confidence"
      ],
      "code": "# Validate probability/confidence is in [0, 1]\nif not 0.0 <= min_confidence <= 1.0:\n    raise ValueError(f\"min_confidence must be 0-1, got {min_confidence}\")",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_5_type_validation",
      "type": "input_validation",
      "name": "Type Validation",
      "description": "Validate complex type parameters (dict, list, set)",
      "context": {
        "trigger": "Method accepting dict, list, or complex types without validation",
        "applicable_to": [
          "Library",
          "API",
          "CLI"
        ],
        "priority": "LOW",
        "discovered_in": "pattern_library.py",
        "auto_fixable": true
      },
      "tags": [
        "validation",
        "type",
        "isinstance"
      ],
      "code": "# Validate type before using\nif not isinstance(context, dict):\n    raise TypeError(f\"context must be dict, got {type(context).__name__}\")",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_6_file_path_validation",
      "type": "security_path_traversal",
      "name": "File Path Validation",
      "description": "Validate file paths to prevent path traversal attacks",
      "context": {
        "trigger": "open(path) or Path(path) with user-provided path",
        "applicable_to": [
          "API",
          "CLI",
          "Workflows"
        ],
        "priority": "CRITICAL",
        "discovered_in": "control_panel.py",
        "auto_fixable": true,
        "security_impact": "CRITICAL",
        "prevents": [
          "Path traversal attacks (../../../etc/passwd)",
          "Arbitrary file writes",
          "System directory modifications",
          "Null byte injection"
        ]
      },
      "tags": [
        "security",
        "path-traversal",
        "file-io",
        "validation"
      ],
      "code": "def _validate_file_path(path: str, allowed_dir: str | None = None) -> Path:\n    '''Validate file path to prevent path traversal and arbitrary writes.'''\n    if not path or not isinstance(path, str):\n        raise ValueError(\"path must be a non-empty string\")\n\n    # Check for null bytes\n    if \"\\x00\" in path:\n        raise ValueError(\"path contains null bytes\")\n\n    try:\n        resolved = Path(path).resolve()\n    except (OSError, RuntimeError) as e:\n        raise ValueError(f\"Invalid path: {e}\")\n\n    # Check if within allowed directory\n    if allowed_dir:\n        try:\n            allowed = Path(allowed_dir).resolve()\n            resolved.relative_to(allowed)\n        except ValueError:\n            raise ValueError(f\"path must be within {allowed_dir}\")\n\n    # Check for dangerous system paths\n    dangerous_paths = [\"/etc\", \"/sys\", \"/proc\", \"/dev\"]\n    for dangerous in dangerous_paths:\n        if str(resolved).startswith(dangerous):\n            raise ValueError(f\"Cannot write to system directory: {dangerous}\")\n\n    return resolved\n\n# Usage:\nvalidated_path = _validate_file_path(args.output)\nwith open(validated_path, 'w') as f:\n    f.write(data)",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_7_validation_integration",
      "type": "architecture_defensive",
      "name": "Validation Integration",
      "description": "Ensure all validation helpers are called at method entry",
      "context": {
        "trigger": "Public method in API/server code without centralized validation",
        "applicable_to": [
          "API",
          "CLI"
        ],
        "priority": "HIGH",
        "discovered_in": "control_panel.py",
        "auto_fixable": false
      },
      "tags": [
        "validation",
        "architecture",
        "api",
        "defensive"
      ],
      "code": "def delete_pattern(self, pattern_id: str, user_id: str) -> bool:\n    '''Delete pattern with comprehensive input validation.'''\n\n    # Validate ALL inputs at method entry\n    if not _validate_pattern_id(pattern_id):\n        raise ValueError(f\"Invalid pattern_id format: {pattern_id}\")\n\n    if not _validate_agent_id(user_id):\n        raise ValueError(f\"Invalid user_id format: {user_id}\")\n\n    # Business logic here (after validation)\n    long_term = self._get_long_term()\n    try:\n        return long_term.delete_pattern(pattern_id, user_id)\n    except Exception as e:\n        logger.error(\"delete_pattern_failed\", pattern_id=pattern_id, error=str(e))\n        return False  # Graceful degradation",
      "confidence": 0.8,
      "success_rate": 0.0
    },
    {
      "id": "pattern_8_stats_error_handling",
      "type": "reliability_graceful_degradation",
      "name": "Stats Error Handling",
      "description": "Gracefully handle errors in stats/metrics collection (best effort)",
      "context": {
        "trigger": "Operations collecting metrics/stats that may fail",
        "applicable_to": [
          "API",
          "Monitoring",
          "Telemetry"
        ],
        "priority": "MEDIUM",
        "discovered_in": "control_panel.py",
        "auto_fixable": true,
        "pattern": "Log error + return default/False, don't crash"
      },
      "tags": [
        "error-handling",
        "stats",
        "metrics",
        "graceful-degradation"
      ],
      "code": "def get_statistics(self) -> MemoryStats | None:\n    '''Get statistics with graceful degradation on errors.'''\n    try:\n        redis_stats = self._redis.info(\"memory\")\n        return MemoryStats(\n            total_keys=redis_stats.get(\"keys\", 0),\n            memory_used_mb=redis_stats.get(\"used_memory\", 0) / (1024 * 1024)\n        )\n    except Exception as e:\n        logger.error(\"stats_collection_failed\", error=str(e))\n        return None  # Best effort - don't crash",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_9_cli_argument_validation",
      "type": "security_input_sanitization",
      "name": "CLI Argument Validation",
      "description": "Validate CLI arguments from argparse before use in file operations",
      "context": {
        "trigger": "args.param from argparse used in file operations or system calls",
        "applicable_to": [
          "CLI"
        ],
        "priority": "HIGH",
        "discovered_in": "cli.py",
        "auto_fixable": true,
        "security_impact": "HIGH"
      },
      "tags": [
        "cli",
        "argparse",
        "validation",
        "security"
      ],
      "code": "def cmd_init(args):\n    '''Initialize project with validated arguments.\n\n    Raises:\n        ValueError: If output path is invalid or unsafe\n    '''\n    config_format = args.format\n    output_path = args.output or f\"attune.config.{config_format}\"\n\n    # Validate output path to prevent path traversal attacks\n    validated_path = _validate_file_path(output_path)\n\n    logger.info(f\"Initializing project with format: {config_format}\")\n\n    config = EmpathyConfig()\n    if config_format == \"yaml\":\n        config.to_yaml(str(validated_path))\n    elif config_format == \"json\":\n        config.to_json(str(validated_path))",
      "confidence": 1.0,
      "success_rate": 0.0
    },
    {
      "id": "pattern_10_subprocess_safety",
      "type": "security_command_injection",
      "name": "Subprocess Safety Audit",
      "description": "Prevent command injection by using array form with shell=False",
      "context": {
        "trigger": "subprocess.run(), os.system(), shell=True with user input",
        "applicable_to": [
          "CLI",
          "Workflows",
          "Backend"
        ],
        "priority": "CRITICAL",
        "discovered_in": "cli.py",
        "auto_fixable": false,
        "security_impact": "CRITICAL",
        "prevents": [
          "Command injection attacks",
          "Shell escape attacks",
          "Arbitrary command execution"
        ]
      },
      "tags": [
        "security",
        "subprocess",
        "command-injection",
        "shell"
      ],
      "code": "# UNSAFE - DO NOT USE:\nimport os\nuser_message = args.message\nos.system(f\"git commit -m '{user_message}'\")  # INJECTION RISK!\n\n# SAFE - Use array form:\nimport subprocess\nuser_message = args.message\nsubprocess.run(\n    [\"git\", \"commit\", \"-m\", user_message],  # Array form\n    shell=False,  # Never True with user input\n    check=True\n)",
      "confidence": 0.7,
      "success_rate": 0.0
    }
  ],
  "stats": {
    "total_patterns": 10,
    "total_agents": 1,
    "total_usage": 0,
    "average_confidence": 0.9399999999999998,
    "average_success_rate": 0.0,
    "patterns_by_type": {
      "input_validation": 3,
      "data_integrity": 1,
      "algorithm_correctness": 1,
      "security_path_traversal": 1,
      "architecture_defensive": 1,
      "reliability_graceful_degradation": 1,
      "security_input_sanitization": 1,
      "security_command_injection": 1
    }
  }
}
