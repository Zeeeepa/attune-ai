# User-Centric Improvements Implementation Plan

**Created:** December 26, 2025
**Status:** Planning
**Approach:** Option D (User Journey) + Option B (Parallel Phase 1)

---

## Overview

This plan implements three major improvements to the Empathy Framework:

| Phase | Feature | Priority | Effort |
|-------|---------|----------|--------|
| 1A | Interactive Onboarding Wizard | High | Medium |
| 1B | Pre-flight Checks & Live Progress | High | Medium |
| 2 | Interactive Results Panel (test-gen) | High | Large |
| 3 | Enterprise Orchestration (LangGraph + CrewAI) | Medium | Large |

Phase 1A and 1B run in parallel. Phase 2 follows. Phase 3 is enterprise tier.

---

## Resolved Design Decisions

| Decision | Choice | Rationale |
| -------- | ------ | --------- |
| Tokenizer | tiktoken | Accuracy matters for cost trust; ~5MB acceptable |
| Progress Transport | WebSocket | Real-time UX, enables future collaborative features |
| Checklist Storage | `.empathy/checklists/` | Team visibility, git-trackable, CLI accessible |

---

## Phase 1A: Interactive Onboarding Wizard

### Goal
New users productive in <5 minutes with guided setup.

### What Exists
- VS Code extension with 21 commands, 3 webview panels
- `context.secrets` API available (not currently used)
- Configuration system via `vscode.workspace.getConfiguration('empathy')`
- File I/O patterns for `.empathy/` directory
- Python CLI: `python -m empathy_os.models.cli provider`

### Implementation

#### 1. New Command: `empathy.initializeProject`

**File:** `vscode-extension/src/commands/initializeProject.ts`

```typescript
export async function initializeProject(context: vscode.ExtensionContext) {
  // Check if already initialized
  const initialized = context.globalState.get('empathy.initialized');
  if (initialized) {
    const proceed = await vscode.window.showWarningMessage(
      'Project already initialized. Reinitialize?',
      'Yes', 'No'
    );
    if (proceed !== 'Yes') return;
  }

  // Launch wizard webview
  InitializeWizardPanel.createOrShow(context);
}
```

#### 2. Wizard Webview Panel

**File:** `vscode-extension/src/panels/InitializeWizardPanel.ts`

**Steps:**
1. **Welcome** - Brief intro, what will be configured
2. **Provider Selection** - Radio buttons: Anthropic, OpenAI, Ollama (local), Hybrid
3. **API Key Entry** - Secure input, validate key format
4. **Model Preferences** - Optional tier overrides
5. **Generate Config** - Create `empathy.config.yml`
6. **First Run** - Optional: run hello_empathy.py demo

**Message Types:**
```typescript
type WizardMessage =
  | { type: 'selectProvider'; provider: string }
  | { type: 'setApiKey'; provider: string; key: string }
  | { type: 'setTierPreference'; tier: string; model: string }
  | { type: 'generateConfig' }
  | { type: 'runDemo' }
  | { type: 'complete' };
```

#### 3. Secure Key Storage

```typescript
// Store API key securely
await context.secrets.store(`empathy.${provider}.apiKey`, apiKey);

// Retrieve for config generation
const key = await context.secrets.get(`empathy.${provider}.apiKey`);
```

#### 4. Config File Generation

**Template:** `empathy.config.yml`
```yaml
# Generated by Empathy Initialize Wizard
# Date: {{timestamp}}

provider: {{provider}}
model_preferences:
  cheap: {{cheap_model}}
  capable: {{capable_model}}
  premium: {{premium_model}}

# API key stored securely in VS Code secrets
# Access via: empathy.{{provider}}.apiKey
```

#### 5. Hello Empathy Demo

**File:** `hello_empathy.py` (generated in workspace)
```python
"""Your first Empathy workflow - generated by Initialize Wizard."""
from empathy_os.workflows import SecurityAuditWorkflow

# Run a quick security scan on this file
workflow = SecurityAuditWorkflow()
result = workflow.run(target=".")

print(f"✓ Scan complete! Found {len(result.findings)} items.")
print(f"  Cost: ${result.cost_report.total_cost:.4f}")
```

#### 6. Registration in package.json

```json
{
  "commands": [
    {
      "command": "empathy.initializeProject",
      "title": "Empathy: Initialize Project",
      "icon": "$(rocket)"
    }
  ]
}
```

### Files to Create/Modify

| File | Action |
|------|--------|
| `vscode-extension/src/panels/InitializeWizardPanel.ts` | Create |
| `vscode-extension/src/commands/initializeProject.ts` | Create |
| `vscode-extension/src/extension.ts` | Add command registration |
| `vscode-extension/package.json` | Add command contribution |
| `vscode-extension/src/templates/hello_empathy.py` | Create template |
| `vscode-extension/src/templates/empathy.config.yml` | Create template |

---

## Phase 1B: Pre-flight Checks & Live Progress

### Goal
Users see estimated cost before running, and live progress during execution.

### What Exists
- `MODEL_REGISTRY` with complete pricing
- `estimate_cost(task_type, input_tokens, output_tokens)` method
- `WorkflowStepConfig` for stage definitions
- `ResilientExecutor` with fallback status tracking
- `TelemetryStore` for recording calls
- Cost tracking in `CostTracker`

### What's Missing
- Token estimation before execution
- Progress callback system
- Live UI updates during workflow

### Implementation

#### 1. Token Estimation Service

**File:** `src/empathy_os/models/token_estimator.py`

```python
"""Pre-flight token estimation for cost prediction."""

# Heuristic: ~4 tokens per word, ~0.75 words per character
TOKENS_PER_CHAR = 0.25  # Conservative estimate

def estimate_tokens(text: str) -> int:
    """Estimate token count without tokenizer."""
    return max(1, int(len(text) * TOKENS_PER_CHAR))

def estimate_workflow_cost(
    workflow_name: str,
    input_text: str,
    provider: str = "anthropic"
) -> dict:
    """Estimate total workflow cost before execution."""
    from .registry import get_model
    from ..workflows.config import get_workflow_config

    config = get_workflow_config(workflow_name)
    stages = config.get("stages", [])

    input_tokens = estimate_tokens(input_text)
    estimates = []
    total_min = 0.0
    total_max = 0.0

    for stage in stages:
        tier = stage.get("tier", "capable")
        model = get_model(provider, tier)

        # Estimate output tokens (varies by stage type)
        output_multiplier = {
            "identify": 0.3,
            "analyze": 0.8,
            "generate": 2.0,
            "review": 0.5,
        }.get(stage["name"], 1.0)

        est_output = int(input_tokens * output_multiplier)

        cost = (
            (input_tokens / 1_000_000) * model.input_cost_per_million +
            (est_output / 1_000_000) * model.output_cost_per_million
        )

        estimates.append({
            "stage": stage["name"],
            "tier": tier,
            "model": model.id,
            "estimated_tokens": input_tokens + est_output,
            "estimated_cost": cost,
        })

        # Accumulate with 20% variance
        total_min += cost * 0.8
        total_max += cost * 1.2

    return {
        "workflow": workflow_name,
        "provider": provider,
        "input_tokens": input_tokens,
        "stages": estimates,
        "total_min": total_min,
        "total_max": total_max,
        "display": f"${total_min:.3f} - ${total_max:.3f}",
        "risk": "high" if total_max > 1.0 else "medium" if total_max > 0.1 else "low",
    }
```

#### 2. Progress Callback System

**File:** `src/empathy_os/workflows/progress.py`

```python
"""Progress tracking for workflow execution."""
from dataclasses import dataclass
from typing import Callable, Optional
from enum import Enum

class ProgressStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    FALLBACK = "fallback"

@dataclass
class ProgressUpdate:
    workflow: str
    current_stage: str
    stage_index: int
    total_stages: int
    status: ProgressStatus
    message: str
    cost_so_far: float = 0.0
    tokens_so_far: int = 0
    fallback_info: Optional[str] = None

ProgressCallback = Callable[[ProgressUpdate], None]

class ProgressTracker:
    """Tracks and broadcasts workflow progress."""

    def __init__(self, workflow_name: str, stages: list[str]):
        self.workflow = workflow_name
        self.stages = stages
        self.current_index = 0
        self.callbacks: list[ProgressCallback] = []
        self.cost_accumulated = 0.0
        self.tokens_accumulated = 0

    def add_callback(self, callback: ProgressCallback):
        self.callbacks.append(callback)

    def start_stage(self, stage_name: str):
        self._emit(ProgressStatus.RUNNING, f"Running {stage_name}...")

    def complete_stage(self, stage_name: str, cost: float, tokens: int):
        self.cost_accumulated += cost
        self.tokens_accumulated += tokens
        self.current_index += 1
        self._emit(ProgressStatus.COMPLETED, f"Completed {stage_name}")

    def fallback_occurred(self, original: str, fallback: str, reason: str):
        self._emit(
            ProgressStatus.FALLBACK,
            f"Falling back from {original} to {fallback}",
            fallback_info=f"{reason}: {original} → {fallback}"
        )

    def _emit(self, status: ProgressStatus, message: str, **kwargs):
        update = ProgressUpdate(
            workflow=self.workflow,
            current_stage=self.stages[min(self.current_index, len(self.stages)-1)],
            stage_index=self.current_index,
            total_stages=len(self.stages),
            status=status,
            message=message,
            cost_so_far=self.cost_accumulated,
            tokens_so_far=self.tokens_accumulated,
            **kwargs
        )
        for callback in self.callbacks:
            callback(update)
```

#### 3. Integrate Progress into BaseWorkflow

**File:** `src/empathy_os/workflows/base.py` (modifications)

```python
class BaseWorkflow:
    def __init__(self, ..., progress_callback: Optional[ProgressCallback] = None):
        self.progress_tracker = None
        if progress_callback:
            self.progress_tracker = ProgressTracker(
                self.name,
                [s.name for s in self.steps]
            )
            self.progress_tracker.add_callback(progress_callback)

    async def _run_stage(self, stage: WorkflowStage, ...):
        if self.progress_tracker:
            self.progress_tracker.start_stage(stage.name)

        result = await self._execute_with_resilience(...)

        if self.progress_tracker:
            self.progress_tracker.complete_stage(
                stage.name,
                result.cost,
                result.tokens
            )

        return result
```

#### 4. VS Code Integration

**File:** `vscode-extension/src/services/WorkflowService.ts`

```typescript
interface WorkflowProgress {
  workflow: string;
  currentStage: string;
  stageIndex: number;
  totalStages: number;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'fallback';
  message: string;
  costSoFar: number;
  tokensSoFar: number;
  fallbackInfo?: string;
}

class WorkflowService {
  async estimateCost(workflow: string, input: string): Promise<CostEstimate> {
    // Call Python: python -m empathy_os.models.token_estimator ...
  }

  async runWithProgress(
    workflow: string,
    input: string,
    onProgress: (p: WorkflowProgress) => void
  ): Promise<WorkflowResult> {
    // Spawn workflow process with progress streaming
    // Parse JSON lines from stdout for progress updates
  }
}
```

#### 5. Dashboard UI Updates

**In EmpathyDashboardPanel.ts workflows tab:**

```html
<!-- Pre-run cost estimate -->
<div class="cost-estimate">
  <span class="estimate-label">Estimated cost:</span>
  <span class="estimate-value">${estimate.display}</span>
  <span class="estimate-risk risk-${estimate.risk}">${estimate.risk}</span>
</div>

<!-- Live progress during run -->
<div class="workflow-progress">
  <div class="progress-bar">
    <div class="progress-fill" style="width: ${progress.percentage}%"></div>
  </div>
  <div class="progress-stages">
    ${stages.map((s, i) => `
      <div class="stage ${i < current ? 'completed' : i === current ? 'running' : 'pending'}">
        ${s.name}
      </div>
    `).join('')}
  </div>
  <div class="progress-status">
    ${progress.message}
    ${progress.fallbackInfo ? `<span class="fallback-notice">${progress.fallbackInfo}</span>` : ''}
  </div>
  <div class="progress-cost">
    Cost so far: $${progress.costSoFar.toFixed(4)}
  </div>
</div>
```

### Files to Create/Modify

| File | Action |
|------|--------|
| `src/empathy_os/models/token_estimator.py` | Create |
| `src/empathy_os/workflows/progress.py` | Create |
| `src/empathy_os/workflows/base.py` | Add progress hooks |
| `vscode-extension/src/services/WorkflowService.ts` | Create |
| `vscode-extension/src/panels/EmpathyDashboardPanel.ts` | Add progress UI |

---

## Phase 2: Interactive Results Panel (test-gen)

### Goal
Transform test-gen output from passive text to actionable UI with "Save to file" buttons.

### What Exists
- test-gen returns structured data:
  ```python
  {
    "generated_tests": [
      {
        "source_file": "src/foo.py",
        "test_file": "tests/test_foo.py",
        "tests": [{"target": "func_name", "type": "function", "code": "..."}],
        "test_count": 3
      }
    ]
  }
  ```
- XML parsing extracts `<test>` elements with code
- `format_test_gen_report()` creates formatted output

### Implementation

#### 1. Results Panel Component

**File:** `vscode-extension/src/panels/ResultsPanel.ts`

```typescript
export class ResultsPanel {
  public static readonly viewType = 'empathy.resultsPanel';

  public static show(
    context: vscode.ExtensionContext,
    workflowType: string,
    result: WorkflowResult
  ) {
    const panel = vscode.window.createWebviewPanel(
      ResultsPanel.viewType,
      `Results: ${workflowType}`,
      vscode.ViewColumn.Two,
      { enableScripts: true }
    );

    panel.webview.html = this.getHtml(workflowType, result);
    panel.webview.onDidReceiveMessage(msg => this.handleMessage(msg));
  }

  private static getHtml(type: string, result: WorkflowResult): string {
    if (type === 'test-gen') {
      return this.getTestGenHtml(result);
    }
    // Extensible for other workflow types
  }
}
```

#### 2. Test-Gen Results UI

```html
<div class="results-container">
  <header>
    <h1>Generated Tests</h1>
    <div class="summary">
      <span class="stat">${result.total_tests} tests</span>
      <span class="stat">${result.files_covered} files</span>
      <span class="stat">$${result.cost.toFixed(4)}</span>
    </div>
  </header>

  ${result.generated_tests.map(file => `
    <div class="test-file-group">
      <div class="file-header">
        <span class="source-file">${file.source_file}</span>
        <span class="arrow">→</span>
        <span class="test-file">${file.test_file}</span>
        <button class="save-all-btn" data-file="${file.test_file}">
          Save All Tests
        </button>
      </div>

      ${file.tests.map((test, i) => `
        <div class="test-item">
          <div class="test-header">
            <span class="test-target">${test.type}: ${test.target}</span>
            <div class="test-actions">
              <button class="copy-btn" data-index="${i}">Copy</button>
              <button class="preview-btn" data-index="${i}">Preview Diff</button>
            </div>
          </div>
          <pre class="test-code"><code class="language-python">${escapeHtml(test.code)}</code></pre>
        </div>
      `).join('')}
    </div>
  `).join('')}

  <!-- Checklist from XML output -->
  ${result.checklist ? `
    <div class="checklist">
      <h2>Follow-up Checklist</h2>
      ${result.checklist.map((item, i) => `
        <label class="checklist-item">
          <input type="checkbox" data-index="${i}">
          <span>${item}</span>
        </label>
      `).join('')}
    </div>
  ` : ''}
</div>
```

#### 3. Message Handlers

```typescript
private static async handleMessage(msg: WebviewMessage) {
  switch (msg.type) {
    case 'saveTest':
      await this.saveTestFile(msg.testFile, msg.content);
      break;

    case 'saveAllTests':
      await this.saveAllTestsForFile(msg.sourceFile, msg.tests);
      break;

    case 'previewDiff':
      await this.showDiffPreview(msg.testFile, msg.newContent);
      break;

    case 'copyToClipboard':
      await vscode.env.clipboard.writeText(msg.content);
      vscode.window.showInformationMessage('Copied to clipboard');
      break;

    case 'checklistUpdate':
      await this.updateChecklistState(msg.index, msg.checked);
      break;
  }
}

private static async saveTestFile(filePath: string, content: string) {
  const uri = vscode.Uri.file(path.join(workspaceRoot, filePath));

  // Check if file exists
  try {
    await vscode.workspace.fs.stat(uri);
    // File exists - show diff and ask to merge
    const action = await vscode.window.showWarningMessage(
      `${filePath} already exists. What would you like to do?`,
      'Append', 'Replace', 'Show Diff', 'Cancel'
    );
    // Handle action...
  } catch {
    // File doesn't exist - create it
    await vscode.workspace.fs.writeFile(uri, Buffer.from(content));
    vscode.window.showInformationMessage(`Created ${filePath}`);
  }
}
```

#### 4. Syntax Highlighting

Use VS Code's built-in tokenization or a lightweight highlighter:

```typescript
// In webview, use Prism.js or highlight.js
const highlightScript = `
  <script src="${prismJsUri}"></script>
  <link rel="stylesheet" href="${prismCssUri}">
`;
```

#### 5. Checklist Persistence

Store checklist state in workspace storage:

```typescript
private static async updateChecklistState(
  workflowRunId: string,
  index: number,
  checked: boolean
) {
  const key = `empathy.checklist.${workflowRunId}`;
  const state = context.workspaceState.get<boolean[]>(key) || [];
  state[index] = checked;
  await context.workspaceState.update(key, state);
}
```

### Files to Create/Modify

| File | Action |
|------|--------|
| `vscode-extension/src/panels/ResultsPanel.ts` | Create |
| `vscode-extension/src/panels/results/TestGenResults.ts` | Create |
| `vscode-extension/src/services/TestFileService.ts` | Create |
| `vscode-extension/package.json` | Add resources for syntax highlighting |

---

## Phase 3: Enterprise Orchestration (LangGraph + CrewAI)

### Goal
Enable complex enterprise workflows with approval gates, multi-agent coordination, and iterative refinement cycles.

### Strategic Positioning

```
┌─────────────────────────────────────────────────────────────┐
│                    Empathy Framework                        │
├─────────────────────────────────────────────────────────────┤
│  CORE (Free / Small Teams)                                  │
│  └── BaseWorkflow + ResilientExecutor                       │
│      • Linear stages with fallbacks                         │
│      • Cost tracking, progress callbacks                    │
│      • Works great for 80% of use cases                     │
├─────────────────────────────────────────────────────────────┤
│  ENTERPRISE (Licensed - contact us for pricing)                      │
│  └── AdvancedOrchestrator                                   │
│      ├── LangGraph integration                              │
│      │   • Cycles, conditionals, checkpoints                │
│      │   • Human-in-the-loop approval gates                 │
│      │   • Persistent state across sessions                 │
│      └── CrewAI integration                                 │
│          • Multi-agent crews (Security, Perf, Compliance)   │
│          • Role-based delegation                            │
│          • Hierarchical coordination                        │
└─────────────────────────────────────────────────────────────┘
```

### Enterprise Use Cases

| Use Case | Why Current System Can't | What LangGraph/CrewAI Adds |
| -------- | ------------------------ | -------------------------- |
| Approval gates | Linear execution only | Human checkpoints, pause/resume |
| Iterative refinement | Fixed stage count | Cycles until quality threshold met |
| Multi-team review | Single agent per stage | Specialized agent crews collaborating |
| Compliance workflows | No conditional branching | Graph-based routing by policy result |
| Audit trails | Basic logging | Full state persistence with reasoning |

### Plugin Interface Architecture

The core framework gains an `Orchestrator` protocol that advanced users can implement:

**File:** `src/empathy_os/orchestration/protocol.py`

```python
"""Orchestrator protocol - enables LangGraph/CrewAI integration."""
from typing import Protocol, Any, AsyncIterator
from dataclasses import dataclass
from enum import Enum

class CheckpointType(Enum):
    """Types of workflow checkpoints."""
    AUTOMATIC = "automatic"      # System-managed
    HUMAN_REQUIRED = "human"     # Requires human approval
    CONDITIONAL = "conditional"  # Based on result evaluation


@dataclass
class OrchestratorState:
    """Persistent state for complex workflows."""
    workflow_id: str
    current_node: str
    iteration: int
    accumulated_cost: float
    checkpoint_data: dict[str, Any]
    agent_states: dict[str, Any]  # Per-agent memory
    pending_approvals: list[str]


@dataclass
class StepResult:
    """Result from a single orchestration step."""
    node_name: str
    output: Any
    cost: float
    tokens: int
    next_nodes: list[str]  # For graph branching
    requires_checkpoint: CheckpointType | None = None
    checkpoint_message: str | None = None


class Orchestrator(Protocol):
    """
    Protocol for workflow orchestration backends.

    Implementations:
    - DefaultOrchestrator: Linear execution (current BaseWorkflow behavior)
    - LangGraphOrchestrator: Graph-based with cycles and checkpoints
    - CrewAIOrchestrator: Multi-agent crews with delegation
    - HybridOrchestrator: LangGraph for flow, CrewAI for nodes
    """

    async def initialize(
        self,
        workflow_definition: dict[str, Any],
        initial_input: Any,
    ) -> OrchestratorState:
        """Initialize workflow state."""
        ...

    async def step(
        self,
        state: OrchestratorState,
    ) -> tuple[OrchestratorState, StepResult]:
        """Execute one step, return updated state and result."""
        ...

    async def run(
        self,
        workflow_definition: dict[str, Any],
        initial_input: Any,
        on_progress: ProgressCallback | None = None,
    ) -> AsyncIterator[StepResult]:
        """Run workflow to completion, yielding results."""
        ...

    async def checkpoint(
        self,
        state: OrchestratorState,
    ) -> str:
        """Save state for later resumption. Returns checkpoint ID."""
        ...

    async def resume(
        self,
        checkpoint_id: str,
        approval_data: dict[str, Any] | None = None,
    ) -> OrchestratorState:
        """Resume from checkpoint, optionally with approval data."""
        ...

    def get_graph_visualization(
        self,
        workflow_definition: dict[str, Any],
    ) -> str:
        """Return Mermaid/DOT graph for UI rendering."""
        ...
```

### Default Orchestrator (Backward Compatible)

**File:** `src/empathy_os/orchestration/default.py`

```python
"""Default orchestrator - wraps existing BaseWorkflow behavior."""
from .protocol import Orchestrator, OrchestratorState, StepResult

class DefaultOrchestrator(Orchestrator):
    """
    Linear stage execution matching current BaseWorkflow.
    Zero new dependencies, full backward compatibility.
    """

    async def initialize(self, workflow_definition, initial_input):
        return OrchestratorState(
            workflow_id=uuid4().hex,
            current_node=workflow_definition["stages"][0]["name"],
            iteration=0,
            accumulated_cost=0.0,
            checkpoint_data={},
            agent_states={},
            pending_approvals=[],
        )

    async def step(self, state):
        stages = self._workflow_def["stages"]
        current_idx = self._get_stage_index(state.current_node)

        # Execute current stage using existing ResilientExecutor
        result = await self._execute_stage(stages[current_idx])

        # Linear: next node is simply the next stage
        next_idx = current_idx + 1
        next_nodes = [stages[next_idx]["name"]] if next_idx < len(stages) else []

        new_state = OrchestratorState(
            workflow_id=state.workflow_id,
            current_node=next_nodes[0] if next_nodes else "__end__",
            iteration=state.iteration,
            accumulated_cost=state.accumulated_cost + result.cost,
            checkpoint_data=state.checkpoint_data,
            agent_states=state.agent_states,
            pending_approvals=[],
        )

        return new_state, StepResult(
            node_name=stages[current_idx]["name"],
            output=result.output,
            cost=result.cost,
            tokens=result.tokens,
            next_nodes=next_nodes,
        )
```

### LangGraph Orchestrator (Enterprise)

**File:** `src/empathy_os/enterprise/orchestration/langgraph_orchestrator.py`

```python
"""LangGraph-based orchestrator for complex workflows."""
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from ..protocol import Orchestrator, OrchestratorState, StepResult, CheckpointType

class LangGraphOrchestrator(Orchestrator):
    """
    Graph-based execution with cycles, conditionals, and checkpoints.

    Features:
    - Cyclic execution (retry until quality threshold)
    - Conditional branching (route by result)
    - Human-in-the-loop checkpoints
    - Persistent state across sessions
    """

    def __init__(self, checkpoint_db: str = ".empathy/checkpoints.db"):
        self.checkpointer = SqliteSaver.from_conn_string(checkpoint_db)

    def _build_graph(self, workflow_definition: dict) -> StateGraph:
        """Convert Empathy workflow definition to LangGraph."""
        graph = StateGraph(WorkflowState)

        for node in workflow_definition["nodes"]:
            graph.add_node(node["name"], self._make_node_fn(node))

        for edge in workflow_definition["edges"]:
            if edge.get("conditional"):
                graph.add_conditional_edges(
                    edge["from"],
                    self._make_router(edge["conditions"]),
                    edge["targets"],
                )
            else:
                graph.add_edge(edge["from"], edge["to"])

        graph.set_entry_point(workflow_definition["entry"])

        return graph.compile(checkpointer=self.checkpointer)

    async def run(self, workflow_definition, initial_input, on_progress=None):
        graph = self._build_graph(workflow_definition)

        async for event in graph.astream(
            {"input": initial_input},
            config={"configurable": {"thread_id": uuid4().hex}},
        ):
            node_name = list(event.keys())[0]
            result = event[node_name]

            step_result = StepResult(
                node_name=node_name,
                output=result.get("output"),
                cost=result.get("cost", 0),
                tokens=result.get("tokens", 0),
                next_nodes=result.get("next", []),
                requires_checkpoint=self._check_for_checkpoint(node_name),
            )

            if on_progress:
                on_progress(self._to_progress_update(step_result))

            yield step_result

    async def checkpoint(self, state):
        """Save to SQLite for cross-session persistence."""
        return await self.checkpointer.aput(
            config={"configurable": {"thread_id": state.workflow_id}},
            checkpoint=state.checkpoint_data,
        )

    async def resume(self, checkpoint_id, approval_data=None):
        """Resume with optional human approval injection."""
        state = await self.checkpointer.aget(checkpoint_id)
        if approval_data:
            state["approval"] = approval_data
        return self._to_orchestrator_state(state)
```

### CrewAI Orchestrator (Enterprise)

**File:** `src/empathy_os/enterprise/orchestration/crewai_orchestrator.py`

```python
"""CrewAI-based orchestrator for multi-agent workflows."""
from crewai import Agent, Task, Crew, Process
from ..protocol import Orchestrator, OrchestratorState, StepResult

class CrewAIOrchestrator(Orchestrator):
    """
    Multi-agent crews with role-based delegation.

    Features:
    - Specialized agents (Security, Performance, Compliance)
    - Hierarchical coordination with manager agents
    - Agent memory persistence
    - Delegation and collaboration patterns
    """

    def _build_crew(self, crew_definition: dict) -> Crew:
        """Convert Empathy crew definition to CrewAI."""
        agents = [
            Agent(
                role=agent["role"],
                goal=agent["goal"],
                backstory=agent["backstory"],
                llm=self._get_llm_for_tier(agent.get("tier", "capable")),
                tools=self._load_tools(agent.get("tools", [])),
                memory=True,  # Enable agent memory
            )
            for agent in crew_definition["agents"]
        ]

        tasks = [
            Task(
                description=task["description"],
                expected_output=task["expected_output"],
                agent=agents[task["agent_index"]],
            )
            for task in crew_definition["tasks"]
        ]

        return Crew(
            agents=agents,
            tasks=tasks,
            process=Process.hierarchical if crew_definition.get("hierarchical") else Process.sequential,
            manager_llm=self._get_llm_for_tier("premium") if crew_definition.get("hierarchical") else None,
        )

    async def run(self, workflow_definition, initial_input, on_progress=None):
        crew = self._build_crew(workflow_definition["crew"])

        # CrewAI execution with progress tracking
        result = await crew.kickoff_async(inputs={"context": initial_input})

        yield StepResult(
            node_name="crew_execution",
            output=result.raw,
            cost=self._calculate_crew_cost(result),
            tokens=result.token_usage.total_tokens,
            next_nodes=[],
        )


# Pre-built agent definitions for common use cases
SECURITY_AGENT = {
    "role": "Senior Security Analyst",
    "goal": "Identify and assess security vulnerabilities with actionable fixes",
    "backstory": "Expert in OWASP Top 10, secure coding practices, and threat modeling",
    "tier": "capable",
    "tools": ["code_search", "dependency_check", "secret_scan"],
}

PERFORMANCE_AGENT = {
    "role": "Performance Engineer",
    "goal": "Identify bottlenecks and optimization opportunities",
    "backstory": "Specialist in profiling, algorithmic complexity, and system optimization",
    "tier": "capable",
    "tools": ["complexity_analyzer", "profiler", "benchmark"],
}

COMPLIANCE_AGENT = {
    "role": "Compliance Officer",
    "goal": "Ensure code meets regulatory and policy requirements",
    "backstory": "Expert in SOC2, GDPR, HIPAA, and enterprise security policies",
    "tier": "premium",  # Needs nuanced judgment
    "tools": ["policy_checker", "audit_logger"],
}

COORDINATOR_AGENT = {
    "role": "Technical Lead",
    "goal": "Synthesize findings and prioritize recommendations",
    "backstory": "Senior architect who balances security, performance, and business needs",
    "tier": "premium",
}
```

### Hybrid Orchestrator (LangGraph + CrewAI)

**File:** `src/empathy_os/enterprise/orchestration/hybrid_orchestrator.py`

```python
"""Hybrid orchestrator combining LangGraph flow with CrewAI nodes."""

class HybridOrchestrator(Orchestrator):
    """
    Best of both worlds:
    - LangGraph for workflow orchestration (cycles, checkpoints, routing)
    - CrewAI for complex nodes requiring multi-agent collaboration

    Example workflow:

        analyze ──► security_crew ──► compliance_check
                                           │
                         ┌─────────────────┴─────────────────┐
                         ▼                                   ▼
                   (pass) architect_review            (fail) remediate
                         │                                   │
                         ▼                                   │
                   human_approval ◄──────────────────────────┘
                         │
                         ▼
                      finalize
    """

    def __init__(self):
        self.langgraph = LangGraphOrchestrator()
        self.crewai = CrewAIOrchestrator()

    def _make_node_fn(self, node_def: dict):
        """Create node function, using CrewAI for crew-type nodes."""
        if node_def.get("type") == "crew":
            return self._make_crew_node(node_def["crew"])
        else:
            return self._make_llm_node(node_def)

    def _make_crew_node(self, crew_def: dict):
        """Wrap CrewAI execution as a LangGraph node."""
        async def crew_node(state: WorkflowState) -> dict:
            crew = self.crewai._build_crew(crew_def)
            result = await crew.kickoff_async(inputs=state)
            return {
                "output": result.raw,
                "cost": self.crewai._calculate_crew_cost(result),
                "agent_outputs": {
                    agent.role: agent.last_output
                    for agent in crew.agents
                },
            }
        return crew_node
```

### Example Enterprise Workflow Definition

```yaml
# .empathy/workflows/compliant-code-review.yml
name: compliant-code-review
description: Enterprise code review with multi-team approval
tier: enterprise

orchestrator: hybrid  # Uses HybridOrchestrator

nodes:
  - name: analyze
    type: llm
    tier: capable
    prompt: "Analyze the following code for review priorities..."

  - name: security_crew
    type: crew
    crew:
      hierarchical: true
      agents:
        - role: Security Analyst
          goal: Find vulnerabilities
          tier: capable
        - role: Dependency Auditor
          goal: Check for vulnerable dependencies
          tier: cheap
        - role: Secret Scanner
          goal: Detect exposed credentials
          tier: cheap
      tasks:
        - description: "Scan for OWASP Top 10 vulnerabilities"
          agent_index: 0
        - description: "Audit all dependencies against CVE database"
          agent_index: 1
        - description: "Search for hardcoded secrets and credentials"
          agent_index: 2

  - name: compliance_check
    type: llm
    tier: premium
    prompt: "Evaluate if findings meet compliance requirements..."

  - name: remediate
    type: llm
    tier: capable
    prompt: "Generate fixes for compliance failures..."

  - name: architect_review
    type: llm
    tier: premium
    prompt: "Review architectural implications..."

  - name: human_approval
    type: checkpoint
    checkpoint_type: human_required
    message: "Review requires architect sign-off before proceeding"

  - name: finalize
    type: llm
    tier: cheap
    prompt: "Generate final report..."

edges:
  - from: analyze
    to: security_crew
  - from: security_crew
    to: compliance_check
  - from: compliance_check
    conditional: true
    conditions:
      - if: "result.compliant == true"
        to: architect_review
      - else:
        to: remediate
  - from: remediate
    to: compliance_check  # Cycle back
  - from: architect_review
    to: human_approval
  - from: human_approval
    to: finalize

checkpoints:
  - node: human_approval
    persist: true
    notify:
      - slack: "#code-review"
      - email: "architects@company.com"
```

### VS Code Integration for Enterprise

**File:** `vscode-extension/src/panels/WorkflowGraphPanel.ts`

```typescript
/**
 * Visualize enterprise workflow graphs in VS Code.
 * Renders Mermaid diagrams, shows checkpoint status, enables approvals.
 */
export class WorkflowGraphPanel {

  private renderGraph(workflow: EnterpriseWorkflow): string {
    // Get Mermaid from orchestrator
    const mermaid = workflow.orchestrator.get_graph_visualization();

    return `
      <div class="workflow-graph">
        <div class="mermaid">${mermaid}</div>

        ${workflow.pendingCheckpoints.map(cp => `
          <div class="checkpoint-approval">
            <h3>Approval Required: ${cp.node}</h3>
            <p>${cp.message}</p>
            <div class="approval-actions">
              <button onclick="approve('${cp.id}')">Approve</button>
              <button onclick="reject('${cp.id}')">Reject</button>
              <button onclick="requestChanges('${cp.id}')">Request Changes</button>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }
}
```

### Files to Create (Phase 3)

| File | Action |
| ---- | ------ |
| `src/empathy_os/orchestration/__init__.py` | Create package |
| `src/empathy_os/orchestration/protocol.py` | Create Orchestrator protocol |
| `src/empathy_os/orchestration/default.py` | Create DefaultOrchestrator |
| `src/empathy_os/enterprise/__init__.py` | Create enterprise package |
| `src/empathy_os/enterprise/orchestration/langgraph_orchestrator.py` | Create |
| `src/empathy_os/enterprise/orchestration/crewai_orchestrator.py` | Create |
| `src/empathy_os/enterprise/orchestration/hybrid_orchestrator.py` | Create |
| `src/empathy_os/enterprise/agents/prebuilt.py` | Pre-built agent definitions |
| `vscode-extension/src/panels/WorkflowGraphPanel.ts` | Create |

### Dependencies (Enterprise Only)

```toml
# pyproject.toml [project.optional-dependencies]
enterprise = [
    "langgraph>=0.2.0",
    "langgraph-checkpoint>=1.0.0",
    "crewai>=0.80.0",
    "crewai-tools>=0.14.0",
]
```

Installation for enterprise users:
```bash
pip install empathy-framework[enterprise]
```

---

## Implementation Order

### Week 1-2: Phase 1A + 1B Foundation
**Parallel tracks:**

| Day | 1A: Onboarding | 1B: Progress |
|-----|----------------|--------------|
| 1-2 | Wizard panel scaffold | Token estimator module |
| 3-4 | Provider selection UI | Progress callback system |
| 5-6 | API key storage | BaseWorkflow integration |
| 7-8 | Config generation | VS Code progress service |
| 9-10 | Demo file + testing | Dashboard progress UI |

### Week 3-4: Phase 1 Polish + Phase 2 Start
- Onboarding: Edge cases, error handling, polish
- Progress: Fallback notifications, cost display
- Results Panel: Scaffold, test-gen rendering

### Week 5-6: Phase 2 Completion
- Save/copy functionality
- Diff preview
- Checklist persistence
- Testing across workflows

---

## Success Metrics

| Metric | Target |
|--------|--------|
| Time to first workflow (new user) | < 5 minutes |
| Users completing onboarding | > 80% |
| Cost estimate accuracy | Within 30% of actual |
| Test save success rate | > 95% |

---

## Open Questions

1. **Tokenizer choice:** Use tiktoken (accurate but heavy) or heuristic (fast but approximate)?
2. **Progress transport:** JSON lines over stdout vs WebSocket vs polling?
3. **Checklist sync:** Local only or sync to `.empathy/` for team sharing?

---

## Next Steps

1. Review and approve this plan
2. Create feature branches: `feature/onboarding-wizard`, `feature/live-progress`
3. Begin parallel implementation
