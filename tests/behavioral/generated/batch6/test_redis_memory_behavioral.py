"""Behavioral tests for redis_memory.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime, timedelta
from unittest.mock import Mock, MagicMock, patch, call
import pytest

from empathy_os.redis_memory import (
    REDIS_AVAILABLE,
    AccessTier,
    TTLStrategy,
    AgentCredentials,
    StagedPattern,
    RedisMemory,
    ConflictResolution,
)


@pytest.fixture
def mock_redis():
    """Fixture providing a mocked Redis client."""
    with patch('empathy_os.redis_memory.redis') as mock_redis_module:
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_redis_module.ConnectionError = ConnectionError
        yield mock_client


@pytest.fixture
def observer_credentials():
    """Fixture for observer tier credentials."""
    return AgentCredentials(
        agent_id="observer_1",
        tier=AccessTier.OBSERVER,
        roles=["reader"]
    )


@pytest.fixture
def contributor_credentials():
    """Fixture for contributor tier credentials."""
    return AgentCredentials(
        agent_id="contributor_1",
        tier=AccessTier.CONTRIBUTOR,
        roles=["writer"]
    )


@pytest.fixture
def validator_credentials():
    """Fixture for validator tier credentials."""
    return AgentCredentials(
        agent_id="validator_1",
        tier=AccessTier.VALIDATOR,
        roles=["validator"]
    )


@pytest.fixture
def steward_credentials():
    """Fixture for steward tier credentials."""
    return AgentCredentials(
        agent_id="steward_1",
        tier=AccessTier.STEWARD,
        roles=["admin"]
    )


@pytest.fixture
def sample_pattern():
    """Fixture for a sample staged pattern."""
    return StagedPattern(
        pattern_id="pattern_123",
        agent_id="agent_1",
        pattern_type="behavior",
        name="Test Pattern",
        description="A test pattern",
        code="def test(): pass",
        context={"env": "test"},
        confidence=0.8,
        interests=["accuracy", "performance"]
    )


@pytest.fixture
def redis_memory(mock_redis):
    """Fixture for RedisMemory instance."""
    memory = RedisMemory(host="localhost", port=6379, db=0)
    return memory


class TestAccessTier:
    """Tests for AccessTier enum."""

    def test_access_tier_values(self):
        """
        Given the AccessTier enum
        When accessing tier values
        Then correct integer values are returned
        """
        assert AccessTier.OBSERVER.value == 1
        assert AccessTier.CONTRIBUTOR.value == 2
        assert AccessTier.VALIDATOR.value == 3
        assert AccessTier.STEWARD.value == 4

    def test_access_tier_comparison(self):
        """
        Given different access tiers
        When comparing their values
        Then proper ordering is maintained
        """
        assert AccessTier.OBSERVER.value < AccessTier.CONTRIBUTOR.value
        assert AccessTier.CONTRIBUTOR.value < AccessTier.VALIDATOR.value
        assert AccessTier.VALIDATOR.value < AccessTier.STEWARD.value


class TestTTLStrategy:
    """Tests for TTLStrategy enum."""

    def test_ttl_strategy_values(self):
        """
        Given the TTLStrategy enum
        When accessing TTL values
        Then correct time durations in seconds are returned
        """
        assert TTLStrategy.WORKING_RESULTS.value == 3600
        assert TTLStrategy.STAGED_PATTERNS.value == 86400
        assert TTLStrategy.COORDINATION.value == 300
        assert TTLStrategy.CONFLICT_CONTEXT.value == 604800
        assert TTLStrategy.SESSION.value == 1800


class TestAgentCredentials:
    """Tests for AgentCredentials class."""

    def test_observer_permissions(self, observer_credentials):
        """
        Given observer tier credentials
        When checking permissions
        Then only read access is granted
        """
        assert observer_credentials.can_read() is True
        assert observer_credentials.can_stage() is False
        assert observer_credentials.can_validate() is False
        assert observer_credentials.can_administer() is False

    def test_contributor_permissions(self, contributor_credentials):
        """
        Given contributor tier credentials
        When checking permissions
        Then read and stage access is granted
        """
        assert contributor_credentials.can_read() is True
        assert contributor_credentials.can_stage() is True
        assert contributor_credentials.can_validate() is False
        assert contributor_credentials.can_administer() is False

    def test_validator_permissions(self, validator_credentials):
        """
        Given validator tier credentials
        When checking permissions
        Then read, stage, and validate access is granted
        """
        assert validator_credentials.can_read() is True
        assert validator_credentials.can_stage() is True
        assert validator_credentials.can_validate() is True
        assert validator_credentials.can_administer() is False

    def test_steward_permissions(self, steward_credentials):
        """
        Given steward tier credentials
        When checking permissions
        Then all access permissions are granted
        """
        assert steward_credentials.can_read() is True
        assert steward_credentials.can_stage() is True
        assert steward_credentials.can_validate() is True
        assert steward_credentials.can_administer() is True

    def test_credentials_created_at(self):
        """
        Given new credentials being created
        When the instance is initialized
        Then created_at is set to current time
        """
        before = datetime.now()
        creds = AgentCredentials(agent_id="test", tier=AccessTier.OBSERVER)
        after = datetime.now()
        
        assert before <= creds.created_at <= after

    def test_credentials_with_roles(self):
        """
        Given credentials with custom roles
        When the instance is initialized
        Then roles are properly stored
        """
        roles = ["reader", "writer", "admin"]
        creds = AgentCredentials(
            agent_id="test",
            tier=AccessTier.STEWARD,
            roles=roles
        )
        assert creds.roles == roles


class TestStagedPattern:
    """Tests for StagedPattern class."""

    def test_pattern_to_dict(self, sample_pattern):
        """
        Given a staged pattern
        When converting to dictionary
        Then all fields are properly serialized
        """
        result = sample_pattern.to_dict()
        
        assert result["pattern_id"] == "pattern_123"
        assert result["agent_id"] == "agent_1"
        assert result["pattern_type"] == "behavior"
        assert result["name"] == "Test Pattern"
        assert result["description"] == "A test pattern"
        assert result["code"] == "def test(): pass"
        assert result["context"] == {"env": "test"}
        assert result["confidence"] == 0.8
        assert result["interests"] == ["accuracy", "performance"]
        assert "staged_at" in result

    def test_pattern_from_dict(self, sample_pattern):
        """
        Given a pattern dictionary
        When creating a StagedPattern from it
        Then all fields are properly deserialized
        """
        pattern_dict = sample_pattern.to_dict()
        result = StagedPattern.from_dict(pattern_dict)
        
        assert result.pattern_id == sample_pattern.pattern_id
        assert result.agent_id == sample_pattern.agent_id
        assert result.pattern_type == sample_pattern.pattern_type
        assert result.name == sample_pattern.name
        assert result.description == sample_pattern.description
        assert result.code == sample_pattern.code
        assert result.context == sample_pattern.context
        assert result.confidence == sample_pattern.confidence
        assert result.interests == sample_pattern.interests

    def test_pattern_default_values(self):
        """
        Given minimal pattern creation parameters
        When creating a staged pattern
        Then default values are properly set
        """
        pattern = StagedPattern(
            pattern_id="test",
            agent_id="agent",
            pattern_type="type",
            name="name",
            description="desc"
        )
        
        assert pattern.code is None
        assert pattern.context == {}
        assert pattern.confidence == 0.5
        assert pattern.interests == []
        assert isinstance(pattern.staged_at, datetime)

    def test_pattern_datetime_serialization(self):
        """
        Given a pattern with a datetime
        When converting to dictionary
        Then datetime is serialized to ISO format
        """
        pattern = StagedPattern(
            pattern_id="test",
            agent_id="agent",
            pattern_type="type",
            name="name",
            description="desc",
            staged_at=datetime(2025, 1, 1, 12, 0, 0)
        )
        
        result = pattern.to_dict()
        assert result["staged_at"] == "2025-01-01T12:00:00"


class TestRedisMemoryInitialization:
    """Tests for RedisMemory initialization."""

    @patch('empathy_os.redis_memory.REDIS_AVAILABLE', True)
    def test_successful_initialization(self, mock_redis):
        """
        Given Redis is available
        When initializing RedisMemory
        Then connection is established successfully
        """
        memory = RedisMemory(host="localhost", port=6379, db=0)
        
        assert memory.client is not None
        assert memory.host == "localhost"
        assert memory.port == 6379
        assert memory.db == 0

    @patch('empathy_os.redis_memory.REDIS_AVAILABLE', False)
    def test_initialization_without_redis(self):
        """
        Given Redis is not available
        When initializing RedisMemory
        Then ImportError is raised
        """
        with pytest.raises(ImportError, match="Redis package not available"):
            RedisMemory()

    def test_initialization_with_custom_parameters(self, mock_redis):
        """
        Given custom Redis connection parameters
        When initializing RedisMemory
        Then parameters are properly stored
        """
        memory = RedisMemory(
            host="redis.example.com",
            port=6380,
            db=2,
            password="secret"
        )
        
        assert memory.host == "redis.example.com"
        assert memory.port == 6380
        assert memory.db == 2


class TestRedisMemorySetGet:
    """Tests for RedisMemory set and get operations."""

    def test_set_simple_value(self, redis_memory, mock_redis):
        """
        Given a key-value pair
        When setting a value with default TTL
        Then value is stored in Redis
        """
        redis_memory.set("test_key", "test_value")
        
        mock_redis.setex.assert_called_once()
        call_args = mock_redis.setex.call_args
        assert call_args[0][0] == "test_key"
        assert call_args[0][2] == '"test_value"'

    def test_set_with_custom_ttl(self, redis_memory, mock_redis):
        """
        Given a key-value pair and custom TTL
        When setting a value
        Then value is stored with specified TTL
        """
        redis_memory.set("test_key", "test_value", ttl=7200)
        
        call_args = mock_redis.setex.call_args
        assert call_args[0][1] == 7200

    def test_set_complex_value(self, redis_memory, mock_redis):
        """
        Given a complex data structure
        When setting a value
        Then value is JSON serialized
        """
        complex_data = {"nested": {"key": "value"}, "list": [1, 2, 3]}
        redis_memory.set("test_key", complex_data)
        
        call_args = mock_redis.setex.call_args
        stored_value = call_args[0][2]
        assert json.loads(stored_value) == complex_data

    def test_get_existing_value(self, redis_memory, mock_redis):
        """
        Given a key exists in Redis
        When getting the value
        Then value is properly deserialized
        """
        mock_redis.get.return_value = b'{"key": "value"}'
        
        result = redis_memory.get("test_key")
        
        assert result == {"key": "value"}
        mock_redis.get.assert_called_once_with("test_key")

    def test_get_nonexistent_value(self, redis_memory, mock_redis):
        """
        Given a key does not exist in Redis
        When getting the value
        Then None is returned
        """
        mock_redis.get.return_value = None
        
        result = redis_memory.get("nonexistent_key")
        
        assert result is None

    def test_get_with_default(self, redis_memory, mock_redis):
        """
        Given a key does not exist
        When getting the value with a default
        Then default value is returned
        """
        mock_redis.get.return_value = None
        
        result = redis_memory.get("nonexistent_key", default="default_value")
        
        assert result == "default_value"

    def test_get_invalid_json(self, redis_memory, mock_redis):
        """
        Given stored value is not valid JSON
        When getting the value
        Then raw string is returned
        """
        mock_redis.get.return_value = b'invalid json{'
        
        result = redis_memory.get("test_key")
        
        assert result == "invalid json{"


class TestRedisMemoryPatternStaging:
    """Tests for pattern staging operations."""

    def test_stage_pattern_as_contributor(
        self, redis_memory, mock_redis, contributor_credentials, sample_pattern
    ):
        """
        Given contributor credentials
        When staging a pattern
        Then pattern is stored successfully
        """
        redis_memory.stage_pattern(sample_pattern, contributor_credentials)
        
        mock_redis.setex.assert_called_once()
        call_args = mock_redis.setex.call_args
        assert "staged_pattern:pattern_123" in call_args[0][0]
        assert call_args[0][1] == TTLStrategy.STAGED_PATTERNS.value

    def test_stage_pattern_as_observer(
        self, redis_memory, observer_credentials, sample_pattern
    ):
        """
        Given observer credentials
        When attempting to stage a pattern
        Then PermissionError is raised
        """
        with pytest.raises(PermissionError, match="Agent cannot stage patterns"):
            redis_memory.stage_pattern(sample_pattern, observer_credentials)

    def test_get_staged_pattern_existing(
        self, redis_memory, mock_redis, sample_pattern
    ):
        """
        Given a staged pattern exists
        When retrieving it
        Then pattern is properly deserialized
        """
        pattern_dict = sample_pattern.to_dict()
        mock_redis.get.return_value = json.dumps(pattern_dict).encode()
        
        result = redis_memory.get_staged_pattern("pattern_123")
        
        assert result.pattern_id == sample_pattern.pattern_id
        assert result.agent_id == sample_pattern.agent_id

    def test_get_staged_pattern_nonexistent(self, redis_memory, mock_redis):
        """
        Given a staged pattern does not exist
        When retrieving it
        Then None is returned
        """
        mock_redis.get.return_value = None
        
        result = redis_memory.get_staged_pattern("nonexistent")
        
        assert result is