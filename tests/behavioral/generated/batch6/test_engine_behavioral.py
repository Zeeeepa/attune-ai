"""Behavioral tests for engine.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.socratic.engine import (
    DOMAIN_PATTERNS,
    DomainPattern,
    SocraticEngine,
    detect_domain,
)
from empathy_os.socratic.forms import FieldType, Form, FormField
from empathy_os.socratic.generator import GeneratedWorkflow
from empathy_os.socratic.session import GoalAnalysis, SessionState, SocraticSession
from empathy_os.socratic.success import MetricType, SuccessCriteria, SuccessMetric


# =============================================================================
# FIXTURES
# =============================================================================


@pytest.fixture
def mock_session():
    """Given a mock SocraticSession."""
    session = Mock(spec=SocraticSession)
    session.session_id = "test-session-123"
    session.state = SessionState.INITIAL
    session.goal_text = "Review my code"
    session.responses = {}
    session.domain = None
    session.analysis = None
    session.workflow = None
    session.success_criteria = None
    return session


@pytest.fixture
def mock_goal_analysis():
    """Given a mock GoalAnalysis."""
    return GoalAnalysis(
        domain="code_review",
        complexity="medium",
        clarifications_needed=["What programming language?", "What scope?"],
        recommended_questions=["language", "scope", "quality_focus"],
    )


@pytest.fixture
def mock_workflow():
    """Given a mock GeneratedWorkflow."""
    return GeneratedWorkflow(
        agents=[
            {
                "name": "CodeReviewer",
                "role": "reviewer",
                "capabilities": ["review", "analyze"],
                "config": {},
            }
        ],
        flow=[{"step": 1, "agent": "CodeReviewer", "action": "review"}],
        metadata={"domain": "code_review"},
    )


@pytest.fixture
def mock_success_criteria():
    """Given mock SuccessCriteria."""
    return SuccessCriteria(
        domain="code_review",
        metrics=[
            SuccessMetric(
                name="coverage",
                type=MetricType.PERCENTAGE,
                target=80.0,
                threshold=70.0,
            )
        ],
        description="Test success criteria",
    )


@pytest.fixture
def socratic_engine():
    """Given a SocraticEngine instance."""
    return SocraticEngine()


# =============================================================================
# DOMAIN DETECTION TESTS
# =============================================================================


class TestDetectDomain:
    """Behavioral tests for domain detection."""

    def test_detect_code_review_domain_with_explicit_keywords(self):
        """
        Given a user goal containing explicit code review keywords
        When detect_domain is called
        Then it should return 'code_review' domain
        """
        # Given
        goal_text = "I need to review my pull request and check code changes"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "code_review"

    def test_detect_security_domain_with_high_weight_keywords(self):
        """
        Given a user goal containing security-related keywords
        When detect_domain is called
        Then it should return 'security' domain due to higher weight
        """
        # Given
        goal_text = "Find security vulnerabilities in my application"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "security"

    def test_detect_testing_domain_with_test_keywords(self):
        """
        Given a user goal about test generation
        When detect_domain is called
        Then it should return 'testing' domain
        """
        # Given
        goal_text = "Generate unit tests and improve test coverage"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "testing"

    def test_detect_documentation_domain(self):
        """
        Given a user goal about documentation
        When detect_domain is called
        Then it should return 'documentation' domain
        """
        # Given
        goal_text = "Write documentation and add docstrings to my code"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "documentation"

    def test_detect_performance_domain(self):
        """
        Given a user goal about performance optimization
        When detect_domain is called
        Then it should return 'performance' domain
        """
        # Given
        goal_text = "Optimize my code and improve performance"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "performance"

    def test_detect_refactoring_domain(self):
        """
        Given a user goal about refactoring
        When detect_domain is called
        Then it should return 'refactoring' domain
        """
        # Given
        goal_text = "Refactor my code and clean up the structure"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "refactoring"

    def test_detect_general_domain_with_no_matching_keywords(self):
        """
        Given a user goal with no domain-specific keywords
        When detect_domain is called
        Then it should return 'general' domain
        """
        # Given
        goal_text = "Help me with my project"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "general"

    def test_detect_domain_case_insensitive(self):
        """
        Given a user goal with mixed case keywords
        When detect_domain is called
        Then it should detect domain case-insensitively
        """
        # Given
        goal_text = "REVIEW MY CODE CHANGES"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "code_review"

    def test_detect_domain_with_phrase_match(self):
        """
        Given a user goal containing a phrase pattern
        When detect_domain is called
        Then it should match on phrase with higher score
        """
        # Given
        goal_text = "I want a security audit for my application"

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "security"

    def test_detect_domain_with_empty_string(self):
        """
        Given an empty goal text
        When detect_domain is called
        Then it should return 'general' domain
        """
        # Given
        goal_text = ""

        # When
        result = detect_domain(goal_text)

        # Then
        assert result == "general"

    def test_detect_domain_with_multiple_keyword_matches(self):
        """
        Given a user goal with keywords from multiple domains
        When detect_domain is called
        Then it should return the domain with highest score
        """
        # Given
        goal_text = "Review code and write tests for security"

        # When
        result = detect_domain(goal_text)

        # Then
        # Security has weight 1.2, so should win if it matches
        assert result in ["code_review", "testing", "security"]


# =============================================================================
# DOMAIN PATTERN TESTS
# =============================================================================


class TestDomainPattern:
    """Behavioral tests for DomainPattern dataclass."""

    def test_domain_pattern_creation_with_defaults(self):
        """
        Given domain pattern parameters
        When creating a DomainPattern
        Then it should have correct attributes with default weight
        """
        # Given
        domain = "test_domain"
        keywords = ["test", "check"]
        phrases = ["run test"]

        # When
        pattern = DomainPattern(
            domain=domain, keywords=keywords, phrases=phrases
        )

        # Then
        assert pattern.domain == domain
        assert pattern.keywords == keywords
        assert pattern.phrases == phrases
        assert pattern.weight == 1.0

    def test_domain_pattern_with_custom_weight(self):
        """
        Given domain pattern parameters with custom weight
        When creating a DomainPattern
        Then it should have the specified weight
        """
        # Given
        domain = "high_priority"
        keywords = ["important"]
        phrases = ["very important"]
        weight = 2.5

        # When
        pattern = DomainPattern(
            domain=domain, keywords=keywords, phrases=phrases, weight=weight
        )

        # Then
        assert pattern.weight == weight


# =============================================================================
# SOCRATIC ENGINE INITIALIZATION TESTS
# =============================================================================


class TestSocraticEngineInit:
    """Behavioral tests for SocraticEngine initialization."""

    def test_engine_initialization(self, socratic_engine):
        """
        Given no parameters
        When creating a SocraticEngine instance
        Then it should initialize with empty sessions dictionary
        """
        # Then
        assert hasattr(socratic_engine, "sessions")
        assert isinstance(socratic_engine.sessions, dict)
        assert len(socratic_engine.sessions) == 0

    def test_engine_has_generator(self, socratic_engine):
        """
        Given a SocraticEngine instance
        When accessing the generator
        Then it should have an AgentGenerator instance
        """
        # Then
        assert hasattr(socratic_engine, "generator")


# =============================================================================
# START SESSION TESTS
# =============================================================================


class TestStartSession:
    """Behavioral tests for starting a Socratic session."""

    @patch("empathy_os.socratic.engine.SocraticSession")
    def test_start_session_creates_new_session(self, mock_session_class, socratic_engine):
        """
        Given a goal text
        When start_session is called
        Then it should create a new SocraticSession
        """
        # Given
        goal_text = "Review my code"
        mock_session_instance = Mock()
        mock_session_instance.session_id = "new-session-123"
        mock_session_class.return_value = mock_session_instance

        # When
        session_id = socratic_engine.start_session(goal_text)

        # Then
        mock_session_class.assert_called_once_with(goal_text=goal_text)
        assert session_id == "new-session-123"
        assert session_id in socratic_engine.sessions

    @patch("empathy_os.socratic.engine.SocraticSession")
    @patch("empathy_os.socratic.engine.detect_domain")
    def test_start_session_detects_domain(
        self, mock_detect_domain, mock_session_class, socratic_engine
    ):
        """
        Given a goal text
        When start_session is called
        Then it should detect the domain
        """
        # Given
        goal_text = "Review my code"
        mock_detect_domain.return_value = "code_review"
        mock_session_instance = Mock()
        mock_session_instance.session_id = "session-123"
        mock_session_class.return_value = mock_session_instance

        # When
        socratic_engine.start_session(goal_text)

        # Then
        mock_detect_domain.assert_called_once_with(goal_text)
        assert mock_session_instance.domain == "code_review"

    @patch("empathy_os.socratic.engine.SocraticSession")
    def test_start_session_returns_session_id(self, mock_session_class, socratic_engine):
        """
        Given a goal text
        When start_session is called
        Then it should return the session_id
        """
        # Given
        goal_text = "Test goal"
        expected_id = "test-id-456"
        mock_session_instance = Mock()
        mock_session_instance.session_id = expected_id
        mock_session_class.return_value = mock_session_instance

        # When
        result = socratic_engine.start_session(goal_text)

        # Then
        assert result == expected_id


# =============================================================================
# ANALYZE GOAL TESTS
# =============================================================================


class TestAnalyzeGoal:
    """Behavioral tests for goal analysis."""

    def test_analyze_goal_for_existing_session(
        self, socratic_engine, mock_session, mock_goal_analysis
    ):
        """
        Given an existing session
        When analyze_goal is called
        Then it should return GoalAnalysis
        """
        # Given
        socratic_engine.sessions[mock_session.session_id] = mock_session
        with patch.object(
            socratic_engine, "_perform_goal_analysis", return_value=mock_goal_analysis
        ):
            # When
            result = socratic_engine.analyze_goal(mock_session.session_id)

            # Then
            assert result == mock_goal_analysis
            assert mock_session.analysis == mock_goal_analysis

    def test_analyze_goal_for_nonexistent_session(self, socratic_engine):
        """
        Given a non-existent session ID
        When analyze_goal is called
        Then it should raise ValueError
        """
        # Given
        invalid_session_id = "nonexistent-session"

        # When/Then
        with pytest.raises(ValueError, match="Session.*not found"):
            socratic_engine.analyze_goal(invalid_session_id)

    def test_analyze_goal_updates_session_state(
        self, socratic_engine, mock_session, mock_goal_analysis
    ):
        """
        Given an existing session in INITIAL state
        When analyze_goal is called
        Then it should update session state to ANALYZING
        """
        # Given
        socratic_engine.sessions[mock_session.session_id] = mock_session
        mock_session.state = SessionState.INITIAL
        with patch.object(
            socratic_engine, "_perform_goal_analysis", return_value=mock_goal_analysis
        ):
            # When
            socratic_engine.analyze_goal(mock_session.session_id)

            # Then
            assert mock_session.state == SessionState.ANALYZING


# =============================================================================
# GENERATE QUESTIONS TESTS
# =============================================================================


class TestGenerateQuestions:
    """Behavioral tests for question generation."""

    def test_generate_questions_returns_form(
        self, socratic_engine, mock_session, mock_goal_analysis
    ):
        """
        Given a session with analysis
        When generate_questions is called
        Then it should return a Form
        """
        # Given
        mock_session.analysis = mock_goal_analysis
        socratic_engine.sessions[mock_session.session_id] = mock_session
        with patch.object(socratic_engine, "_create_question_form") as mock_create:
            mock_form = Mock(spec=Form)
            mock_create.return_value = mock_form

            # When
            result = socratic_engine.generate_questions(mock_session.session_id)

            # Then
            assert result == mock_form
            mock_create.assert_called_once()

    def test_generate_questions_without_analysis_raises_error(
        self, socratic_engine, mock_session
    ):
        """
        Given a session without analysis
        When generate_questions is called
        Then it should raise ValueError
        """
        # Given
        mock_session.analysis = None
        socratic_engine.sessions[mock_session.session_id] = mock_session

        # When/Then
        with pytest.raises(ValueError, match="Goal must be analyzed first"):
            socratic_engine.generate_questions(mock_session.session_id)

    def test_generate_questions_for_nonexistent_session(self, socratic_engine):
        """
        Given a non-existent session ID
        When generate_questions is called
        Then it should raise ValueError
        """
        # Given
        invalid_session_id =