"""Behavioral tests for feedback_loop.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from datetime import datetime, timedelta
from typing import Any
from unittest.mock import MagicMock, patch

import pytest

from empathy_os.telemetry.feedback_loop import (
    FeedbackEntry,
    FeedbackLoop,
    ModelTier,
    TierRecommendation,
    QualityStats,
)


class TestModelTier:
    """Test ModelTier enum."""

    def test_given_model_tier_enum_when_accessing_values_then_returns_expected_strings(self):
        """Given ModelTier enum, when accessing values, then returns expected strings."""
        # Given/When/Then
        assert ModelTier.CHEAP == "cheap"
        assert ModelTier.CAPABLE == "capable"
        assert ModelTier.PREMIUM == "premium"

    def test_given_model_tier_when_created_from_string_then_matches_enum(self):
        """Given model tier string, when creating enum, then matches expected value."""
        # Given
        tier_str = "cheap"

        # When
        tier = ModelTier(tier_str)

        # Then
        assert tier == ModelTier.CHEAP
        assert tier.value == "cheap"


class TestFeedbackEntry:
    """Test FeedbackEntry dataclass."""

    def test_given_feedback_data_when_creating_entry_then_initializes_correctly(self):
        """Given feedback data, when creating entry, then initializes correctly."""
        # Given
        feedback_id = "test-123"
        workflow_name = "code-review"
        stage_name = "analysis"
        tier = ModelTier.CHEAP
        quality_score = 0.8
        timestamp = datetime.utcnow()
        metadata = {"tokens": 150}

        # When
        entry = FeedbackEntry(
            feedback_id=feedback_id,
            workflow_name=workflow_name,
            stage_name=stage_name,
            tier=tier,
            quality_score=quality_score,
            timestamp=timestamp,
            metadata=metadata,
        )

        # Then
        assert entry.feedback_id == feedback_id
        assert entry.workflow_name == workflow_name
        assert entry.stage_name == stage_name
        assert entry.tier == tier
        assert entry.quality_score == quality_score
        assert entry.timestamp == timestamp
        assert entry.metadata == metadata

    def test_given_feedback_entry_when_converting_to_dict_then_returns_serializable_dict(self):
        """Given feedback entry, when converting to dict, then returns serializable dict."""
        # Given
        timestamp = datetime(2025, 1, 15, 12, 30, 45)
        entry = FeedbackEntry(
            feedback_id="fb-001",
            workflow_name="review",
            stage_name="analyze",
            tier=ModelTier.CAPABLE,
            quality_score=0.85,
            timestamp=timestamp,
            metadata={"latency_ms": 1200},
        )

        # When
        result = entry.to_dict()

        # Then
        assert result["feedback_id"] == "fb-001"
        assert result["workflow_name"] == "review"
        assert result["stage_name"] == "analyze"
        assert result["tier"] == ModelTier.CAPABLE
        assert result["quality_score"] == 0.85
        assert result["timestamp"] == "2025-01-15T12:30:45"
        assert result["metadata"] == {"latency_ms": 1200}

    def test_given_dict_with_iso_timestamp_when_creating_from_dict_then_parses_correctly(self):
        """Given dict with ISO timestamp, when creating from dict, then parses correctly."""
        # Given
        data = {
            "feedback_id": "fb-002",
            "workflow_name": "test-workflow",
            "stage_name": "test-stage",
            "tier": "premium",
            "quality_score": 0.95,
            "timestamp": "2025-01-15T12:30:45",
            "metadata": {"key": "value"},
        }

        # When
        entry = FeedbackEntry.from_dict(data)

        # Then
        assert entry.feedback_id == "fb-002"
        assert entry.workflow_name == "test-workflow"
        assert entry.stage_name == "test-stage"
        assert entry.tier == "premium"
        assert entry.quality_score == 0.95
        assert isinstance(entry.timestamp, datetime)
        assert entry.timestamp == datetime(2025, 1, 15, 12, 30, 45)
        assert entry.metadata == {"key": "value"}

    def test_given_dict_with_datetime_object_when_creating_from_dict_then_uses_datetime(self):
        """Given dict with datetime object, when creating from dict, then uses datetime."""
        # Given
        timestamp = datetime(2025, 2, 1, 10, 0, 0)
        data = {
            "feedback_id": "fb-003",
            "workflow_name": "wf",
            "stage_name": "st",
            "tier": "cheap",
            "quality_score": 0.5,
            "timestamp": timestamp,
            "metadata": {},
        }

        # When
        entry = FeedbackEntry.from_dict(data)

        # Then
        assert entry.timestamp == timestamp

    def test_given_dict_without_timestamp_when_creating_from_dict_then_uses_current_time(self):
        """Given dict without timestamp, when creating from dict, then uses current time."""
        # Given
        data = {
            "feedback_id": "fb-004",
            "workflow_name": "wf",
            "stage_name": "st",
            "tier": "cheap",
            "quality_score": 0.5,
            "metadata": {},
        }

        # When
        with patch("empathy_os.telemetry.feedback_loop.datetime") as mock_datetime:
            mock_now = datetime(2025, 3, 1, 15, 30, 0)
            mock_datetime.utcnow.return_value = mock_now
            mock_datetime.fromisoformat = datetime.fromisoformat
            entry = FeedbackEntry.from_dict(data)

        # Then
        assert entry.timestamp == mock_now

    def test_given_entry_without_metadata_when_creating_then_defaults_to_empty_dict(self):
        """Given entry without metadata, when creating, then defaults to empty dict."""
        # Given/When
        entry = FeedbackEntry(
            feedback_id="fb-005",
            workflow_name="wf",
            stage_name="st",
            tier=ModelTier.CHEAP,
            quality_score=0.7,
            timestamp=datetime.utcnow(),
        )

        # Then
        assert entry.metadata == {}


class TestTierRecommendation:
    """Test TierRecommendation dataclass."""

    def test_given_recommendation_data_when_creating_then_initializes_correctly(self):
        """Given recommendation data, when creating, then initializes correctly."""
        # Given
        recommended_tier = ModelTier.CAPABLE
        confidence = 0.85
        reason = "High quality scores"
        stats = {"avg": 0.9}

        # When
        rec = TierRecommendation(
            recommended_tier=recommended_tier,
            confidence=confidence,
            reason=reason,
            stats=stats,
        )

        # Then
        assert rec.recommended_tier == recommended_tier
        assert rec.confidence == confidence
        assert rec.reason == reason
        assert rec.stats == stats


class TestQualityStats:
    """Test QualityStats dataclass."""

    def test_given_stats_data_when_creating_then_initializes_correctly(self):
        """Given stats data, when creating, then initializes correctly."""
        # Given
        avg_quality = 0.8
        min_quality = 0.5
        max_quality = 0.95
        sample_count = 10
        tier_breakdown = {ModelTier.CHEAP: 0.7, ModelTier.CAPABLE: 0.85}

        # When
        stats = QualityStats(
            avg_quality=avg_quality,
            min_quality=min_quality,
            max_quality=max_quality,
            sample_count=sample_count,
            tier_breakdown=tier_breakdown,
        )

        # Then
        assert stats.avg_quality == avg_quality
        assert stats.min_quality == min_quality
        assert stats.max_quality == max_quality
        assert stats.sample_count == sample_count
        assert stats.tier_breakdown == tier_breakdown


class TestFeedbackLoop:
    """Test FeedbackLoop class."""

    @pytest.fixture
    def feedback_loop(self):
        """Create a FeedbackLoop instance for testing."""
        return FeedbackLoop()

    def test_given_feedback_loop_when_initialized_then_has_empty_storage(self, feedback_loop):
        """Given feedback loop, when initialized, then has empty storage."""
        # Given/When
        loop = FeedbackLoop()

        # Then
        assert loop._feedback_storage == []

    def test_given_feedback_data_when_recording_then_creates_entry(self, feedback_loop):
        """Given feedback data, when recording, then creates entry."""
        # Given
        workflow_name = "code-review"
        stage_name = "analysis"
        tier = ModelTier.CHEAP
        quality_score = 0.8
        metadata = {"tokens": 150}

        # When
        with patch("empathy_os.telemetry.feedback_loop.uuid4") as mock_uuid:
            mock_uuid.return_value = MagicMock(hex="test-uuid-123")
            feedback_loop.record_feedback(
                workflow_name=workflow_name,
                stage_name=stage_name,
                tier=tier,
                quality_score=quality_score,
                metadata=metadata,
            )

        # Then
        assert len(feedback_loop._feedback_storage) == 1
        entry = feedback_loop._feedback_storage[0]
        assert entry.workflow_name == workflow_name
        assert entry.stage_name == stage_name
        assert entry.tier == tier
        assert entry.quality_score == quality_score
        assert entry.metadata == metadata

    def test_given_multiple_feedback_when_recording_then_stores_all_entries(self, feedback_loop):
        """Given multiple feedback, when recording, then stores all entries."""
        # Given/When
        feedback_loop.record_feedback("wf1", "st1", ModelTier.CHEAP, 0.7)
        feedback_loop.record_feedback("wf1", "st1", ModelTier.CAPABLE, 0.85)
        feedback_loop.record_feedback("wf2", "st2", ModelTier.PREMIUM, 0.95)

        # Then
        assert len(feedback_loop._feedback_storage) == 3

    def test_given_feedback_without_metadata_when_recording_then_uses_empty_dict(self, feedback_loop):
        """Given feedback without metadata, when recording, then uses empty dict."""
        # Given/When
        feedback_loop.record_feedback("wf", "st", ModelTier.CHEAP, 0.6)

        # Then
        entry = feedback_loop._feedback_storage[0]
        assert entry.metadata == {}

    def test_given_workflow_stage_when_getting_quality_stats_then_calculates_correctly(self, feedback_loop):
        """Given workflow/stage, when getting quality stats, then calculates correctly."""
        # Given
        feedback_loop.record_feedback("wf1", "st1", ModelTier.CHEAP, 0.5)
        feedback_loop.record_feedback("wf1", "st1", ModelTier.CHEAP, 0.7)
        feedback_loop.record_feedback("wf1", "st1", ModelTier.CAPABLE, 0.9)

        # When
        stats = feedback_loop.get_quality_stats("wf1", "st1")

        # Then
        assert stats.sample_count == 3
        assert stats.min_quality == 0.5
        assert stats.max_quality == 0.9
        assert abs(stats.avg_quality - 0.7) < 0.01
        assert ModelTier.CHEAP in stats.tier_breakdown
        assert ModelTier.CAPABLE in stats.tier_breakdown

    def test_given_no_matching_feedback_when_getting_stats_then_returns_none(self, feedback_loop):
        """Given no matching feedback, when getting stats, then returns None."""
        # Given
        feedback_loop.record_feedback("wf1", "st1", ModelTier.CHEAP, 0.7)

        # When
        stats = feedback_loop.get_quality_stats("wf2", "st2")

        # Then
        assert stats is None

    def test_given_tier_breakdown_when_calculating_stats_then_averages_by_tier(self, feedback_loop):
        """Given tier breakdown, when calculating stats, then averages by tier."""
        # Given
        feedback_loop.record_feedback("wf", "st", ModelTier.CHEAP, 0.5)
        feedback_loop.record_feedback("wf", "st", ModelTier.CHEAP, 0.7)
        feedback_loop.record_feedback("wf", "st", ModelTier.CAPABLE, 0.9)
        feedback_loop.record_feedback("wf", "st", ModelTier.CAPABLE, 0.95)

        # When
        stats = feedback_loop.get_quality_stats("wf", "st")

        # Then
        assert abs(stats.tier_breakdown[ModelTier.CHEAP] - 0.6) < 0.01
        assert abs(stats.tier_breakdown[ModelTier.CAPABLE] - 0.925) < 0.01

    def test_given_sufficient_data_when_recommending_tier_then_returns_recommendation(self, feedback_loop):
        """Given sufficient data, when recommending tier, then returns recommendation."""
        # Given
        for _ in range(10):
            feedback_loop.record_feedback("wf", "st", ModelTier.CHEAP, 0.5)

        # When
        recommendation = feedback_loop.recommend_tier("wf", "st")

        # Then
        assert recommendation is not None
        assert recommendation.recommended_tier in [ModelTier.CHEAP, ModelTier.CAPABLE, ModelTier.PREMIUM]
        assert 0.0 <= recommendation.confidence <= 1.0
        assert recommendation.reason is not None

    def test_given_insufficient_data_when_recommending_tier_then_returns_none(self, feedback_loop):
        """Given insufficient data, when recommending tier, then returns None."""
        # Given
        feedback_loop.record_feedback("wf", "st", ModelTier.CHEAP, 0.7)

        # When
        recommendation = feedback_loop.recommend_tier("wf", "st")

        # Then
        assert recommendation is None

    def test_given_no_data_when_recommending_tier_then_returns_none(self, feedback_loop):
        """Given no data, when recommending tier, then returns None."""
        # Given/When
        recommendation = feedback_loop.recommend_tier("wf", "st")

        # Then
        assert recommendation is None

    def test_given_high_quality_cheap_tier_when_recommending_then_suggests_keep_cheap(self, feedback_loop):
        """Given high quality cheap tier, when recommending, then suggests keep cheap."""
        # Given
        for _ in range(10):
            feedback_loop.record_feedback("wf", "st", ModelTier.CHEAP, 0.85)

        # When
        recommendation = feedback_loop.recommend_tier("wf",