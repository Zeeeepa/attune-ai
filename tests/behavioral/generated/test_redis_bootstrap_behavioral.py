"""Behavioral tests for redis_bootstrap.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import platform
import shutil
import subprocess
from unittest.mock import MagicMock, Mock, patch

import pytest

from attune.memory.redis_bootstrap import (
    IS_LINUX,
    IS_MACOS,
    IS_WINDOWS,
    RedisStartMethod,
    RedisStatus,
    _check_redis_running,
    _find_command,
    _run_silent,
    _start_via_chocolatey,
    _start_via_direct,
    _start_via_docker,
    _start_via_homebrew,
    _start_via_scoop,
    _start_via_systemd,
    _start_via_windows_service,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def mock_redis_client():
    """Mock Redis client for testing connections."""
    mock_client = MagicMock()
    mock_module = MagicMock()
    mock_module.Redis.return_value = mock_client
    with patch.dict("sys.modules", {"redis": mock_module}):
        yield mock_client


@pytest.fixture
def mock_subprocess():
    """Mock subprocess.run for command execution."""
    with patch("attune.memory.redis_bootstrap.subprocess.run") as mock_run:
        yield mock_run


@pytest.fixture
def mock_shutil_which():
    """Mock shutil.which for command finding."""
    with patch("attune.memory.redis_bootstrap.shutil.which") as mock_which:
        yield mock_which


@pytest.fixture
def mock_time_sleep():
    """Mock time.sleep to speed up tests."""
    with patch("attune.memory.redis_bootstrap.time.sleep") as mock_sleep:
        yield mock_sleep


# ============================================================================
# Tests for RedisStartMethod Enum
# ============================================================================


class TestRedisStartMethod:
    """Tests for RedisStartMethod enum."""

    def test_given_enum_when_accessing_values_then_returns_correct_strings(self):
        """Verify that enum values are correct strings."""
        # Given/When
        already_running = RedisStartMethod.ALREADY_RUNNING
        homebrew = RedisStartMethod.HOMEBREW
        systemd = RedisStartMethod.SYSTEMD
        windows_service = RedisStartMethod.WINDOWS_SERVICE

        # Then
        assert already_running.value == "already_running"
        assert homebrew.value == "homebrew"
        assert systemd.value == "systemd"
        assert windows_service.value == "windows_service"

    def test_given_enum_when_checking_all_methods_then_all_exist(self):
        """Verify all expected start methods are defined."""
        # Given
        expected_methods = {
            "already_running",
            "homebrew",
            "systemd",
            "windows_service",
            "chocolatey",
            "scoop",
            "wsl",
            "docker",
            "direct",
            "mock",
        }

        # When
        actual_methods = {method.value for method in RedisStartMethod}

        # Then
        assert actual_methods == expected_methods


# ============================================================================
# Tests for RedisStatus Dataclass
# ============================================================================


class TestRedisStatus:
    """Tests for RedisStatus dataclass."""

    def test_given_minimal_params_when_creating_status_then_uses_defaults(self):
        """Verify RedisStatus can be created with minimal parameters."""
        # Given/When
        status = RedisStatus(available=True, method=RedisStartMethod.ALREADY_RUNNING)

        # Then
        assert status.available is True
        assert status.method == RedisStartMethod.ALREADY_RUNNING
        assert status.host == "localhost"
        assert status.port == 6379
        assert status.message == ""
        assert status.pid is None

    def test_given_full_params_when_creating_status_then_all_set_correctly(self):
        """Verify RedisStatus can be created with all parameters."""
        # Given/When
        status = RedisStatus(
            available=True,
            method=RedisStartMethod.DOCKER,
            host="127.0.0.1",
            port=6380,
            message="Started via Docker",
            pid=12345,
        )

        # Then
        assert status.available is True
        assert status.method == RedisStartMethod.DOCKER
        assert status.host == "127.0.0.1"
        assert status.port == 6380
        assert status.message == "Started via Docker"
        assert status.pid == 12345

    def test_given_unavailable_when_creating_status_then_available_is_false(self):
        """Verify RedisStatus can represent unavailable state."""
        # Given/When
        status = RedisStatus(
            available=False,
            method=RedisStartMethod.DIRECT,
            message="Failed to start",
        )

        # Then
        assert status.available is False
        assert status.message == "Failed to start"


# ============================================================================
# Tests for _check_redis_running
# ============================================================================


class TestCheckRedisRunning:
    """Tests for _check_redis_running function."""

    def test_given_redis_responds_when_checking_then_returns_true(
        self, mock_redis_client
    ):
        """Verify returns True when Redis responds to ping."""
        # Given
        mock_redis_client.ping.return_value = True

        # When
        result = _check_redis_running()

        # Then
        assert result is True
        mock_redis_client.ping.assert_called_once()

    def test_given_redis_not_responding_when_checking_then_returns_false(
        self, mock_redis_client
    ):
        """Verify returns False when Redis doesn't respond."""
        # Given
        mock_redis_client.ping.side_effect = Exception("Connection refused")

        # When
        result = _check_redis_running()

        # Then
        assert result is False

    def test_given_custom_host_port_when_checking_then_uses_correct_params(self):
        """Verify custom host and port are used."""
        # Given
        mock_client = MagicMock()
        mock_client.ping.return_value = True
        mock_module = MagicMock()
        mock_module.Redis.return_value = mock_client

        # When
        with patch.dict("sys.modules", {"redis": mock_module}):
            result = _check_redis_running(host="192.168.1.1", port=6380)

            # Then
            assert result is True
            mock_module.Redis.assert_called_once_with(
                host="192.168.1.1", port=6380, socket_connect_timeout=1
            )

    def test_given_timeout_when_checking_then_returns_false(self, mock_redis_client):
        """Verify returns False on connection timeout."""
        # Given
        mock_redis_client.ping.side_effect = TimeoutError("Timeout")

        # When
        result = _check_redis_running()

        # Then
        assert result is False

    def test_given_redis_module_missing_when_checking_then_returns_false(self):
        """Verify returns False when redis module is not available."""
        # Given/When - Removing redis from sys.modules forces ImportError
        import sys

        saved = sys.modules.get("redis")
        sys.modules["redis"] = None  # type: ignore[assignment]
        try:
            result = _check_redis_running()
        finally:
            if saved is not None:
                sys.modules["redis"] = saved
            else:
                sys.modules.pop("redis", None)

        # Then - should handle gracefully (catches all exceptions)
        assert result is False


# ============================================================================
# Tests for _find_command
# ============================================================================


class TestFindCommand:
    """Tests for _find_command function."""

    def test_given_command_exists_when_finding_then_returns_path(
        self, mock_shutil_which
    ):
        """Verify returns path when command exists."""
        # Given
        mock_shutil_which.return_value = "/usr/bin/redis-server"

        # When
        result = _find_command("redis-server")

        # Then
        assert result == "/usr/bin/redis-server"
        mock_shutil_which.assert_called_once_with("redis-server")

    def test_given_command_not_exists_when_finding_then_returns_none(
        self, mock_shutil_which
    ):
        """Verify returns None when command doesn't exist."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _find_command("nonexistent-command")

        # Then
        assert result is None

    def test_given_empty_command_when_finding_then_returns_none(self, mock_shutil_which):
        """Verify handles empty command string."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _find_command("")

        # Then
        assert result is None


# ============================================================================
# Tests for _run_silent
# ============================================================================


class TestRunSilent:
    """Tests for _run_silent function."""

    def test_given_successful_command_when_running_then_returns_true_and_output(
        self, mock_subprocess
    ):
        """Verify returns success for successful command execution."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "Success output"
        mock_result.stderr = ""
        mock_subprocess.return_value = mock_result

        # When
        success, output = _run_silent(["echo", "test"])

        # Then
        assert success is True
        assert "Success output" in output

    def test_given_failed_command_when_running_then_returns_false_and_output(
        self, mock_subprocess
    ):
        """Verify returns failure for failed command execution."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 1
        mock_result.stdout = ""
        mock_result.stderr = "Error message"
        mock_subprocess.return_value = mock_result

        # When
        success, output = _run_silent(["false"])

        # Then
        assert success is False
        assert "Error message" in output

    def test_given_timeout_when_running_then_returns_false_and_timeout_message(
        self, mock_subprocess
    ):
        """Verify handles command timeout gracefully."""
        # Given
        mock_subprocess.side_effect = subprocess.TimeoutExpired(
            cmd=["sleep", "100"], timeout=5
        )

        # When
        success, output = _run_silent(["sleep", "100"], timeout=5)

        # Then
        assert success is False
        assert output == "timeout"

    def test_given_exception_when_running_then_returns_false_and_error(
        self, mock_subprocess
    ):
        """Verify handles general exceptions gracefully."""
        # Given
        mock_subprocess.side_effect = Exception("Something went wrong")

        # When
        success, output = _run_silent(["some-command"])

        # Then
        assert success is False
        assert "Something went wrong" in output

    def test_given_custom_timeout_when_running_then_uses_correct_timeout(
        self, mock_subprocess
    ):
        """Verify custom timeout is used."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = ""
        mock_result.stderr = ""
        mock_subprocess.return_value = mock_result

        # When
        _run_silent(["echo", "test"], timeout=10)

        # Then
        mock_subprocess.assert_called_once_with(
            ["echo", "test"],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )

    def test_given_stdout_and_stderr_when_running_then_combines_output(
        self, mock_subprocess
    ):
        """Verify stdout and stderr are combined in output."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "stdout content"
        mock_result.stderr = "stderr content"
        mock_subprocess.return_value = mock_result

        # When
        success, output = _run_silent(["test-command"])

        # Then
        assert "stdout content" in output
        assert "stderr content" in output


# ============================================================================
# Tests for _start_via_homebrew
# ============================================================================


class TestStartViaHomebrew:
    """Tests for _start_via_homebrew function."""

    def test_given_brew_not_found_when_starting_then_returns_false(
        self, mock_shutil_which
    ):
        """Verify returns False when brew command is not available."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _start_via_homebrew()

        # Then
        assert result is False

    def test_given_redis_not_installed_when_starting_then_returns_false(
        self, mock_shutil_which, mock_subprocess
    ):
        """Verify returns False when Redis is not installed via Homebrew."""
        # Given
        mock_shutil_which.return_value = "/usr/local/bin/brew"
        mock_result = Mock()
        mock_result.returncode = 1
        mock_result.stdout = ""
        mock_result.stderr = "redis not installed"
        mock_subprocess.return_value = mock_result

        # When
        result = _start_via_homebrew()

        # Then
        assert result is False

    def test_given_redis_installed_when_starting_successfully_then_returns_true(
        self, mock_shutil_which, mock_subprocess, mock_time_sleep
    ):
        """Verify returns True when Redis is started successfully."""
        # Given
        mock_shutil_which.return_value = "/usr/local/bin/brew"

        # Mock two calls: brew list (success), brew services start (success)
        mock_result_list = Mock()
        mock_result_list.returncode = 0
        mock_result_list.stdout = "redis"
        mock_result_list.stderr = ""

        mock_result_start = Mock()
        mock_result_start.returncode = 0
        mock_result_start.stdout = "Started redis"
        mock_result_start.stderr = ""

        mock_subprocess.side_effect = [mock_result_list, mock_result_start]

        # When
        result = _start_via_homebrew()

        # Then
        assert result is True
        mock_time_sleep.assert_called_once_with(1)

    def test_given_start_fails_when_starting_then_returns_false(
        self, mock_shutil_which, mock_subprocess
    ):
        """Verify returns False when brew services start fails."""
        # Given
        mock_shutil_which.return_value = "/usr/local/bin/brew"

        # Mock two calls: brew list (success), brew services start (failure)
        mock_result_list = Mock()
        mock_result_list.returncode = 0
        mock_result_list.stdout = "redis"
        mock_result_list.stderr = ""

        mock_result_start = Mock()
        mock_result_start.returncode = 1
        mock_result_start.stdout = ""
        mock_result_start.stderr = "Failed to start"

        mock_subprocess.side_effect = [mock_result_list, mock_result_start]

        # When
        result = _start_via_homebrew()

        # Then
        assert result is False


# ============================================================================
# Tests for _start_via_systemd
# ============================================================================


