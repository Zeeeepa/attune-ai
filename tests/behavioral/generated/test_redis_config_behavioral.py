"""Behavioral tests for redis_config.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from unittest.mock import patch

import pytest

from attune.redis_config import (
    get_redis_config,
    parse_redis_url,
)


@pytest.fixture
def clean_env(monkeypatch):
    """Remove all Redis-related environment variables."""
    redis_vars = [
        "REDIS_URL",
        "REDIS_HOST",
        "REDIS_PORT",
        "REDIS_PASSWORD",
        "REDIS_DB",
        "EMPATHY_REDIS_MOCK",
        "REDIS_SSL",
        "REDIS_SSL_CERT_REQS",
        "REDIS_SSL_CA_CERTS",
        "REDIS_SSL_CERTFILE",
        "REDIS_SSL_KEYFILE",
        "REDIS_SOCKET_TIMEOUT",
        "REDIS_MAX_CONNECTIONS",
        "REDIS_RETRY_MAX_ATTEMPTS",
        "REDIS_RETRY_BASE_DELAY",
        "REDIS_RETRY_MAX_DELAY",
        "REDIS_SENTINEL_HOSTS",
        "REDIS_SENTINEL_MASTER",
    ]
    for var in redis_vars:
        monkeypatch.delenv(var, raising=False)
    return monkeypatch


@pytest.fixture
def mock_redis_config():
    """Mock RedisConfig class."""
    with patch("attune.redis_config.RedisConfig") as mock:
        yield mock


@pytest.fixture
def mock_redis_memory():
    """Mock RedisShortTermMemory class."""
    with patch("attune.redis_config.RedisShortTermMemory") as mock:
        yield mock


class TestParseRedisUrl:
    """Behavioral tests for parse_redis_url function."""

    def test_given_standard_redis_url_when_parsed_then_returns_correct_config(self):
        """
        GIVEN: A standard redis:// URL with all components
        WHEN: parse_redis_url is called
        THEN: Returns dict with correct host, port, password, db, and ssl=False
        """
        # Given
        url = "redis://user:password123@example.com:6380/5"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["host"] == "example.com"
        assert result["port"] == 6380
        assert result["password"] == "password123"
        assert result["db"] == 5
        assert result["ssl"] is False

    def test_given_rediss_url_when_parsed_then_ssl_is_enabled(self):
        """
        GIVEN: A rediss:// URL (SSL scheme)
        WHEN: parse_redis_url is called
        THEN: Returns config with ssl=True
        """
        # Given
        url = "rediss://user:pass@secure.redis.com:6379/0"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["ssl"] is True
        assert result["host"] == "secure.redis.com"

    def test_given_url_without_password_when_parsed_then_password_is_none(self):
        """
        GIVEN: Redis URL without password
        WHEN: parse_redis_url is called
        THEN: Returns config with password=None
        """
        # Given
        url = "redis://localhost:6379"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["password"] is None

    def test_given_url_without_port_when_parsed_then_uses_default_port(self):
        """
        GIVEN: Redis URL without explicit port
        WHEN: parse_redis_url is called
        THEN: Returns config with default port 6379
        """
        # Given
        url = "redis://localhost"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["port"] == 6379

    def test_given_url_without_db_when_parsed_then_uses_default_db(self):
        """
        GIVEN: Redis URL without database number
        WHEN: parse_redis_url is called
        THEN: Returns config with db=0
        """
        # Given
        url = "redis://localhost:6379"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["db"] == 0

    def test_given_url_with_empty_path_when_parsed_then_uses_default_db(self):
        """
        GIVEN: Redis URL with empty path
        WHEN: parse_redis_url is called
        THEN: Returns config with db=0
        """
        # Given
        url = "redis://localhost:6379/"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["db"] == 0

    def test_given_minimal_url_when_parsed_then_uses_all_defaults(self):
        """
        GIVEN: Minimal Redis URL (just scheme and hostname)
        WHEN: parse_redis_url is called
        THEN: Returns config with all default values
        """
        # Given
        url = "redis://localhost"

        # When
        result = parse_redis_url(url)

        # Then
        assert result["host"] == "localhost"
        assert result["port"] == 6379
        assert result["password"] is None
        assert result["db"] == 0
        assert result["ssl"] is False


class TestGetRedisConfig:
    """Behavioral tests for get_redis_config function."""

    def test_given_redis_url_env_when_called_then_parses_url(self, clean_env, mock_redis_config):
        """
        GIVEN: REDIS_URL environment variable is set
        WHEN: get_redis_config is called
        THEN: Parses URL and creates RedisConfig with parsed values
        """
        # Given
        clean_env.setenv("REDIS_URL", "redis://user:pass@host.com:6380/2")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["host"] == "host.com"
        assert call_kwargs["port"] == 6380
        assert call_kwargs["password"] == "pass"
        assert call_kwargs["db"] == 2

    def test_given_individual_env_vars_when_called_then_uses_them(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: Individual Redis environment variables are set
        WHEN: get_redis_config is called
        THEN: Uses individual values to create RedisConfig
        """
        # Given
        clean_env.setenv("REDIS_HOST", "myredis.local")
        clean_env.setenv("REDIS_PORT", "7000")
        clean_env.setenv("REDIS_PASSWORD", "secret")
        clean_env.setenv("REDIS_DB", "3")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["host"] == "myredis.local"
        assert call_kwargs["port"] == 7000
        assert call_kwargs["password"] == "secret"
        assert call_kwargs["db"] == 3

    def test_given_no_env_vars_when_called_then_uses_defaults(self, clean_env, mock_redis_config):
        """
        GIVEN: No Redis environment variables are set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with default values
        """
        # Given/When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["host"] == "localhost"
        assert call_kwargs["port"] == 6379
        assert call_kwargs["db"] == 0

    @pytest.mark.xfail(reason="SSL env var not passed to RedisConfig in local mode")
    def test_given_ssl_enabled_env_when_called_then_enables_ssl(self, clean_env, mock_redis_config):
        """
        GIVEN: REDIS_SSL environment variable is set to "true"
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with ssl=True
        """
        # Given
        clean_env.setenv("REDIS_SSL", "true")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["ssl"] is True

    @pytest.mark.xfail(reason="SSL cert fields not yet supported in get_redis_config")
    def test_given_ssl_cert_reqs_env_when_called_then_sets_cert_reqs(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_SSL_CERT_REQS environment variable is set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with ssl_cert_reqs
        """
        # Given
        clean_env.setenv("REDIS_SSL_CERT_REQS", "required")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["ssl_cert_reqs"] == "required"

    @pytest.mark.xfail(reason="SSL cert fields not yet supported in get_redis_config")
    def test_given_ssl_ca_certs_env_when_called_then_sets_ca_certs(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_SSL_CA_CERTS environment variable is set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with ssl_ca_certs path
        """
        # Given
        clean_env.setenv("REDIS_SSL_CA_CERTS", "/path/to/ca.pem")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["ssl_ca_certs"] == "/path/to/ca.pem"

    @pytest.mark.xfail(reason="SSL cert fields not yet supported in get_redis_config")
    def test_given_ssl_certfile_env_when_called_then_sets_certfile(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_SSL_CERTFILE environment variable is set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with ssl_certfile path
        """
        # Given
        clean_env.setenv("REDIS_SSL_CERTFILE", "/path/to/cert.pem")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["ssl_certfile"] == "/path/to/cert.pem"

    @pytest.mark.xfail(reason="SSL cert fields not yet supported in get_redis_config")
    def test_given_ssl_keyfile_env_when_called_then_sets_keyfile(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_SSL_KEYFILE environment variable is set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with ssl_keyfile path
        """
        # Given
        clean_env.setenv("REDIS_SSL_KEYFILE", "/path/to/key.pem")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["ssl_keyfile"] == "/path/to/key.pem"

    def test_given_socket_timeout_env_when_called_then_sets_timeout(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_SOCKET_TIMEOUT environment variable is set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with socket_timeout
        """
        # Given
        clean_env.setenv("REDIS_SOCKET_TIMEOUT", "10.5")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["socket_timeout"] == 10.5

    def test_given_max_connections_env_when_called_then_sets_max_connections(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_MAX_CONNECTIONS environment variable is set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with max_connections
        """
        # Given
        clean_env.setenv("REDIS_MAX_CONNECTIONS", "20")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["max_connections"] == 20

    def test_given_retry_settings_env_when_called_then_sets_retry_params(
        self, clean_env, mock_redis_config
    ):
        """
        GIVEN: REDIS_RETRY_* environment variables are set
        WHEN: get_redis_config is called
        THEN: Creates RedisConfig with retry parameters
        """
        # Given
        clean_env.setenv("REDIS_RETRY_MAX_ATTEMPTS", "5")
        clean_env.setenv("REDIS_RETRY_BASE_DELAY", "0.2")
        clean_env.setenv("REDIS_RETRY_MAX_DELAY", "3.0")

        # When
        get_redis_config()

        # Then
        mock_redis_config.assert_called_once()
        call_kwargs = mock_redis_config.call_args[1]
        assert call_kwargs["retry_max_attempts"] == 5
        assert call_kwargs["retry_base_delay"] == 0.2
        assert call_kwargs["retry_max_delay"] == 3.0
