"""Behavioral tests for meta_orchestrator.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from dataclasses import asdict

from empathy_os.orchestration.meta_orchestrator import (
    MetaOrchestrator,
    TaskComplexity,
    TaskDomain,
    CompositionPattern,
    TaskRequirements,
    ExecutionPlan,
)
from empathy_os.orchestration.agent_templates import AgentTemplate


@pytest.fixture
def sample_agent_template():
    """Create a sample agent template for testing."""
    return AgentTemplate(
        name="Test Agent",
        role="Test Role",
        capabilities=["testing", "analysis"],
        system_prompt="Test prompt",
        model="gpt-4",
        temperature=0.7,
    )


@pytest.fixture
def sample_agent_templates():
    """Create multiple sample agent templates."""
    return [
        AgentTemplate(
            name="Test Coverage Expert",
            role="Test Coverage Expert",
            capabilities=["testing", "coverage_analysis"],
            system_prompt="Expert in coverage",
            model="gpt-4",
            temperature=0.5,
        ),
        AgentTemplate(
            name="Test Generation Specialist",
            role="Test Generation Specialist",
            capabilities=["testing", "test_generation"],
            system_prompt="Generate tests",
            model="gpt-4",
            temperature=0.7,
        ),
        AgentTemplate(
            name="Quality Assurance Validator",
            role="Quality Assurance Validator",
            capabilities=["testing", "validation"],
            system_prompt="Validate quality",
            model="gpt-4",
            temperature=0.3,
        ),
    ]


@pytest.fixture
def orchestrator():
    """Create a MetaOrchestrator instance."""
    return MetaOrchestrator()


@pytest.fixture
def simple_task_requirements():
    """Create simple task requirements."""
    return TaskRequirements(
        complexity=TaskComplexity.SIMPLE,
        domain=TaskDomain.TESTING,
        capabilities_needed=["testing"],
        parallelizable=False,
        quality_gates={"coverage": 80},
        context={"current_coverage": 60},
    )


@pytest.fixture
def complex_task_requirements():
    """Create complex task requirements."""
    return TaskRequirements(
        complexity=TaskComplexity.COMPLEX,
        domain=TaskDomain.ARCHITECTURE,
        capabilities_needed=["architecture", "security", "performance"],
        parallelizable=True,
        quality_gates={"security_score": 95, "performance_threshold": 100},
        context={"project_size": "large"},
    )


class TestTaskComplexity:
    """Tests for TaskComplexity enum."""

    def test_given_task_complexity_enum_when_accessing_values_then_returns_correct_strings(
        self,
    ):
        """Test that TaskComplexity enum values are correct."""
        # Given/When
        simple = TaskComplexity.SIMPLE
        moderate = TaskComplexity.MODERATE
        complex_task = TaskComplexity.COMPLEX

        # Then
        assert simple.value == "simple"
        assert moderate.value == "moderate"
        assert complex_task.value == "complex"

    def test_given_task_complexity_when_comparing_enums_then_equality_works(self):
        """Test TaskComplexity enum equality."""
        # Given
        complexity1 = TaskComplexity.SIMPLE
        complexity2 = TaskComplexity.SIMPLE
        complexity3 = TaskComplexity.MODERATE

        # When/Then
        assert complexity1 == complexity2
        assert complexity1 != complexity3


class TestTaskDomain:
    """Tests for TaskDomain enum."""

    def test_given_task_domain_enum_when_accessing_all_values_then_returns_correct_strings(
        self,
    ):
        """Test that all TaskDomain enum values are correct."""
        # Given/When/Then
        assert TaskDomain.TESTING.value == "testing"
        assert TaskDomain.SECURITY.value == "security"
        assert TaskDomain.CODE_QUALITY.value == "code_quality"
        assert TaskDomain.DOCUMENTATION.value == "documentation"
        assert TaskDomain.PERFORMANCE.value == "performance"
        assert TaskDomain.ARCHITECTURE.value == "architecture"
        assert TaskDomain.REFACTORING.value == "refactoring"
        assert TaskDomain.GENERAL.value == "general"

    def test_given_task_domain_when_iterating_then_contains_all_domains(self):
        """Test that TaskDomain contains all expected domains."""
        # Given
        expected_domains = [
            "testing",
            "security",
            "code_quality",
            "documentation",
            "performance",
            "architecture",
            "refactoring",
            "general",
        ]

        # When
        actual_domains = [domain.value for domain in TaskDomain]

        # Then
        assert set(actual_domains) == set(expected_domains)


class TestCompositionPattern:
    """Tests for CompositionPattern enum."""

    def test_given_composition_pattern_enum_when_accessing_values_then_returns_correct_strings(
        self,
    ):
        """Test that CompositionPattern enum values are correct."""
        # Given/When/Then
        assert CompositionPattern.SEQUENTIAL.value == "sequential"
        assert CompositionPattern.PARALLEL.value == "parallel"
        assert CompositionPattern.DEBATE.value == "debate"
        assert CompositionPattern.TEACHING.value == "teaching"
        assert CompositionPattern.REFINEMENT.value == "refinement"
        assert CompositionPattern.ADAPTIVE.value == "adaptive"

    def test_given_composition_pattern_when_comparing_then_equality_works(self):
        """Test CompositionPattern enum equality."""
        # Given
        pattern1 = CompositionPattern.SEQUENTIAL
        pattern2 = CompositionPattern.SEQUENTIAL
        pattern3 = CompositionPattern.PARALLEL

        # When/Then
        assert pattern1 == pattern2
        assert pattern1 != pattern3


class TestTaskRequirements:
    """Tests for TaskRequirements dataclass."""

    def test_given_task_requirements_when_created_with_all_fields_then_stores_correctly(
        self,
    ):
        """Test TaskRequirements creation with all fields."""
        # Given
        complexity = TaskComplexity.MODERATE
        domain = TaskDomain.TESTING
        capabilities = ["testing", "coverage"]
        quality_gates = {"coverage": 90}
        context = {"current_coverage": 75}

        # When
        requirements = TaskRequirements(
            complexity=complexity,
            domain=domain,
            capabilities_needed=capabilities,
            parallelizable=True,
            quality_gates=quality_gates,
            context=context,
        )

        # Then
        assert requirements.complexity == complexity
        assert requirements.domain == domain
        assert requirements.capabilities_needed == capabilities
        assert requirements.parallelizable is True
        assert requirements.quality_gates == quality_gates
        assert requirements.context == context

    def test_given_task_requirements_when_created_with_minimal_fields_then_uses_defaults(
        self,
    ):
        """Test TaskRequirements creation with default values."""
        # Given
        complexity = TaskComplexity.SIMPLE
        domain = TaskDomain.GENERAL
        capabilities = ["general"]

        # When
        requirements = TaskRequirements(
            complexity=complexity, domain=domain, capabilities_needed=capabilities
        )

        # Then
        assert requirements.parallelizable is False
        assert requirements.quality_gates == {}
        assert requirements.context == {}

    def test_given_task_requirements_when_converting_to_dict_then_contains_all_fields(
        self,
    ):
        """Test TaskRequirements conversion to dictionary."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.COMPLEX,
            domain=TaskDomain.SECURITY,
            capabilities_needed=["security", "audit"],
            parallelizable=True,
        )

        # When
        requirements_dict = asdict(requirements)

        # Then
        assert "complexity" in requirements_dict
        assert "domain" in requirements_dict
        assert "capabilities_needed" in requirements_dict
        assert "parallelizable" in requirements_dict
        assert "quality_gates" in requirements_dict
        assert "context" in requirements_dict


class TestExecutionPlan:
    """Tests for ExecutionPlan dataclass."""

    def test_given_execution_plan_when_created_with_all_fields_then_stores_correctly(
        self, sample_agent_templates
    ):
        """Test ExecutionPlan creation with all fields."""
        # Given
        agents = sample_agent_templates
        strategy = CompositionPattern.SEQUENTIAL
        quality_gates = {"coverage": 90}
        cost = 0.5
        duration = 120

        # When
        plan = ExecutionPlan(
            agents=agents,
            strategy=strategy,
            quality_gates=quality_gates,
            estimated_cost=cost,
            estimated_duration=duration,
        )

        # Then
        assert plan.agents == agents
        assert plan.strategy == strategy
        assert plan.quality_gates == quality_gates
        assert plan.estimated_cost == cost
        assert plan.estimated_duration == duration

    def test_given_execution_plan_when_created_with_minimal_fields_then_uses_defaults(
        self, sample_agent_template
    ):
        """Test ExecutionPlan creation with default values."""
        # Given
        agents = [sample_agent_template]
        strategy = CompositionPattern.SEQUENTIAL

        # When
        plan = ExecutionPlan(agents=agents, strategy=strategy)

        # Then
        assert plan.quality_gates == {}
        assert plan.estimated_cost == 0.0
        assert plan.estimated_duration == 0

    def test_given_execution_plan_when_no_agents_then_creates_with_empty_list(self):
        """Test ExecutionPlan with empty agent list."""
        # Given
        agents = []
        strategy = CompositionPattern.SEQUENTIAL

        # When
        plan = ExecutionPlan(agents=agents, strategy=strategy)

        # Then
        assert plan.agents == []
        assert len(plan.agents) == 0


class TestMetaOrchestrator:
    """Tests for MetaOrchestrator class."""

    def test_given_orchestrator_when_initialized_then_creates_instance(self):
        """Test MetaOrchestrator initialization."""
        # Given/When
        orchestrator = MetaOrchestrator()

        # Then
        assert orchestrator is not None
        assert isinstance(orchestrator, MetaOrchestrator)

    @patch("empathy_os.orchestration.meta_orchestrator.get_templates_by_capability")
    def test_given_simple_task_when_analyze_and_compose_then_returns_sequential_plan(
        self, mock_get_templates, orchestrator, sample_agent_templates
    ):
        """Test analyze_and_compose with a simple task."""
        # Given
        mock_get_templates.return_value = [sample_agent_templates[0]]
        task = "Analyze test coverage"
        context = {"current_coverage": 75}

        # When
        with patch.object(
            orchestrator, "_analyze_task"
        ) as mock_analyze, patch.object(
            orchestrator, "_select_agents"
        ) as mock_select, patch.object(
            orchestrator, "_choose_composition_pattern"
        ) as mock_pattern:

            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.TESTING,
                capabilities_needed=["testing"],
            )
            mock_select.return_value = [sample_agent_templates[0]]
            mock_pattern.return_value = CompositionPattern.SEQUENTIAL

            plan = orchestrator.analyze_and_compose(task=task, context=context)

        # Then
        assert isinstance(plan, ExecutionPlan)
        assert plan.strategy == CompositionPattern.SEQUENTIAL
        assert len(plan.agents) == 1
        mock_analyze.assert_called_once()
        mock_select.assert_called_once()
        mock_pattern.assert_called_once()

    @patch("empathy_os.orchestration.meta_orchestrator.get_templates_by_capability")
    def test_given_complex_task_when_analyze_and_compose_then_returns_multi_agent_plan(
        self, mock_get_templates, orchestrator, sample_agent_templates
    ):
        """Test analyze_and_compose with a complex task."""
        # Given
        mock_get_templates.return_value = sample_agent_templates
        task = "Boost test coverage to 90%"
        context = {"current_coverage": 60, "project_size": "large"}

        # When
        with patch.object(
            orchestrator, "_analyze_task"
        ) as mock_analyze, patch.object(
            orchestrator, "_select_agents"
        ) as mock_select, patch.object(
            orchestrator, "_choose_composition_pattern"
        ) as mock_pattern:

            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.COMPLEX,
                domain=TaskDomain.TESTING,
                capabilities_needed=["testing", "coverage_analysis", "validation"],
            )
            mock_select.return_value = sample_agent_templates
            mock_pattern.return_value = CompositionPattern.REFINEMENT

            plan = orchestrator.analyze_and_compose(task=task, context=context)

        # Then
        assert isinstance(plan, ExecutionPlan)
        assert plan.strategy == CompositionPattern.REFINEMENT
        assert len(plan.agents) == 3

    def test_given_task_with_no_context_when_analyze_and_compose_then_uses_empty_context(
        self, orchestrator
    ):
        """Test analyze_and_compose with no context provided."""
        # Given
        task = "Simple task"

        # When
        with patch.object(
            orchestrator, "_analyze_task"
        ) as mock_analyze, patch.object(
            orchestrator, "_select_agents"
        ) as mock_select, patch.object(
            orchestrator, "_choose_composition_pattern"
        ) as mock_pattern:

            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=["general"],
            )
            mock_select.return_value = []
            mock_pattern.return_value = CompositionPattern.SEQUENTIAL

            plan = orchestrator.analyze_and_compose(task=task)

        # Then
        assert isinstance(plan, ExecutionPlan)
        mock_analyze.assert_called_once()

    def test_given_empty_task_string_when_analyze_and_compose_then_handles_gracefully(
        self, orchestrator
    ):
        """Test analyze_and_compose with empty task string."""
        # Given
        task = ""

        # When
        with patch.object(
            orchestrator, "_analyze_task"
        ) as mock_analyze, patch.object(
            orchestrator, "_select_agents"
        ) as mock_select, patch.object(
            orchestrator, "_choose_composition_pattern"
        ) as mock_pattern:

            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=["general"],
            )
            mock_select.return_value = []
            mock_pattern.return_value = CompositionPattern.SEQUENTIAL

            plan = orchestrator.analyze_and_compose(task=task)

        # Then
        assert isinstance(plan, ExecutionPlan)

    def test_given_