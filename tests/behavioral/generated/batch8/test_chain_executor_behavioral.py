"""Behavioral tests for chain_executor.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from datetime import datetime
from pathlib import Path
from unittest.mock import Mock, mock_open, patch, MagicMock
import pytest
import yaml

from empathy_os.routing.chain_executor import (
    ChainConfig,
    ChainExecutor,
    ChainExecution,
    ChainStep,
    ChainTrigger,
)


@pytest.fixture
def temp_config_path(tmp_path):
    """Create a temporary config path."""
    return tmp_path / "workflow_chains.yaml"


@pytest.fixture
def sample_chain_config():
    """Sample chain configuration data."""
    return {
        "global": {
            "default_approval_required": False,
            "max_chain_depth": 5,
        },
        "chains": {
            "security-audit": {
                "auto_chain": True,
                "description": "Security audit workflow",
                "triggers": [
                    {
                        "condition": "high_severity_count > 3",
                        "next_workflow": "create-security-tickets",
                        "approval_required": False,
                        "reason": "High severity findings detected",
                    },
                    {
                        "condition": "vulnerability_type == 'injection'",
                        "next_workflow": "emergency-review",
                        "approval_required": True,
                        "reason": "Critical vulnerability type",
                    },
                ],
            },
            "code-review": {
                "auto_chain": False,
                "description": "Code review workflow",
                "triggers": [],
            },
        },
        "templates": {
            "full-security-review": ["security-audit", "create-security-tickets"],
            "quick-scan": ["security-audit"],
        },
    }


@pytest.fixture
def mock_workflow_registry():
    """Mock WorkflowRegistry."""
    with patch("empathy_os.routing.chain_executor.WorkflowRegistry") as mock_registry:
        registry_instance = Mock()
        mock_registry.return_value = registry_instance
        yield registry_instance


class TestChainTrigger:
    """Tests for ChainTrigger dataclass."""

    def test_given_trigger_data_when_created_then_attributes_set(self):
        """Given trigger parameters, when ChainTrigger is created, then attributes are properly set."""
        # Given
        condition = "severity > 5"
        next_workflow = "escalate"
        approval_required = True
        reason = "High severity"

        # When
        trigger = ChainTrigger(
            condition=condition,
            next_workflow=next_workflow,
            approval_required=approval_required,
            reason=reason,
        )

        # Then
        assert trigger.condition == condition
        assert trigger.next_workflow == next_workflow
        assert trigger.approval_required == approval_required
        assert trigger.reason == reason

    def test_given_minimal_data_when_created_then_defaults_applied(self):
        """Given minimal data, when ChainTrigger is created, then default values are applied."""
        # Given/When
        trigger = ChainTrigger(condition="x > 1", next_workflow="next")

        # Then
        assert trigger.approval_required is False
        assert trigger.reason == ""


class TestChainConfig:
    """Tests for ChainConfig dataclass."""

    def test_given_config_data_when_created_then_attributes_set(self):
        """Given config parameters, when ChainConfig is created, then attributes are properly set."""
        # Given
        workflow_name = "test-workflow"
        auto_chain = False
        description = "Test description"
        triggers = [ChainTrigger(condition="x > 1", next_workflow="next")]

        # When
        config = ChainConfig(
            workflow_name=workflow_name,
            auto_chain=auto_chain,
            description=description,
            triggers=triggers,
        )

        # Then
        assert config.workflow_name == workflow_name
        assert config.auto_chain is False
        assert config.description == description
        assert len(config.triggers) == 1

    def test_given_minimal_data_when_created_then_defaults_applied(self):
        """Given minimal data, when ChainConfig is created, then default values are applied."""
        # Given/When
        config = ChainConfig(workflow_name="test")

        # Then
        assert config.auto_chain is True
        assert config.description == ""
        assert config.triggers == []


class TestChainStep:
    """Tests for ChainStep dataclass."""

    def test_given_step_data_when_created_then_attributes_set(self):
        """Given step parameters, when ChainStep is created, then attributes are properly set."""
        # Given
        workflow_name = "step-workflow"
        triggered_by = "manual"
        approval_required = True

        # When
        step = ChainStep(
            workflow_name=workflow_name,
            triggered_by=triggered_by,
            approval_required=approval_required,
        )

        # Then
        assert step.workflow_name == workflow_name
        assert step.triggered_by == triggered_by
        assert step.approval_required is True
        assert step.approved is None
        assert step.result == {}
        assert step.started_at is None
        assert step.completed_at is None

    def test_given_complete_step_data_when_created_then_all_fields_set(self):
        """Given complete step data, when ChainStep is created, then all fields are set."""
        # Given
        now = datetime.now()
        result = {"status": "success"}

        # When
        step = ChainStep(
            workflow_name="workflow",
            triggered_by="condition",
            approval_required=False,
            approved=True,
            result=result,
            started_at=now,
            completed_at=now,
        )

        # Then
        assert step.approved is True
        assert step.result == result
        assert step.started_at == now
        assert step.completed_at == now


class TestChainExecution:
    """Tests for ChainExecution dataclass."""

    def test_given_execution_data_when_created_then_attributes_set(self):
        """Given execution parameters, when ChainExecution is created, then attributes are properly set."""
        # Given
        chain_id = "chain-123"
        initial_workflow = "start-workflow"

        # When
        execution = ChainExecution(chain_id=chain_id, initial_workflow=initial_workflow)

        # Then
        assert execution.chain_id == chain_id
        assert execution.initial_workflow == initial_workflow
        assert execution.steps == []
        assert execution.status == "running"
        assert execution.current_step == 0
        assert execution.completed_at is None
        assert isinstance(execution.started_at, datetime)

    def test_given_complete_execution_data_when_created_then_all_fields_set(self):
        """Given complete execution data, when ChainExecution is created, then all fields are set."""
        # Given
        chain_id = "chain-456"
        initial_workflow = "workflow"
        steps = [
            ChainStep(
                workflow_name="step1", triggered_by="manual", approval_required=False
            )
        ]
        now = datetime.now()

        # When
        execution = ChainExecution(
            chain_id=chain_id,
            initial_workflow=initial_workflow,
            steps=steps,
            started_at=now,
            completed_at=now,
            status="completed",
            current_step=1,
        )

        # Then
        assert len(execution.steps) == 1
        assert execution.status == "completed"
        assert execution.current_step == 1
        assert execution.completed_at == now


class TestChainExecutorInit:
    """Tests for ChainExecutor initialization."""

    def test_given_no_config_file_when_initialized_then_executor_created(
        self, temp_config_path, mock_workflow_registry
    ):
        """Given no config file exists, when ChainExecutor is initialized, then executor is created with empty config."""
        # Given - temp_config_path doesn't exist

        # When
        executor = ChainExecutor(config_path=temp_config_path)

        # Then
        assert executor.config_path == temp_config_path
        assert executor._configs == {}
        assert executor._templates == {}
        assert executor._global_settings == {}
        assert executor._executions == []

    def test_given_valid_config_file_when_initialized_then_config_loaded(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given valid config file, when ChainExecutor is initialized, then config is loaded."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))

        # When
        executor = ChainExecutor(config_path=temp_config_path)

        # Then
        assert len(executor._configs) == 2
        assert "security-audit" in executor._configs
        assert "code-review" in executor._configs
        assert len(executor._templates) == 2
        assert "full-security-review" in executor._templates
        assert executor._global_settings["max_chain_depth"] == 5

    def test_given_empty_yaml_when_initialized_then_defaults_used(
        self, temp_config_path, mock_workflow_registry
    ):
        """Given empty YAML file, when ChainExecutor is initialized, then defaults are used."""
        # Given
        temp_config_path.write_text("")

        # When
        executor = ChainExecutor(config_path=temp_config_path)

        # Then
        assert executor._configs == {}
        assert executor._templates == {}
        assert executor._global_settings == {}

    def test_given_malformed_yaml_when_initialized_then_exception_handled(
        self, temp_config_path, mock_workflow_registry
    ):
        """Given malformed YAML, when ChainExecutor is initialized, then exception is handled gracefully."""
        # Given
        temp_config_path.write_text("invalid: yaml: content: [")

        # When/Then - Should not raise exception but handle gracefully
        with pytest.raises(yaml.YAMLError):
            ChainExecutor(config_path=temp_config_path)


class TestChainExecutorLoadConfig:
    """Tests for ChainExecutor._load_config method."""

    def test_given_chains_with_triggers_when_loaded_then_triggers_parsed(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given chains with triggers, when config is loaded, then triggers are properly parsed."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))

        # When
        executor = ChainExecutor(config_path=temp_config_path)

        # Then
        security_config = executor._configs["security-audit"]
        assert len(security_config.triggers) == 2
        assert security_config.triggers[0].condition == "high_severity_count > 3"
        assert security_config.triggers[0].next_workflow == "create-security-tickets"
        assert security_config.triggers[1].approval_required is True

    def test_given_templates_when_loaded_then_templates_stored(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given templates in config, when loaded, then templates are stored."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))

        # When
        executor = ChainExecutor(config_path=temp_config_path)

        # Then
        assert "full-security-review" in executor._templates
        assert executor._templates["full-security-review"] == [
            "security-audit",
            "create-security-tickets",
        ]
        assert executor._templates["quick-scan"] == ["security-audit"]

    def test_given_global_settings_when_loaded_then_settings_stored(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given global settings in config, when loaded, then settings are stored."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))

        # When
        executor = ChainExecutor(config_path=temp_config_path)

        # Then
        assert executor._global_settings["default_approval_required"] is False
        assert executor._global_settings["max_chain_depth"] == 5


class TestChainExecutorGetTriggeredChains:
    """Tests for ChainExecutor.get_triggered_chains method."""

    def test_given_matching_condition_when_checked_then_chain_triggered(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given result matching trigger condition, when checked, then chain is triggered."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))
        executor = ChainExecutor(config_path=temp_config_path)
        result = {"high_severity_count": 5}

        # When
        triggered = executor.get_triggered_chains("security-audit", result)

        # Then
        assert len(triggered) == 1
        assert triggered[0].next_workflow == "create-security-tickets"

    def test_given_no_matching_condition_when_checked_then_no_chains_triggered(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given result not matching any condition, when checked, then no chains are triggered."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))
        executor = ChainExecutor(config_path=temp_config_path)
        result = {"high_severity_count": 1}

        # When
        triggered = executor.get_triggered_chains("security-audit", result)

        # Then
        assert len(triggered) == 0

    def test_given_multiple_matching_conditions_when_checked_then_all_triggered(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given result matching multiple conditions, when checked, then all chains are triggered."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))
        executor = ChainExecutor(config_path=temp_config_path)
        result = {"high_severity_count": 5, "vulnerability_type": "injection"}

        # When
        triggered = executor.get_triggered_chains("security-audit", result)

        # Then
        assert len(triggered) == 2

    def test_given_unknown_workflow_when_checked_then_empty_list_returned(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given unknown workflow name, when checked, then empty list is returned."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))
        executor = ChainExecutor(config_path=temp_config_path)
        result = {"data": "value"}

        # When
        triggered = executor.get_triggered_chains("unknown-workflow", result)

        # Then
        assert triggered == []

    def test_given_workflow_with_no_triggers_when_checked_then_empty_list_returned(
        self, temp_config_path, sample_chain_config, mock_workflow_registry
    ):
        """Given workflow with no triggers, when checked, then empty list is returned."""
        # Given
        temp_config_path.write_text(yaml.dump(sample_chain_config))
        executor = ChainExecutor(config_path=temp_config_path)
        result = {"data": "value"}

        # When
        triggered = executor.get_triggered_chains("code-review",