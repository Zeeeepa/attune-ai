"""Behavioral tests for caching.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import time
from unittest.mock import patch

import pytest

from attune.memory.short_term.caching import CacheManager


# Fixtures
@pytest.fixture
def cache_enabled():
    """Create an enabled cache manager with default settings."""
    return CacheManager(enabled=True, max_size=100)


@pytest.fixture
def cache_disabled():
    """Create a disabled cache manager."""
    return CacheManager(enabled=False, max_size=100)


@pytest.fixture
def small_cache():
    """Create a cache with very small size for testing eviction."""
    return CacheManager(enabled=True, max_size=2)


# Test __init__
class TestCacheManagerInit:
    """Test CacheManager initialization."""

    def test_init_with_default_values(self):
        """
        Given: No parameters provided
        When: Creating a CacheManager
        Then: Default values are set correctly
        """
        cache = CacheManager()
        assert cache.enabled is True
        assert cache.max_size == 1000
        assert cache.hits == 0
        assert cache.misses == 0
        assert len(cache._cache) == 0

    def test_init_with_custom_values(self):
        """
        Given: Custom parameters for enabled and max_size
        When: Creating a CacheManager
        Then: Custom values are set correctly
        """
        cache = CacheManager(enabled=False, max_size=500)
        assert cache.enabled is False
        assert cache.max_size == 500
        assert cache.hits == 0
        assert cache.misses == 0

    def test_init_with_zero_max_size(self):
        """
        Given: max_size is set to 0
        When: Creating a CacheManager
        Then: Cache manager is created without error
        """
        cache = CacheManager(enabled=True, max_size=0)
        assert cache.max_size == 0
        assert cache.enabled is True


# Test hits property
class TestCacheManagerHits:
    """Test hits property."""

    def test_hits_initially_zero(self, cache_enabled):
        """
        Given: A newly created cache
        When: Accessing hits property
        Then: Returns 0
        """
        assert cache_enabled.hits == 0

    def test_hits_after_cache_hit(self, cache_enabled):
        """
        Given: A cache with a stored value
        When: Getting the value successfully
        Then: Hits counter increments
        """
        cache_enabled.add("key1", "value1")
        cache_enabled.get("key1")
        assert cache_enabled.hits == 1

    def test_hits_multiple_times(self, cache_enabled):
        """
        Given: A cache with stored values
        When: Multiple successful gets occur
        Then: Hits counter increments each time
        """
        cache_enabled.add("key1", "value1")
        cache_enabled.get("key1")
        cache_enabled.get("key1")
        cache_enabled.get("key1")
        assert cache_enabled.hits == 3


# Test misses property
class TestCacheManagerMisses:
    """Test misses property."""

    def test_misses_initially_zero(self, cache_enabled):
        """
        Given: A newly created cache
        When: Accessing misses property
        Then: Returns 0
        """
        assert cache_enabled.misses == 0

    def test_misses_after_cache_miss(self, cache_enabled):
        """
        Given: An empty cache
        When: Getting a non-existent key
        Then: Misses counter increments
        """
        cache_enabled.get("nonexistent")
        assert cache_enabled.misses == 1

    def test_misses_when_disabled(self, cache_disabled):
        """
        Given: A disabled cache
        When: Getting any key
        Then: Misses counter increments
        """
        cache_disabled.get("key1")
        assert cache_disabled.misses == 1


# Test get method
class TestCacheManagerGet:
    """Test get method."""

    def test_get_from_disabled_cache_returns_none(self, cache_disabled):
        """
        Given: A disabled cache
        When: Getting any key
        Then: Returns None and increments misses
        """
        result = cache_disabled.get("key1")
        assert result is None
        assert cache_disabled.misses == 1
        assert cache_disabled.hits == 0

    def test_get_nonexistent_key_returns_none(self, cache_enabled):
        """
        Given: An enabled cache without the key
        When: Getting a nonexistent key
        Then: Returns None and increments misses
        """
        result = cache_enabled.get("nonexistent")
        assert result is None
        assert cache_enabled.misses == 1
        assert cache_enabled.hits == 0

    def test_get_existing_key_returns_value(self, cache_enabled):
        """
        Given: A cache with a stored value
        When: Getting the existing key
        Then: Returns the value and increments hits
        """
        cache_enabled.add("key1", "value1")
        result = cache_enabled.get("key1")
        assert result == "value1"
        assert cache_enabled.hits == 1
        assert cache_enabled.misses == 0

    @patch("attune.memory.short_term.caching.time.time")
    def test_get_updates_last_access_time(self, mock_time, cache_enabled):
        """
        Given: A cache with a stored value
        When: Getting the value
        Then: Last access time is updated
        """
        mock_time.return_value = 1000.0
        cache_enabled.add("key1", "value1")

        mock_time.return_value = 2000.0
        cache_enabled.get("key1")

        # Verify last access was updated
        _, _, last_access = cache_enabled._cache["key1"]
        assert last_access == 2000.0

    def test_get_after_remove_returns_none(self, cache_enabled):
        """
        Given: A cache with a key that has been removed
        When: Getting the removed key
        Then: Returns None and increments misses
        """
        cache_enabled.add("key1", "value1")
        cache_enabled.remove("key1")
        result = cache_enabled.get("key1")

        assert result is None
        assert cache_enabled.misses == 1


# Test add method
class TestCacheManagerAdd:
    """Test add method."""

    def test_add_to_disabled_cache_does_nothing(self, cache_disabled):
        """
        Given: A disabled cache
        When: Adding a value
        Then: Nothing is stored
        """
        cache_disabled.add("key1", "value1")
        assert len(cache_disabled._cache) == 0

    def test_add_single_value(self, cache_enabled):
        """
        Given: An empty enabled cache
        When: Adding a key-value pair
        Then: Value is stored in cache
        """
        cache_enabled.add("key1", "value1")
        assert "key1" in cache_enabled._cache
        assert cache_enabled.get("key1") == "value1"

    @patch("attune.memory.short_term.caching.time.time")
    def test_add_stores_with_timestamp(self, mock_time, cache_enabled):
        """
        Given: An enabled cache
        When: Adding a value
        Then: Value is stored with correct timestamp
        """
        mock_time.return_value = 1000.0
        cache_enabled.add("key1", "value1")

        value, timestamp, last_access = cache_enabled._cache["key1"]
        assert value == "value1"
        assert timestamp == 1000.0
        assert last_access == 1000.0

    def test_add_overwrites_existing_key(self, cache_enabled):
        """
        Given: A cache with an existing key
        When: Adding the same key with a new value
        Then: Old value is overwritten
        """
        cache_enabled.add("key1", "old_value")
        cache_enabled.add("key1", "new_value")
        assert cache_enabled.get("key1") == "new_value"

    def test_add_triggers_lru_eviction_when_full(self, small_cache):
        """
        Given: A cache at max capacity
        When: Adding a new key
        Then: Least recently used key is evicted
        """
        with patch("attune.memory.short_term.caching.time.time") as mock_time:
            mock_time.return_value = 1000.0
            small_cache.add("key1", "value1")

            mock_time.return_value = 1001.0
            small_cache.add("key2", "value2")

            mock_time.return_value = 1002.0
            # Access key2 to make key1 the LRU
            small_cache.get("key2")

            mock_time.return_value = 1003.0
            # Adding key3 should evict key1
            small_cache.add("key3", "value3")

            assert "key1" not in small_cache._cache
            assert "key2" in small_cache._cache
            assert "key3" in small_cache._cache

    def test_add_multiple_values_within_limit(self, cache_enabled):
        """
        Given: An enabled cache with sufficient capacity
        When: Adding multiple values
        Then: All values are stored
        """
        for i in range(10):
            cache_enabled.add(f"key{i}", f"value{i}")

        assert len(cache_enabled._cache) == 10
        for i in range(10):
            assert cache_enabled.get(f"key{i}") == f"value{i}"


# Test remove method
class TestCacheManagerRemove:
    """Test remove method."""

    def test_remove_from_disabled_cache_does_nothing(self, cache_disabled):
        """
        Given: A disabled cache
        When: Removing a key
        Then: No error occurs
        """
        cache_disabled.remove("key1")
        # No exception should be raised

    def test_remove_existing_key(self, cache_enabled):
        """
        Given: A cache with a stored value
        When: Removing the key
        Then: Key is removed from cache
        """
        cache_enabled.add("key1", "value1")
        cache_enabled.remove("key1")
        assert "key1" not in cache_enabled._cache
        assert cache_enabled.get("key1") is None

    def test_remove_nonexistent_key(self, cache_enabled):
        """
        Given: An enabled cache
        When: Removing a nonexistent key
        Then: No error occurs
        """
        cache_enabled.remove("nonexistent")
        # No exception should be raised

    def test_remove_multiple_keys(self, cache_enabled):
        """
        Given: A cache with multiple values
        When: Removing several keys
        Then: Only specified keys are removed
        """
        cache_enabled.add("key1", "value1")
        cache_enabled.add("key2", "value2")
        cache_enabled.add("key3", "value3")

        cache_enabled.remove("key1")
        cache_enabled.remove("key2")

        assert "key1" not in cache_enabled._cache
        assert "key2" not in cache_enabled._cache
        assert "key3" in cache_enabled._cache


# Test invalidate method
class TestCacheManagerInvalidate:
    """Test invalidate method."""

    def test_invalidate_on_disabled_cache_returns_false(self, cache_disabled):
        """
        Given: A disabled cache
        When: Invalidating a key
        Then: Returns False
        """
        result = cache_disabled.invalidate("user:123")
        assert result is False

    def test_invalidate_with_exact_match(self, cache_enabled):
        """
        Given: A cache with multiple keys
        When: Invalidating with exact key
        Then: Only matching key is removed and returns True
        """
        cache_enabled.add("user:123", "value1")
        cache_enabled.add("user:456", "value2")
        cache_enabled.add("post:789", "value3")

        result = cache_enabled.invalidate("user:123")

        assert result is True
        assert "user:123" not in cache_enabled._cache
        assert "user:456" in cache_enabled._cache

    def test_invalidate_nonexistent_key_returns_false(self, cache_enabled):
        """
        Given: A cache with keys
        When: Invalidating a nonexistent key
        Then: Returns False
        """
        cache_enabled.add("user:123", "value1")
        result = cache_enabled.invalidate("admin:999")
        assert result is False
        assert "user:123" in cache_enabled._cache

    def test_invalidate_multiple_keys_individually(self, cache_enabled):
        """
        Given: A cache with multiple keys
        When: Invalidating each key individually
        Then: Each returns True and keys are removed
        """
        cache_enabled.add("user:123", "value1")
        cache_enabled.add("user:456", "value2")
        cache_enabled.add("post:789", "value3")

        assert cache_enabled.invalidate("user:123") is True
        assert cache_enabled.invalidate("user:456") is True
        assert "user:123" not in cache_enabled._cache
        assert "user:456" not in cache_enabled._cache
        assert "post:789" in cache_enabled._cache

    def test_invalidate_same_key_twice(self, cache_enabled):
        """
        Given: A cache with a key
        When: Invalidating the same key twice
        Then: First returns True, second returns False
        """
        cache_enabled.add("key1", "value1")

        assert cache_enabled.invalidate("key1") is True
        assert cache_enabled.invalidate("key1") is False


# Test contains method
class TestCacheManagerContains:
    """Test contains method."""

    def test_contains_on_disabled_cache_returns_false(self, cache_disabled):
        """
        Given: A disabled cache
        When: Checking if key exists
        Then: Returns False
        """
        assert cache_disabled.contains("key1") is False
