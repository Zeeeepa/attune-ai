"""Behavioral tests for streams.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING
from unittest.mock import MagicMock, Mock, patch

import pytest
import redis

from attune.memory.short_term.streams import StreamManager
from attune.memory.types import AccessTier, AgentCredentials

if TYPE_CHECKING:
    from attune.memory.short_term.base import BaseOperations


# Fixtures


@pytest.fixture
def mock_base_ops():
    """Create a mock BaseOperations instance."""
    base_ops = Mock()
    base_ops.use_mock = False
    base_ops._client = Mock()
    base_ops._metrics = Mock()
    return base_ops


@pytest.fixture
def mock_base_ops_mocked():
    """Create a mock BaseOperations instance in mocked mode."""
    base_ops = Mock()
    base_ops.use_mock = True
    base_ops._client = None
    base_ops._metrics = Mock()
    return base_ops


@pytest.fixture
def stream_manager(mock_base_ops):
    """Create a StreamManager instance with mock base operations."""
    return StreamManager(mock_base_ops)


@pytest.fixture
def stream_manager_mocked(mock_base_ops_mocked):
    """Create a StreamManager instance with mocked base operations."""
    return StreamManager(mock_base_ops_mocked)


@pytest.fixture
def contributor_creds():
    """Create contributor credentials."""
    return AgentCredentials("agent_1", AccessTier.CONTRIBUTOR)


@pytest.fixture
def observer_creds():
    """Create observer credentials."""
    return AgentCredentials("agent_2", AccessTier.OBSERVER)


@pytest.fixture
def admin_creds():
    """Create admin credentials."""
    return AgentCredentials("admin_1", AccessTier.STEWARD)


# StreamManager.__init__ Tests


class TestStreamManagerInit:
    """Test StreamManager initialization."""

    def test_init_sets_base_operations(self, mock_base_ops):
        """
        GIVEN a BaseOperations instance
        WHEN StreamManager is initialized
        THEN it stores the base operations and initializes empty mock streams
        """
        manager = StreamManager(mock_base_ops)

        assert manager._base is mock_base_ops
        assert manager._mock_streams == {}

    def test_init_sets_prefix_stream_constant(self, mock_base_ops):
        """
        GIVEN a BaseOperations instance
        WHEN StreamManager is initialized
        THEN it has the correct PREFIX_STREAM constant
        """
        manager = StreamManager(mock_base_ops)

        assert manager.PREFIX_STREAM == "stream:"


# StreamManager.append Tests


class TestStreamManagerAppend:
    """Test StreamManager.append method."""

    def test_append_success_with_contributor(
        self, stream_manager, contributor_creds
    ):
        """
        GIVEN a stream manager with contributor credentials
        WHEN appending data to a stream
        THEN the entry is added to Redis and an entry ID is returned
        """
        stream_manager._base._client.xadd.return_value = "1234567890-0"
        data = {"action": "promoted", "details": "test"}

        entry_id = stream_manager.append("audit", data, contributor_creds)

        assert entry_id == "1234567890-0"
        call_args = stream_manager._base._client.xadd.call_args
        assert call_args[0][0] == "stream:audit"
        entry = call_args[0][1]
        assert entry["agent_id"] == "agent_1"
        assert entry["action"] == "promoted"
        assert entry["details"] == "test"
        assert call_args[1]["maxlen"] == 10000

    def test_append_success_with_admin(self, stream_manager, admin_creds):
        """
        GIVEN a stream manager with steward credentials
        WHEN appending data to a stream
        THEN the entry is added to Redis and an entry ID is returned
        """
        stream_manager._base._client.xadd.return_value = "1234567890-0"
        data = {"action": "deleted"}

        entry_id = stream_manager.append("audit", data, admin_creds)

        assert entry_id == "1234567890-0"

    def test_append_with_custom_max_len(self, stream_manager, contributor_creds):
        """
        GIVEN a stream manager
        WHEN appending data with a custom max_len
        THEN the max_len is passed to Redis xadd
        """
        stream_manager._base._client.xadd.return_value = "1234567890-0"
        data = {"action": "test"}

        stream_manager.append("audit", data, contributor_creds, max_len=5000)

        call_args = stream_manager._base._client.xadd.call_args
        assert call_args[0][0] == "stream:audit"
        assert call_args[1]["maxlen"] == 5000

    def test_append_with_observer_credentials_raises_permission_error(
        self, stream_manager, observer_creds
    ):
        """
        GIVEN a stream manager with observer credentials
        WHEN attempting to append data
        THEN it raises PermissionError (insufficient permissions)
        """
        data = {"action": "test"}

        with pytest.raises(PermissionError):
            stream_manager.append("audit", data, observer_creds)

        stream_manager._base.client.xadd.assert_not_called()

    def test_append_with_redis_error(self, stream_manager, contributor_creds):
        """
        GIVEN a stream manager
        WHEN Redis raises an error during xadd
        THEN the error propagates
        """
        stream_manager._base._client.xadd.side_effect = redis.RedisError("Connection error")
        data = {"action": "test"}

        with pytest.raises(redis.RedisError):
            stream_manager.append("audit", data, contributor_creds)

    def test_append_with_generic_exception(self, stream_manager, contributor_creds):
        """
        GIVEN a stream manager
        WHEN a generic exception occurs during xadd
        THEN the error propagates
        """
        stream_manager._base._client.xadd.side_effect = Exception("Unexpected error")
        data = {"action": "test"}

        with pytest.raises(Exception, match="Unexpected error"):
            stream_manager.append("audit", data, contributor_creds)

    def test_append_mocked_mode_success(
        self, stream_manager_mocked, contributor_creds
    ):
        """
        GIVEN a stream manager in mocked mode
        WHEN appending data to a stream
        THEN the data is stored in mock_streams and a mock ID is returned
        """
        data = {"action": "test"}

        entry_id = stream_manager_mocked.append("audit", data, contributor_creds)

        assert entry_id is not None
        assert "stream:audit" in stream_manager_mocked._mock_streams
        assert len(stream_manager_mocked._mock_streams["stream:audit"]) == 1
        stored_entry = stream_manager_mocked._mock_streams["stream:audit"][0]
        assert stored_entry[0] == entry_id
        assert stored_entry[1]["agent_id"] == "agent_1"
        assert stored_entry[1]["action"] == "test"

    def test_append_mocked_mode_multiple_entries(
        self, stream_manager_mocked, contributor_creds
    ):
        """
        GIVEN a stream manager in mocked mode
        WHEN appending multiple entries
        THEN all entries are stored
        """
        data1 = {"action": "first"}
        data2 = {"action": "second"}

        entry_id1 = stream_manager_mocked.append("audit", data1, contributor_creds)
        entry_id2 = stream_manager_mocked.append("audit", data2, contributor_creds)

        assert entry_id1 is not None
        assert entry_id2 is not None
        assert len(stream_manager_mocked._mock_streams["stream:audit"]) == 2

    def test_append_mocked_mode_with_observer_raises_permission_error(
        self, stream_manager_mocked, observer_creds
    ):
        """
        GIVEN a stream manager in mocked mode with observer credentials
        WHEN attempting to append data
        THEN PermissionError is raised
        """
        data = {"action": "test"}

        with pytest.raises(PermissionError):
            stream_manager_mocked.append("audit", data, observer_creds)

    def test_append_with_empty_data(self, stream_manager, contributor_creds):
        """
        GIVEN a stream manager
        WHEN appending empty data
        THEN the entry is still added with agent_id and timestamp
        """
        stream_manager._base._client.xadd.return_value = "1234567890-0"
        data = {}

        entry_id = stream_manager.append("audit", data, contributor_creds)

        assert entry_id == "1234567890-0"
        stream_manager._base._client.xadd.assert_called_once()

    def test_append_with_complex_data(self, stream_manager, contributor_creds):
        """
        GIVEN a stream manager
        WHEN appending complex nested data
        THEN dicts and lists are JSON-serialized in the entry
        """
        stream_manager._base._client.xadd.return_value = "1234567890-0"
        data = {
            "action": "test",
            "nested": {"key": "value"},
            "items": [1, 2, 3],
        }

        entry_id = stream_manager.append("audit", data, contributor_creds)

        assert entry_id == "1234567890-0"
        call_args = stream_manager._base._client.xadd.call_args[0]
        entry = call_args[1]
        assert entry["action"] == "test"
        assert entry["nested"] == '{"key": "value"}'
        assert entry["items"] == "[1, 2, 3]"


# StreamManager.read Tests


class TestStreamManagerRead:
    """Test StreamManager.read method."""

    def test_read_success_with_observer(self, stream_manager, observer_creds):
        """
        GIVEN a stream manager with observer credentials
        WHEN reading from a stream
        THEN entries are returned from Redis
        """
        stream_manager._base._client.xrange.return_value = [
            ("1234567890-0", {"action": "test"}),
            ("1234567891-0", {"action": "test2"}),
        ]

        entries = stream_manager.read("audit", observer_creds, count=50)

        assert len(entries) == 2
        assert entries[0][0] == "1234567890-0"
        stream_manager._base._client.xrange.assert_called_once_with(
            "stream:audit", min="0", count=50
        )

    def test_read_with_start_id(self, stream_manager, observer_creds):
        """
        GIVEN a stream manager
        WHEN reading from a specific start ID
        THEN xrange is called with the correct min parameter
        """
        stream_manager._base._client.xrange.return_value = []

        stream_manager.read("audit", observer_creds, start_id="1234567890-0")

        stream_manager._base._client.xrange.assert_called_once_with(
            "stream:audit", min="1234567890-0", count=100
        )

    def test_read_with_custom_count(self, stream_manager, observer_creds):
        """
        GIVEN a stream manager
        WHEN reading with a custom count
        THEN xrange is called with the correct count parameter
        """
        stream_manager._base._client.xrange.return_value = []

        stream_manager.read("audit", observer_creds, count=10)

        stream_manager._base._client.xrange.assert_called_once_with(
            "stream:audit", min="0", count=10
        )

    def test_read_with_redis_error(self, stream_manager, observer_creds):
        """
        GIVEN a stream manager
        WHEN Redis raises an error during xrange
        THEN the error propagates
        """
        stream_manager._base._client.xrange.side_effect = redis.RedisError(
            "Connection error"
        )

        with pytest.raises(redis.RedisError):
            stream_manager.read("audit", observer_creds)

    def test_read_with_generic_exception(self, stream_manager, observer_creds):
        """
        GIVEN a stream manager
        WHEN a generic exception occurs during xrange
        THEN the error propagates
        """
        stream_manager._base._client.xrange.side_effect = Exception("Unexpected error")

        with pytest.raises(Exception, match="Unexpected error"):
            stream_manager.read("audit", observer_creds)

    def test_read_returns_string_keys(self, stream_manager, observer_creds):
        """
        GIVEN a stream manager
        WHEN reading entries with bytes keys
        THEN entry data keys are converted to strings
        """
        stream_manager._base._client.xrange.return_value = [
            ("1234567890-0", {"action": "test", "agent_id": "agent_1"}),
        ]

        entries = stream_manager.read("audit", observer_creds)

        assert len(entries) == 1
        entry_data = entries[0][1]
        assert "action" in entry_data
        assert "agent_id" in entry_data

    def test_read_mocked_mode_success(self, stream_manager_mocked, observer_creds):
        """
        GIVEN a stream manager in mocked mode with existing entries
        WHEN reading from a stream
        THEN entries are returned from mock_streams
        """
        stream_manager_mocked._mock_streams["stream:audit"] = [
            ("1234567890-0", {"action": "test1", "agent_id": "a1"}),
            ("1234567891-0", {"action": "test2", "agent_id": "a2"}),
        ]

        entries = stream_manager_mocked.read("audit", observer_creds)

        assert len(entries) == 2
        assert entries[0][0] == "1234567890-0"
        assert entries[0][1]["action"] == "test1"
        assert entries[1][0] == "1234567891-0"
        assert entries[1][1]["action"] == "test2"

    def test_read_mocked_mode_with_start_id(
        self, stream_manager_mocked, observer_creds
    ):
        """
        GIVEN a stream manager in mocked mode with multiple entries
        WHEN reading from a specific start ID
        THEN only entries after the start ID are returned
        """
