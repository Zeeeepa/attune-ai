"""Behavioral tests for data_models.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from dataclasses import fields, is_dataclass
from typing import get_type_hints

from empathy_os.workflows.test_gen.data_models import (
    FunctionSignature,
    ClassSignature,
)


class TestFunctionSignature:
    """Behavioral tests for FunctionSignature dataclass."""

    def test_given_minimal_params_when_creating_function_signature_then_instance_created(self):
        """Given minimal required parameters.
        When creating a FunctionSignature instance.
        Then the instance is created with correct attributes.
        """
        # Given
        name = "test_function"
        params = [("arg1", "str", None), ("arg2", "int", "0")]
        return_type = "bool"
        is_async = False
        raises = {"ValueError", "TypeError"}
        has_side_effects = True
        docstring = "Test docstring"
        
        # When
        signature = FunctionSignature(
            name=name,
            params=params,
            return_type=return_type,
            is_async=is_async,
            raises=raises,
            has_side_effects=has_side_effects,
            docstring=docstring,
        )
        
        # Then
        assert signature.name == name
        assert signature.params == params
        assert signature.return_type == return_type
        assert signature.is_async == is_async
        assert signature.raises == raises
        assert signature.has_side_effects == has_side_effects
        assert signature.docstring == docstring
        assert signature.complexity == 1  # Default value
        assert signature.decorators == []  # Default value

    def test_given_all_params_when_creating_function_signature_then_all_attributes_set(self):
        """Given all parameters including optional ones.
        When creating a FunctionSignature instance.
        Then all attributes are correctly set.
        """
        # Given
        name = "complex_function"
        params = [("x", "float", None), ("y", "float", "1.0")]
        return_type = "tuple[int, str]"
        is_async = True
        raises = {"RuntimeError"}
        has_side_effects = False
        docstring = "Complex function docstring"
        complexity = 5
        decorators = ["@staticmethod", "@property"]
        
        # When
        signature = FunctionSignature(
            name=name,
            params=params,
            return_type=return_type,
            is_async=is_async,
            raises=raises,
            has_side_effects=has_side_effects,
            docstring=docstring,
            complexity=complexity,
            decorators=decorators,
        )
        
        # Then
        assert signature.name == name
        assert signature.params == params
        assert signature.return_type == return_type
        assert signature.is_async is True
        assert signature.raises == raises
        assert signature.has_side_effects is False
        assert signature.docstring == docstring
        assert signature.complexity == complexity
        assert signature.decorators == decorators

    def test_given_no_params_when_creating_function_signature_then_empty_params_list(self):
        """Given no parameters for the function.
        When creating a FunctionSignature instance.
        Then params is an empty list.
        """
        # Given
        name = "no_param_func"
        params = []
        
        # When
        signature = FunctionSignature(
            name=name,
            params=params,
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # Then
        assert signature.params == []
        assert len(signature.params) == 0

    def test_given_no_return_type_when_creating_function_signature_then_return_type_is_none(self):
        """Given no return type specified.
        When creating a FunctionSignature instance.
        Then return_type is None.
        """
        # Given/When
        signature = FunctionSignature(
            name="void_function",
            params=[],
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # Then
        assert signature.return_type is None

    def test_given_empty_raises_set_when_creating_function_signature_then_no_exceptions_raised(self):
        """Given an empty set of raised exceptions.
        When creating a FunctionSignature instance.
        Then raises is an empty set.
        """
        # Given/When
        signature = FunctionSignature(
            name="safe_function",
            params=[],
            return_type="str",
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # Then
        assert signature.raises == set()
        assert len(signature.raises) == 0

    def test_given_multiple_raises_when_creating_function_signature_then_all_exceptions_stored(self):
        """Given multiple exception types that can be raised.
        When creating a FunctionSignature instance.
        Then all exception types are stored in raises set.
        """
        # Given
        exceptions = {"ValueError", "TypeError", "KeyError", "IndexError"}
        
        # When
        signature = FunctionSignature(
            name="risky_function",
            params=[],
            return_type=None,
            is_async=False,
            raises=exceptions,
            has_side_effects=True,
            docstring=None,
        )
        
        # Then
        assert signature.raises == exceptions
        assert len(signature.raises) == 4

    def test_given_async_function_when_creating_signature_then_is_async_is_true(self):
        """Given an async function.
        When creating a FunctionSignature instance.
        Then is_async is True.
        """
        # Given/When
        signature = FunctionSignature(
            name="async_function",
            params=[],
            return_type="Awaitable[str]",
            is_async=True,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # Then
        assert signature.is_async is True

    def test_given_sync_function_when_creating_signature_then_is_async_is_false(self):
        """Given a synchronous function.
        When creating a FunctionSignature instance.
        Then is_async is False.
        """
        # Given/When
        signature = FunctionSignature(
            name="sync_function",
            params=[],
            return_type="str",
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # Then
        assert signature.is_async is False

    def test_given_complex_params_when_creating_signature_then_params_with_defaults_stored(self):
        """Given parameters with mixed default values.
        When creating a FunctionSignature instance.
        Then all parameters with their defaults are correctly stored.
        """
        # Given
        params = [
            ("required_arg", "str", None),
            ("optional_arg", "int", "42"),
            ("optional_str", "str", "'default'"),
            ("optional_list", "list", "[]"),
        ]
        
        # When
        signature = FunctionSignature(
            name="function_with_defaults",
            params=params,
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # Then
        assert len(signature.params) == 4
        assert signature.params[0] == ("required_arg", "str", None)
        assert signature.params[1] == ("optional_arg", "int", "42")
        assert signature.params[2] == ("optional_str", "str", "'default'")
        assert signature.params[3] == ("optional_list", "list", "[]")

    def test_given_multiple_decorators_when_creating_signature_then_all_decorators_stored(self):
        """Given multiple decorators.
        When creating a FunctionSignature instance.
        Then all decorators are stored in order.
        """
        # Given
        decorators = ["@classmethod", "@lru_cache", "@deprecated"]
        
        # When
        signature = FunctionSignature(
            name="decorated_function",
            params=[],
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
            decorators=decorators,
        )
        
        # Then
        assert signature.decorators == decorators
        assert len(signature.decorators) == 3

    def test_given_high_complexity_when_creating_signature_then_complexity_value_stored(self):
        """Given a high complexity value.
        When creating a FunctionSignature instance.
        Then complexity value is correctly stored.
        """
        # Given
        complexity = 15
        
        # When
        signature = FunctionSignature(
            name="complex_function",
            params=[],
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=True,
            docstring=None,
            complexity=complexity,
        )
        
        # Then
        assert signature.complexity == 15

    def test_given_function_signature_when_checking_dataclass_then_is_dataclass(self):
        """Given a FunctionSignature instance.
        When checking if it's a dataclass.
        Then it is confirmed as a dataclass.
        """
        # Given
        signature = FunctionSignature(
            name="test",
            params=[],
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None,
        )
        
        # When/Then
        assert is_dataclass(signature)
        assert is_dataclass(FunctionSignature)

    def test_given_function_signature_when_accessing_fields_then_all_fields_present(self):
        """Given FunctionSignature class.
        When accessing its fields.
        Then all expected fields are present.
        """
        # Given
        expected_fields = {
            "name", "params", "return_type", "is_async", "raises",
            "has_side_effects", "docstring", "complexity", "decorators"
        }
        
        # When
        actual_fields = {f.name for f in fields(FunctionSignature)}
        
        # Then
        assert actual_fields == expected_fields


class TestClassSignature:
    """Behavioral tests for ClassSignature dataclass."""

    def test_given_minimal_params_when_creating_class_signature_then_instance_created(self):
        """Given minimal required parameters.
        When creating a ClassSignature instance.
        Then the instance is created with correct attributes.
        """
        # Given
        name = "TestClass"
        methods = []
        init_params = []
        base_classes = []
        docstring = "Test class docstring"
        
        # When
        signature = ClassSignature(
            name=name,
            methods=methods,
            init_params=init_params,
            base_classes=base_classes,
            docstring=docstring,
        )
        
        # Then
        assert signature.name == name
        assert signature.methods == methods
        assert signature.init_params == init_params
        assert signature.base_classes == base_classes
        assert signature.docstring == docstring
        assert signature.is_enum is False  # Default value
        assert signature.is_dataclass is False  # Default value
        assert signature.required_init_params == 0  # Default value

    def test_given_class_with_methods_when_creating_signature_then_methods_stored(self):
        """Given a class with multiple methods.
        When creating a ClassSignature instance.
        Then all methods are stored correctly.
        """
        # Given
        method1 = FunctionSignature(
            name="method1",
            params=[("self", "Self", None)],
            return_type="str",
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring="Method 1",
        )
        method2 = FunctionSignature(
            name="method2",
            params=[("self", "Self", None), ("arg", "int", None)],
            return_type="int",
            is_async=True,
            raises={"ValueError"},
            has_side_effects=True,
            docstring="Method 2",
        )
        methods = [method1, method2]
        
        # When
        signature = ClassSignature(
            name="MyClass",
            methods=methods,
            init_params=[],
            base_classes=[],
            docstring=None,
        )
        
        # Then
        assert len(signature.methods) == 2
        assert signature.methods[0].name == "method1"
        assert signature.methods[1].name == "method2"

    def test_given_init_params_when_creating_class_signature_then_init_params_stored(self):
        """Given constructor parameters.
        When creating a ClassSignature instance.
        Then init_params are correctly stored.
        """
        # Given
        init_params = [
            ("name", "str", None),
            ("age", "int", "0"),
            ("active", "bool", "True"),
        ]
        
        # When
        signature = ClassSignature(
            name="Person",
            methods=[],
            init_params=init_params,
            base_classes=[],
            docstring=None,
        )
        
        # Then
        assert len(signature.init_params) == 3
        assert signature.init_params[0] == ("name", "str", None)
        assert signature.init_params[1] == ("age", "int", "0")
        assert signature.init_params[2] == ("active", "bool", "True")

    def test_given_base_classes_when_creating_signature_then_base_classes_stored(self):
        """Given multiple base classes.
        When creating a ClassSignature instance.
        Then all base classes are stored.
        """
        # Given
        base_classes = ["BaseClass", "Mixin1", "Mixin2"]
        
        # When
        signature = ClassSignature(
            name="DerivedClass",
            methods=[],
            init_params=[],
            base_classes=base_classes,
            docstring=None,
        )
        
        # Then
        assert signature.base_classes == base_classes
        assert len(signature.base_classes) == 3

    def test_given_enum_class_when_creating_signature_then_is_enum_is_true(self):
        """Given an Enum class.
        When creating a ClassSignature instance.
        Then is_enum is True.
        """
        # Given/When
        signature = ClassSignature(
            name="MyEnum",
            methods=[],
            init_params=[],
            base_classes=["Enum"],
            docstring=None,
            is_enum=True,
        )
        
        # Then
        assert signature.is_enum is True

    def test_given_dataclass_when_creating_signature_then_is_dataclass_is_true(self):
        """Given a dataclass.
        When creating a ClassSignature instance.
        Then is_dataclass is True.
        """
        # Given/When
        signature = ClassSignature(
            name="MyDataClass",
            methods=[],
            init_params=[("field1", "str", None), ("field2", "int", "0")],
            base_classes=[],
            docstring=None,
            is_dataclass=True,
        )
        
        # Then
        assert signature.is_dataclass is True

    def test_given_required_params_when_creating_signature_then_required_count_stored(self):
        """Given required init parameters count.
        When creating a ClassSignature instance.
        Then required_init_params is correctly set.
        """
        # Given
        required_count = 3
        
        # When
        signature = ClassSignature(
            name="MyClass",
            methods=[],
            init_params=[
                ("param1", "str", None),
                ("param2", "int", None),
                ("param3", "bool", None),
                ("param4", "str", "'default'"),
            ],
            base_classes=[],
            docstring=None,
            required_init_params=required_count,
        )
        
        # Then
        assert signature.required_init_params == 3

    def test_given_no_docstring_when_creating_signature_then_docstring_is_none(self):
        """Given no docstring.
        When creating a ClassSignature instance.
        Then docstring is None.
        """
        # Given/When
        signature = ClassSignature(
            name="UndocumentedClass",
            methods=[],
            init_params=[],
            base_classes=[],
            docstring=None,
        )
        
        # Then
        assert signature.docstring is None

    def test_given_empty_methods_when_creating_signature_then_methods_list_empty(self):
        """Given no methods.
        When creating a ClassSignature instance.
        Then methods list is empty.
        """
        # Given/When
        signature = ClassSignature(
            name="EmptyClass",
            methods=[],
            init_params=[],
            base_classes=[],
            docstring=None,
        )
        
        # Then
        assert signature.methods == []
        assert len(signature.methods) == 0

    def test_given_no_base_classes_when_creating_signature_then_base_classes_empty(self):
        """Given no base classes.
        When creating a ClassSignature instance.
        Then base_classes list is empty.
        """
        # Given/When
        signature = ClassSignature(
            name="StandaloneClass",
            methods=[],
            init_params=[],
            base_classes=[],
            docstring=None,
        )
        
        # Then
        assert signature.base_classes == []
        assert len(signature.base_classes) == 0

    def test_given_all_params_when_creating_class_signature_then_all_attributes_set(self):
        """Given all parameters including optional ones.
        When creating a ClassSignature instance.
        Then all attributes are correctly set.
        """
        # Given
        name = "ComplexClass"
        method = FunctionSignature(
            name="do_something",
            params=[("self", "Self", None)],
            return_type="None",
            is_async=False,
            raises=set(),
            has_side_effects=True,
            docstring=None,
        )
        methods = [method]
        init_params = [("x", "int", None), ("y", "str", "'default'")]
        base_classes = ["BaseClass"]
        docstring = "Complex class"
        is_enum = False
        is_dataclass = True
        required_init_params = 1
        
        # When
        signature = ClassSignature(
            name=name,
            methods=methods,
            init_params=init_params,
            base_classes=base_classes,
            docstring=docstring,
            is_enum=is_enum,
            is_dataclass=is_dataclass,
            required_init_params=required_init_params,
        )
        
        # Then
        assert signature.name == name
        assert signature.methods == methods
        assert signature.init_params == init_params
        assert signature.base_classes == base_classes
        assert signature.docstring == docstring
        assert signature.is_enum == is_enum
        assert signature.is_dataclass == is_dataclass
        assert signature.required_init_params == required_init_params

    def test_given_class_signature_when_checking_dataclass_then_is_dataclass(self):
        """Given a ClassSignature instance.
        When checking if it's a dataclass.
        Then it is confirmed as a dataclass.
        """
        # Given
        signature = ClassSignature(
            name="TestClass",
            methods=[],
            init_params=[],
            base_classes=[],
            docstring=None,
        )
        
        # When/Then
        assert is_dataclass(signature)
        assert is_dataclass(ClassSignature)

    def test_given_class_signature_when_accessing_fields_then_all_fields_present(self):
        """Given ClassSignature class.
        When accessing its fields.
        Then all expected fields are present.
        """
        # Given
        expected_fields = {
            "name", "methods", "init_params", "base_classes", "docstring",
            "is_enum", "is_dataclass", "required_init_params"
        }
        
        # When
        actual_fields = {f.name for f in fields(ClassSignature)}
        
        # Then
        assert actual_fields == expected_fields

    def test_given_many_methods_when_creating_signature_then_all_methods_stored(self):
        """Given a class with many methods.
        When creating a ClassSignature instance.
        Then all methods are stored in order.
        """
        # Given
        methods = [
            FunctionSignature(
                name=f"method_{i}",
                params=[("self", "Self", None)],
                return_type=None,
                is_async=False,
                raises=set(),
                has_side_effects=False,
                docstring=None,
            )
            for i in range(10)
        ]
        
        # When
        signature = ClassSignature(
            name="ClassWithManyMethods",
            methods=methods,
            init_params=[],
            base_classes=[],
            docstring=None,
        )
        
        # Then
        assert len(signature.methods) == 10
        for i, method in enumerate(signature.methods):
            assert method.name == f"method_{i}"


class TestDataModelsIntegration:
    """Integration tests for data models working together."""

    def test_given_class_with_complex_methods_when_creating_signature_then_full_structure_captured(self):
        """Given a class with complex method signatures.
        When creating a ClassSignature with those methods.
        Then the full structure is correctly captured.
        """
        # Given
        async_method = FunctionSignature(
            name="fetch_data",
            params=[("self", "Self", None), ("url", "str", None)],
            return_type="dict",
            is_async=True,
            raises={"HTTPError", "TimeoutError"},
            has_side_effects=True,
            docstring="Fetches data from URL",
            complexity=3,
            decorators=["@retry"],
        )
        
        static_method = FunctionSignature(
            name="validate",
            params=[("data", "dict", None)],
            return_type="bool",
            is_async=False,
            raises={"ValidationError"},
            has_side_effects=False,
            docstring="Validates data",
            complexity=2,
            decorators=["@staticmethod"],
        )
        
        # When
        class_sig = ClassSignature(
            name="DataFetcher",
            methods=[async_method, static_method],
            init_params=[("base_url", "str", None), ("timeout", "int", "30")],
            base_classes=["BaseHTTPClient"],
            docstring="Fetches and validates data",
            is_enum=False,
            is_dataclass=False,
            required_init_params=1,
        )
        
        # Then
        assert class_sig.name == "DataFetcher"
        assert len(class_sig.methods) == 2
        assert class_sig.methods[0].name == "fetch_data"
        assert class_sig.methods[0].is_async is True
        assert class_sig.methods[1].name == "validate"
        assert class_sig.methods[1].is_async is False
        assert len(class_sig.init_params) == 2
        assert class_sig.required_init_params == 1

    def test_given_nested_class_structure_when_storing_signatures_then_hierarchy_preserved(self):
        """Given nested class relationships.
        When storing class signatures.
        Then the hierarchy is preserved through base_classes.
        """
        # Given
        base_sig = ClassSignature(
            name="BaseClass",
            methods=[],
            init_params=[("id", "int", None)],
            base_classes=[],
            docstring="Base class",
        )
        
        derived_sig = ClassSignature(
            name="DerivedClass",
            methods=[],
            init_params=[("id", "int", None), ("name", "str", None)],
            base_classes=["BaseClass"],
            docstring="Derived class",
        )
        
        # Then
        assert base_sig.base_classes == []
        assert "BaseClass" in derived_sig.base_classes
        assert len(derived_sig.init_params) > len(base_sig.init_params)

    def test_given_dataclass_signature_when_checking_attributes_then_matches_dataclass_pattern(self):
        """Given a ClassSignature representing a dataclass.
        When checking its attributes.
        Then it matches expected dataclass patterns.
        """
        # Given/When
        dataclass_sig = ClassSignature(
            name="Person",
            methods=[],
            init_params=[
                ("name", "str", None),
                ("age", "int", None),
                ("email", "str | None", "None"),
            ],
            base_classes=[],
            docstring="Represents a person",
            is_dataclass=True,
            required_init_params=2,
        )
        
        # Then
        assert dataclass_sig.is_dataclass is True
        assert dataclass_sig.is_enum is False
        assert len(dataclass_sig.methods) == 0  # Auto-generated methods not included
        assert dataclass_sig.required_init_params == 2
        assert len(dataclass_sig.init_params) == 3

    def test_given_enum_signature_when_checking_attributes_then_matches_enum_pattern(self):
        """Given a ClassSignature representing an Enum.
        When checking its attributes.
        Then it matches expected Enum patterns.
        """
        # Given/When
        enum_sig = ClassSignature(
            name="Status",
            methods=[],
            init_params=[],
            base_classes=["Enum"],
            docstring="Status enumeration",
            is_enum=True,
        )
        
        # Then
        assert enum_sig.is_enum is True
        assert enum_sig.is_dataclass is False
        assert "Enum" in enum_sig.base_classes
        assert len(enum_sig.init_params) == 0