"""Behavioral tests for test_templates.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest

from attune.workflows.test_gen.test_templates import (
    generate_test_for_function,
)


# Fixtures
@pytest.fixture
def basic_function_metadata():
    """Provide basic function metadata for testing."""
    return {
        "name": "example_func",
        "params": [("x", "int", None), ("y", "str", "'default'")],
        "param_names": ["x", "y"],
        "is_async": False,
        "return_type": "str",
        "raises": [],
        "has_side_effects": False,
    }


@pytest.fixture
def async_function_metadata():
    """Provide async function metadata for testing."""
    return {
        "name": "async_example",
        "params": [("data", "dict", None)],
        "param_names": ["data"],
        "is_async": True,
        "return_type": "dict",
        "raises": ["ValueError"],
        "has_side_effects": True,
    }


@pytest.fixture
def function_with_no_params():
    """Provide function metadata with no parameters."""
    return {
        "name": "no_params_func",
        "params": [],
        "param_names": [],
        "is_async": False,
        "return_type": "bool",
        "raises": [],
        "has_side_effects": False,
    }


@pytest.fixture
def function_with_multiple_params():
    """Provide function metadata with multiple parameters."""
    return {
        "name": "multi_param_func",
        "params": [
            ("a", "int", None),
            ("b", "float", "0.0"),
            ("c", "list", "[]"),
            ("d", "bool", "True"),
        ],
        "param_names": ["a", "b", "c", "d"],
        "is_async": False,
        "return_type": "dict",
        "raises": ["TypeError", "ValueError"],
        "has_side_effects": True,
    }


@pytest.fixture
def mock_test_cases():
    """Provide mock test cases data."""
    return {
        "valid_args": ["1", "'test'"],
        "parametrize_cases": ["(1, 'hello')", "(2, 'world')", "(3, 'test')"],
        "edge_cases": ["(0, '')", "(-1, 'x' * 1000)", "(999999, None)"],
    }


@pytest.fixture
def empty_test_cases():
    """Provide empty test cases data."""
    return {
        "valid_args": [],
        "parametrize_cases": [],
        "edge_cases": [],
    }


# Tests for generate_test_for_function


class TestGenerateTestForFunctionBasicBehavior:
    """Test basic behavior of generate_test_for_function."""

    def test_generates_import_statements(self, basic_function_metadata):
        """
        Given: A basic function metadata
        When: Generating test code
        Then: Import statements should be present
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "import pytest" in result
        assert f"from {module} import {basic_function_metadata['name']}" in result

    def test_generates_test_function_name(self, basic_function_metadata):
        """
        Given: A function with name 'example_func'
        When: Generating test code
        Then: Test function should be named test_example_func_*
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert f"test_{basic_function_metadata['name']}" in result

    def test_generates_docstring(self, basic_function_metadata):
        """
        Given: A function metadata
        When: Generating test code
        Then: Generated test should contain docstrings
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert '"""' in result
        assert "Test" in result

    def test_synchronous_function_without_async_marker(self, basic_function_metadata):
        """
        Given: A synchronous function
        When: Generating test code
        Then: Should not include @pytest.mark.asyncio
        """
        # Given
        module = "my_module"
        basic_function_metadata["is_async"] = False

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "@pytest.mark.asyncio" not in result
        assert "async def test_" not in result

    def test_function_with_empty_params_list(self, function_with_no_params):
        """
        Given: A function with no parameters
        When: Generating test code
        Then: Should handle empty parameter list gracefully
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, function_with_no_params)

        # Then
        assert "import pytest" in result
        assert f"from {module} import {function_with_no_params['name']}" in result
        assert f"{function_with_no_params['name']}()" in result


class TestGenerateTestForFunctionAsyncSupport:
    """Test async function support in generate_test_for_function."""

    def test_async_function_includes_asyncio_marker(self, async_function_metadata):
        """
        Given: An async function metadata
        When: Generating test code
        Then: Should include @pytest.mark.asyncio decorator
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, async_function_metadata)

        # Then
        assert "@pytest.mark.asyncio" in result

    def test_async_function_uses_async_def(self, async_function_metadata):
        """
        Given: An async function metadata
        When: Generating test code
        Then: Should use 'async def' for test function
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, async_function_metadata)

        # Then
        assert "async def test_" in result

    def test_async_function_uses_await(self, async_function_metadata):
        """
        Given: An async function metadata
        When: Generating test code
        Then: Should use 'await' when calling the function
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, async_function_metadata)

        # Then
        assert f"await {async_function_metadata['name']}" in result


class TestGenerateTestForFunctionParametrization:
    """Test parametrization support in generate_test_for_function."""

    def test_parametrize_decorator_with_multiple_cases(
        self, function_with_multiple_params, monkeypatch
    ):
        """
        Given: A function with multiple test cases
        When: Generating test code with parametrization
        Then: Should include @pytest.mark.parametrize decorator
        """
        # Given
        module = "my_module"
        mock_cases = {
            "valid_args": ["1", "0.5", "[]", "True"],
            "parametrize_cases": ["(1, 0.5, [], True)", "(2, 1.0, [1], False)"],
            "edge_cases": [],
        }

        def mock_generate_cases(params):
            return mock_cases

        monkeypatch.setattr(
            "attune.workflows.test_gen.test_templates.generate_test_cases_for_params",
            mock_generate_cases,
        )

        # When
        result = generate_test_for_function(module, function_with_multiple_params)

        # Then
        assert "@pytest.mark.parametrize" in result

    def test_parametrize_includes_param_names(self, function_with_multiple_params, monkeypatch):
        """
        Given: A function with multiple parameters
        When: Generating parametrized test
        Then: Should include parameter names in parametrize decorator
        """
        # Given
        module = "my_module"
        mock_cases = {
            "valid_args": ["1", "0.5", "[]", "True"],
            "parametrize_cases": ["(1, 0.5, [], True)", "(2, 1.0, [1], False)"],
            "edge_cases": [],
        }

        def mock_generate_cases(params):
            return mock_cases

        monkeypatch.setattr(
            "attune.workflows.test_gen.test_templates.generate_test_cases_for_params",
            mock_generate_cases,
        )

        # When
        result = generate_test_for_function(module, function_with_multiple_params)

        # Then
        param_names_str = ", ".join(function_with_multiple_params["param_names"])
        assert param_names_str in result

    def test_single_test_case_no_parametrization(self, basic_function_metadata, monkeypatch):
        """
        Given: A function with only one test case
        When: Generating test code
        Then: Should not use parametrization
        """
        # Given
        module = "my_module"
        mock_cases = {
            "valid_args": ["1", "'test'"],
            "parametrize_cases": ["(1, 'test')"],  # Only one case
            "edge_cases": [],
        }

        def mock_generate_cases(params):
            return mock_cases

        monkeypatch.setattr(
            "attune.workflows.test_gen.test_templates.generate_test_cases_for_params",
            mock_generate_cases,
        )

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert (
            "@pytest.mark.parametrize" not in result or result.count("@pytest.mark.parametrize") < 2
        )


class TestGenerateTestForFunctionEdgeCases:
    """Test edge case generation in generate_test_for_function."""

    def test_edge_cases_generate_separate_test(self, basic_function_metadata, monkeypatch):
        """
        Given: A function with edge cases defined
        When: Generating test code
        Then: Should generate separate edge case test
        """
        # Given
        module = "my_module"
        mock_cases = {
            "valid_args": ["1", "'test'"],
            "parametrize_cases": [],
            "edge_cases": ["(0, '')", "(-1, None)"],
        }

        def mock_generate_cases(params):
            return mock_cases

        monkeypatch.setattr(
            "attune.workflows.test_gen.test_templates.generate_test_cases_for_params",
            mock_generate_cases,
        )

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "edge_cases" in result or "edge_input" in result

    def test_no_edge_cases_no_edge_test(self, basic_function_metadata, monkeypatch):
        """
        Given: A function with no edge cases
        When: Generating test code
        Then: Should not generate edge case test
        """
        # Given
        module = "my_module"
        mock_cases = {
            "valid_args": ["1", "'test'"],
            "parametrize_cases": [],
            "edge_cases": [],
        }

        def mock_generate_cases(params):
            return mock_cases

        monkeypatch.setattr(
            "attune.workflows.test_gen.test_templates.generate_test_cases_for_params",
            mock_generate_cases,
        )

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        edge_test_count = result.count("edge_input")
        assert edge_test_count == 0


class TestGenerateTestForFunctionReturnTypeHandling:
    """Test return type handling in generate_test_for_function."""

    def test_function_with_return_type_checks_not_none(self, basic_function_metadata):
        """
        Given: A function with a return type
        When: Generating test code
        Then: Should include assertion that result is not None
        """
        # Given
        module = "my_module"
        basic_function_metadata["return_type"] = "str"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "assert result is not None" in result

    def test_function_without_explicit_return_type(self, basic_function_metadata):
        """
        Given: A function without explicit return type
        When: Generating test code
        Then: Should still generate valid test code
        """
        # Given
        module = "my_module"
        basic_function_metadata["return_type"] = None

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "import pytest" in result
        assert f"def test_{basic_function_metadata['name']}" in result


class TestGenerateTestForFunctionErrorHandling:
    """Test error handling scenarios in generate_test_for_function."""

    def test_function_with_raises_field(self, basic_function_metadata):
        """
        Given: A function that raises exceptions
        When: Generating test code
        Then: Should handle raises field without errors
        """
        # Given
        module = "my_module"
        basic_function_metadata["raises"] = ["ValueError", "TypeError"]

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert result is not None
        assert "import pytest" in result

    def test_function_with_side_effects_flag(self, basic_function_metadata):
        """
        Given: A function with side effects
        When: Generating test code
        Then: Should handle has_side_effects flag
        """
        # Given
        module = "my_module"
        basic_function_metadata["has_side_effects"] = True

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert result is not None
        assert "import pytest" in result


class TestGenerateTestForFunctionComplexScenarios:
    """Test complex scenarios and combinations."""

    def test_async_function_with_parametrization(self, async_function_metadata, monkeypatch):
        """
        Given: An async function with multiple test cases
        When: Generating test code
        Then: Should combine async and parametrization correctly
        """
        # Given
        module = "my_module"
        mock_cases = {
            "valid_args": ["{'key': 'value'}"],
            "parametrize_cases": ["({'a': 1},)", "({'b': 2},)"],
            "edge_cases": [],
        }

        def mock_generate_cases(params):
            return mock_cases

        monkeypatch.setattr(
            "attune.workflows.test_gen.test_templates.generate_test_cases_for_params",
            mock_generate_cases,
        )

        # When
        result = generate_test_for_function(module, async_function_metadata)

        # Then
        assert "@pytest.mark.asyncio" in result
        assert "@pytest.mark.parametrize" in result
        assert "async def test_" in result
        assert "await" in result

    def test_function_with_tuple_params(self):
        """
        Given: A function with tuple-style parameters
        When: Generating test code
        Then: Should extract parameter names correctly
        """
        # Given
        module = "my_module"
        metadata = {
            "name": "tuple_param_func",
            "params": [("x", "int", None), ("y", "str", "'default'")],
            "param_names": ["x", "y"],
            "is_async": False,
            "return_type": "bool",
        }

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert "import pytest" in result
        assert "from my_module import tuple_param_func" in result

    def test_function_with_mixed_param_formats(self):
        """
        Given: A function with mixed parameter formats
        When: Generating test code
        Then: Should handle both tuple and string formats
        """
        # Given
        module = "my_module"
        metadata = {
            "name": "mixed_func",
            "params": [("x", "int", None), "y"],
            "param_names": [],  # Empty, should be derived
            "is_async": False,
        }

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert result is not None
        assert "import pytest" in result

    def test_long_module_path(self):
        """
        Given: A function from a deeply nested module
        When: Generating test code
        Then: Should handle long module paths correctly
        """
        # Given
        module = "my_package.subpackage.nested.deeply.module"
        metadata = {
            "name": "deep_func",
            "params": [],
            "param_names": [],
            "is_async": False,
        }

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert f"from {module} import deep_func" in result

    def test_function_with_special_characters_in_name(self):
        """
        Given: A function with underscores in name
        When: Generating test code
        Then: Should preserve function name correctly
        """
        # Given
        module = "my_module"
        metadata = {
            "name": "my_special_func_with_underscores",
            "params": [],
            "param_names": [],
            "is_async": False,
        }

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert "my_special_func_with_underscores" in result
        assert "test_my_special_func_with_underscores" in result


class TestGenerateTestForFunctionAssertions:
    """Test assertion generation in test code."""

    def test_basic_assertion_present(self, basic_function_metadata):
        """
        Given: Any function metadata
        When: Generating test code
        Then: Should include at least one assertion
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "assert" in result

    def test_result_variable_assigned(self, basic_function_metadata):
        """
        Given: Any function metadata
        When: Generating test code
        Then: Should assign function result to a variable
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "result =" in result

    def test_function_call_in_test(self, basic_function_metadata):
        """
        Given: A function metadata
        When: Generating test code
        Then: Should include actual function call
        """
        # Given
        module = "my_module"
        func_name = basic_function_metadata["name"]

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert f"{func_name}(" in result


class TestGenerateTestForFunctionOutputFormat:
    """Test output format and structure."""

    def test_output_is_string(self, basic_function_metadata):
        """
        Given: Any function metadata
        When: Generating test code
        Then: Should return a string
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert isinstance(result, str)

    def test_output_is_not_empty(self, basic_function_metadata):
        """
        Given: Any function metadata
        When: Generating test code
        Then: Should return non-empty string
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert len(result) > 0

    def test_output_contains_valid_python_syntax(self, basic_function_metadata):
        """
        Given: Any function metadata
        When: Generating test code
        Then: Should contain valid Python keywords
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        assert "def " in result or "async def " in result
        assert "import" in result

    def test_proper_indentation(self, basic_function_metadata):
        """
        Given: Any function metadata
        When: Generating test code
        Then: Should have proper indentation for test function body
        """
        # Given
        module = "my_module"

        # When
        result = generate_test_for_function(module, basic_function_metadata)

        # Then
        lines = result.split("\n")
        # Check that function body lines have indentation
        in_function = False
        for line in lines:
            if "def test_" in line:
                in_function = True
            elif in_function and line.strip() and not line.startswith(" "):
                in_function = False
            elif in_function and line.strip():
                assert line.startswith(" ")


class TestGenerateTestForFunctionEdgeCasesIntegration:
    """Integration tests for edge case handling."""

    def test_minimal_function_metadata(self):
        """
        Given: Minimal function metadata with only name
        When: Generating test code
        Then: Should handle gracefully with defaults
        """
        # Given
        module = "my_module"
        metadata = {"name": "minimal_func"}

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert "import pytest" in result
        assert "minimal_func" in result

    def test_function_with_all_optional_fields_none(self):
        """
        Given: Function metadata with all optional fields as None
        When: Generating test code
        Then: Should use sensible defaults
        """
        # Given
        module = "my_module"
        metadata = {
            "name": "none_fields_func",
            "params": None,
            "param_names": None,
            "is_async": None,
            "return_type": None,
            "raises": None,
            "has_side_effects": None,
        }

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert result is not None
        assert "import pytest" in result

    def test_empty_string_function_name(self):
        """
        Given: Function metadata with empty name
        When: Generating test code
        Then: Should handle without crashing
        """
        # Given
        module = "my_module"
        metadata = {"name": ""}

        # When
        result = generate_test_for_function(module, metadata)

        # Then
        assert isinstance(result, str)
