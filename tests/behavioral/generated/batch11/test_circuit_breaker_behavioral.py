"""Behavioral tests for circuit_breaker.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import time
from typing import Callable
from unittest.mock import Mock, patch

import pytest

from empathy_os.resilience.circuit_breaker import (
    CircuitBreaker,
    CircuitOpenError,
    CircuitState,
)


# Fixtures


@pytest.fixture
def basic_circuit_breaker():
    """Given a basic circuit breaker with default settings."""
    return CircuitBreaker(
        name="test_circuit",
        failure_threshold=3,
        reset_timeout=1.0,
        half_open_max_calls=2,
    )


@pytest.fixture
def circuit_breaker_with_exclusions():
    """Given a circuit breaker that excludes certain exceptions."""
    return CircuitBreaker(
        name="test_circuit_exclusions",
        failure_threshold=3,
        reset_timeout=1.0,
        excluded_exceptions=(ValueError, KeyError),
    )


@pytest.fixture
def mock_time():
    """Given a mocked time module for testing timeouts."""
    with patch("empathy_os.resilience.circuit_breaker.time") as mock:
        mock.time.return_value = 1000.0
        yield mock


@pytest.fixture
def failing_function():
    """Given a function that always fails."""

    def func():
        raise RuntimeError("Service unavailable")

    return func


@pytest.fixture
def succeeding_function():
    """Given a function that always succeeds."""

    def func():
        return "success"

    return func


@pytest.fixture
def intermittent_function():
    """Given a function that fails then succeeds."""
    call_count = {"count": 0}

    def func():
        call_count["count"] += 1
        if call_count["count"] <= 2:
            raise RuntimeError("Temporary failure")
        return "success"

    return func


# Test CircuitState Enum


class TestCircuitState:
    """Tests for CircuitState enum."""

    def test_given_circuit_states_when_accessed_then_has_correct_values(self):
        """Given circuit states, when accessed, then they have correct values."""
        # Then
        assert CircuitState.CLOSED.value == "closed"
        assert CircuitState.OPEN.value == "open"
        assert CircuitState.HALF_OPEN.value == "half_open"


# Test CircuitOpenError


class TestCircuitOpenError:
    """Tests for CircuitOpenError exception."""

    def test_given_circuit_name_and_time_when_error_created_then_contains_details(self):
        """Given circuit name and reset time, when error created, then contains details."""
        # Given
        name = "test_circuit"
        reset_time = 45.5

        # When
        error = CircuitOpenError(name, reset_time)

        # Then
        assert error.name == name
        assert error.reset_time == reset_time
        assert "test_circuit" in str(error)
        assert "45.5s" in str(error)


# Test CircuitBreaker State Management


class TestCircuitBreakerInitialization:
    """Tests for CircuitBreaker initialization."""

    def test_given_basic_params_when_created_then_initializes_correctly(self):
        """Given basic parameters, when circuit breaker created, then initializes correctly."""
        # When
        cb = CircuitBreaker(
            name="test",
            failure_threshold=5,
            reset_timeout=60.0,
            half_open_max_calls=3,
        )

        # Then
        assert cb.name == "test"
        assert cb.failure_threshold == 5
        assert cb.reset_timeout == 60.0
        assert cb.half_open_max_calls == 3
        assert cb.state == CircuitState.CLOSED
        assert cb.is_closed is True
        assert cb.is_open is False

    def test_given_excluded_exceptions_when_created_then_stores_them(self):
        """Given excluded exceptions, when created, then stores them."""
        # When
        cb = CircuitBreaker(
            name="test", excluded_exceptions=(ValueError, KeyError)
        )

        # Then
        assert ValueError in cb.excluded_exceptions
        assert KeyError in cb.excluded_exceptions

    def test_given_no_params_when_created_then_uses_defaults(self):
        """Given no optional parameters, when created, then uses defaults."""
        # When
        cb = CircuitBreaker(name="test")

        # Then
        assert cb.failure_threshold == 5
        assert cb.reset_timeout == 60.0
        assert cb.half_open_max_calls == 3
        assert cb.excluded_exceptions == ()


class TestCircuitBreakerStateTransitions:
    """Tests for circuit breaker state transitions."""

    def test_given_closed_circuit_when_failures_exceed_threshold_then_opens(
        self, basic_circuit_breaker, failing_function
    ):
        """Given closed circuit, when failures exceed threshold, then opens."""
        # Given
        cb = basic_circuit_breaker
        assert cb.is_closed

        # When - trigger failures up to threshold
        for _ in range(cb.failure_threshold):
            try:
                cb.call(failing_function)
            except RuntimeError:
                pass

        # Then
        assert cb.is_open
        assert cb.state == CircuitState.OPEN

    def test_given_open_circuit_when_timeout_expires_then_transitions_to_half_open(
        self, basic_circuit_breaker, mock_time
    ):
        """Given open circuit, when timeout expires, then transitions to half-open."""
        # Given - force circuit open
        cb = basic_circuit_breaker
        cb._state = CircuitState.OPEN
        cb._last_failure_time = 1000.0

        # When - advance time past reset timeout
        mock_time.time.return_value = 1002.0

        # Then
        assert cb.state == CircuitState.HALF_OPEN

    def test_given_half_open_circuit_when_success_then_closes(
        self, basic_circuit_breaker, succeeding_function
    ):
        """Given half-open circuit, when successful calls complete, then closes."""
        # Given - force circuit to half-open
        cb = basic_circuit_breaker
        cb._state = CircuitState.HALF_OPEN
        cb._half_open_calls = 0

        # When - make successful calls up to half_open_max_calls
        for _ in range(cb.half_open_max_calls):
            cb.call(succeeding_function)

        # Then
        assert cb.is_closed
        assert cb.state == CircuitState.CLOSED

    def test_given_half_open_circuit_when_failure_then_reopens(
        self, basic_circuit_breaker, failing_function
    ):
        """Given half-open circuit, when failure occurs, then reopens."""
        # Given - force circuit to half-open
        cb = basic_circuit_breaker
        cb._state = CircuitState.HALF_OPEN

        # When - call fails
        with pytest.raises(RuntimeError):
            cb.call(failing_function)

        # Then
        assert cb.is_open
        assert cb.state == CircuitState.OPEN

    def test_given_open_circuit_when_not_timed_out_then_stays_open(
        self, basic_circuit_breaker, mock_time
    ):
        """Given open circuit, when timeout not expired, then stays open."""
        # Given - force circuit open
        cb = basic_circuit_breaker
        cb._state = CircuitState.OPEN
        cb._last_failure_time = 1000.0

        # When - time hasn't advanced enough
        mock_time.time.return_value = 1000.5

        # Then
        assert cb.state == CircuitState.OPEN


# Test CircuitBreaker Call Methods


class TestCircuitBreakerCall:
    """Tests for circuit breaker call method."""

    def test_given_closed_circuit_when_call_succeeds_then_returns_result(
        self, basic_circuit_breaker, succeeding_function
    ):
        """Given closed circuit, when call succeeds, then returns result."""
        # Given
        cb = basic_circuit_breaker
        assert cb.is_closed

        # When
        result = cb.call(succeeding_function)

        # Then
        assert result == "success"
        assert cb.is_closed

    def test_given_closed_circuit_when_call_fails_then_increments_failure_count(
        self, basic_circuit_breaker, failing_function
    ):
        """Given closed circuit, when call fails, then increments failure count."""
        # Given
        cb = basic_circuit_breaker
        initial_count = cb._failure_count

        # When
        with pytest.raises(RuntimeError):
            cb.call(failing_function)

        # Then
        assert cb._failure_count == initial_count + 1

    def test_given_open_circuit_when_call_attempted_then_raises_circuit_open_error(
        self, basic_circuit_breaker, succeeding_function
    ):
        """Given open circuit, when call attempted, then raises CircuitOpenError."""
        # Given - force circuit open
        cb = basic_circuit_breaker
        cb._state = CircuitState.OPEN
        cb._last_failure_time = time.time()

        # When/Then
        with pytest.raises(CircuitOpenError) as exc_info:
            cb.call(succeeding_function)

        assert exc_info.value.name == cb.name

    def test_given_excluded_exception_when_raised_then_does_not_count_as_failure(
        self, circuit_breaker_with_exclusions
    ):
        """Given excluded exception, when raised, then does not count as failure."""
        # Given
        cb = circuit_breaker_with_exclusions

        def func():
            raise ValueError("Excluded error")

        # When
        initial_count = cb._failure_count
        with pytest.raises(ValueError):
            cb.call(func)

        # Then
        assert cb._failure_count == initial_count
        assert cb.is_closed

    def test_given_non_excluded_exception_when_raised_then_counts_as_failure(
        self, circuit_breaker_with_exclusions
    ):
        """Given non-excluded exception, when raised, then counts as failure."""
        # Given
        cb = circuit_breaker_with_exclusions

        def func():
            raise RuntimeError("Not excluded")

        # When
        initial_count = cb._failure_count
        with pytest.raises(RuntimeError):
            cb.call(func)

        # Then
        assert cb._failure_count == initial_count + 1

    def test_given_call_with_args_when_executed_then_passes_args(
        self, basic_circuit_breaker
    ):
        """Given call with arguments, when executed, then passes arguments correctly."""
        # Given
        cb = basic_circuit_breaker

        def func(a, b, c=None):
            return f"{a}-{b}-{c}"

        # When
        result = cb.call(func, 1, 2, c=3)

        # Then
        assert result == "1-2-3"


class TestCircuitBreakerAsyncCall:
    """Tests for circuit breaker async call method."""

    @pytest.mark.asyncio
    async def test_given_closed_circuit_when_async_call_succeeds_then_returns_result(
        self, basic_circuit_breaker
    ):
        """Given closed circuit, when async call succeeds, then returns result."""
        # Given
        cb = basic_circuit_breaker

        async def async_func():
            return "async_success"

        # When
        result = await cb.call_async(async_func)

        # Then
        assert result == "async_success"
        assert cb.is_closed

    @pytest.mark.asyncio
    async def test_given_closed_circuit_when_async_call_fails_then_increments_failure(
        self, basic_circuit_breaker
    ):
        """Given closed circuit, when async call fails, then increments failure count."""
        # Given
        cb = basic_circuit_breaker

        async def async_failing():
            raise RuntimeError("Async failure")

        # When
        initial_count = cb._failure_count
        with pytest.raises(RuntimeError):
            await cb.call_async(async_failing)

        # Then
        assert cb._failure_count == initial_count + 1

    @pytest.mark.asyncio
    async def test_given_open_circuit_when_async_call_attempted_then_raises_error(
        self, basic_circuit_breaker
    ):
        """Given open circuit, when async call attempted, then raises CircuitOpenError."""
        # Given - force circuit open
        cb = basic_circuit_breaker
        cb._state = CircuitState.OPEN
        cb._last_failure_time = time.time()

        async def async_func():
            return "success"

        # When/Then
        with pytest.raises(CircuitOpenError):
            await cb.call_async(async_func)

    @pytest.mark.asyncio
    async def test_given_async_call_with_args_when_executed_then_passes_args(
        self, basic_circuit_breaker
    ):
        """Given async call with arguments, when executed, then passes arguments correctly."""
        # Given
        cb = basic_circuit_breaker

        async def async_func(x, y, z=0):
            await asyncio.sleep(0.01)
            return x + y + z

        # When
        result = await cb.call_async(async_func, 10, 20, z=30)

        # Then
        assert result == 60


class TestCircuitBreakerDecorator:
    """Tests for circuit breaker decorator."""

    def test_given_decorated_function_when_called_then_uses_circuit_breaker(
        self, basic_circuit_breaker
    ):
        """Given decorated function, when called, then uses circuit breaker."""
        # Given
        cb = basic_circuit_breaker

        @cb.decorate
        def decorated_func():
            return "decorated_result"

        # When
        result = decorated_func()

        # Then
        assert result == "decorated_result"

    def test_given_decorated_function_when_fails_then_increments_failure_count(
        self, basic_circuit_breaker
    ):
        """Given decorated function, when fails, then increments failure count."""
        # Given
        cb = basic_circuit_breaker

        @cb.decorate
        def failing_decorated():
            raise RuntimeError("Decorated failure")

        # When
        initial_count = cb._failure_count
        with pytest.raises(RuntimeError):
            failing_decorated()

        # Then
        assert cb._failure_count == initial_count + 1

    def test_given_decorated_function_when_circuit_open_then_raises_circuit_error(
        self, basic_circuit_breaker
    ):
        """Given decorated function, when circuit open, then raises CircuitOpenError."""
        # Given
        cb = basic_circuit_breaker

        @cb.decorate
        def decorated_func():
            return "result"

        # Force circuit open
        cb._state = CircuitState.OPEN
        cb._last_failure_time = time.time()

        # When/Then
        with pytest.raises(CircuitOpenError):
            decorated_func()

    def test_given_decorated_async_function_when_called_then_uses_circuit_breaker(
        self, basic_circuit_breaker
    ):
        """Given decorated async function, when called, then uses circuit breaker."""
        # Given
        cb = basic_circuit_breaker

        @cb.decorate
        async def async_decorated():
            return "async_decorated_result"

        # When
        result = asyncio.run(async