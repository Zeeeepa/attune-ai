"""Behavioral tests for ast_analyzer.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from attune.workflows.test_gen.ast_analyzer import ASTFunctionAnalyzer


class TestASTFunctionAnalyzerInitialization:
    """Test initialization of ASTFunctionAnalyzer."""

    def test_given_new_analyzer_when_initialized_then_collections_are_empty(self):
        """Given: A new ASTFunctionAnalyzer instance
        When: It is initialized
        Then: Functions and classes lists should be empty
        """
        # Given / When
        analyzer = ASTFunctionAnalyzer()

        # Then
        assert analyzer.functions == []
        assert analyzer.classes == []
        assert analyzer._current_class is None
        assert analyzer.last_error is None


class TestASTFunctionAnalyzerSimpleFunctionAnalysis:
    """Test analysis of simple function definitions."""

    def test_given_simple_function_when_analyzed_then_signature_extracted(self):
        """Given: A simple function definition
        When: Code is analyzed
        Then: Function signature should be extracted correctly
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def add(a: int, b: int) -> int:
    return a + b
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert len(classes) == 0
        assert functions[0].name == "add"
        assert functions[0].return_type == "int"
        assert len(functions[0].params) == 2

    def test_given_function_without_types_when_analyzed_then_signature_extracted(self):
        """Given: A function without type annotations
        When: Code is analyzed
        Then: Function signature should be extracted with empty types
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def multiply(x, y):
    return x * y
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "multiply"
        assert len(functions[0].params) == 2

    def test_given_function_with_default_args_when_analyzed_then_defaults_captured(self):
        """Given: A function with default arguments
        When: Code is analyzed
        Then: Default values should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def greet(name: str, greeting: str = "Hello") -> str:
    return f"{greeting}, {name}"
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert len(functions[0].params) == 2
        assert functions[0].params[0][0] == "name"
        assert functions[0].params[1][0] == "greeting"

    def test_given_async_function_when_analyzed_then_marked_as_async(self):
        """Given: An async function definition
        When: Code is analyzed
        Then: Function should be marked as async
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
async def fetch_data(url: str) -> dict:
    return {}
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "fetch_data"
        assert functions[0].is_async is True


class TestASTFunctionAnalyzerComplexFunctionAnalysis:
    """Test analysis of complex function definitions."""

    def test_given_function_with_raises_when_analyzed_then_exceptions_captured(self):
        """Given: A function that raises exceptions
        When: Code is analyzed
        Then: Exception types should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def validate(value: int) -> int:
    if value < 0:
        raise ValueError("Negative value")
    if value > 100:
        raise RuntimeError("Too large")
    return value
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert len(functions[0].raises) >= 2
        assert "ValueError" in functions[0].raises or "RuntimeError" in functions[0].raises

    def test_given_nested_function_when_analyzed_then_only_top_level_captured(self):
        """Given: A function with nested function definitions
        When: Code is analyzed
        Then: Only top-level function should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def outer(x: int) -> int:
    def inner(y: int) -> int:
        return y * 2
    return inner(x)
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "outer"

    def test_given_function_with_multiple_returns_when_analyzed_then_signature_extracted(self):
        """Given: A function with multiple return statements
        When: Code is analyzed
        Then: Function signature should be extracted
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def process(value: int) -> str:
    if value > 0:
        return "positive"
    elif value < 0:
        return "negative"
    else:
        return "zero"
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "process"
        assert functions[0].return_type == "str"


class TestASTFunctionAnalyzerClassAnalysis:
    """Test analysis of class definitions."""

    def test_given_simple_class_when_analyzed_then_class_signature_extracted(self):
        """Given: A simple class definition
        When: Code is analyzed
        Then: Class signature should be extracted
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class Calculator:
    def add(self, a: int, b: int) -> int:
        return a + b

    def subtract(self, a: int, b: int) -> int:
        return a - b
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 0  # Class methods not added to top-level functions
        assert len(classes) == 1
        assert classes[0].name == "Calculator"
        assert len(classes[0].methods) == 2

    def test_given_class_with_init_when_analyzed_then_init_params_captured(self):
        """Given: A class with __init__ method
        When: Code is analyzed
        Then: Init parameters should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(classes) == 1
        assert classes[0].name == "Person"
        assert len(classes[0].init_params) >= 2

    def test_given_class_with_base_classes_when_analyzed_then_bases_captured(self):
        """Given: A class with base classes
        When: Code is analyzed
        Then: Base classes should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class Base:
    pass

class Derived(Base):
    def method(self) -> None:
        pass
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(classes) == 2
        derived = [c for c in classes if c.name == "Derived"][0]
        assert "Base" in derived.base_classes

    def test_given_class_with_async_methods_when_analyzed_then_methods_marked_async(self):
        """Given: A class with async methods
        When: Code is analyzed
        Then: Async methods should be marked correctly
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class AsyncProcessor:
    async def process(self, data: str) -> dict:
        return {"result": data}
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(classes) == 1
        assert len(classes[0].methods) == 1
        assert classes[0].methods[0].is_async is True

    def test_given_class_with_static_and_class_methods_when_analyzed_then_methods_captured(self):
        """Given: A class with static and class methods
        When: Code is analyzed
        Then: All methods should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class Utility:
    @staticmethod
    def static_method(x: int) -> int:
        return x * 2

    @classmethod
    def class_method(cls, y: int) -> int:
        return y * 3

    def instance_method(self, z: int) -> int:
        return z * 4
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(classes) == 1
        assert len(classes[0].methods) == 3

    def test_given_nested_classes_when_analyzed_then_only_top_level_captured(self):
        """Given: A class with nested class definitions
        When: Code is analyzed
        Then: Only top-level class should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class Outer:
    class Inner:
        def inner_method(self) -> None:
            pass

    def outer_method(self) -> None:
        pass
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(classes) == 1
        assert classes[0].name == "Outer"


class TestASTFunctionAnalyzerErrorHandling:
    """Test error handling during analysis."""

    def test_given_syntax_error_when_analyzed_then_error_tracked(self):
        """Given: Code with syntax error
        When: Code is analyzed
        Then: Empty results returned and error tracked
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def broken_function(
    return "incomplete"
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 0
        assert len(classes) == 0
        assert analyzer.last_error is not None
        assert "SyntaxError" in analyzer.last_error

    def test_given_syntax_error_with_filepath_when_analyzed_then_filepath_in_error(self):
        """Given: Code with syntax error and file path provided
        When: Code is analyzed
        Then: File path should be included in error message
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = "def bad syntax here"
        file_path = "/path/to/file.py"

        # When
        functions, classes = analyzer.analyze(code, file_path=file_path)

        # Then
        assert len(functions) == 0
        assert len(classes) == 0
        assert analyzer.last_error is not None
        assert file_path in analyzer.last_error

    def test_given_empty_code_when_analyzed_then_empty_results(self):
        """Given: Empty code string
        When: Code is analyzed
        Then: Empty results should be returned
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = ""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 0
        assert len(classes) == 0
        assert analyzer.last_error is None

    def test_given_only_comments_when_analyzed_then_empty_results(self):
        """Given: Code with only comments
        When: Code is analyzed
        Then: Empty results should be returned
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
# This is a comment
# Another comment
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 0
        assert len(classes) == 0
        assert analyzer.last_error is None


class TestASTFunctionAnalyzerMultipleAnalysis:
    """Test multiple sequential analyses."""

    def test_given_multiple_analyses_when_executed_then_results_reset(self):
        """Given: Multiple sequential analyses
        When: Analyzer is reused
        Then: Previous results should not interfere
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code1 = """
def func1():
    pass
"""
        code2 = """
def func2():
    pass
"""

        # When
        functions1, classes1 = analyzer.analyze(code1)
        functions2, classes2 = analyzer.analyze(code2)

        # Then
        assert len(functions1) == 1
        assert functions1[0].name == "func1"
        assert len(functions2) == 1
        assert functions2[0].name == "func2"

    def test_given_error_then_success_when_analyzed_then_error_cleared(self):
        """Given: Analysis with error followed by successful analysis
        When: Both are executed
        Then: Error should be cleared on success
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        bad_code = "def bad syntax"
        good_code = "def good(): pass"

        # When
        analyzer.analyze(bad_code)
        assert analyzer.last_error is not None
        functions, classes = analyzer.analyze(good_code)

        # Then
        assert analyzer.last_error is None
        assert len(functions) == 1


class TestASTFunctionAnalyzerMixedContent:
    """Test analysis of mixed functions and classes."""

    def test_given_mixed_functions_and_classes_when_analyzed_then_both_captured(self):
        """Given: Code with both functions and classes
        When: Code is analyzed
        Then: Both should be captured separately
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def standalone_function(x: int) -> int:
    return x * 2

class MyClass:
    def method(self, y: int) -> int:
        return y * 3

def another_function(z: str) -> str:
    return z.upper()
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 2
        assert len(classes) == 1
        assert functions[0].name == "standalone_function"
        assert functions[1].name == "another_function"
        assert classes[0].name == "MyClass"

    def test_given_complex_module_when_analyzed_then_all_components_captured(self):
        """Given: A complex module with various definitions
        When: Code is analyzed
        Then: All components should be captured correctly
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
import os
from typing import Optional

CONSTANT = 42

def helper(value: int) -> int:
    return value + 1

class BaseClass:
    def __init__(self, name: str):
        self.name = name

class DerivedClass(BaseClass):
    def __init__(self, name: str, age: int):
        super().__init__(name)
        self.age = age

    def describe(self) -> str:
        return f"{self.name} is {self.age}"

async def async_operation(data: str) -> Optional[dict]:
    if not data:
        raise ValueError("Empty data")
    return {"data": data}
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 2  # helper and async_operation
        assert len(classes) == 2  # BaseClass and DerivedClass
        assert any(f.is_async for f in functions)


class TestASTFunctionAnalyzerEdgeCases:
    """Test edge cases and special scenarios."""

    def test_given_function_with_complex_type_annotations_when_analyzed_then_handled(self):
        """Given: A function with complex type annotations
        When: Code is analyzed
        Then: Function should be extracted successfully
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
from typing import List, Dict, Optional, Union

def complex_types(
    items: List[Dict[str, int]],
    optional: Optional[str] = None,
    union: Union[int, str] = 0
) -> Dict[str, List[int]]:
    return {}
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "complex_types"
        assert len(functions[0].params) == 3

    def test_given_function_with_decorators_when_analyzed_then_function_captured(self):
        """Given: A function with decorators
        When: Code is analyzed
        Then: Function should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def decorator(func):
    return func

@decorator
def decorated_function(x: int) -> int:
    return x * 2
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 2  # Both decorator and decorated_function

    def test_given_function_with_varargs_when_analyzed_then_params_captured(self):
        """Given: A function with *args and **kwargs
        When: Code is analyzed
        Then: Variable arguments should be captured
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def flexible_function(a: int, *args, **kwargs) -> None:
    pass
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "flexible_function"

    def test_given_class_with_properties_when_analyzed_then_methods_captured(self):
        """Given: A class with property decorators
        When: Code is analyzed
        Then: Properties should be captured as methods
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
class PropertyClass:
    @property
    def value(self) -> int:
        return 42

    @value.setter
    def value(self, v: int) -> None:
        pass
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(classes) == 1
        assert len(classes[0].methods) >= 1

    def test_given_multiline_function_signature_when_analyzed_then_captured(self):
        """Given: A function with multiline signature
        When: Code is analyzed
        Then: Function should be captured correctly
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
def multiline_signature(
    first_param: str,
    second_param: int,
    third_param: float,
    fourth_param: bool
) -> dict:
    return {}
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "multiline_signature"
        assert len(functions[0].params) == 4

    def test_given_lambda_expressions_when_analyzed_then_not_captured(self):
        """Given: Code with lambda expressions
        When: Code is analyzed
        Then: Lambdas should not be captured as functions
        """
        # Given
        analyzer = ASTFunctionAnalyzer()
        code = """
square = lambda x: x * 2
double = lambda y: y * 2

def real_function():
    pass
"""

        # When
        functions, classes = analyzer.analyze(code)

        # Then
        assert len(functions) == 1
        assert functions[0].name == "real_function"
