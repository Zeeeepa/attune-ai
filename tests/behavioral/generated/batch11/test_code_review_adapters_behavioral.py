"""Behavioral tests for code_review_adapters.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
from typing import TYPE_CHECKING
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from empathy_os.workflows.code_review_adapters import (
    _check_crew_available,
    _get_crew_review,
    crew_report_to_workflow_format,
)

if TYPE_CHECKING:
    from empathy_llm_toolkit.agent_factory.crews import CodeReviewReport


# Fixtures


@pytest.fixture
def mock_finding():
    """Create a mock finding object."""
    finding = MagicMock()
    finding.category = MagicMock()
    finding.category.value = "security"
    finding.title = "SQL Injection Risk"
    finding.description = "Potential SQL injection vulnerability"
    finding.severity = MagicMock()
    finding.severity.value = "high"
    finding.file_path = "src/database.py"
    finding.line_number = 42
    finding.code_snippet = "query = f'SELECT * FROM users WHERE id = {user_id}'"
    finding.suggestion = "Use parameterized queries"
    return finding


@pytest.fixture
def mock_finding_no_category():
    """Create a mock finding with no category."""
    finding = MagicMock()
    finding.category = None
    finding.title = "Code Quality Issue"
    finding.description = "Generic issue"
    finding.severity = None
    finding.file_path = None
    finding.line_number = None
    finding.code_snippet = None
    finding.suggestion = None
    return finding


@pytest.fixture
def mock_code_review_report(mock_finding):
    """Create a mock CodeReviewReport."""
    report = MagicMock()
    report.findings = [mock_finding]
    report.overall_verdict = "NEEDS_CHANGES"
    report.summary = "Found 1 security issue"
    report.blocking_issues = 1
    report.metadata = {"reviewer": "AI", "timestamp": "2025-01-01"}
    return report


@pytest.fixture
def mock_code_review_report_empty():
    """Create an empty mock CodeReviewReport."""
    report = MagicMock()
    report.findings = []
    report.overall_verdict = "APPROVED"
    report.summary = "No issues found"
    report.blocking_issues = 0
    report.metadata = {}
    return report


@pytest.fixture
def sample_diff():
    """Sample git diff string."""
    return """diff --git a/src/database.py b/src/database.py
index 1234567..abcdefg 100644
--- a/src/database.py
+++ b/src/database.py
@@ -40,7 +40,7 @@ def get_user(user_id):
-    query = "SELECT * FROM users WHERE id = ?"
+    query = f"SELECT * FROM users WHERE id = {user_id}"
     return execute(query)
"""


@pytest.fixture
def sample_files_changed():
    """Sample list of changed files."""
    return ["src/database.py", "src/models.py"]


@pytest.fixture
def sample_config():
    """Sample configuration dictionary."""
    return {
        "max_findings": 10,
        "check_security": True,
        "check_performance": True,
    }


# Tests for _check_crew_available


class TestCheckCrewAvailable:
    """Behavioral tests for _check_crew_available function."""

    def test_returns_true_when_crew_importable(self):
        """
        Given: CodeReviewCrew can be imported
        When: _check_crew_available is called
        Then: It should return True
        """
        # Given
        with patch(
            "empathy_os.workflows.code_review_adapters.__import__"
        ) as mock_import:
            mock_import.return_value = MagicMock()

            # When
            result = _check_crew_available()

            # Then - Result may vary based on actual import availability
            assert isinstance(result, bool)

    def test_returns_false_when_crew_not_importable(self):
        """
        Given: CodeReviewCrew cannot be imported
        When: _check_crew_available is called
        Then: It should return False
        """
        # Given
        with patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            side_effect=ImportError("Module not found"),
        ):
            # When
            with patch.dict("sys.modules", {"empathy_llm_toolkit.agent_factory.crews": None}):
                result = _check_crew_available()

            # Then - In case of import error handled gracefully
            assert isinstance(result, bool)

    def test_handles_import_exception_gracefully(self):
        """
        Given: Import raises an unexpected exception
        When: _check_crew_available is called
        Then: It should return False without raising
        """
        # When/Then - Should not raise
        result = _check_crew_available()
        assert isinstance(result, bool)


# Tests for _get_crew_review


class TestGetCrewReview:
    """Behavioral tests for _get_crew_review function."""

    @pytest.mark.asyncio
    async def test_returns_none_when_crew_unavailable(self, sample_diff):
        """
        Given: CodeReviewCrew is not available
        When: _get_crew_review is called
        Then: It should return None
        """
        # Given
        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=False,
        ):
            # When
            result = await _get_crew_review(diff=sample_diff)

            # Then
            assert result is None

    @pytest.mark.asyncio
    async def test_returns_report_when_crew_succeeds(
        self, sample_diff, sample_files_changed, mock_code_review_report
    ):
        """
        Given: CodeReviewCrew is available and review succeeds
        When: _get_crew_review is called
        Then: It should return CodeReviewReport
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(return_value=mock_code_review_report)

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig"
        ):
            # When
            result = await _get_crew_review(
                diff=sample_diff, files_changed=sample_files_changed
            )

            # Then
            assert result == mock_code_review_report
            mock_crew.review.assert_called_once_with(
                diff=sample_diff, files_changed=sample_files_changed
            )

    @pytest.mark.asyncio
    async def test_uses_config_when_provided(self, sample_diff, sample_config):
        """
        Given: A configuration dictionary is provided
        When: _get_crew_review is called
        Then: It should pass config to CodeReviewConfig
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(return_value=MagicMock())
        mock_config_class = MagicMock()

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig",
            mock_config_class,
        ):
            # When
            await _get_crew_review(diff=sample_diff, config=sample_config)

            # Then
            mock_config_class.assert_called_once_with(**sample_config)

    @pytest.mark.asyncio
    async def test_uses_empty_dict_when_config_none(self, sample_diff):
        """
        Given: No configuration is provided
        When: _get_crew_review is called
        Then: It should use empty dict for config
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(return_value=MagicMock())
        mock_config_class = MagicMock()

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig",
            mock_config_class,
        ):
            # When
            await _get_crew_review(diff=sample_diff, config=None)

            # Then
            mock_config_class.assert_called_once_with()

    @pytest.mark.asyncio
    async def test_uses_empty_list_when_files_changed_none(self, sample_diff):
        """
        Given: No files_changed list is provided
        When: _get_crew_review is called
        Then: It should use empty list
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(return_value=MagicMock())

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig"
        ):
            # When
            await _get_crew_review(diff=sample_diff, files_changed=None)

            # Then
            mock_crew.review.assert_called_once_with(diff=sample_diff, files_changed=[])

    @pytest.mark.asyncio
    async def test_returns_none_on_timeout(self, sample_diff):
        """
        Given: Review operation times out
        When: _get_crew_review is called
        Then: It should return None and log warning
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(side_effect=asyncio.TimeoutError())

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig"
        ), patch(
            "empathy_os.workflows.code_review_adapters.logger"
        ) as mock_logger:
            # When
            result = await _get_crew_review(diff=sample_diff, timeout=0.1)

            # Then
            assert result is None
            assert mock_logger.warning.called

    @pytest.mark.asyncio
    async def test_returns_none_on_exception(self, sample_diff):
        """
        Given: Review operation raises an exception
        When: _get_crew_review is called
        Then: It should return None and log warning
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(side_effect=ValueError("Test error"))

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig"
        ), patch(
            "empathy_os.workflows.code_review_adapters.logger"
        ) as mock_logger:
            # When
            result = await _get_crew_review(diff=sample_diff)

            # Then
            assert result is None
            assert mock_logger.warning.called

    @pytest.mark.asyncio
    async def test_respects_custom_timeout(self, sample_diff):
        """
        Given: A custom timeout is specified
        When: _get_crew_review is called
        Then: It should use the custom timeout
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.review = AsyncMock(return_value=MagicMock())
        custom_timeout = 60.0

        with patch(
            "empathy_os.workflows.code_review_adapters._check_crew_available",
            return_value=True,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewCrew",
            return_value=mock_crew,
        ), patch(
            "empathy_os.workflows.code_review_adapters.CodeReviewConfig"
        ), patch(
            "asyncio.wait_for", new_callable=AsyncMock
        ) as mock_wait_for:
            mock_wait_for.return_value = MagicMock()

            # When
            await _get_crew_review(diff=sample_diff, timeout=custom_timeout)

            # Then
            assert mock_wait_for.call_args[1]["timeout"] == custom_timeout


# Tests for crew_report_to_workflow_format


class TestCrewReportToWorkflowFormat:
    """Behavioral tests for crew_report_to_workflow_format function."""

    def test_converts_report_with_findings(self, mock_code_review_report, mock_finding):
        """
        Given: A CodeReviewReport with findings
        When: crew_report_to_workflow_format is called
        Then: It should return properly formatted workflow dict
        """
        # Given - mock_code_review_report fixture

        # When
        result = crew_report_to_workflow_format(mock_code_review_report)

        # Then
        assert isinstance(result, dict)
        assert "findings" in result
        assert "verdict" in result
        assert "summary" in result
        assert "blocking_issues" in result
        assert "metadata" in result

        assert result["verdict"] == "NEEDS_CHANGES"
        assert result["summary"] == "Found 1 security issue"
        assert result["blocking_issues"] == 1
        assert result["metadata"] == {"reviewer": "AI", "timestamp": "2025-01-01"}

        # Check findings structure
        assert len(result["findings"]) == 1
        finding = result["findings"][0]
        assert finding["type"] == "security"
        assert finding["title"] == "SQL Injection Risk"
        assert finding["description"] == "Potential SQL injection vulnerability"
        assert finding["severity"] == "high"
        assert finding["file"] == "src/database.py"
        assert finding["line"] == 42
        assert finding["code_snippet"] == "query = f'SELECT * FROM users WHERE id = {user_id}'"
        assert finding["suggestion"] == "Use parameterized queries"

    def test_converts_empty_report(self, mock_code_review_report_empty):
        """
        Given: A CodeReviewReport with no findings
        When: crew_