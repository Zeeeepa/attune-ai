"""Behavioral tests for provider_config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, mock_open, patch

import pytest

from empathy_os.models.provider_config import (
    ProviderConfig,
    ProviderMode,
)


@pytest.fixture
def clean_environment(monkeypatch):
    """Given a clean environment without API keys."""
    monkeypatch.delenv("ANTHROPIC_API_KEY", raising=False)
    monkeypatch.delenv("OPENAI_API_KEY", raising=False)
    return monkeypatch


@pytest.fixture
def anthropic_api_key_in_env(monkeypatch):
    """Given an environment with Anthropic API key configured."""
    monkeypatch.setenv("ANTHROPIC_API_KEY", "test-anthropic-key-123")
    return monkeypatch


@pytest.fixture
def mock_env_file(tmp_path):
    """Given a temporary .env file with API keys."""
    env_file = tmp_path / ".env"
    env_content = """
# Test environment file
ANTHROPIC_API_KEY=test-key-from-file
OTHER_VAR=some_value

EMPTY_LINE_ABOVE=value
"""
    env_file.write_text(env_content)
    return env_file


@pytest.fixture
def mock_empty_env_file(tmp_path):
    """Given an empty .env file."""
    env_file = tmp_path / ".env"
    env_file.write_text("")
    return env_file


@pytest.fixture
def mock_malformed_env_file(tmp_path):
    """Given a malformed .env file."""
    env_file = tmp_path / ".env"
    env_content = """
VALID_KEY=valid_value
INVALID_LINE_NO_EQUALS
=NO_KEY
KEY_NO_VALUE=
# Comment line
"""
    env_file.write_text(env_content)
    return env_file


@pytest.fixture
def mock_config_file(tmp_path):
    """Given a temporary config file."""
    config_file = tmp_path / "provider_config.json"
    return config_file


class TestProviderMode:
    """Behavioral tests for ProviderMode enum."""

    def test_provider_mode_single_value(self):
        """Given the ProviderMode enum, when accessing SINGLE, then it has correct value."""
        # When
        mode = ProviderMode.SINGLE

        # Then
        assert mode == "single"
        assert mode.value == "single"

    def test_provider_mode_is_string_enum(self):
        """Given ProviderMode, when checking type, then it extends str and Enum."""
        # When
        mode = ProviderMode.SINGLE

        # Then
        assert isinstance(mode, str)
        assert isinstance(mode, ProviderMode)

    def test_provider_mode_comparison(self):
        """Given ProviderMode values, when comparing, then string comparison works."""
        # When
        mode = ProviderMode.SINGLE

        # Then
        assert mode == "single"
        assert mode == ProviderMode.SINGLE


class TestProviderConfigInitialization:
    """Behavioral tests for ProviderConfig initialization."""

    def test_default_initialization(self):
        """Given no parameters, when creating ProviderConfig, then defaults are set correctly."""
        # When
        config = ProviderConfig()

        # Then
        assert config.mode == ProviderMode.SINGLE
        assert config.primary_provider == "anthropic"
        assert config.tier_providers == {}
        assert config.available_providers == []
        assert config.prefer_local is False
        assert config.cost_optimization is True

    def test_initialization_with_custom_values(self):
        """Given custom parameters, when creating ProviderConfig, then values are set correctly."""
        # Given
        tier_providers = {"tier1": "provider1", "tier2": "provider2"}
        available_providers = ["anthropic", "openai"]

        # When
        config = ProviderConfig(
            mode=ProviderMode.SINGLE,
            primary_provider="openai",
            tier_providers=tier_providers,
            available_providers=available_providers,
            prefer_local=True,
            cost_optimization=False,
        )

        # Then
        assert config.mode == ProviderMode.SINGLE
        assert config.primary_provider == "openai"
        assert config.tier_providers == tier_providers
        assert config.available_providers == available_providers
        assert config.prefer_local is True
        assert config.cost_optimization is False

    def test_default_factory_creates_independent_dicts(self):
        """Given multiple ProviderConfig instances, when using defaults, then they have independent dicts."""
        # When
        config1 = ProviderConfig()
        config2 = ProviderConfig()

        config1.tier_providers["test"] = "value"
        config1.available_providers.append("anthropic")

        # Then
        assert "test" not in config2.tier_providers
        assert "anthropic" not in config2.available_providers


class TestLoadEnvFiles:
    """Behavioral tests for _load_env_files method."""

    def test_load_env_file_with_valid_content(self, mock_env_file):
        """Given a valid .env file, when loading, then keys are parsed correctly."""
        # Given
        with patch.object(Path, "cwd", return_value=mock_env_file.parent):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert "ANTHROPIC_API_KEY" in env_keys
        assert env_keys["ANTHROPIC_API_KEY"] == "test-key-from-file"
        assert env_keys["OTHER_VAR"] == "some_value"
        assert env_keys["EMPTY_LINE_ABOVE"] == "value"

    def test_load_env_file_with_quotes(self, tmp_path):
        """Given an .env file with quoted values, when loading, then quotes are stripped."""
        # Given
        env_file = tmp_path / ".env"
        env_file.write_text('KEY1="double_quoted"\nKEY2=\'single_quoted\'\n')

        with patch.object(Path, "cwd", return_value=tmp_path):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert env_keys["KEY1"] == "double_quoted"
        assert env_keys["KEY2"] == "single_quoted"

    def test_load_env_file_skips_comments(self, tmp_path):
        """Given an .env file with comments, when loading, then comments are skipped."""
        # Given
        env_file = tmp_path / ".env"
        env_file.write_text("# This is a comment\nVALID_KEY=value\n# Another comment\n")

        with patch.object(Path, "cwd", return_value=tmp_path):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert "VALID_KEY" in env_keys
        assert len(env_keys) == 1

    def test_load_env_file_skips_empty_lines(self, tmp_path):
        """Given an .env file with empty lines, when loading, then empty lines are skipped."""
        # Given
        env_file = tmp_path / ".env"
        env_file.write_text("KEY1=value1\n\n\nKEY2=value2\n")

        with patch.object(Path, "cwd", return_value=tmp_path):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert len(env_keys) == 2
        assert env_keys["KEY1"] == "value1"
        assert env_keys["KEY2"] == "value2"

    def test_load_env_file_skips_invalid_lines(self, mock_malformed_env_file):
        """Given an .env file with invalid lines, when loading, then invalid lines are skipped."""
        # Given
        with patch.object(Path, "cwd", return_value=mock_malformed_env_file.parent):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert "VALID_KEY" in env_keys
        assert env_keys["VALID_KEY"] == "valid_value"
        # Invalid lines should be skipped
        assert "INVALID_LINE_NO_EQUALS" not in env_keys

    def test_load_env_file_handles_whitespace(self, tmp_path):
        """Given an .env file with whitespace, when loading, then whitespace is stripped."""
        # Given
        env_file = tmp_path / ".env"
        env_file.write_text("  KEY1  =  value1  \n KEY2=value2\n")

        with patch.object(Path, "cwd", return_value=tmp_path):
            with patch.object(Path, "home", return_range=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert env_keys["KEY1"] == "value1"
        assert env_keys["KEY2"] == "value2"

    def test_load_env_file_nonexistent(self):
        """Given no .env files exist, when loading, then empty dict is returned."""
        # Given
        with patch.object(Path, "cwd", return_value=Path("/nonexistent")):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert env_keys == {}

    def test_load_env_file_handles_exception(self, tmp_path):
        """Given an .env file that raises exception, when loading, then exception is handled."""
        # Given
        env_file = tmp_path / ".env"
        env_file.write_text("KEY=value")

        with patch.object(Path, "cwd", return_value=tmp_path):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                with patch("builtins.open", side_effect=IOError("Permission denied")):
                    # When
                    env_keys = ProviderConfig._load_env_files()

        # Then - should return empty dict without raising
        assert env_keys == {}

    def test_load_env_file_checks_multiple_locations(self, tmp_path):
        """Given .env files in multiple locations, when loading, then all are checked."""
        # Given
        cwd_env = tmp_path / "cwd" / ".env"
        cwd_env.parent.mkdir(parents=True)
        cwd_env.write_text("CWD_KEY=cwd_value")

        home_env = tmp_path / "home" / ".env"
        home_env.parent.mkdir(parents=True)
        home_env.write_text("HOME_KEY=home_value")

        empathy_env = tmp_path / "home" / ".empathy" / ".env"
        empathy_env.parent.mkdir(parents=True)
        empathy_env.write_text("EMPATHY_KEY=empathy_value")

        with patch.object(Path, "cwd", return_value=cwd_env.parent):
            with patch.object(Path, "home", return_value=home_env.parent):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then - keys from all locations should be present
        assert "CWD_KEY" in env_keys
        assert "HOME_KEY" in env_keys
        assert "EMPATHY_KEY" in env_keys

    def test_load_env_file_empty_key_value_skipped(self, tmp_path):
        """Given .env file with empty keys or values, when loading, then they are skipped."""
        # Given
        env_file = tmp_path / ".env"
        env_file.write_text("=empty_key\nEMPTY_VALUE=\n   =   \nVALID=valid")

        with patch.object(Path, "cwd", return_value=tmp_path):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                env_keys = ProviderConfig._load_env_files()

        # Then
        assert "VALID" in env_keys
        assert len([k for k in env_keys if k]) == 1  # Only valid key


class TestDetectAvailableProviders:
    """Behavioral tests for detect_available_providers method."""

    def test_detect_anthropic_from_environment(self, anthropic_api_key_in_env):
        """Given Anthropic API key in environment, when detecting, then Anthropic is available."""
        # When
        available = ProviderConfig.detect_available_providers()

        # Then
        assert "anthropic" in available

    def test_detect_no_providers_when_no_keys(self, clean_environment):
        """Given no API keys configured, when detecting, then no providers available."""
        # Given
        with patch.object(ProviderConfig, "_load_env_files", return_value={}):
            # When
            available = ProviderConfig.detect_available_providers()

        # Then
        assert available == []

    def test_detect_anthropic_from_env_file(self, clean_environment, mock_env_file):
        """Given Anthropic API key in .env file, when detecting, then Anthropic is available."""
        # Given
        with patch.object(Path, "cwd", return_value=mock_env_file.parent):
            with patch.object(Path, "home", return_value=Path("/nonexistent")):
                # When
                available = ProviderConfig.detect_available_providers()

        # Then
        assert "anthropic" in available

    def test_detect_prefers_environment_over_file(self, anthropic_api_key_in_env):
        """Given API key in both environment and file, when detecting, then environment takes precedence."""
        # Given
        env_keys = {"ANTHROPIC_API_KEY": "file-key"}

        with patch.object(ProviderConfig, "_load_env_files", return_value=env_keys):
            # When
            available = ProviderConfig.detect_available_providers()

        # Then
        assert "anthropic" in available

    def test_detect_returns_list(self, clean_environment):
        """Given any configuration, when detecting, then list is returned."""
        # Given
        with patch.object(ProviderConfig, "_load_env_files", return_value={}):
            # When
            available = ProviderConfig.detect_available_providers()

        # Then
        assert isinstance(available, list)

    def test_detect_handles_env_file_exception(self, clean_environment):
        """Given _load_env_files raises exception, when detecting, then empty list is returned."""
        # Given
        with patch.object(ProviderConfig, "_load_env_files", side_effect=Exception("Error")):
            # When - should not raise
            available = ProviderConfig.detect