"""Behavioral tests for base.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import logging
import os
import tempfile
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
from unittest.mock import MagicMock, Mock, PropertyMock, patch, mock_open

import pytest

from empathy_os.workflows.base import (
    WORKFLOW_HISTORY_FILE,
    BaseWorkflow,
    CachedResponse,
    CachingMixin,
    ModelTier,
    ProgressCallback,
    ProgressTracker,
    RichProgressReporter,
    TelemetryMixin,
    TELEMETRY_AVAILABLE,
)
from empathy_os.models import (
    ExecutionContext,
    LLMExecutor,
    TaskRoutingRecord,
    TelemetryBackend,
    ModelTier as UnifiedModelTier,
    ModelProvider as UnifiedModelProvider,
)


# Test Fixtures


@pytest.fixture
def mock_llm_executor():
    """Provide a mocked LLMExecutor."""
    executor = Mock(spec=LLMExecutor)
    executor.execute.return_value = {"result": "test response"}
    return executor


@pytest.fixture
def mock_telemetry_backend():
    """Provide a mocked TelemetryBackend."""
    backend = Mock(spec=TelemetryBackend)
    backend.store_task_routing.return_value = None
    return backend


@pytest.fixture
def mock_cache():
    """Provide a mocked cache."""
    from empathy_os.cache import BaseCache
    
    cache = Mock(spec=BaseCache)
    cache.get.return_value = None
    cache.set.return_value = None
    return cache


@pytest.fixture
def execution_context(mock_llm_executor, mock_telemetry_backend):
    """Provide a basic ExecutionContext."""
    return ExecutionContext(
        llm_executor=mock_llm_executor,
        telemetry_backend=mock_telemetry_backend,
    )


@pytest.fixture
def temp_workflow_history():
    """Provide a temporary workflow history file."""
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.json') as f:
        temp_path = f.name
        json.dump([], f)
    
    yield temp_path
    
    # Cleanup
    if os.path.exists(temp_path):
        os.unlink(temp_path)


@pytest.fixture
def concrete_workflow(execution_context):
    """Provide a concrete implementation of BaseWorkflow for testing."""
    class TestWorkflow(BaseWorkflow):
        def execute(self, input_data: Any) -> Any:
            return {"status": "success", "data": input_data}
        
        def _get_workflow_steps(self) -> List[Any]:
            return []
    
    return TestWorkflow(
        name="test_workflow",
        execution_context=execution_context,
    )


# Tests for ModelTier (Deprecated Enum)


class TestModelTierEnum:
    """Test suite for deprecated ModelTier enum."""

    def test_given_modeltier_enum_when_accessing_values_then_returns_correct_strings(self):
        """
        Given: The deprecated ModelTier enum
        When: Accessing enum values
        Then: Returns correct string representations
        """
        assert ModelTier.CHEAP.value == "cheap"

    def test_given_modeltier_enum_when_compared_with_unified_then_values_match(self):
        """
        Given: Both deprecated and unified ModelTier enums
        When: Comparing equivalent values
        Then: String values match
        """
        assert ModelTier.CHEAP.value == UnifiedModelTier.CHEAP.value


# Tests for CachedResponse


class TestCachedResponse:
    """Test suite for CachedResponse dataclass."""

    def test_given_cached_response_when_created_then_stores_data_correctly(self):
        """
        Given: Response data and metadata
        When: Creating a CachedResponse
        Then: Stores all fields correctly
        """
        timestamp = datetime.now()
        response = CachedResponse(
            response="test data",
            tier=UnifiedModelTier.CHEAP,
            cost=0.001,
            timestamp=timestamp,
        )
        
        assert response.response == "test data"
        assert response.tier == UnifiedModelTier.CHEAP
        assert response.cost == 0.001
        assert response.timestamp == timestamp


# Tests for CachingMixin


class TestCachingMixin:
    """Test suite for CachingMixin."""

    def test_given_caching_mixin_when_cache_enabled_then_returns_cached_result(self, mock_cache):
        """
        Given: A workflow with caching enabled
        When: Calling a cached operation
        Then: Returns result from cache
        """
        class CachedWorkflow(CachingMixin):
            def __init__(self):
                self.cache = mock_cache
                self._cache_enabled = True
        
        workflow = CachedWorkflow()
        cached_data = CachedResponse(
            response="cached",
            tier=UnifiedModelTier.CHEAP,
            cost=0.0,
            timestamp=datetime.now(),
        )
        mock_cache.get.return_value = cached_data
        
        result = workflow._get_cached_response("test_key")
        
        assert result == cached_data
        mock_cache.get.assert_called_once_with("test_key")

    def test_given_caching_mixin_when_cache_disabled_then_returns_none(self, mock_cache):
        """
        Given: A workflow with caching disabled
        When: Attempting to get cached response
        Then: Returns None without checking cache
        """
        class CachedWorkflow(CachingMixin):
            def __init__(self):
                self.cache = mock_cache
                self._cache_enabled = False
        
        workflow = CachedWorkflow()
        result = workflow._get_cached_response("test_key")
        
        assert result is None
        mock_cache.get.assert_not_called()

    def test_given_caching_mixin_when_storing_response_then_stores_in_cache(self, mock_cache):
        """
        Given: A workflow with caching enabled
        When: Storing a response in cache
        Then: Calls cache.set with correct parameters
        """
        class CachedWorkflow(CachingMixin):
            def __init__(self):
                self.cache = mock_cache
                self._cache_enabled = True
        
        workflow = CachedWorkflow()
        cached_data = CachedResponse(
            response="new_data",
            tier=UnifiedModelTier.CHEAP,
            cost=0.001,
            timestamp=datetime.now(),
        )
        
        workflow._store_cached_response("test_key", cached_data)
        
        mock_cache.set.assert_called_once_with("test_key", cached_data)

    def test_given_caching_mixin_when_no_cache_instance_then_handles_gracefully(self):
        """
        Given: A workflow without cache instance
        When: Attempting cached operations
        Then: Handles gracefully without errors
        """
        class CachedWorkflow(CachingMixin):
            def __init__(self):
                self.cache = None
                self._cache_enabled = True
        
        workflow = CachedWorkflow()
        result = workflow._get_cached_response("test_key")
        
        assert result is None


# Tests for TelemetryMixin


class TestTelemetryMixin:
    """Test suite for TelemetryMixin."""

    def test_given_telemetry_mixin_when_recording_task_then_stores_in_backend(self, mock_telemetry_backend):
        """
        Given: A workflow with telemetry backend
        When: Recording a task routing
        Then: Stores in telemetry backend
        """
        class TelemetryWorkflow(TelemetryMixin):
            def __init__(self):
                self._telemetry_backend = mock_telemetry_backend
        
        workflow = TelemetryWorkflow()
        record = TaskRoutingRecord(
            task_id="test_task",
            tier=UnifiedModelTier.CHEAP,
            provider=UnifiedModelProvider.ANTHROPIC,
            timestamp=datetime.now(),
        )
        
        workflow._record_task_routing(record)
        
        mock_telemetry_backend.store_task_routing.assert_called_once_with(record)

    def test_given_telemetry_mixin_when_no_backend_then_handles_gracefully(self):
        """
        Given: A workflow without telemetry backend
        When: Attempting to record task routing
        Then: Handles gracefully without errors
        """
        class TelemetryWorkflow(TelemetryMixin):
            def __init__(self):
                self._telemetry_backend = None
        
        workflow = TelemetryWorkflow()
        record = TaskRoutingRecord(
            task_id="test_task",
            tier=UnifiedModelTier.CHEAP,
            provider=UnifiedModelProvider.ANTHROPIC,
            timestamp=datetime.now(),
        )
        
        # Should not raise
        workflow._record_task_routing(record)


# Tests for ProgressCallback


class TestProgressCallback:
    """Test suite for ProgressCallback."""

    def test_given_progress_callback_when_called_then_executes_function(self):
        """
        Given: A ProgressCallback with a function
        When: Calling the callback
        Then: Executes the function with correct parameters
        """
        mock_func = Mock()
        callback = ProgressCallback(func=mock_func)
        
        callback(step=1, total=10, message="test")
        
        mock_func.assert_called_once_with(step=1, total=10, message="test")

    def test_given_progress_callback_when_function_raises_then_logs_error(self, caplog):
        """
        Given: A ProgressCallback with a function that raises
        When: Calling the callback
        Then: Logs error and continues
        """
        def failing_func(**kwargs):
            raise ValueError("Test error")
        
        callback = ProgressCallback(func=failing_func)
        
        with caplog.at_level(logging.ERROR):
            callback(step=1, total=10, message="test")
        
        assert "Progress callback error" in caplog.text


# Tests for ProgressTracker


class TestProgressTracker:
    """Test suite for ProgressTracker."""

    def test_given_progress_tracker_when_updating_progress_then_calls_callback(self):
        """
        Given: A ProgressTracker with callback
        When: Updating progress
        Then: Calls callback with correct parameters
        """
        mock_callback = Mock()
        tracker = ProgressTracker(total_steps=10, callback=mock_callback)
        
        tracker.update(step=5, message="halfway")
        
        mock_callback.assert_called_once_with(step=5, total=10, message="halfway")

    def test_given_progress_tracker_when_no_callback_then_handles_gracefully(self):
        """
        Given: A ProgressTracker without callback
        When: Updating progress
        Then: Handles gracefully without errors
        """
        tracker = ProgressTracker(total_steps=10)
        
        # Should not raise
        tracker.update(step=5, message="halfway")

    def test_given_progress_tracker_when_completing_then_marks_complete(self):
        """
        Given: A ProgressTracker
        When: Calling complete
        Then: Marks tracker as complete
        """
        tracker = ProgressTracker(total_steps=10)
        
        tracker.complete()
        
        assert tracker.is_complete is True


# Tests for RichProgressReporter


class TestRichProgressReporter:
    """Test suite for RichProgressReporter."""

    @patch('empathy_os.workflows.base.RICH_AVAILABLE', True)
    def test_given_rich_reporter_when_created_then_initializes_correctly(self):
        """
        Given: Rich is available
        When: Creating RichProgressReporter
        Then: Initializes without errors
        """
        reporter = RichProgressReporter(total_steps=10, description="test")
        
        assert reporter.total_steps == 10
        assert reporter.description == "test"

    @patch('empathy_os.workflows.base.RICH_AVAILABLE', False)
    def test_given_rich_not_available_when_created_then_logs_warning(self, caplog):
        """
        Given: Rich is not available
        When: Creating RichProgressReporter
        Then: Logs warning
        """
        with caplog.at_level(logging.WARNING):
            reporter = RichProgressReporter(total_steps=10, description="test")
        
        assert "Rich library not available" in caplog.text

    @patch('empathy_os.workflows.base.RICH_AVAILABLE', True)
    def test_given_rich_reporter_when_updating_then_updates_progress(self):
        """
        Given: A RichProgressReporter
        When: Updating progress
        Then: Updates internal progress
        """
        with patch('empathy_os.workflows.progress.Progress') as mock_progress:
            reporter = RichProgressReporter(total_steps=10, description="test")
            reporter.update(step=5, message="halfway")
            
            # Should have been called during initialization and update


# Tests for BaseWorkflow


class TestBaseWorkflow:
    """Test suite for BaseWorkflow."""

    def test_given_base_workflow_when_instantiated_then_sets_attributes(self, execution_context):
        """
        Given: Valid execution context and parameters
        When: Instantiating BaseWorkflow subclass
        Then: Sets all attributes correctly
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
            cache_enabled=True,
        )
        
        assert workflow.name == "test"
        assert workflow._execution_context == execution_context
        assert workflow._cache_enabled is True
        assert workflow.workflow_id is not None

    def test_given_base_workflow_when_execute_not_implemented_then_raises(self, execution_context):
        """
        Given: A BaseWorkflow subclass without execute implementation
        When: Calling execute
        Then: Raises NotImplementedError
        """
        class IncompleteWorkflow(BaseWorkflow):
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = IncompleteWorkflow(
            name="incomplete",
            execution_context=execution_context,
        )
        
        with pytest.raises(NotImplementedError):
            workflow.execute({})

    def test_given_base_workflow_when_getting_llm_executor_then_returns_executor(self, execution_context):
        """
        Given: A workflow with execution context
        When: Accessing llm_executor
        Then: Returns the executor from context
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        assert workflow.llm_executor == execution_context.llm_executor

    def test_given_base_workflow_when_getting_telemetry_backend_then_returns_backend(self, execution_context):
        """
        Given: A workflow with execution context
        When: Accessing telemetry_backend
        Then: Returns the backend from context
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        assert workflow.telemetry_backend == execution_context.telemetry_backend

    def test_given_base_workflow_when_workflow_id_not_set_then_generates_uuid(self, execution_context):
        """
        Given: A workflow without explicit workflow_id
        When: Creating the workflow
        Then: Generates a valid UUID
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        assert workflow.workflow_id is not None
        # Should be a valid UUID
        uuid.UUID(workflow.workflow_id)

    def test_given_base_workflow_when_setting_progress_callback_then_stores_callback(self, execution_context):
        """
        Given: A workflow and a progress callback
        When: Setting the progress callback
        Then: Stores the callback
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        mock_callback = Mock()
        workflow.set_progress_callback(mock_callback)
        
        assert workflow._progress_callback == mock_callback

    def test_given_base_workflow_when_cache_not_set_then_returns_none(self, execution_context):
        """
        Given: A workflow without cache
        When: Accessing cache property
        Then: Returns None
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        assert workflow.cache is None

    def test_given_base_workflow_when_setting_cache_then_stores_cache(self, execution_context, mock_cache):
        """
        Given: A workflow and a cache instance
        When: Setting the cache
        Then: Stores the cache
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        workflow._cache = mock_cache
        
        assert workflow.cache == mock_cache

    def test_given_base_workflow_when_generating_cache_key_then_returns_consistent_key(self, execution_context):
        """
        Given: A workflow and input data
        When: Generating cache key multiple times
        Then: Returns consistent key
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        input_data = {"key": "value"}
        key1 = workflow._generate_cache_key(input_data)
        key2 = workflow._generate_cache_key(input_data)
        
        assert key1 == key2
        assert "test" in key1

    def test_given_base_workflow_when_updating_progress_with_callback_then_calls_callback(self, execution_context):
        """
        Given: A workflow with progress callback set
        When: Updating progress
        Then: Calls the callback
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        mock_callback = Mock()
        workflow.set_progress_callback(mock_callback)
        workflow._update_progress(5, 10, "halfway")
        
        mock_callback.assert_called_once()

    def test_given_base_workflow_when_updating_progress_without_callback_then_handles_gracefully(self, execution_context):
        """
        Given: A workflow without progress callback
        When: Updating progress
        Then: Handles gracefully
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        # Should not raise
        workflow._update_progress(5, 10, "halfway")

    @patch('empathy_os.workflows.base.Path.mkdir')
    @patch('builtins.open', new_callable=mock_open)
    @patch('empathy_os.workflows.base.Path.exists')
    def test_given_base_workflow_when_saving_run_history_then_writes_to_file(
        self, mock_exists, mock_file, mock_mkdir, execution_context
    ):
        """
        Given: A workflow execution
        When: Saving run history
        Then: Writes history to file
        """
        mock_exists.return_value = True
        mock_file.return_value.read.return_value = '[]'
        
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        with patch.object(workflow, '_save_workflow_run') as mock_save:
            workflow._save_workflow_run(
                input_data={"test": "data"},
                output_data={"result": "success"},
                duration=1.5,
            )
            
            mock_save.assert_called_once()

    def test_given_base_workflow_when_repr_then_returns_string_representation(self, execution_context):
        """
        Given: A workflow instance
        When: Getting string representation
        Then: Returns formatted string
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return input_data
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        repr_str = repr(workflow)
        
        assert "TestWorkflow" in repr_str
        assert "test" in repr_str
        assert workflow.workflow_id in repr_str


# Tests for Integration


class TestBaseWorkflowIntegration:
    """Integration tests for BaseWorkflow."""

    def test_given_workflow_with_all_features_when_executing_then_works_end_to_end(
        self, execution_context, mock_cache
    ):
        """
        Given: A workflow with caching, telemetry, and progress tracking
        When: Executing the workflow
        Then: All features work together correctly
        """
        class IntegratedWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                self._update_progress(0, 2, "Starting")
                result = {"status": "success", "data": input_data}
                self._update_progress(1, 2, "Processing")
                self._update_progress(2, 2, "Complete")
                return result
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = IntegratedWorkflow(
            name="integrated",
            execution_context=execution_context,
            cache_enabled=True,
        )
        workflow._cache = mock_cache
        
        mock_callback = Mock()
        workflow.set_progress_callback(mock_callback)
        
        input_data = {"test": "data"}
        result = workflow.execute(input_data)
        
        assert result["status"] == "success"
        assert result["data"] == input_data
        assert mock_callback.call_count == 3

    def test_given_workflow_with_cache_when_executing_twice_then_uses_cache(
        self, execution_context, mock_cache
    ):
        """
        Given: A workflow with caching enabled
        When: Executing same input twice
        Then: Second execution uses cache
        """
        class CachedWorkflow(BaseWorkflow):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)
                self.execution_count = 0
            
            def execute(self, input_data: Any) -> Any:
                self.execution_count += 1
                return {"count": self.execution_count, "data": input_data}
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = CachedWorkflow(
            name="cached",
            execution_context=execution_context,
            cache_enabled=True,
        )
        workflow._cache = mock_cache
        
        input_data = {"test": "data"}
        
        # First execution - cache miss
        mock_cache.get.return_value = None
        result1 = workflow.execute(input_data)
        
        # Simulate cache hit
        cached_response = CachedResponse(
            response=result1,
            tier=UnifiedModelTier.CHEAP,
            cost=0.0,
            timestamp=datetime.now(),
        )
        mock_cache.get.return_value = cached_response
        
        # Second execution should use cache
        cache_key = workflow._generate_cache_key(input_data)
        cached = workflow._get_cached_response(cache_key)
        
        assert cached is not None
        assert cached.response == result1


# Tests for Error Handling


class TestBaseWorkflowErrorHandling:
    """Test error handling in BaseWorkflow."""

    def test_given_workflow_when_execution_fails_then_handles_gracefully(self, execution_context):
        """
        Given: A workflow that raises an exception
        When: Executing the workflow
        Then: Exception propagates correctly
        """
        class FailingWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                raise ValueError("Execution failed")
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = FailingWorkflow(
            name="failing",
            execution_context=execution_context,
        )
        
        with pytest.raises(ValueError, match="Execution failed"):
            workflow.execute({})

    def test_given_workflow_when_callback_fails_then_continues_execution(
        self, execution_context, caplog
    ):
        """
        Given: A workflow with a failing progress callback
        When: Executing the workflow
        Then: Continues execution and logs error
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                self._update_progress(1, 1, "test")
                return {"status": "success"}
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        def failing_callback(**kwargs):
            raise RuntimeError("Callback failed")
        
        workflow.set_progress_callback(failing_callback)
        
        with caplog.at_level(logging.ERROR):
            result = workflow.execute({})
        
        assert result["status"] == "success"

    def test_given_workflow_when_cache_operation_fails_then_continues(
        self, execution_context, mock_cache
    ):
        """
        Given: A workflow with a failing cache
        When: Attempting cache operations
        Then: Continues without caching
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return {"status": "success"}
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
            cache_enabled=True,
        )
        
        mock_cache.get.side_effect = Exception("Cache error")
        workflow._cache = mock_cache
        
        # Should not raise
        result = workflow._get_cached_response("test_key")
        assert result is None


# Tests for Edge Cases


class TestBaseWorkflowEdgeCases:
    """Test edge cases in BaseWorkflow."""

    def test_given_workflow_when_empty_input_then_handles_correctly(self, execution_context):
        """
        Given: A workflow
        When: Executing with empty input
        Then: Handles correctly
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return {"received": input_data}
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        result = workflow.execute({})
        assert result["received"] == {}

    def test_given_workflow_when_none_input_then_handles_correctly(self, execution_context):
        """
        Given: A workflow
        When: Executing with None input
        Then: Handles correctly
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return {"received": input_data}
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        result = workflow.execute(None)
        assert result["received"] is None

    def test_given_workflow_when_large_input_then_handles_correctly(self, execution_context):
        """
        Given: A workflow
        When: Executing with large input
        Then: Handles correctly
        """
        class TestWorkflow(BaseWorkflow):
            def execute(self, input_data: Any) -> Any:
                return {"size": len(str(input_data))}
            
            def _get_workflow_steps(self) -> List[Any]:
                return []
        
        workflow = TestWorkflow(
            name="test",
            execution_context=execution_context,
        )
        
        large_input = {"data": "x" * 10000}
        result = workflow.execute(large_input)
        assert result