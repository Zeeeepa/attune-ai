"""Behavioral tests for config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import sys
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest


# Create a mock ModelConfig class before importing EmpathyConfig
class ModelConfig:
    def __init__(self, name=None, provider=None, **kwargs):
        self.name = name
        self.provider = provider
        for key, value in kwargs.items():
            setattr(self, key, value)

# Mock the workflows.config module to provide ModelConfig
workflows_config = MagicMock()
workflows_config.ModelConfig = ModelConfig
sys.modules['empathy_os.workflows'] = MagicMock()
sys.modules['empathy_os.workflows.config'] = workflows_config

from empathy_os.config import (
    YAML_AVAILABLE,
    EmpathyConfig,
    _validate_file_path,
    load_config,
)


class TestValidateFilePath:
    """Tests for _validate_file_path function."""

    def test_validates_simple_file_path_successfully(self):
        """Given a simple file path, when validating, then returns resolved Path."""
        # Given
        path = "config.yml"

        # When
        result = _validate_file_path(path)

        # Then
        assert isinstance(result, Path)
        assert result.name == "config.yml"

    def test_rejects_empty_string_path(self):
        """Given an empty string, when validating, then raises ValueError."""
        # Given
        path = ""

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_rejects_none_path(self):
        """Given None as path, when validating, then raises ValueError."""
        # Given
        path = None

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_rejects_path_with_null_bytes(self):
        """Given a path with null bytes, when validating, then raises ValueError."""
        # Given
        path = "config\x00.yml"

        # When/Then
        with pytest.raises(ValueError, match="path contains null bytes"):
            _validate_file_path(path)

    def test_rejects_path_outside_allowed_directory(self, tmp_path):
        """Given a path outside allowed directory, when validating, then raises ValueError."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        outside_path = tmp_path / "outside" / "config.yml"

        # When/Then
        with pytest.raises(ValueError, match="path must be within"):
            _validate_file_path(str(outside_path), str(allowed_dir))

    def test_accepts_path_within_allowed_directory(self, tmp_path):
        """Given a path within allowed directory, when validating, then returns Path."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        inside_path = allowed_dir / "config.yml"

        # When
        result = _validate_file_path(str(inside_path), str(allowed_dir))

        # Then
        assert isinstance(result, Path)

    @pytest.mark.skipif(sys.platform == "win32", reason="Unix paths not applicable on Windows")
    def test_rejects_dangerous_system_paths(self):
        """Given a dangerous system path, when validating, then raises ValueError."""
        # Given
        with patch('empathy_os.config.Path') as MockPath:
            mock_instance = MagicMock()
            mock_resolved = MagicMock()
            mock_resolved.__str__ = MagicMock(return_value="/etc/passwd")
            mock_instance.resolve.return_value = mock_resolved
            MockPath.return_value = mock_instance

            # When/Then
            with pytest.raises(ValueError, match="Cannot write to system directory"):
                _validate_file_path("/etc/passwd")


class TestEmpathyConfigDefaults:
    """Tests for EmpathyConfig default initialization."""

    def test_creates_config_with_default_values(self):
        """Given no arguments, when creating config, then uses default values."""
        # Given/When
        config = EmpathyConfig()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3
        assert config.confidence_threshold == 0.75
        assert config.trust_building_rate == 0.05
        assert config.trust_erosion_rate == 0.10
        assert config.persistence_enabled is True
        assert config.persistence_backend == "sqlite"
        assert config.persistence_path == "./empathy_data"

    def test_creates_config_with_custom_values(self):
        """Given custom values, when creating config, then stores custom values."""
        # Given/When
        config = EmpathyConfig(
            user_id="alice",
            target_level=4,
            confidence_threshold=0.85,
        )

        # Then
        assert config.user_id == "alice"
        assert config.target_level == 4
        assert config.confidence_threshold == 0.85

    def test_post_init_validates_default_model_exists(self):
        """Given default model not in models, when creating config, then raises ValueError."""
        # Given
        models = [ModelConfig(name="model1", provider="test")]

        # When/Then
        with pytest.raises(ValueError, match="Default model 'nonexistent' not in models"):
            EmpathyConfig(models=models, default_model="nonexistent")

    def test_post_init_allows_valid_default_model(self):
        """Given default model in models, when creating config, then succeeds."""
        # Given
        models = [ModelConfig(name="model1", provider="test")]

        # When
        config = EmpathyConfig(models=models, default_model="model1")

        # Then
        assert config.default_model == "model1"


class TestEmpathyConfigFromYaml:
    """Tests for EmpathyConfig.from_yaml method."""

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_loads_config_from_valid_yaml_file(self, tmp_path):
        """Given a valid YAML file, when loading, then returns config with values."""
        # Given
        yaml_content = """
user_id: alice
target_level: 4
confidence_threshold: 0.85
"""
        yaml_file = tmp_path / "config.yml"
        yaml_file.write_text(yaml_content)

        # When
        config = EmpathyConfig.from_yaml(str(yaml_file))

        # Then
        assert config.user_id == "alice"
        assert config.target_level == 4
        assert config.confidence_threshold == 0.85

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_ignores_unknown_fields_in_yaml(self, tmp_path):
        """Given YAML with unknown fields, when loading, then ignores them gracefully."""
        # Given
        yaml_content = """
user_id: alice
target_level: 4
unknown_field: some_value
provider: openai
"""
        yaml_file = tmp_path / "config.yml"
        yaml_file.write_text(yaml_content)

        # When
        config = EmpathyConfig.from_yaml(str(yaml_file))

        # Then
        assert config.user_id == "alice"
        assert config.target_level == 4
        assert not hasattr(config, "unknown_field")

    def test_raises_import_error_when_yaml_not_available(self, tmp_path, monkeypatch):
        """Given PyYAML not installed, when loading YAML, then raises ImportError."""
        # Given
        monkeypatch.setattr("empathy_os.config.YAML_AVAILABLE", False)
        yaml_file = tmp_path / "config.yml"
        yaml_file.write_text("user_id: alice")

        # When/Then
        with pytest.raises(ImportError, match="PyYAML is required"):
            EmpathyConfig.from_yaml(str(yaml_file))

    def test_raises_file_not_found_for_missing_yaml(self):
        """Given non-existent file, when loading YAML, then raises FileNotFoundError."""
        # Given
        missing_file = "nonexistent.yml"

        # When/Then
        with pytest.raises(FileNotFoundError):
            EmpathyConfig.from_yaml(missing_file)


class TestEmpathyConfigFromJson:
    """Tests for EmpathyConfig.from_json method."""

    def test_loads_config_from_valid_json_file(self, tmp_path):
        """Given a valid JSON file, when loading, then returns config with values."""
        # Given
        json_content = {
            "user_id": "bob",
            "target_level": 5,
            "confidence_threshold": 0.9,
        }
        json_file = tmp_path / "config.json"
        json_file.write_text(json.dumps(json_content))

        # When
        config = EmpathyConfig.from_json(str(json_file))

        # Then
        assert config.user_id == "bob"
        assert config.target_level == 5
        assert config.confidence_threshold == 0.9

    def test_ignores_unknown_fields_in_json(self, tmp_path):
        """Given JSON with unknown fields, when loading, then ignores them gracefully."""
        # Given
        json_content = {
            "user_id": "bob",
            "target_level": 5,
            "unknown_field": "value",
            "provider": "anthropic",
        }
        json_file = tmp_path / "config.json"
        json_file.write_text(json.dumps(json_content))

        # When
        config = EmpathyConfig.from_json(str(json_file))

        # Then
        assert config.user_id == "bob"
        assert config.target_level == 5
        assert not hasattr(config, "unknown_field")

    def test_raises_file_not_found_for_missing_json(self):
        """Given non-existent file, when loading JSON, then raises FileNotFoundError."""
        # Given
        missing_file = "nonexistent.json"

        # When/Then
        with pytest.raises(FileNotFoundError):
            EmpathyConfig.from_json(missing_file)


class TestEmpathyConfigFromDict:
    """Tests for EmpathyConfig.from_dict method."""

    def test_creates_config_from_dict(self):
        """Given a valid dict, when creating config, then returns config with values."""
        # Given
        data = {
            "user_id": "charlie",
            "target_level": 2,
            "confidence_threshold": 0.65,
        }

        # When
        config = EmpathyConfig.from_dict(data)

        # Then
        assert config.user_id == "charlie"
        assert config.target_level == 2
        assert config.confidence_threshold == 0.65

    def test_ignores_unknown_fields_in_dict(self):
        """Given dict with unknown fields, when creating config, then ignores them."""
        # Given
        data = {
            "user_id": "charlie",
            "unknown_field": "value",
            "another_unknown": 123,
        }

        # When
        config = EmpathyConfig.from_dict(data)

        # Then
        assert config.user_id == "charlie"
        assert not hasattr(config, "unknown_field")

    def test_handles_model_config_objects_in_dict(self):
        """Given dict with models, when creating config, then converts to ModelConfig objects."""
        # Given
        data = {
            "user_id": "dave",
            "models": [{"name": "model1", "provider": "test"}],
            "default_model": "model1",
        }

        # When
        config = EmpathyConfig.from_dict(data)

        # Then
        assert len(config.models) == 1
        assert config.models[0].name == "model1"
        assert config.default_model == "model1"


class TestEmpathyConfigFromEnv:
    """Tests for EmpathyConfig.from_env method."""

    def test_loads_string_fields_from_environment(self, monkeypatch):
        """Given env vars for string fields, when loading, then returns config with values."""
        # Given
        monkeypatch.setenv("EMPATHY_USER_ID", "env_user")
        monkeypatch.setenv("EMPATHY_PERSISTENCE_BACKEND", "json")

        # When
        config = EmpathyConfig.from_env()

        # Then
        assert config.user_id == "env_user"
        assert config.persistence_backend == "json"

    def test_loads_integer_fields_from_environment(self, monkeypatch):
        """Given env vars for integer fields, when loading, then converts to int."""
        # Given
        monkeypatch.setenv("EMPATHY_TARGET_LEVEL", "4")

        # When
        config = EmpathyConfig.from_env()

        # Then
        assert config.target_level == 4
        assert isinstance(config.target_level, int)

    def test_loads_float_fields_from_environment(self, monkeypatch):
        """Given env vars for float fields, when loading, then converts to float."""
        # Given
        monkeypatch.setenv("EMPATHY_CONFIDENCE_THRESHOLD", "0.88")
        monkeypatch.setenv("EMPATHY_TRUST_BUILDING_RATE", "0.07")

        # When
        config = EmpathyConfig.from_env()

        # Then
        assert config.confidence_threshold == 0.88
        assert config.trust_building_rate == 0.07
        assert isinstance(config.confidence_threshold, float)

    def test_loads_boolean_fields_from_environment(self, monkeypatch):
        """Given env vars for boolean fields, when loading, then converts to bool."""
        # Given
        monkeypatch.setenv("EMPATHY_PERSISTENCE_ENABLED", "true")
        monkeypatch.setenv("EMPATHY_METRICS_ENABLED", "false")
        monkeypatch.setenv("EMPATHY_ASYNC_ENABLED", "1")

        # When
        config = EmpathyConfig.from_env()

        # Then
        assert config.persistence_enabled is True
        assert config.metrics_enabled is False
        assert config.async_enabled is True

    def test_ignores_unknown_environment_variables(self, monkeypatch):
        """Given unknown env vars, when loading, then ignores them gracefully."""
        # Given
        monkeypatch.setenv("EMPATHY_USER_ID", "user")
        monkeypatch.setenv("EMPATHY_UNKNOWN_FIELD", "value")
        monkeypatch.setenv("EMPATHY_MASTER_KEY", "secret")

        # When
        config = EmpathyConfig.from_env()

        # Then
        assert config.user_id == "user"
        assert not hasattr(config, "unknown_field")
        assert not hasattr(config, "master_key")

    def test_uses_custom_prefix_for_environment_variables(self, monkeypatch):
        """Given custom prefix, when loading from env, then uses custom prefix."""
        # Given
        monkeypatch.setenv("CUSTOM_USER_ID", "custom_user")

        # When
        config = EmpathyConfig.from_env(prefix="CUSTOM_")

        # Then
        assert config.user_id == "custom_user"


class TestEmpathyConfigFromFile:
    """Tests for EmpathyConfig.from_file method."""

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_loads_from_explicit_yaml_file(self, tmp_path):
        """Given explicit YAML filepath, when loading, then returns config from file."""
        # Given
        yaml_content = "user_id: explicit_user\ntarget_level: 4"
        yaml_file = tmp_path / "custom.yml"
        yaml_file.write_text(yaml_content)

        # When
        config = EmpathyConfig.from_file(str(yaml_file))

        # Then
        assert config.user_id == "explicit_user"
        assert config.target_level == 4

    def test_loads_from_explicit_json_file(self, tmp_path):
        """Given explicit JSON filepath, when loading, then returns config from file."""
        # Given
        json_content = {"user_id": "json_user", "target_level": 5}
        json_file = tmp_path / "custom.json"
        json_file.write_text(json.dumps(json_content))

        # When
        config = EmpathyConfig.from_file(str(json_file))

        # Then
        assert config.user_id == "json_user"
        assert config.target_level == 5

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_auto_detects_empathy_yml(self, tmp_path, monkeypatch):
        """Given .empathy.yml exists, when auto-detecting, then loads from it."""
        # Given
        monkeypatch.chdir(tmp_path)
        yaml_content = "user_id: auto_user"
        yaml_file = tmp_path / ".empathy.yml"
        yaml_file.write_text(yaml_content)

        # When
        config = EmpathyConfig.from_file()

        # Then
        assert config.user_id == "auto_user"

    def test_returns_defaults_when_no_file_found(self, tmp_path, monkeypatch):
        """Given no config file exists, when loading, then returns default config."""
        # Given
        monkeypatch.chdir(tmp_path)

        # When
        config = EmpathyConfig.from_file()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3


class TestEmpathyConfigToYaml:
    """Tests for EmpathyConfig.to_yaml method."""

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_saves_config_to_yaml_file(self, tmp_path):
        """Given a config, when saving to YAML, then writes file successfully."""
        # Given
        config = EmpathyConfig(user_id="save_user", target_level=4)
        output_file = tmp_path / "output.yml"

        # When
        config.to_yaml(str(output_file))

        # Then
        assert output_file.exists()
        import yaml
        with open(output_file) as f:
            data = yaml.safe_load(f)
        assert data["user_id"] == "save_user"
        assert data["target_level"] == 4

    def test_raises_import_error_when_yaml_not_available(self, tmp_path, monkeypatch):
        """Given PyYAML not installed, when saving to YAML, then raises ImportError."""
        # Given
        monkeypatch.setattr("empathy_os.config.YAML_AVAILABLE", False)
        config = EmpathyConfig()
        output_file = tmp_path / "output.yml"

        # When/Then
        with pytest.raises(ImportError, match="PyYAML is required"):
            config.to_yaml(str(output_file))


class TestEmpathyConfigToJson:
    """Tests for EmpathyConfig.to_json method."""

    def test_saves_config_to_json_file(self, tmp_path):
        """Given a config, when saving to JSON, then writes file successfully."""
        # Given
        config = EmpathyConfig(user_id="json_save", target_level=5)
        output_file = tmp_path / "output.json"

        # When
        config.to_json(str(output_file))

        # Then
        assert output_file.exists()
        with open(output_file) as f:
            data = json.load(f)
        assert data["user_id"] == "json_save"
        assert data["target_level"] == 5

    def test_saves_with_custom_indentation(self, tmp_path):
        """Given custom indent, when saving to JSON, then uses custom indent."""
        # Given
        config = EmpathyConfig(user_id="indent_test")
        output_file = tmp_path / "output.json"

        # When
        config.to_json(str(output_file), indent=4)

        # Then
        content = output_file.read_text()
        assert "    " in content  # 4-space indentation


class TestEmpathyConfigToDict:
    """Tests for EmpathyConfig.to_dict method."""

    def test_converts_config_to_dictionary(self):
        """Given a config, when converting to dict, then returns dict with all fields."""
        # Given
        config = EmpathyConfig(user_id="dict_user", target_level=3)

        # When
        result = config.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["user_id"] == "dict_user"
        assert result["target_level"] == 3
        assert "confidence_threshold" in result


class TestEmpathyConfigUpdate:
    """Tests for EmpathyConfig.update method."""

    def test_updates_existing_fields(self):
        """Given field updates, when updating config, then changes field values."""
        # Given
        config = EmpathyConfig(user_id="original")

        # When
        config.update(user_id="updated", target_level=5)

        # Then
        assert config.user_id == "updated"
        assert config.target_level == 5

    def test_ignores_nonexistent_fields(self):
        """Given nonexistent field, when updating, then ignores it silently."""
        # Given
        config = EmpathyConfig()

        # When
        config.update(nonexistent_field="value")

        # Then
        assert not hasattr(config, "nonexistent_field")


class TestEmpathyConfigMerge:
    """Tests for EmpathyConfig.merge method."""

    def test_merges_configs_with_other_precedence(self):
        """Given two configs, when merging, then other takes precedence."""
        # Given
        base = EmpathyConfig(user_id="base", target_level=3)
        other = EmpathyConfig(target_level=5, confidence_threshold=0.9)

        # When
        merged = base.merge(other)

        # Then
        assert merged.user_id == "base"  # base value (other is default)
        assert merged.target_level == 5  # other value
        assert merged.confidence_threshold == 0.9  # other value

    def test_merge_only_changes_non_default_values(self):
        """Given other with default values, when merging, then keeps base values."""
        # Given
        base = EmpathyConfig(user_id="base", target_level=4)
        other = EmpathyConfig()  # All defaults

        # When
        merged = base.merge(other)

        # Then
        assert merged.user_id == "base"
        assert merged.target_level == 4


class TestEmpathyConfigValidate:
    """Tests for EmpathyConfig.validate method."""

    def test_validates_correct_configuration(self):
        """Given valid config, when validating, then returns True."""
        # Given
        config = EmpathyConfig(
            target_level=3,
            confidence_threshold=0.75,
            pattern_confidence_threshold=0.3,
            persistence_backend="sqlite",
        )

        # When
        result = config.validate()

        # Then
        assert result is True

    def test_rejects_invalid_target_level_too_low(self):
        """Given target_level < 1, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(target_level=0)

        # When/Then
        with pytest.raises(ValueError, match="target_level must be 1-5"):
            config.validate()

    def test_rejects_invalid_target_level_too_high(self):
        """Given target_level > 5, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(target_level=6)

        # When/Then
        with pytest.raises(ValueError, match="target_level must be 1-5"):
            config.validate()

    def test_rejects_invalid_confidence_threshold_too_low(self):
        """Given confidence_threshold < 0, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(confidence_threshold=-0.1)

        # When/Then
        with pytest.raises(ValueError, match="confidence_threshold must be 0.0-1.0"):
            config.validate()

    def test_rejects_invalid_confidence_threshold_too_high(self):
        """Given confidence_threshold > 1, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(confidence_threshold=1.5)

        # When/Then
        with pytest.raises(ValueError, match="confidence_threshold must be 0.0-1.0"):
            config.validate()

    def test_rejects_invalid_pattern_confidence_threshold(self):
        """Given invalid pattern_confidence_threshold, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(pattern_confidence_threshold=1.5)

        # When/Then
        with pytest.raises(ValueError, match="pattern_confidence_threshold must be 0.0-1.0"):
            config.validate()

    def test_rejects_invalid_persistence_backend(self):
        """Given invalid persistence_backend, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(persistence_backend="invalid")

        # When/Then
        with pytest.raises(ValueError, match="persistence_backend must be"):
            config.validate()


class TestEmpathyConfigRepr:
    """Tests for EmpathyConfig.__repr__ method."""

    def test_returns_meaningful_string_representation(self):
        """Given a config, when getting repr, then returns descriptive string."""
        # Given
        config = EmpathyConfig(user_id="test_user", target_level=4)

        # When
        result = repr(config)

        # Then
        assert "EmpathyConfig" in result
        assert "test_user" in result
        assert "4" in result


class TestLoadConfig:
    """Tests for load_config function."""

    def test_loads_default_config_with_no_arguments(self):
        """Given no arguments, when loading config, then returns default config."""
        # Given/When
        config = load_config(filepath=None, use_env=False, defaults=None)

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3

    def test_applies_custom_defaults(self):
        """Given custom defaults, when loading config, then applies them."""
        # Given
        defaults = {"user_id": "custom_default", "target_level": 4}

        # When
        config = load_config(defaults=defaults, use_env=False)

        # Then
        assert config.user_id == "custom_default"
        assert config.target_level == 4

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_loads_from_config_file(self, tmp_path, monkeypatch):
        """Given config file exists, when loading, then loads from file."""
        # Given
        monkeypatch.chdir(tmp_path)
        yaml_content = "user_id: file_user\ntarget_level: 5"
        yaml_file = tmp_path / ".empathy.yml"
        yaml_file.write_text(yaml_content)

        # When
        config = load_config(use_env=False)

        # Then
        assert config.user_id == "file_user"
        assert config.target_level == 5

    def test_overrides_with_environment_variables(self, monkeypatch):
        """Given env vars set, when loading with use_env=True, then env vars take precedence."""
        # Given
        monkeypatch.setenv("EMPATHY_USER_ID", "env_user")
        monkeypatch.setenv("EMPATHY_TARGET_LEVEL", "5")
        defaults = {"user_id": "default_user", "target_level": 3}

        # When
        config = load_config(defaults=defaults, use_env=True)

        # Then
        assert config.user_id == "env_user"
        assert config.target_level == 5

    def test_skips_environment_when_use_env_false(self, monkeypatch):
        """Given use_env=False, when loading, then ignores environment variables."""
        # Given
        monkeypatch.setenv("EMPATHY_USER_ID", "env_user")

        # When
        config = load_config(use_env=False)

        # Then
        assert config.user_id == "default_user"

    def test_validates_final_configuration(self):
        """Given invalid defaults, when loading config, then raises ValueError."""
        # Given
        defaults = {"target_level": 10}  # Invalid

        # When/Then
        with pytest.raises(ValueError, match="target_level must be 1-5"):
            load_config(defaults=defaults, use_env=False)

    def test_handles_file_not_found_gracefully(self):
        """Given nonexistent file, when loading, then falls back to defaults."""
        # Given
        nonexistent_file = "/path/that/does/not/exist.yml"

        # When
        config = load_config(filepath=nonexistent_file, use_env=False)

        # Then
        assert config.user_id == "default_user"

    def test_handles_invalid_env_vars_gracefully(self, monkeypatch):
        """Given invalid env var value, when loading, then falls back gracefully."""
        # Given
        monkeypatch.setenv("EMPATHY_TARGET_LEVEL", "invalid_int")

        # When
        try:
            config = load_config(use_env=True)
            # If we get here, it fell back to defaults
            assert config.target_level == 3
        except ValueError:
            # This is also acceptable - strict validation
            pass

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not installed")
    def test_correct_precedence_order(self, tmp_path, monkeypatch):
        """Given all config sources, when loading, then env > file > defaults > built-in."""
        # Given
        monkeypatch.chdir(tmp_path)

        # Custom defaults
        defaults = {"user_id": "defaults_user", "target_level": 4}

        # File config
        yaml_content = "user_id: file_user\nconfidence_threshold: 0.85"
        yaml_file = tmp_path / ".empathy.yml"
        yaml_file.write_text(yaml_content)

        # Environment variables
        monkeypatch.setenv("EMPATHY_USER_ID", "env_user")

        # When
        config = load_config(defaults=defaults, use_env=True)

        # Then
        assert config.user_id == "env_user"  # From env (highest precedence)
        assert config.target_level == 4  # From defaults
        assert config.confidence_threshold == 0.85  # From file


class TestEmpathyConfigEdgeCases:
    """Tests for edge cases and special scenarios."""

    def test_handles_empty_metadata_dict(self):
        """Given no metadata, when creating config, then initializes empty dict."""
        # Given/When
        config = EmpathyConfig()

        # Then
        assert config.metadata == {}
        assert isinstance(config.metadata, dict)

    def test_handles_custom_metadata(self):
        """Given custom metadata, when creating config, then stores it."""
        # Given
        metadata = {"custom_key": "custom_value", "version": "1.0"}

        # When
        config = EmpathyConfig(metadata=metadata)

        # Then
        assert config.metadata == metadata
        assert config.metadata["custom_key"] == "custom_value"

    def test_handles_none_log_file(self):
        """Given log_file=None, when creating config, then accepts it."""
        # Given/When
        config = EmpathyConfig(log_file=None)

        # Then
        assert config.log_file is None

    def test_handles_none_default_model(self):
        """Given default_model=None, when creating config, then accepts it."""
        # Given/When
        config = EmpathyConfig(default_model=None)

        # Then
        assert config.default_model is None

    def test_boundary_values_for_thresholds(self):
        """Given boundary threshold values, when validating, then accepts them."""
        # Given
        config = EmpathyConfig(
            confidence_threshold=0.0,
            pattern_confidence_threshold=1.0,
        )

        # When
        result = config.validate()

        # Then
        assert result is True

    def test_boundary_values_for_target_level(self):
        """Given boundary target_level values, when validating, then accepts them."""
        # Given
        config_min = EmpathyConfig(target_level=1)
        config_max = EmpathyConfig(target_level=5)

        # When/Then
        assert config_min.validate() is True
        assert config_max.validate() is True
