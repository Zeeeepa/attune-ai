"""Behavioral tests for progress_server.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import asyncio
import json
from typing import Any
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import pytest

from empathy_os.workflows.progress_server import (
    WEBSOCKETS_AVAILABLE,
    ProgressServer,
    ProgressServerConfig,
)


# Fixtures


@pytest.fixture
def server_config() -> ProgressServerConfig:
    """Given a server configuration."""
    return ProgressServerConfig(
        host="localhost",
        port=8766,
        ping_interval=20.0,
        ping_timeout=20.0,
        max_connections=100,
    )


@pytest.fixture
def mock_websockets():
    """Given mocked websockets module."""
    with patch("empathy_os.workflows.progress_server.websockets") as mock_ws:
        mock_ws.serve = AsyncMock()
        yield mock_ws


@pytest.fixture
def mock_server_protocol():
    """Given a mock WebSocket server protocol."""
    mock = AsyncMock()
    mock.close = AsyncMock()
    mock.send = AsyncMock()
    mock.recv = AsyncMock()
    return mock


@pytest.fixture
async def progress_server(server_config):
    """Given an initialized progress server."""
    if not WEBSOCKETS_AVAILABLE:
        pytest.skip("websockets not available")
    
    server = ProgressServer(server_config)
    yield server
    
    # Cleanup
    if server._running:
        await server.stop()


# ProgressServerConfig Tests


class TestProgressServerConfig:
    """Tests for ProgressServerConfig dataclass."""

    def test_default_configuration(self):
        """Given default configuration
        When creating a ProgressServerConfig
        Then it should have expected default values.
        """
        # When
        config = ProgressServerConfig()

        # Then
        assert config.host == "localhost"
        assert config.port == 8766
        assert config.ping_interval == 20.0
        assert config.ping_timeout == 20.0
        assert config.max_connections == 100

    def test_custom_configuration(self):
        """Given custom configuration values
        When creating a ProgressServerConfig
        Then it should use the provided values.
        """
        # When
        config = ProgressServerConfig(
            host="0.0.0.0",
            port=9000,
            ping_interval=30.0,
            ping_timeout=15.0,
            max_connections=50,
        )

        # Then
        assert config.host == "0.0.0.0"
        assert config.port == 9000
        assert config.ping_interval == 30.0
        assert config.ping_timeout == 15.0
        assert config.max_connections == 50


# ProgressServer Initialization Tests


class TestProgressServerInitialization:
    """Tests for ProgressServer initialization."""

    @patch("empathy_os.workflows.progress_server.WEBSOCKETS_AVAILABLE", False)
    def test_init_without_websockets(self):
        """Given websockets is not available
        When initializing ProgressServer
        Then it should raise ImportError.
        """
        # When/Then
        with pytest.raises(ImportError, match="websockets package is required"):
            ProgressServer()

    @pytest.mark.skipif(not WEBSOCKETS_AVAILABLE, reason="websockets not available")
    def test_init_with_default_config(self):
        """Given no configuration
        When initializing ProgressServer
        Then it should create default configuration.
        """
        # When
        server = ProgressServer()

        # Then
        assert isinstance(server.config, ProgressServerConfig)
        assert server.config.host == "localhost"
        assert server.config.port == 8766
        assert server._clients == set()
        assert server._server is None
        assert server._running is False
        assert server._trackers == {}

    @pytest.mark.skipif(not WEBSOCKETS_AVAILABLE, reason="websockets not available")
    def test_init_with_custom_config(self, server_config):
        """Given custom configuration
        When initializing ProgressServer
        Then it should use the provided configuration.
        """
        # When
        server = ProgressServer(server_config)

        # Then
        assert server.config == server_config
        assert server.config.port == 8766


# ProgressServer Start/Stop Tests


class TestProgressServerStartStop:
    """Tests for starting and stopping the progress server."""

    @pytest.mark.asyncio
    async def test_start_server(self, progress_server, mock_websockets):
        """Given a progress server
        When starting the server
        Then it should initialize websocket server.
        """
        # Given
        with patch("empathy_os.workflows.progress_server.websockets", mock_websockets):
            mock_server = AsyncMock()
            mock_websockets.serve.return_value = mock_server

            # When
            await progress_server.start()

            # Then
            assert progress_server._running is True
            assert progress_server._server is not None
            mock_websockets.serve.assert_called_once_with(
                progress_server._handle_connection,
                progress_server.config.host,
                progress_server.config.port,
                ping_interval=progress_server.config.ping_interval,
                ping_timeout=progress_server.config.ping_timeout,
            )

    @pytest.mark.asyncio
    async def test_stop_server_with_no_clients(self, progress_server, mock_websockets):
        """Given a running server with no clients
        When stopping the server
        Then it should close cleanly.
        """
        # Given
        with patch("empathy_os.workflows.progress_server.websockets", mock_websockets):
            mock_server = MagicMock()
            mock_server.close = Mock()
            mock_server.wait_closed = AsyncMock()
            progress_server._server = mock_server
            progress_server._running = True

            # When
            await progress_server.stop()

            # Then
            assert progress_server._running is False
            assert len(progress_server._clients) == 0
            mock_server.close.assert_called_once()

    @pytest.mark.asyncio
    async def test_stop_server_with_clients(self, progress_server, mock_websockets):
        """Given a running server with connected clients
        When stopping the server
        Then it should close all client connections.
        """
        # Given
        with patch("empathy_os.workflows.progress_server.websockets", mock_websockets):
            mock_client1 = AsyncMock()
            mock_client1.close = AsyncMock()
            mock_client2 = AsyncMock()
            mock_client2.close = AsyncMock()
            
            progress_server._clients = {mock_client1, mock_client2}
            
            mock_server = MagicMock()
            mock_server.close = Mock()
            mock_server.wait_closed = AsyncMock()
            progress_server._server = mock_server
            progress_server._running = True

            # When
            await progress_server.stop()

            # Then
            assert progress_server._running is False
            assert len(progress_server._clients) == 0
            mock_client1.close.assert_called_once_with(1001, "Server shutting down")
            mock_client2.close.assert_called_once_with(1001, "Server shutting down")
            mock_server.close.assert_called_once()

    @pytest.mark.asyncio
    async def test_stop_server_client_close_exception(self, progress_server):
        """Given a running server where client close raises exception
        When stopping the server
        Then it should handle exceptions gracefully.
        """
        # Given
        mock_client = AsyncMock()
        mock_client.close = AsyncMock(side_effect=Exception("Connection error"))
        progress_server._clients = {mock_client}
        
        mock_server = MagicMock()
        mock_server.close = Mock()
        mock_server.wait_closed = AsyncMock()
        progress_server._server = mock_server
        progress_server._running = True

        # When
        await progress_server.stop()

        # Then
        assert progress_server._running is False
        assert len(progress_server._clients) == 0


# ProgressServer Connection Handling Tests


class TestProgressServerConnectionHandling:
    """Tests for WebSocket connection handling."""

    @pytest.mark.asyncio
    async def test_handle_connection_registration(self, progress_server, mock_server_protocol):
        """Given a new WebSocket connection
        When handling the connection
        Then it should register the client.
        """
        # Given
        mock_server_protocol.recv.side_effect = asyncio.CancelledError()
        progress_server._running = True

        # When
        with pytest.raises(asyncio.CancelledError):
            await progress_server._handle_connection(mock_server_protocol)

        # Then
        assert mock_server_protocol not in progress_server._clients

    @pytest.mark.asyncio
    async def test_handle_connection_cleanup(self, progress_server, mock_server_protocol):
        """Given an active connection that closes
        When handling the connection
        Then it should remove the client from the set.
        """
        # Given
        progress_server._running = True
        mock_server_protocol.recv.side_effect = asyncio.CancelledError()
        progress_server._clients.add(mock_server_protocol)

        # When
        with pytest.raises(asyncio.CancelledError):
            await progress_server._handle_connection(mock_server_protocol)

        # Then
        assert mock_server_protocol not in progress_server._clients

    @pytest.mark.asyncio
    async def test_handle_connection_exception(self, progress_server, mock_server_protocol):
        """Given a connection that raises an exception
        When handling the connection
        Then it should clean up properly.
        """
        # Given
        progress_server._running = True
        mock_server_protocol.recv.side_effect = Exception("Connection error")

        # When
        with pytest.raises(Exception, match="Connection error"):
            await progress_server._handle_connection(mock_server_protocol)

        # Then
        assert mock_server_protocol not in progress_server._clients


# ProgressServer Broadcasting Tests


class TestProgressServerBroadcasting:
    """Tests for broadcasting progress updates."""

    @pytest.mark.asyncio
    async def test_broadcast_to_no_clients(self, progress_server):
        """Given no connected clients
        When broadcasting a message
        Then it should complete without error.
        """
        # Given
        message = {"type": "progress", "data": {"step": 1}}

        # When/Then (should not raise)
        await progress_server._broadcast(message)

    @pytest.mark.asyncio
    async def test_broadcast_to_multiple_clients(self, progress_server):
        """Given multiple connected clients
        When broadcasting a message
        Then all clients should receive the message.
        """
        # Given
        mock_client1 = AsyncMock()
        mock_client1.send = AsyncMock()
        mock_client2 = AsyncMock()
        mock_client2.send = AsyncMock()
        progress_server._clients = {mock_client1, mock_client2}
        
        message = {"type": "progress", "data": {"step": 1}}

        # When
        await progress_server._broadcast(message)

        # Then
        mock_client1.send.assert_called_once()
        mock_client2.send.assert_called_once()
        
        # Verify JSON serialization
        sent_data1 = mock_client1.send.call_args[0][0]
        sent_data2 = mock_client2.send.call_args[0][0]
        assert json.loads(sent_data1) == message
        assert json.loads(sent_data2) == message

    @pytest.mark.asyncio
    async def test_broadcast_with_client_send_failure(self, progress_server):
        """Given a client that fails to send
        When broadcasting a message
        Then it should remove the failed client and continue.
        """
        # Given
        mock_client1 = AsyncMock()
        mock_client1.send = AsyncMock(side_effect=Exception("Send failed"))
        mock_client2 = AsyncMock()
        mock_client2.send = AsyncMock()
        progress_server._clients = {mock_client1, mock_client2}
        
        message = {"type": "progress", "data": {"step": 1}}

        # When
        await progress_server._broadcast(message)

        # Then
        assert mock_client1 not in progress_server._clients
        assert mock_client2 in progress_server._clients
        mock_client2.send.assert_called_once()


# ProgressServer Tracker Management Tests


class TestProgressServerTrackerManagement:
    """Tests for managing progress trackers."""

    def test_create_tracker(self, progress_server):
        """Given a workflow ID
        When creating a tracker
        Then it should return a new ProgressTracker.
        """
        # Given
        workflow_id = "test-workflow-123"

        # When
        tracker = progress_server.create_tracker(workflow_id)

        # Then
        assert workflow_id in progress_server._trackers
        assert progress_server._trackers[workflow_id] == tracker
        assert tracker.workflow_id == workflow_id

    def test_create_tracker_duplicate_id(self, progress_server):
        """Given an existing workflow ID
        When creating a tracker with the same ID
        Then it should return the existing tracker.
        """
        # Given
        workflow_id = "test-workflow-123"
        tracker1 = progress_server.create_tracker(workflow_id)

        # When
        tracker2 = progress_server.create_tracker(workflow_id)

        # Then
        assert tracker1 is tracker2
        assert len(progress_server._trackers) == 1

    def test_get_tracker_exists(self, progress_server):
        """Given an existing tracker
        When getting the tracker by ID
        Then it should return the tracker.
        """
        # Given
        workflow_id = "test-workflow-123"
        tracker = progress_server.create_tracker(workflow_id)

        # When
        retrieved = progress_server.get_tracker(workflow_id)

        # Then
        assert retrieved == tracker

    def test_get_tracker_not_exists(self, progress_server):
        """Given no tracker for an ID
        When getting the tracker by ID
        Then it should return None.
        """
        # Given
        workflow_id = "nonexistent"

        # When
        retrieved = progress_server.get_tracker(workflow_id)

        # Then
        assert retrieved is None

    def test_remove_tracker(self, progress_server):
        """Given an existing tracker
        When removing the tracker
        Then it should be removed from the trackers dict.
        """
        # Given
        workflow_id = "test-workflow-123"
        progress_server.create_tracker(workflow_id)

        # When
        progress_server.remove_tracker(workflow_id)

        # Then
        assert workflow_id not in progress_server._trackers

    def test_remove_tracker_not_exists(self, progress_server):
        """Given no tracker for an ID
        When removing the tracker
        Then it should not raise an error.
        """
        # Given
        workflow_id = "nonexistent"

        # When/Then (should not raise)
        progress_server.remove_tracker(workflow_id)


# Integration Tests


class TestProgressServerIntegration:
    """Integration tests for ProgressServer."""

    @pytest.mark.asyncio
    async def test_full_lifecycle(self, server_config, mock_websockets):
        """Given a complete server lifecycle
        When starting,