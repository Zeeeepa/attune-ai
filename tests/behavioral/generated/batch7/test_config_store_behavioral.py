"""Behavioral tests for config_store.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.orchestration.config_store import (
    AgentConfiguration,
    ConfigurationStore,
    _validate_file_path,
)
from empathy_os.pattern_library import Pattern


@pytest.fixture
def temp_storage_dir(tmp_path):
    """Provide a temporary directory for configuration storage."""
    storage_dir = tmp_path / "config_store"
    storage_dir.mkdir()
    return storage_dir


@pytest.fixture
def mock_pattern_library():
    """Provide a mock PatternLibrary instance."""
    library = Mock()
    library.get_pattern.return_value = Pattern(
        id="test_pattern",
        name="Test Pattern",
        description="Test pattern description",
        tags=["test"],
        metadata={},
    )
    return library


@pytest.fixture
def sample_agent_config():
    """Provide a sample AgentConfiguration for testing."""
    return AgentConfiguration(
        id="comp_test_001",
        task_pattern="test_pattern",
        agents=[
            {"role": "security_auditor", "tier": "PREMIUM"},
            {"role": "test_analyzer", "tier": "CAPABLE"},
        ],
        strategy="parallel",
        quality_gates={"min_coverage": 80},
        success_rate=0.95,
        avg_quality_score=87.5,
        execution_count=10,
        last_used=datetime(2025, 1, 15, 10, 30, 0),
        created_at=datetime(2025, 1, 1, 0, 0, 0),
        metadata={"source": "test"},
    )


@pytest.fixture
def config_store(temp_storage_dir, mock_pattern_library):
    """Provide a ConfigurationStore instance with temporary storage."""
    return ConfigurationStore(
        storage_path=str(temp_storage_dir / "configs.json"),
        pattern_library=mock_pattern_library,
    )


class TestValidateFilePath:
    """Behavioral tests for _validate_file_path function."""

    def test_given_valid_path_when_validating_then_returns_resolved_path(self):
        """Given a valid file path, when validating, then return resolved Path object."""
        # Given
        path = "/tmp/test_file.json"

        # When
        result = _validate_file_path(path)

        # Then
        assert isinstance(result, Path)
        assert result.is_absolute()

    def test_given_empty_string_when_validating_then_raises_value_error(self):
        """Given an empty string, when validating, then raise ValueError."""
        # Given
        path = ""

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_none_when_validating_then_raises_value_error(self):
        """Given None as path, when validating, then raise ValueError."""
        # Given
        path = None

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_non_string_when_validating_then_raises_value_error(self):
        """Given a non-string path, when validating, then raise ValueError."""
        # Given
        path = 123

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_null_bytes_when_validating_then_raises_value_error(self):
        """Given path with null bytes, when validating, then raise ValueError."""
        # Given
        path = "/tmp/test\x00file.json"

        # When/Then
        with pytest.raises(ValueError, match="path contains null bytes"):
            _validate_file_path(path)

    def test_given_path_outside_allowed_dir_when_validating_then_raises_value_error(
        self, tmp_path
    ):
        """Given path outside allowed directory, when validating, then raise ValueError."""
        # Given
        allowed_dir = str(tmp_path / "allowed")
        Path(allowed_dir).mkdir()
        path = str(tmp_path / "not_allowed" / "file.json")

        # When/Then
        with pytest.raises(ValueError, match="path must be within"):
            _validate_file_path(path, allowed_dir=allowed_dir)

    def test_given_system_path_when_validating_then_raises_value_error(self):
        """Given a dangerous system path, when validating, then raise ValueError."""
        # Given
        path = "/etc/passwd"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    @pytest.mark.parametrize("dangerous_path", ["/etc", "/sys", "/proc", "/dev"])
    def test_given_various_system_paths_when_validating_then_raises_value_error(
        self, dangerous_path
    ):
        """Given various system paths, when validating, then raise ValueError."""
        # Given
        path = f"{dangerous_path}/test.json"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_path_within_allowed_dir_when_validating_then_returns_path(
        self, tmp_path
    ):
        """Given path within allowed directory, when validating, then return valid path."""
        # Given
        allowed_dir = str(tmp_path / "allowed")
        Path(allowed_dir).mkdir()
        path = str(Path(allowed_dir) / "file.json")

        # When
        result = _validate_file_path(path, allowed_dir=allowed_dir)

        # Then
        assert isinstance(result, Path)
        assert str(result).startswith(allowed_dir)


class TestAgentConfiguration:
    """Behavioral tests for AgentConfiguration dataclass."""

    def test_given_required_fields_when_creating_then_instance_created(self):
        """Given required fields, when creating AgentConfiguration, then instance is created."""
        # Given/When
        config = AgentConfiguration(
            id="test_001",
            task_pattern="test_pattern",
            agents=[{"role": "tester"}],
            strategy="sequential",
            quality_gates={},
            success_rate=0.8,
            avg_quality_score=75.0,
            execution_count=5,
            last_used=datetime.now(),
            created_at=datetime.now(),
        )

        # Then
        assert config.id == "test_001"
        assert config.task_pattern == "test_pattern"
        assert len(config.agents) == 1
        assert config.strategy == "sequential"
        assert config.success_rate == 0.8

    def test_given_optional_metadata_when_creating_then_metadata_stored(self):
        """Given optional metadata, when creating AgentConfiguration, then metadata is stored."""
        # Given
        metadata = {"source": "test", "version": "1.0"}

        # When
        config = AgentConfiguration(
            id="test_002",
            task_pattern="test_pattern",
            agents=[],
            strategy="parallel",
            quality_gates={},
            success_rate=0.9,
            avg_quality_score=80.0,
            execution_count=1,
            last_used=datetime.now(),
            created_at=datetime.now(),
            metadata=metadata,
        )

        # Then
        assert config.metadata == metadata
        assert config.metadata["source"] == "test"

    def test_given_config_when_converting_to_dict_then_returns_dict(
        self, sample_agent_config
    ):
        """Given AgentConfiguration, when converting to dict, then returns dictionary."""
        # Given
        config = sample_agent_config

        # When
        from dataclasses import asdict

        config_dict = asdict(config)

        # Then
        assert isinstance(config_dict, dict)
        assert config_dict["id"] == "comp_test_001"
        assert config_dict["task_pattern"] == "test_pattern"


class TestConfigurationStore:
    """Behavioral tests for ConfigurationStore class."""

    def test_given_new_store_when_initializing_then_empty_configurations(
        self, config_store
    ):
        """Given new ConfigurationStore, when initializing, then configurations are empty."""
        # Given/When
        store = config_store

        # Then
        assert len(store.configurations) == 0

    def test_given_existing_file_when_initializing_then_loads_configurations(
        self, temp_storage_dir, mock_pattern_library
    ):
        """Given existing config file, when initializing, then loads configurations."""
        # Given
        storage_path = temp_storage_dir / "configs.json"
        existing_config = {
            "id": "comp_001",
            "task_pattern": "test_pattern",
            "agents": [],
            "strategy": "sequential",
            "quality_gates": {},
            "success_rate": 0.85,
            "avg_quality_score": 80.0,
            "execution_count": 3,
            "last_used": "2025-01-15T10:30:00",
            "created_at": "2025-01-01T00:00:00",
            "metadata": {},
        }
        storage_path.write_text(json.dumps([existing_config]))

        # When
        store = ConfigurationStore(
            storage_path=str(storage_path), pattern_library=mock_pattern_library
        )

        # Then
        assert len(store.configurations) == 1
        assert store.configurations[0].id == "comp_001"

    def test_given_invalid_json_when_initializing_then_starts_empty(
        self, temp_storage_dir, mock_pattern_library, caplog
    ):
        """Given invalid JSON file, when initializing, then starts with empty configurations."""
        # Given
        storage_path = temp_storage_dir / "configs.json"
        storage_path.write_text("invalid json{")

        # When
        with caplog.at_level(logging.ERROR):
            store = ConfigurationStore(
                storage_path=str(storage_path), pattern_library=mock_pattern_library
            )

        # Then
        assert len(store.configurations) == 0
        assert "Failed to load configurations" in caplog.text

    def test_given_nonexistent_file_when_initializing_then_starts_empty(
        self, temp_storage_dir, mock_pattern_library
    ):
        """Given nonexistent file, when initializing, then starts with empty configurations."""
        # Given
        storage_path = temp_storage_dir / "nonexistent.json"

        # When
        store = ConfigurationStore(
            storage_path=str(storage_path), pattern_library=mock_pattern_library
        )

        # Then
        assert len(store.configurations) == 0

    def test_given_config_when_saving_then_persists_to_file(
        self, config_store, sample_agent_config
    ):
        """Given configuration, when saving, then persists to file."""
        # Given
        store = config_store
        config = sample_agent_config

        # When
        store.save_configuration(config)

        # Then
        assert len(store.configurations) == 1
        assert Path(store.storage_path).exists()

        # Verify file content
        with open(store.storage_path, "r") as f:
            saved_data = json.load(f)
        assert len(saved_data) == 1
        assert saved_data[0]["id"] == "comp_test_001"

    def test_given_duplicate_config_when_saving_then_updates_existing(
        self, config_store, sample_agent_config
    ):
        """Given duplicate configuration, when saving, then updates existing entry."""
        # Given
        store = config_store
        config1 = sample_agent_config
        store.save_configuration(config1)

        config2 = AgentConfiguration(
            id="comp_test_001",  # Same ID
            task_pattern="updated_pattern",
            agents=[{"role": "new_role"}],
            strategy="parallel",
            quality_gates={},
            success_rate=0.99,
            avg_quality_score=95.0,
            execution_count=20,
            last_used=datetime.now(),
            created_at=datetime.now(),
        )

        # When
        store.save_configuration(config2)

        # Then
        assert len(store.configurations) == 1
        assert store.configurations[0].task_pattern == "updated_pattern"
        assert store.configurations[0].success_rate == 0.99

    def test_given_write_error_when_saving_then_logs_error(
        self, config_store, sample_agent_config, caplog
    ):
        """Given write error, when saving, then logs error."""
        # Given
        store = config_store
        config = sample_agent_config

        with patch("builtins.open", side_effect=OSError("Write error")):
            with caplog.at_level(logging.ERROR):
                # When
                store.save_configuration(config)

                # Then
                assert "Failed to save configurations" in caplog.text

    def test_given_task_pattern_when_retrieving_then_returns_matching_configs(
        self, config_store
    ):
        """Given task pattern, when retrieving, then returns matching configurations."""
        # Given
        store = config_store
        config1 = AgentConfiguration(
            id="comp_001",
            task_pattern="release_prep",
            agents=[],
            strategy="parallel",
            quality_gates={},
            success_rate=0.9,
            avg_quality_score=85.0,
            execution_count=5,
            last_used=datetime.now(),
            created_at=datetime.now(),
        )
        config2 = AgentConfiguration(
            id="comp_002",
            task_pattern="test_coverage",
            agents=[],
            strategy="sequential",
            quality_gates={},
            success_rate=0.8,
            avg_quality_score=75.0,
            execution_count=3,
            last_used=datetime.now(),
            created_at=datetime.now(),
        )
        store.save_configuration(config1)
        store.save_configuration(config2)

        # When
        results = store.get_configurations_for_pattern("release_prep")

        # Then
        assert len(results) == 1
        assert results[0].id == "comp_001"

    def test_given_task_pattern_when_retrieving_then_sorts_by_success_rate(
        self, config_store
    ):
        """Given task pattern, when retrieving, then sorts by success rate descending."""
        # Given
        store = config_store
        config1 = AgentConfiguration(
            id="comp_001",
            task_pattern="release_prep",
            agents=[],
            strategy="parallel",
            quality_gates={},
            success_rate=0.8,
            avg_quality_score=80.0,
            execution_count=5,
            last_used=datetime.now(),
            created_at=datetime.now(),
        )
        config2 = AgentConfiguration(
            id="comp_002",
            task_pattern="release_prep",
            agents=[],
            strategy="sequential",
            quality_gates={},
            success_rate=0.95,
            avg_quality_score=90