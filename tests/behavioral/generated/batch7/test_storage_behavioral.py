"""Behavioral tests for storage.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import sqlite3
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.socratic.storage import (
    JSONFileStorage,
    SQLiteStorage,
    StorageBackend,
)
from empathy_os.socratic.blueprint import WorkflowBlueprint
from empathy_os.socratic.session import SessionState, SocraticSession
from empathy_os.socratic.success import SuccessEvaluation


# =============================================================================
# FIXTURES
# =============================================================================


@pytest.fixture
def temp_dir(tmp_path):
    """Given a temporary directory for storage."""
    return tmp_path


@pytest.fixture
def json_storage(temp_dir):
    """Given a JSONFileStorage instance."""
    return JSONFileStorage(base_dir=temp_dir)


@pytest.fixture
def sqlite_storage(temp_dir):
    """Given a SQLiteStorage instance."""
    db_path = temp_dir / "test.db"
    return SQLiteStorage(db_path=str(db_path))


@pytest.fixture
def mock_session():
    """Given a mock SocraticSession."""
    session = Mock(spec=SocraticSession)
    session.session_id = "test-session-123"
    session.state = SessionState.INTERVIEWING
    session.domain = "test-domain"
    session.goal_statement = "Test goal"
    session.created_at = datetime(2026, 1, 1, 12, 0, 0)
    session.questions = []
    session.insights = []
    session.generated_blueprint = None
    session.to_dict.return_value = {
        "session_id": "test-session-123",
        "state": "interviewing",
        "domain": "test-domain",
        "goal_statement": "Test goal",
        "created_at": "2026-01-01T12:00:00",
        "questions": [],
        "insights": [],
        "generated_blueprint": None,
    }
    return session


@pytest.fixture
def mock_blueprint():
    """Given a mock WorkflowBlueprint."""
    blueprint = Mock(spec=WorkflowBlueprint)
    blueprint.blueprint_id = "test-blueprint-456"
    blueprint.domain = "test-domain"
    blueprint.name = "Test Blueprint"
    blueprint.description = "Test description"
    blueprint.steps = []
    blueprint.metadata = {}
    blueprint.to_dict.return_value = {
        "blueprint_id": "test-blueprint-456",
        "domain": "test-domain",
        "name": "Test Blueprint",
        "description": "Test description",
        "steps": [],
        "metadata": {},
    }
    return blueprint


@pytest.fixture
def mock_evaluation():
    """Given a mock SuccessEvaluation."""
    evaluation = Mock(spec=SuccessEvaluation)
    evaluation.overall_score = 0.85
    evaluation.dimension_scores = {"clarity": 0.9, "completeness": 0.8}
    evaluation.feedback = "Good workflow"
    evaluation.timestamp = datetime(2026, 1, 1, 13, 0, 0)
    evaluation.to_dict.return_value = {
        "overall_score": 0.85,
        "dimension_scores": {"clarity": 0.9, "completeness": 0.8},
        "feedback": "Good workflow",
        "timestamp": "2026-01-01T13:00:00",
    }
    return evaluation


# =============================================================================
# JSONFILESTORAGE TESTS
# =============================================================================


class TestJSONFileStorageInit:
    """Tests for JSONFileStorage initialization."""

    def test_given_base_dir_when_initialized_then_creates_directories(self, temp_dir):
        """Given a base directory, when JSONFileStorage is initialized, then it creates required subdirectories."""
        # When
        storage = JSONFileStorage(base_dir=temp_dir)

        # Then
        assert (temp_dir / "sessions").exists()
        assert (temp_dir / "blueprints").exists()
        assert (temp_dir / "evaluations").exists()

    def test_given_existing_directories_when_initialized_then_does_not_fail(self, temp_dir):
        """Given existing directories, when JSONFileStorage is initialized, then it does not fail."""
        # Given
        (temp_dir / "sessions").mkdir()
        (temp_dir / "blueprints").mkdir()
        (temp_dir / "evaluations").mkdir()

        # When/Then - should not raise
        storage = JSONFileStorage(base_dir=temp_dir)
        assert storage.base_dir == temp_dir


class TestJSONFileStorageSaveSession:
    """Tests for JSONFileStorage.save_session."""

    def test_given_session_when_saved_then_creates_json_file(self, json_storage, mock_session):
        """Given a session, when saved, then it creates a JSON file."""
        # When
        json_storage.save_session(mock_session)

        # Then
        session_file = json_storage.sessions_dir / f"{mock_session.session_id}.json"
        assert session_file.exists()

    def test_given_session_when_saved_then_file_contains_correct_data(self, json_storage, mock_session):
        """Given a session, when saved, then the file contains correct data."""
        # When
        json_storage.save_session(mock_session)

        # Then
        session_file = json_storage.sessions_dir / f"{mock_session.session_id}.json"
        with open(session_file, "r") as f:
            data = json.load(f)
        assert data["session_id"] == "test-session-123"
        assert data["state"] == "interviewing"

    def test_given_existing_session_when_saved_again_then_overwrites(self, json_storage, mock_session):
        """Given an existing session, when saved again, then it overwrites the file."""
        # Given
        json_storage.save_session(mock_session)
        mock_session.state = SessionState.COMPLETED
        mock_session.to_dict.return_value["state"] = "completed"

        # When
        json_storage.save_session(mock_session)

        # Then
        session_file = json_storage.sessions_dir / f"{mock_session.session_id}.json"
        with open(session_file, "r") as f:
            data = json.load(f)
        assert data["state"] == "completed"

    def test_given_session_with_write_error_when_saved_then_logs_error(self, json_storage, mock_session):
        """Given a session with write error, when saved, then it logs error."""
        # Given
        with patch("builtins.open", side_effect=IOError("Write error")):
            with patch("empathy_os.socratic.storage.logger") as mock_logger:
                # When/Then
                with pytest.raises(IOError):
                    json_storage.save_session(mock_session)


class TestJSONFileStorageLoadSession:
    """Tests for JSONFileStorage.load_session."""

    def test_given_saved_session_when_loaded_then_returns_session(self, json_storage, mock_session):
        """Given a saved session, when loaded, then it returns the session."""
        # Given
        json_storage.save_session(mock_session)

        # When
        with patch("empathy_os.socratic.storage.SocraticSession") as MockSession:
            MockSession.from_dict.return_value = mock_session
            loaded = json_storage.load_session("test-session-123")

        # Then
        assert loaded is not None
        MockSession.from_dict.assert_called_once()

    def test_given_nonexistent_session_when_loaded_then_returns_none(self, json_storage):
        """Given a nonexistent session, when loaded, then it returns None."""
        # When
        loaded = json_storage.load_session("nonexistent-id")

        # Then
        assert loaded is None

    def test_given_corrupted_json_when_loaded_then_returns_none(self, json_storage):
        """Given a corrupted JSON file, when loaded, then it returns None."""
        # Given
        session_file = json_storage.sessions_dir / "corrupted.json"
        session_file.write_text("not valid json {{{")

        # When
        with patch("empathy_os.socratic.storage.logger") as mock_logger:
            loaded = json_storage.load_session("corrupted")

        # Then
        assert loaded is None
        mock_logger.error.assert_called_once()


class TestJSONFileStorageListSessions:
    """Tests for JSONFileStorage.list_sessions."""

    def test_given_no_sessions_when_listed_then_returns_empty_list(self, json_storage):
        """Given no sessions, when listed, then it returns an empty list."""
        # When
        sessions = json_storage.list_sessions()

        # Then
        assert sessions == []

    def test_given_multiple_sessions_when_listed_then_returns_all(self, json_storage):
        """Given multiple sessions, when listed, then it returns all."""
        # Given
        session1_file = json_storage.sessions_dir / "session1.json"
        session2_file = json_storage.sessions_dir / "session2.json"
        session1_file.write_text(json.dumps({"session_id": "session1", "state": "interviewing"}))
        session2_file.write_text(json.dumps({"session_id": "session2", "state": "completed"}))

        # When
        sessions = json_storage.list_sessions()

        # Then
        assert len(sessions) == 2
        session_ids = {s["session_id"] for s in sessions}
        assert session_ids == {"session1", "session2"}

    def test_given_state_filter_when_listed_then_filters_by_state(self, json_storage):
        """Given a state filter, when listed, then it filters sessions by state."""
        # Given
        session1_file = json_storage.sessions_dir / "session1.json"
        session2_file = json_storage.sessions_dir / "session2.json"
        session1_file.write_text(json.dumps({"session_id": "session1", "state": "interviewing"}))
        session2_file.write_text(json.dumps({"session_id": "session2", "state": "completed"}))

        # When
        sessions = json_storage.list_sessions(state=SessionState.COMPLETED)

        # Then
        assert len(sessions) == 1
        assert sessions[0]["session_id"] == "session2"

    def test_given_limit_when_listed_then_respects_limit(self, json_storage):
        """Given a limit, when listed, then it respects the limit."""
        # Given
        for i in range(10):
            session_file = json_storage.sessions_dir / f"session{i}.json"
            session_file.write_text(json.dumps({"session_id": f"session{i}", "state": "interviewing"}))

        # When
        sessions = json_storage.list_sessions(limit=5)

        # Then
        assert len(sessions) == 5

    def test_given_corrupted_file_when_listed_then_skips_it(self, json_storage):
        """Given a corrupted file, when listed, then it skips it."""
        # Given
        good_file = json_storage.sessions_dir / "good.json"
        bad_file = json_storage.sessions_dir / "bad.json"
        good_file.write_text(json.dumps({"session_id": "good", "state": "interviewing"}))
        bad_file.write_text("not valid json")

        # When
        with patch("empathy_os.socratic.storage.logger") as mock_logger:
            sessions = json_storage.list_sessions()

        # Then
        assert len(sessions) == 1
        assert sessions[0]["session_id"] == "good"


class TestJSONFileStorageDeleteSession:
    """Tests for JSONFileStorage.delete_session."""

    def test_given_existing_session_when_deleted_then_removes_file(self, json_storage, mock_session):
        """Given an existing session, when deleted, then it removes the file."""
        # Given
        json_storage.save_session(mock_session)
        session_file = json_storage.sessions_dir / f"{mock_session.session_id}.json"
        assert session_file.exists()

        # When
        result = json_storage.delete_session(mock_session.session_id)

        # Then
        assert result is True
        assert not session_file.exists()

    def test_given_nonexistent_session_when_deleted_then_returns_false(self, json_storage):
        """Given a nonexistent session, when deleted, then it returns False."""
        # When
        result = json_storage.delete_session("nonexistent")

        # Then
        assert result is False


class TestJSONFileStorageSaveBlueprint:
    """Tests for JSONFileStorage.save_blueprint."""

    def test_given_blueprint_when_saved_then_creates_json_file(self, json_storage, mock_blueprint):
        """Given a blueprint, when saved, then it creates a JSON file."""
        # When
        json_storage.save_blueprint(mock_blueprint)

        # Then
        blueprint_file = json_storage.blueprints_dir / f"{mock_blueprint.blueprint_id}.json"
        assert blueprint_file.exists()

    def test_given_blueprint_when_saved_then_file_contains_correct_data(self, json_storage, mock_blueprint):
        """Given a blueprint, when saved, then the file contains correct data."""
        # When
        json_storage.save_blueprint(mock_blueprint)

        # Then
        blueprint_file = json_storage.blueprints_dir / f"{mock_blueprint.blueprint_id}.json"
        with open(blueprint_file, "r") as f:
            data = json.load(f)
        assert data["blueprint_id"] == "test-blueprint-456"
        assert data["domain"] == "test-domain"


class TestJSONFileStorageLoadBlueprint:
    """Tests for JSONFileStorage.load_blueprint."""

    def test_given_saved_blueprint_when_loaded_then_returns_blueprint(self, json_storage, mock_blueprint):
        """Given a saved blueprint, when loaded, then it returns the blueprint."""
        # Given
        json_storage.save_blueprint(mock_blueprint)

        # When
        with patch("empathy_os.socratic.storage.WorkflowBlueprint") as MockBlueprint:
            MockBlueprint.from_dict.return_value = mock_blueprint
            loaded = json_storage.load_blueprint("test-blueprint-456")

        # Then
        assert loaded is not None
        MockBlueprint.from_dict.assert_called_once()

    def test_given_nonexistent_blueprint_when_loaded_then_returns_none(self, json_storage):
        """Given a nonexistent blueprint, when loaded, then it returns None."""
        # When
        loaded = json_storage.load_blueprint("nonexistent")

        # Then
        assert loaded is None


class TestJSONFileStorageListBlueprints:
    """Tests for JSONFileStorage.list_blueprints."""

    def test_given_no_blueprints_when_listed_then_returns_empty_list(self, json_storage):
        """Given no blueprints, when listed, then it returns an empty list."""
        # When
        blueprints = json_storage.list_blueprints()

        #