"""Behavioral tests for tier_recommender.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.tier_recommender import TierRecommendationResult, TierRecommender


@pytest.fixture
def temp_patterns_dir(tmp_path):
    """Create a temporary patterns directory with test data."""
    patterns_dir = tmp_path / "patterns"
    patterns_dir.mkdir()
    return patterns_dir


@pytest.fixture
def sample_enhanced_pattern():
    """Sample enhanced pattern with tier progression data."""
    return {
        "bug_type": "import_error",
        "tier_progression": {
            "final_tier": "CAPABLE",
            "attempts": [
                {"tier": "CHEAP", "success": False, "cost": 0.01},
                {"tier": "CAPABLE", "success": True, "cost": 0.15},
            ],
            "total_cost": 0.16,
        },
        "files_affected": ["tests/integration/test_foo.py"],
        "keywords": ["import", "error", "test"],
    }


@pytest.fixture
def sample_legacy_pattern():
    """Sample legacy pattern without tier progression."""
    return {
        "bug_type": "syntax_error",
        "files": ["src/main.py"],
        "description": "syntax error in main file",
    }


@pytest.fixture
def multiple_patterns(temp_patterns_dir, sample_enhanced_pattern):
    """Create multiple pattern files in the temp directory."""
    # Pattern 1: import error
    pattern1 = sample_enhanced_pattern
    with open(temp_patterns_dir / "pattern1.json", "w") as f:
        json.dump(pattern1, f)

    # Pattern 2: type error
    pattern2 = {
        "bug_type": "type_error",
        "tier_progression": {
            "final_tier": "PREMIUM",
            "attempts": [
                {"tier": "CHEAP", "success": False, "cost": 0.01},
                {"tier": "CAPABLE", "success": False, "cost": 0.15},
                {"tier": "PREMIUM", "success": True, "cost": 0.50},
            ],
            "total_cost": 0.66,
        },
        "files_affected": ["src/core/types.py"],
        "keywords": ["type", "error", "annotation"],
    }
    with open(temp_patterns_dir / "pattern2.json", "w") as f:
        json.dump(pattern2, f)

    # Pattern 3: cheap success
    pattern3 = {
        "bug_type": "formatting",
        "tier_progression": {
            "final_tier": "CHEAP",
            "attempts": [{"tier": "CHEAP", "success": True, "cost": 0.01}],
            "total_cost": 0.01,
        },
        "files_affected": ["src/utils.py"],
        "keywords": ["format", "whitespace"],
    }
    with open(temp_patterns_dir / "pattern3.json", "w") as f:
        json.dump(pattern3, f)

    return temp_patterns_dir


class TestTierRecommendationResult:
    """Behavioral tests for TierRecommendationResult dataclass."""

    def test_given_valid_data_when_creating_result_then_all_fields_set(self):
        """Given valid recommendation data, when creating result, then all fields are set correctly."""
        # Given
        tier = "CAPABLE"
        confidence = 0.85
        reasoning = "Based on historical patterns"
        expected_cost = 0.15
        expected_attempts = 1.5
        similar_patterns_count = 10

        # When
        result = TierRecommendationResult(
            tier=tier,
            confidence=confidence,
            reasoning=reasoning,
            expected_cost=expected_cost,
            expected_attempts=expected_attempts,
            similar_patterns_count=similar_patterns_count,
        )

        # Then
        assert result.tier == tier
        assert result.confidence == confidence
        assert result.reasoning == reasoning
        assert result.expected_cost == expected_cost
        assert result.expected_attempts == expected_attempts
        assert result.similar_patterns_count == similar_patterns_count
        assert result.fallback_used is False

    def test_given_fallback_flag_when_creating_result_then_fallback_used_set(self):
        """Given fallback flag, when creating result, then fallback_used is set correctly."""
        # Given / When
        result = TierRecommendationResult(
            tier="CHEAP",
            confidence=0.5,
            reasoning="Default",
            expected_cost=0.01,
            expected_attempts=1.0,
            similar_patterns_count=0,
            fallback_used=True,
        )

        # Then
        assert result.fallback_used is True


class TestTierRecommenderInit:
    """Behavioral tests for TierRecommender initialization."""

    def test_given_no_args_when_initializing_then_uses_default_patterns_dir(self):
        """Given no arguments, when initializing recommender, then uses default patterns directory."""
        # Given / When
        recommender = TierRecommender()

        # Then
        expected_dir = Path(__file__).parent.parent.parent / "patterns" / "debugging"
        assert recommender.patterns_dir == expected_dir
        assert recommender.confidence_threshold == 0.7

    def test_given_custom_patterns_dir_when_initializing_then_uses_custom_dir(
        self, temp_patterns_dir
    ):
        """Given custom patterns directory, when initializing, then uses custom directory."""
        # Given / When
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)

        # Then
        assert recommender.patterns_dir == temp_patterns_dir

    def test_given_custom_threshold_when_initializing_then_uses_custom_threshold(
        self, temp_patterns_dir
    ):
        """Given custom confidence threshold, when initializing, then uses custom threshold."""
        # Given
        threshold = 0.85

        # When
        recommender = TierRecommender(
            patterns_dir=temp_patterns_dir, confidence_threshold=threshold
        )

        # Then
        assert recommender.confidence_threshold == threshold

    def test_given_threshold_below_zero_when_initializing_then_raises_value_error(
        self, temp_patterns_dir
    ):
        """Given threshold below 0.0, when initializing, then raises ValueError."""
        # Given
        invalid_threshold = -0.1

        # When / Then
        with pytest.raises(ValueError, match="confidence_threshold must be between 0.0 and 1.0"):
            TierRecommender(patterns_dir=temp_patterns_dir, confidence_threshold=invalid_threshold)

    def test_given_threshold_above_one_when_initializing_then_raises_value_error(
        self, temp_patterns_dir
    ):
        """Given threshold above 1.0, when initializing, then raises ValueError."""
        # Given
        invalid_threshold = 1.5

        # When / Then
        with pytest.raises(ValueError, match="confidence_threshold must be between 0.0 and 1.0"):
            TierRecommender(patterns_dir=temp_patterns_dir, confidence_threshold=invalid_threshold)

    def test_given_nonexistent_dir_when_initializing_then_loads_empty_patterns(self):
        """Given nonexistent patterns directory, when initializing, then loads empty patterns."""
        # Given
        nonexistent_dir = Path("/nonexistent/path/patterns")

        # When
        recommender = TierRecommender(patterns_dir=nonexistent_dir)

        # Then
        assert recommender.patterns == []


class TestTierRecommenderLoadPatterns:
    """Behavioral tests for pattern loading functionality."""

    def test_given_enhanced_pattern_file_when_loading_then_pattern_loaded(
        self, temp_patterns_dir, sample_enhanced_pattern
    ):
        """Given enhanced pattern file, when loading patterns, then pattern is loaded."""
        # Given
        pattern_file = temp_patterns_dir / "pattern1.json"
        with open(pattern_file, "w") as f:
            json.dump(sample_enhanced_pattern, f)

        # When
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)

        # Then
        assert len(recommender.patterns) == 1
        assert recommender.patterns[0]["bug_type"] == "import_error"

    def test_given_legacy_pattern_file_when_loading_then_pattern_skipped(
        self, temp_patterns_dir, sample_legacy_pattern
    ):
        """Given legacy pattern file without tier_progression, when loading, then pattern is skipped."""
        # Given
        pattern_file = temp_patterns_dir / "legacy.json"
        with open(pattern_file, "w") as f:
            json.dump(sample_legacy_pattern, f)

        # When
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)

        # Then
        assert len(recommender.patterns) == 0

    def test_given_invalid_json_when_loading_then_file_skipped(self, temp_patterns_dir):
        """Given invalid JSON file, when loading patterns, then file is skipped silently."""
        # Given
        pattern_file = temp_patterns_dir / "invalid.json"
        with open(pattern_file, "w") as f:
            f.write("{ invalid json }")

        # When
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)

        # Then
        assert len(recommender.patterns) == 0

    def test_given_list_pattern_when_loading_then_pattern_skipped(self, temp_patterns_dir):
        """Given pattern as list instead of dict, when loading, then pattern is skipped."""
        # Given
        pattern_file = temp_patterns_dir / "list_pattern.json"
        with open(pattern_file, "w") as f:
            json.dump([{"bug_type": "test"}], f)

        # When
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)

        # Then
        assert len(recommender.patterns) == 0

    def test_given_multiple_pattern_files_when_loading_then_all_valid_loaded(
        self, multiple_patterns
    ):
        """Given multiple pattern files, when loading, then all valid patterns are loaded."""
        # Given / When
        recommender = TierRecommender(patterns_dir=multiple_patterns)

        # Then
        assert len(recommender.patterns) == 3

    @patch("empathy_os.tier_recommender._validate_file_path")
    def test_given_file_validation_error_when_loading_then_file_skipped(
        self, mock_validate, temp_patterns_dir, sample_enhanced_pattern
    ):
        """Given file validation error, when loading patterns, then file is skipped."""
        # Given
        pattern_file = temp_patterns_dir / "pattern.json"
        with open(pattern_file, "w") as f:
            json.dump(sample_enhanced_pattern, f)

        mock_validate.side_effect = ValueError("Invalid path")

        # When
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)

        # Then
        assert len(recommender.patterns) == 0


class TestTierRecommenderBuildIndexes:
    """Behavioral tests for index building functionality."""

    def test_given_patterns_loaded_when_building_indexes_then_indexes_created(
        self, multiple_patterns
    ):
        """Given patterns loaded, when building indexes, then indexes are created correctly."""
        # Given / When
        recommender = TierRecommender(patterns_dir=multiple_patterns)

        # Then
        assert hasattr(recommender, "patterns")
        assert len(recommender.patterns) > 0


class TestTierRecommenderRecommend:
    """Behavioral tests for tier recommendation functionality."""

    def test_given_matching_bug_description_when_recommending_then_returns_appropriate_tier(
        self, multiple_patterns
    ):
        """Given matching bug description, when recommending tier, then returns appropriate tier."""
        # Given
        recommender = TierRecommender(patterns_dir=multiple_patterns)
        bug_description = "import error in integration test"

        # When
        result = recommender.recommend(bug_description=bug_description)

        # Then
        assert result.tier in ["CHEAP", "CAPABLE", "PREMIUM"]
        assert 0.0 <= result.confidence <= 1.0
        assert result.expected_cost >= 0
        assert result.expected_attempts >= 0

    def test_given_matching_files_when_recommending_then_returns_appropriate_tier(
        self, multiple_patterns
    ):
        """Given matching files affected, when recommending tier, then returns appropriate tier."""
        # Given
        recommender = TierRecommender(patterns_dir=multiple_patterns)
        files_affected = ["tests/integration/test_foo.py"]

        # When
        result = recommender.recommend(files_affected=files_affected)

        # Then
        assert result.tier in ["CHEAP", "CAPABLE", "PREMIUM"]
        assert result.similar_patterns_count > 0

    def test_given_no_matching_patterns_when_recommending_then_returns_default(
        self, temp_patterns_dir
    ):
        """Given no matching patterns, when recommending tier, then returns default tier."""
        # Given
        recommender = TierRecommender(patterns_dir=temp_patterns_dir)
        bug_description = "completely unique error never seen before"

        # When
        result = recommender.recommend(bug_description=bug_description)

        # Then
        assert result.tier == "CHEAP"
        assert result.fallback_used is True
        assert result.similar_patterns_count == 0

    def test_given_empty_inputs_when_recommending_then_returns_default(self, multiple_patterns):
        """Given empty inputs, when recommending tier, then returns default tier."""
        # Given
        recommender = TierRecommender(patterns_dir=multiple_patterns)

        # When
        result = recommender.recommend(bug_description="", files_affected=[])

        # Then
        assert result.tier == "CHEAP"
        assert result.fallback_used is True

    def test_given_none_inputs_when_recommending_then_returns_default(self, multiple_patterns):
        """Given None inputs, when recommending tier, then returns default tier."""
        # Given
        recommender = TierRecommender(patterns_dir=multiple_patterns)

        # When
        result = recommender.recommend(bug_description=None, files_affected=None)

        # Then
        assert result.tier == "CHEAP"
        assert result.fallback_used is True

    def test_given_complex_pattern_when_recommending_then_returns_high_confidence(
        self, multiple_patterns
    ):
        """Given complex matching pattern, when recommending tier, then returns high confidence."""
        # Given
        recommender = TierRecommender(patterns_dir=multiple_patterns)
        bug_description = "import error in integration test with module"
        files_affected = ["tests/integration/test_foo.py"]

        # When
        result = recommender.recommend(
            bug_description=bug_description, files_affected=files_affected
        )

        # Then
        assert result.confidence > 0.0
        assert result.reasoning != ""

    def test_given_formatting_issue_when_recommending_then_suggests_cheap_tier(
        self, multiple_patterns
    ):
        """Given formatting issue, when recommending tier, then suggests CHEAP tier."""
        # Given
        recommender =