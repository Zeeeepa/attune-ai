"""Behavioral tests for cli.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import csv
import json
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.telemetry.cli import (
    _validate_file_path,
    cmd_telemetry_export,
    cmd_telemetry_reset,
    cmd_telemetry_show,
    cmd_telemetry_stats,
)


class TestValidateFilePath:
    """Tests for _validate_file_path function."""

    def test_given_valid_path_when_validate_then_returns_resolved_path(self, tmp_path):
        """Given a valid file path, when validating, then returns resolved Path object."""
        # Given
        test_file = tmp_path / "test.txt"
        
        # When
        result = _validate_file_path(str(test_file))
        
        # Then
        assert isinstance(result, Path)
        assert result.is_absolute()

    def test_given_empty_string_when_validate_then_raises_value_error(self):
        """Given an empty string path, when validating, then raises ValueError."""
        # Given
        path = ""
        
        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_none_when_validate_then_raises_value_error(self):
        """Given None as path, when validating, then raises ValueError."""
        # Given
        path = None
        
        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_null_byte_in_path_when_validate_then_raises_value_error(self):
        """Given path with null byte, when validating, then raises ValueError."""
        # Given
        path = "/tmp/test\x00.txt"
        
        # When/Then
        with pytest.raises(ValueError, match="path contains null bytes"):
            _validate_file_path(path)

    def test_given_path_outside_allowed_dir_when_validate_then_raises_value_error(self, tmp_path):
        """Given path outside allowed directory, when validating, then raises ValueError."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        path = tmp_path / "outside.txt"
        
        # When/Then
        with pytest.raises(ValueError, match="path must be within"):
            _validate_file_path(str(path), str(allowed_dir))

    def test_given_path_inside_allowed_dir_when_validate_then_returns_path(self, tmp_path):
        """Given path inside allowed directory, when validating, then returns Path object."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        path = allowed_dir / "test.txt"
        
        # When
        result = _validate_file_path(str(path), str(allowed_dir))
        
        # Then
        assert isinstance(result, Path)
        assert str(result).startswith(str(allowed_dir.resolve()))

    def test_given_system_path_etc_when_validate_then_raises_value_error(self):
        """Given path starting with /etc, when validating, then raises ValueError."""
        # Given
        path = "/etc/test.txt"
        
        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_system_path_sys_when_validate_then_raises_value_error(self):
        """Given path starting with /sys, when validating, then raises ValueError."""
        # Given
        path = "/sys/test.txt"
        
        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_system_path_proc_when_validate_then_raises_value_error(self):
        """Given path starting with /proc, when validating, then raises ValueError."""
        # Given
        path = "/proc/test.txt"
        
        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_system_path_dev_when_validate_then_raises_value_error(self):
        """Given path starting with /dev, when validating, then raises ValueError."""
        # Given
        path = "/dev/test.txt"
        
        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_invalid_path_when_validate_then_raises_value_error(self):
        """Given invalid path causing OSError, when validating, then raises ValueError."""
        # Given/When/Then
        with patch('pathlib.Path.resolve', side_effect=OSError("Invalid")):
            with pytest.raises(ValueError, match="Invalid path"):
                _validate_file_path("/some/path")


class TestCmdTelemetryShow:
    """Tests for cmd_telemetry_show function."""

    @pytest.fixture
    def mock_tracker(self):
        """Fixture providing mocked UsageTracker."""
        with patch('empathy_os.telemetry.cli.UsageTracker') as mock:
            tracker_instance = Mock()
            mock.get_instance.return_value = tracker_instance
            tracker_instance.telemetry_dir = Path("/tmp/telemetry")
            yield tracker_instance

    def test_given_no_entries_when_show_telemetry_then_prints_no_data_message(
        self, mock_tracker, capsys
    ):
        """Given no telemetry entries, when showing telemetry, then prints no data message."""
        # Given
        mock_tracker.get_recent_entries.return_value = []
        args = Mock(limit=20, days=None)
        
        # When
        result = cmd_telemetry_show(args)
        
        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "No telemetry data found" in captured.out

    def test_given_entries_with_no_rich_when_show_telemetry_then_prints_plain_text(
        self, mock_tracker, capsys
    ):
        """Given entries without rich library, when showing telemetry, then prints plain text."""
        # Given
        entries = [
            {
                "timestamp": "2025-01-01T12:00:00",
                "workflow": "test",
                "stage": "start",
                "tier": "tier1",
                "cost": 0.001,
                "input_tokens": 100,
                "output_tokens": 50,
                "cache_hit": True,
                "duration": 1.5,
            }
        ]
        mock_tracker.get_recent_entries.return_value = entries
        args = Mock(limit=20, days=None)
        
        # When
        with patch('empathy_os.telemetry.cli.RICH_AVAILABLE', False):
            result = cmd_telemetry_show(args)
        
        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "test" in captured.out

    @patch('empathy_os.telemetry.cli.RICH_AVAILABLE', True)
    @patch('empathy_os.telemetry.cli.Console')
    @patch('empathy_os.telemetry.cli.Table')
    @patch('empathy_os.telemetry.cli.Panel')
    def test_given_entries_with_rich_when_show_telemetry_then_displays_table(
        self, mock_panel, mock_table_cls, mock_console_cls, mock_tracker
    ):
        """Given entries with rich library, when showing telemetry, then displays rich table."""
        # Given
        entries = [
            {
                "timestamp": "2025-01-01T12:00:00",
                "workflow": "test",
                "stage": "start",
                "tier": "tier1",
                "cost": 0.001,
                "input_tokens": 100,
                "output_tokens": 50,
                "cache_hit": True,
                "duration": 1.5,
            }
        ]
        mock_tracker.get_recent_entries.return_value = entries
        args = Mock(limit=20, days=None)
        mock_table = Mock()
        mock_table_cls.return_value = mock_table
        mock_console = Mock()
        mock_console_cls.return_value = mock_console
        
        # When
        result = cmd_telemetry_show(args)
        
        # Then
        assert result == 0
        mock_table.add_row.assert_called()
        mock_console.print.assert_called()

    def test_given_limit_arg_when_show_telemetry_then_passes_limit_to_tracker(
        self, mock_tracker
    ):
        """Given limit argument, when showing telemetry, then passes limit to tracker."""
        # Given
        mock_tracker.get_recent_entries.return_value = []
        args = Mock(limit=50, days=None)
        
        # When
        cmd_telemetry_show(args)
        
        # Then
        mock_tracker.get_recent_entries.assert_called_once_with(limit=50, days=None)

    def test_given_days_arg_when_show_telemetry_then_passes_days_to_tracker(
        self, mock_tracker
    ):
        """Given days argument, when showing telemetry, then passes days to tracker."""
        # Given
        mock_tracker.get_recent_entries.return_value = []
        args = Mock(limit=20, days=7)
        
        # When
        cmd_telemetry_show(args)
        
        # Then
        mock_tracker.get_recent_entries.assert_called_once_with(limit=20, days=7)


class TestCmdTelemetryStats:
    """Tests for cmd_telemetry_stats function."""

    @pytest.fixture
    def mock_tracker(self):
        """Fixture providing mocked UsageTracker."""
        with patch('empathy_os.telemetry.cli.UsageTracker') as mock:
            tracker_instance = Mock()
            mock.get_instance.return_value = tracker_instance
            yield tracker_instance

    def test_given_no_entries_when_show_stats_then_prints_no_data_message(
        self, mock_tracker, capsys
    ):
        """Given no telemetry entries, when showing stats, then prints no data message."""
        # Given
        mock_tracker.get_recent_entries.return_value = []
        args = Mock(days=None)
        
        # When
        result = cmd_telemetry_stats(args)
        
        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "No telemetry data found" in captured.out

    def test_given_entries_with_no_rich_when_show_stats_then_prints_plain_text(
        self, mock_tracker, capsys
    ):
        """Given entries without rich library, when showing stats, then prints plain text."""
        # Given
        entries = [
            {
                "timestamp": "2025-01-01T12:00:00",
                "workflow": "test",
                "tier": "tier1",
                "cost": 0.001,
                "input_tokens": 100,
                "output_tokens": 50,
                "cache_hit": True,
            },
            {
                "timestamp": "2025-01-01T13:00:00",
                "workflow": "test",
                "tier": "tier2",
                "cost": 0.002,
                "input_tokens": 200,
                "output_tokens": 100,
                "cache_hit": False,
            },
        ]
        mock_tracker.get_recent_entries.return_value = entries
        args = Mock(days=None)
        
        # When
        with patch('empathy_os.telemetry.cli.RICH_AVAILABLE', False):
            result = cmd_telemetry_stats(args)
        
        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "Total Calls: 2" in captured.out
        assert "Total Cost: $0.003" in captured.out

    @patch('empathy_os.telemetry.cli.RICH_AVAILABLE', True)
    @patch('empathy_os.telemetry.cli.Console')
    @patch('empathy_os.telemetry.cli.Panel')
    def test_given_entries_with_rich_when_show_stats_then_displays_panels(
        self, mock_panel_cls, mock_console_cls, mock_tracker
    ):
        """Given entries with rich library, when showing stats, then displays rich panels."""
        # Given
        entries = [
            {
                "timestamp": "2025-01-01T12:00:00",
                "workflow": "test",
                "tier": "tier1",
                "cost": 0.001,
                "input_tokens": 100,
                "output_tokens": 50,
                "cache_hit": True,
            }
        ]
        mock_tracker.get_recent_entries.return_value = entries
        args = Mock(days=None)
        mock_console = Mock()
        mock_console_cls.return_value = mock_console
        
        # When
        result = cmd_telemetry_stats(args)
        
        # Then
        assert result == 0
        mock_console.print.assert_called()

    def test_given_multiple_workflows_when_show_stats_then_aggregates_by_workflow(
        self, mock_tracker, capsys
    ):
        """Given multiple workflows, when showing stats, then aggregates by workflow."""
        # Given
        entries = [
            {
                "timestamp": "2025-01-01T12:00:00",
                "workflow": "workflow1",
                "tier": "tier1",
                "cost": 0.001,
                "input_tokens": 100,
                "output_tokens": 50,
                "cache_hit": True,
            },
            {
                "timestamp": "2025-01-01T13:00:00",
                "workflow": "workflow2",
                "tier": "tier1",
                "cost": 0.002,
                "input_tokens": 200,
                "output_tokens": 100,
                "cache_hit": False,
            },
        ]
        mock_tracker.get_recent_entries.return_value = entries
        args = Mock(days=None)
        
        # When
        with patch('empathy_os.telemetry.cli.RICH_AVAILABLE', False):
            result = cmd_telemetry_stats(args)
        
        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "workflow1" in captured.out
        assert "workflow2" in captured.out


class TestCmdTelemetryExport:
    """Tests for cmd_telemetry_export function."""

    @pytest.fixture
    def mock_tracker(self):
        """Fixture providing mocked UsageTracker."""
        with patch('empathy_os.telemetry.cli.UsageTracker') as mock:
            tracker_instance = Mock()
            mock.get_instance.return_value = tracker_instance
            yield tracker_instance

    def test_given_no_entries_when_export_then_prints_no_data_message(