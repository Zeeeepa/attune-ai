"""Behavioral tests for smart_router.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import AsyncMock, Mock, patch, MagicMock
from typing import Any

from empathy_os.routing.smart_router import (
    RoutingDecision,
    SmartRouter,
)
from empathy_os.routing.classifier import ClassificationResult
from empathy_os.routing.workflow_registry import WorkflowInfo


# Fixtures


@pytest.fixture
def sample_workflows():
    """Given a set of sample workflow information."""
    return [
        WorkflowInfo(
            name="bug_fix",
            description="Fix bugs and issues",
            triggers=["fix", "bug", "error", "issue"],
            chains_to=["test", "commit"],
        ),
        WorkflowInfo(
            name="feature",
            description="Add new features",
            triggers=["feature", "add", "implement"],
            chains_to=["test", "review"],
        ),
        WorkflowInfo(
            name="test",
            description="Write or run tests",
            triggers=["test", "testing"],
            chains_to=["commit"],
        ),
        WorkflowInfo(
            name="commit",
            description="Commit changes",
            triggers=["commit", "save"],
            chains_to=[],
        ),
    ]


@pytest.fixture
def mock_workflow_registry(sample_workflows):
    """Given a mocked workflow registry."""
    with patch("empathy_os.routing.smart_router.WorkflowRegistry") as mock_registry_class:
        mock_registry = Mock()
        mock_registry.list_workflows.return_value = sample_workflows
        mock_registry.get_workflow.side_effect = lambda name: next(
            (w for w in sample_workflows if w.name == name), None
        )
        mock_registry_class.return_value = mock_registry
        yield mock_registry


@pytest.fixture
def mock_classifier():
    """Given a mocked Haiku classifier."""
    with patch("empathy_os.routing.smart_router.HaikuClassifier") as mock_classifier_class:
        mock_instance = Mock()
        mock_classifier_class.return_value = mock_instance
        yield mock_instance


@pytest.fixture
def sample_classification_result():
    """Given a sample classification result."""
    return ClassificationResult(
        primary_workflow="bug_fix",
        secondary_workflows=["test"],
        confidence=0.95,
        reasoning="Request mentions fixing a security issue",
        extracted_context={"file": "auth.py", "issue_type": "security"},
    )


@pytest.fixture
def router(mock_workflow_registry, mock_classifier):
    """Given a configured smart router instance."""
    return SmartRouter(api_key="test-api-key")


# Tests for RoutingDecision


class TestRoutingDecision:
    """Tests for the RoutingDecision dataclass."""

    def test_routing_decision_initialization_with_defaults(self):
        """
        Given no optional parameters
        When creating a RoutingDecision
        Then it should initialize with default values
        """
        # When
        decision = RoutingDecision(primary_workflow="bug_fix")

        # Then
        assert decision.primary_workflow == "bug_fix"
        assert decision.secondary_workflows == []
        assert decision.confidence == 0.0
        assert decision.reasoning == ""
        assert decision.suggested_chain == []
        assert decision.context == {}
        assert decision.classification_method == "llm"
        assert decision.request_summary == ""

    def test_routing_decision_initialization_with_all_params(self):
        """
        Given all parameters specified
        When creating a RoutingDecision
        Then it should initialize with provided values
        """
        # When
        decision = RoutingDecision(
            primary_workflow="feature",
            secondary_workflows=["test", "review"],
            confidence=0.87,
            reasoning="Clear feature request",
            suggested_chain=["feature", "test", "review"],
            context={"file": "main.py"},
            classification_method="keyword",
            request_summary="Add new login feature",
        )

        # Then
        assert decision.primary_workflow == "feature"
        assert decision.secondary_workflows == ["test", "review"]
        assert decision.confidence == 0.87
        assert decision.reasoning == "Clear feature request"
        assert decision.suggested_chain == ["feature", "test", "review"]
        assert decision.context == {"file": "main.py"}
        assert decision.classification_method == "keyword"
        assert decision.request_summary == "Add new login feature"

    def test_routing_decision_mutable_defaults_isolation(self):
        """
        Given multiple RoutingDecision instances
        When created with default values
        Then they should not share mutable default objects
        """
        # When
        decision1 = RoutingDecision(primary_workflow="bug_fix")
        decision2 = RoutingDecision(primary_workflow="feature")

        decision1.secondary_workflows.append("test")
        decision1.context["key"] = "value"

        # Then
        assert len(decision2.secondary_workflows) == 0
        assert "key" not in decision2.context


# Tests for SmartRouter initialization


class TestSmartRouterInitialization:
    """Tests for SmartRouter initialization."""

    def test_smart_router_initialization_with_api_key(self, mock_workflow_registry):
        """
        Given an API key
        When initializing SmartRouter
        Then it should create registry and classifier with the API key
        """
        # Given
        api_key = "test-api-key-123"

        # When
        with patch("empathy_os.routing.smart_router.HaikuClassifier") as mock_classifier_class:
            router = SmartRouter(api_key=api_key)

            # Then
            mock_classifier_class.assert_called_once_with(api_key=api_key)

    def test_smart_router_initialization_without_api_key(self, mock_workflow_registry):
        """
        Given no API key
        When initializing SmartRouter
        Then it should create registry and classifier with None
        """
        # When
        with patch("empathy_os.routing.smart_router.HaikuClassifier") as mock_classifier_class:
            router = SmartRouter()

            # Then
            mock_classifier_class.assert_called_once_with(api_key=None)


# Tests for async route method


class TestSmartRouterRoute:
    """Tests for the async route method."""

    @pytest.mark.asyncio
    async def test_route_successful_classification(
        self, router, mock_classifier, sample_classification_result
    ):
        """
        Given a valid request
        When routing the request
        Then it should return a routing decision with correct workflow
        """
        # Given
        mock_classifier.classify = AsyncMock(return_value=sample_classification_result)
        request = "Fix the security issue in auth.py"

        # When
        decision = await router.route(request)

        # Then
        assert decision.primary_workflow == "bug_fix"
        assert decision.secondary_workflows == ["test"]
        assert decision.confidence == 0.95
        assert decision.reasoning == "Request mentions fixing a security issue"
        assert decision.classification_method == "llm"
        mock_classifier.classify.assert_called_once_with(request=request, context=None)

    @pytest.mark.asyncio
    async def test_route_with_context(self, router, mock_classifier, sample_classification_result):
        """
        Given a request with context
        When routing the request
        Then it should pass context to classifier and merge it in decision
        """
        # Given
        mock_classifier.classify = AsyncMock(return_value=sample_classification_result)
        request = "Fix the bug"
        context = {"project": "empathy_os", "branch": "main"}

        # When
        decision = await router.route(request, context=context)

        # Then
        mock_classifier.classify.assert_called_once_with(request=request, context=context)
        assert decision.context["project"] == "empathy_os"
        assert decision.context["branch"] == "main"
        assert decision.context["file"] == "auth.py"
        assert decision.context["issue_type"] == "security"

    @pytest.mark.asyncio
    async def test_route_builds_suggested_chain(
        self, router, mock_classifier, mock_workflow_registry, sample_workflows
    ):
        """
        Given a classification result
        When routing the request
        Then it should build a suggested workflow chain
        """
        # Given
        classification = ClassificationResult(
            primary_workflow="bug_fix",
            secondary_workflows=[],
            confidence=0.9,
            reasoning="Bug fix needed",
            extracted_context={},
        )
        mock_classifier.classify = AsyncMock(return_value=classification)

        # When
        decision = await router.route("Fix the bug")

        # Then
        assert len(decision.suggested_chain) > 0
        assert "bug_fix" in decision.suggested_chain

    @pytest.mark.asyncio
    async def test_route_with_secondary_workflows(self, router, mock_classifier):
        """
        Given a classification with secondary workflows
        When routing the request
        Then it should include secondary workflows in decision
        """
        # Given
        classification = ClassificationResult(
            primary_workflow="feature",
            secondary_workflows=["test", "review"],
            confidence=0.85,
            reasoning="Feature with testing required",
            extracted_context={},
        )
        mock_classifier.classify = AsyncMock(return_value=classification)

        # When
        decision = await router.route("Add new feature with tests")

        # Then
        assert decision.primary_workflow == "feature"
        assert "test" in decision.secondary_workflows
        assert "review" in decision.secondary_workflows

    @pytest.mark.asyncio
    async def test_route_empty_request(self, router, mock_classifier):
        """
        Given an empty request string
        When routing the request
        Then it should still process and return a decision
        """
        # Given
        classification = ClassificationResult(
            primary_workflow="unknown",
            secondary_workflows=[],
            confidence=0.0,
            reasoning="Empty request",
            extracted_context={},
        )
        mock_classifier.classify = AsyncMock(return_value=classification)

        # When
        decision = await router.route("")

        # Then
        assert decision.primary_workflow == "unknown"
        mock_classifier.classify.assert_called_once()

    @pytest.mark.asyncio
    async def test_route_context_override(self, router, mock_classifier):
        """
        Given context and extracted context with overlapping keys
        When routing the request
        Then extracted context should take precedence
        """
        # Given
        classification = ClassificationResult(
            primary_workflow="bug_fix",
            secondary_workflows=[],
            confidence=0.9,
            reasoning="Bug fix",
            extracted_context={"file": "extracted.py", "new_key": "new_value"},
        )
        mock_classifier.classify = AsyncMock(return_value=classification)
        context = {"file": "original.py", "other_key": "other_value"}

        # When
        decision = await router.route("Fix bug", context=context)

        # Then
        assert decision.context["file"] == "extracted.py"
        assert decision.context["new_key"] == "new_value"
        assert decision.context["other_key"] == "other_value"

    @pytest.mark.asyncio
    async def test_route_classifier_exception(self, router, mock_classifier):
        """
        Given classifier that raises an exception
        When routing the request
        Then the exception should propagate
        """
        # Given
        mock_classifier.classify = AsyncMock(side_effect=Exception("Classifier error"))

        # When/Then
        with pytest.raises(Exception, match="Classifier error"):
            await router.route("Fix the bug")


# Tests for sync route_sync method


class TestSmartRouterRouteSync:
    """Tests for the sync route_sync method."""

    def test_route_sync_with_keyword_matching(self, router, mock_workflow_registry, sample_workflows):
        """
        Given a request with keyword matching
        When using sync routing
        Then it should return a decision based on keywords
        """
        # Given
        request = "Fix the bug in the authentication module"

        # When
        decision = router.route_sync(request)

        # Then
        assert decision.primary_workflow in ["bug_fix", "unknown"]
        assert decision.classification_method == "keyword"

    def test_route_sync_with_context(self, router):
        """
        Given a request with context
        When using sync routing
        Then it should include context in the decision
        """
        # Given
        request = "Add new feature"
        context = {"project": "test_project"}

        # When
        decision = router.route_sync(request, context=context)

        # Then
        assert decision.context["project"] == "test_project"

    def test_route_sync_no_keyword_match(self, router, mock_workflow_registry):
        """
        Given a request with no keyword matches
        When using sync routing
        Then it should return unknown workflow
        """
        # Given
        request = "Some random text without keywords"

        # When
        decision = router.route_sync(request)

        # Then
        assert decision.primary_workflow == "unknown"
        assert decision.confidence < 0.5

    def test_route_sync_empty_request(self, router):
        """
        Given an empty request
        When using sync routing
        Then it should return unknown workflow
        """
        # When
        decision = router.route_sync("")

        # Then
        assert decision.primary_workflow == "unknown"
        assert decision.confidence == 0.0

    def test_route_sync_case_insensitive_matching(self, router, mock_workflow_registry, sample_workflows):
        """
        Given a request with uppercase keywords
        When using sync routing
        Then it should match case-insensitively
        """
        # Given
        request = "FIX the BUG"

        # When
        decision = router.route_sync(request)

        # Then
        assert decision.classification_method == "keyword"


# Tests for internal _build_chain method


class TestSmartRouterBuildChain:
    """Tests for the internal _build_chain method."""

    @pytest.mark.asyncio
    async def test_build_chain_single_workflow(
        self, router, mock_classifier, mock_workflow_registry, sample_workflows
    ):
        """
        Given a workflow that chains to others
        When building a chain
        Then it should include the chained workflows
        """
        # Given
        classification = ClassificationResult(
            primary_workflow="bug_fix",
            secondary_workflows=[],
            confidence=0.9,
            reasoning="Bug fix",
            extracted_context={},
        )
        mock_classifier.classify = AsyncMock(return_value=classification)

        # When
        decision = await router.route("Fix bug")

        # Then
        assert "bug_fix" in decision.suggested_chain

    @pytest.mark.asyncio
    async def test_build_chain_prevents_cycles(
        self, router, mock_classifier, mock_workflow_registry
    ):
        """
        Given workflows that could create cycles
        When building a chain
        Then it should prevent infinite loops
        """
        # Given
        circular_workflows = [
            WorkflowInfo(
                name="workflow_a",
                description="A",
                triggers=["a"],
                chains_to=["workflow_b"],
            ),
            WorkflowInfo(
                name="workflow_b",
                description="B",
                triggers=["b"],
                chains_to=["workflow_a"],
            ),
        ]
        mock_workflow_registry.list_workflows.return_value = circular_workflows
        mock_workflow