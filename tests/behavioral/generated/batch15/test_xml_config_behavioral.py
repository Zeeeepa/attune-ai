"""Behavioral tests for xml_config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import os
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.config.xml_config import (
    AdaptiveConfig,
    MetricsConfig,
    MultilingualConfig,
    OptimizationConfig,
    PromptConfig,
    XMLConfig,
    _validate_file_path,
)


class TestValidateFilePath:
    """Behavioral tests for _validate_file_path function."""

    def test_given_valid_path_when_validated_then_returns_resolved_path(self, tmp_path):
        """Given a valid file path, when validated, then returns resolved Path object."""
        # Given
        test_file = tmp_path / "test.txt"
        test_file.touch()
        path_str = str(test_file)

        # When
        result = _validate_file_path(path_str)

        # Then
        assert isinstance(result, Path)
        assert result == test_file.resolve()

    def test_given_empty_string_when_validated_then_raises_valueerror(self):
        """Given an empty string, when validated, then raises ValueError."""
        # Given
        path_str = ""

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path_str)

    def test_given_none_when_validated_then_raises_valueerror(self):
        """Given None, when validated, then raises ValueError."""
        # Given
        path_str = None

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path_str)

    def test_given_non_string_when_validated_then_raises_valueerror(self):
        """Given a non-string value, when validated, then raises ValueError."""
        # Given
        path_str = 123

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path_str)

    def test_given_path_with_null_byte_when_validated_then_raises_valueerror(self):
        """Given a path with null bytes, when validated, then raises ValueError."""
        # Given
        path_str = "test\x00file.txt"

        # When/Then
        with pytest.raises(ValueError, match="path contains null bytes"):
            _validate_file_path(path_str)

    def test_given_path_outside_allowed_dir_when_validated_then_raises_valueerror(self, tmp_path):
        """Given a path outside allowed directory, when validated, then raises ValueError."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        outside_file = tmp_path / "outside.txt"
        outside_file.touch()

        # When/Then
        with pytest.raises(ValueError, match="path must be within"):
            _validate_file_path(str(outside_file), str(allowed_dir))

    def test_given_path_within_allowed_dir_when_validated_then_returns_path(self, tmp_path):
        """Given a path within allowed directory, when validated, then returns path."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        inside_file = allowed_dir / "inside.txt"
        inside_file.touch()

        # When
        result = _validate_file_path(str(inside_file), str(allowed_dir))

        # Then
        assert result == inside_file.resolve()

    def test_given_etc_path_when_validated_then_raises_valueerror(self):
        """Given a path in /etc, when validated, then raises ValueError."""
        # Given
        path_str = "/etc/passwd"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path_str)

    def test_given_sys_path_when_validated_then_raises_valueerror(self):
        """Given a path in /sys, when validated, then raises ValueError."""
        # Given
        path_str = "/sys/kernel"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path_str)

    def test_given_proc_path_when_validated_then_raises_valueerror(self):
        """Given a path in /proc, when validated, then raises ValueError."""
        # Given
        path_str = "/proc/cpuinfo"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path_str)

    def test_given_dev_path_when_validated_then_raises_valueerror(self):
        """Given a path in /dev, when validated, then raises ValueError."""
        # Given
        path_str = "/dev/null"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path_str)

    def test_given_invalid_path_when_validated_then_raises_valueerror(self):
        """Given an invalid path that causes OSError, when validated, then raises ValueError."""
        # Given/When/Then
        with patch("empathy_os.config.xml_config.Path") as mock_path:
            mock_path.return_value.resolve.side_effect = OSError("Invalid path")
            with pytest.raises(ValueError, match="Invalid path"):
                _validate_file_path("some/path")

    def test_given_path_with_traversal_attempt_when_validated_then_resolves_safely(self, tmp_path):
        """Given a path with traversal attempt, when validated, then resolves safely."""
        # Given
        allowed_dir = tmp_path / "allowed"
        allowed_dir.mkdir()
        traversal_path = str(allowed_dir / ".." / "outside.txt")

        # When/Then
        with pytest.raises(ValueError, match="path must be within"):
            _validate_file_path(traversal_path, str(allowed_dir))


class TestXMLConfig:
    """Behavioral tests for XMLConfig dataclass."""

    def test_given_no_args_when_created_then_has_default_values(self):
        """Given no arguments, when XMLConfig created, then has default values."""
        # Given/When
        config = XMLConfig()

        # Then
        assert config.use_xml_structure is True
        assert config.validate_schemas is False
        assert config.schema_dir == ".empathy/schemas"
        assert config.strict_validation is False

    def test_given_custom_values_when_created_then_has_custom_values(self):
        """Given custom values, when XMLConfig created, then has custom values."""
        # Given
        use_xml = False
        validate = True
        schema_dir = "custom/schemas"
        strict = True

        # When
        config = XMLConfig(
            use_xml_structure=use_xml,
            validate_schemas=validate,
            schema_dir=schema_dir,
            strict_validation=strict,
        )

        # Then
        assert config.use_xml_structure is False
        assert config.validate_schemas is True
        assert config.schema_dir == "custom/schemas"
        assert config.strict_validation is True

    def test_given_xmlconfig_when_converted_to_dict_then_contains_all_fields(self):
        """Given an XMLConfig, when converted to dict, then contains all fields."""
        # Given
        config = XMLConfig()

        # When
        result = asdict(config)

        # Then
        assert "use_xml_structure" in result
        assert "validate_schemas" in result
        assert "schema_dir" in result
        assert "strict_validation" in result


class TestOptimizationConfig:
    """Behavioral tests for OptimizationConfig dataclass."""

    def test_given_no_args_when_created_then_has_default_values(self):
        """Given no arguments, when OptimizationConfig created, then has default values."""
        # Given/When
        config = OptimizationConfig()

        # Then
        assert config.compression_level == "moderate"
        assert config.use_short_tags is True
        assert config.strip_whitespace is True
        assert config.cache_system_prompts is True
        assert config.max_context_tokens == 8000

    def test_given_custom_values_when_created_then_has_custom_values(self):
        """Given custom values, when OptimizationConfig created, then has custom values."""
        # Given
        compression = "aggressive"
        short_tags = False
        strip = False
        cache = False
        max_tokens = 16000

        # When
        config = OptimizationConfig(
            compression_level=compression,
            use_short_tags=short_tags,
            strip_whitespace=strip,
            cache_system_prompts=cache,
            max_context_tokens=max_tokens,
        )

        # Then
        assert config.compression_level == "aggressive"
        assert config.use_short_tags is False
        assert config.strip_whitespace is False
        assert config.cache_system_prompts is False
        assert config.max_context_tokens == 16000

    def test_given_optimizationconfig_when_converted_to_dict_then_contains_all_fields(self):
        """Given an OptimizationConfig, when converted to dict, then contains all fields."""
        # Given
        config = OptimizationConfig()

        # When
        result = asdict(config)

        # Then
        assert "compression_level" in result
        assert "use_short_tags" in result
        assert "strip_whitespace" in result
        assert "cache_system_prompts" in result
        assert "max_context_tokens" in result


class TestAdaptiveConfig:
    """Behavioral tests for AdaptiveConfig dataclass."""

    def test_given_no_args_when_created_then_has_default_values(self):
        """Given no arguments, when AdaptiveConfig created, then has default values."""
        # Given/When
        config = AdaptiveConfig()

        # Then
        assert config.enable_adaptation is True
        assert "simple" in config.model_tier_mapping
        assert "moderate" in config.model_tier_mapping
        assert "complex" in config.model_tier_mapping
        assert "very_complex" in config.model_tier_mapping
        assert config.model_tier_mapping["simple"] == "gpt-3.5-turbo"
        assert "simple" in config.complexity_thresholds
        assert "moderate" in config.complexity_thresholds

    def test_given_custom_model_mapping_when_created_then_uses_custom_mapping(self):
        """Given custom model mapping, when AdaptiveConfig created, then uses custom mapping."""
        # Given
        custom_mapping = {
            "simple": "custom-model-1",
            "moderate": "custom-model-2",
            "complex": "custom-model-3",
            "very_complex": "custom-model-4",
        }

        # When
        config = AdaptiveConfig(model_tier_mapping=custom_mapping)

        # Then
        assert config.model_tier_mapping == custom_mapping
        assert config.model_tier_mapping["simple"] == "custom-model-1"

    def test_given_custom_thresholds_when_created_then_uses_custom_thresholds(self):
        """Given custom thresholds, when AdaptiveConfig created, then uses custom thresholds."""
        # Given
        custom_thresholds = {
            "simple": 100,
            "moderate": 500,
            "complex": 1000,
            "very_complex": 2000,
        }

        # When
        config = AdaptiveConfig(complexity_thresholds=custom_thresholds)

        # Then
        assert config.complexity_thresholds == custom_thresholds

    def test_given_adaptiveconfig_when_converted_to_dict_then_contains_all_fields(self):
        """Given an AdaptiveConfig, when converted to dict, then contains all fields."""
        # Given
        config = AdaptiveConfig()

        # When
        result = asdict(config)

        # Then
        assert "enable_adaptation" in result
        assert "model_tier_mapping" in result
        assert "complexity_thresholds" in result

    def test_given_adaptation_disabled_when_created_then_flag_is_false(self):
        """Given adaptation disabled, when AdaptiveConfig created, then flag is False."""
        # Given/When
        config = AdaptiveConfig(enable_adaptation=False)

        # Then
        assert config.enable_adaptation is False


class TestMetricsConfig:
    """Behavioral tests for MetricsConfig dataclass."""

    def test_given_no_args_when_created_then_has_default_values(self):
        """Given no arguments, when MetricsConfig created, then has default values."""
        # Given/When
        config = MetricsConfig()

        # Then
        assert config.track_metrics is True
        assert config.metrics_file == ".empathy/metrics.json"
        assert config.track_tokens is True
        assert config.track_latency is True
        assert config.track_success_rate is True

    def test_given_custom_values_when_created_then_has_custom_values(self):
        """Given custom values, when MetricsConfig created, then has custom values."""
        # Given
        track = False
        metrics_file = "custom/metrics.json"
        tokens = False
        latency = False
        success = False

        # When
        config = MetricsConfig(
            track_metrics=track,
            metrics_file=metrics_file,
            track_tokens=tokens,
            track_latency=latency,
            track_success_rate=success,
        )

        # Then
        assert config.track_metrics is False
        assert config.metrics_file == "custom/metrics.json"
        assert config.track_tokens is False
        assert config.track_latency is False
        assert config.track_success_rate is False

    def test_given_metricsconfig_when_converted_to_dict_then_contains_all_fields(self):
        """Given a MetricsConfig, when converted to dict, then contains all fields."""
        # Given
        config = MetricsConfig()

        # When
        result = asdict(config)

        # Then
        assert "track_metrics" in result
        assert "metrics_file" in result
        assert "track_tokens" in result
        assert "track_latency" in result
        assert "track_success_rate" in result


class TestMultilingualConfig:
    """Behavioral tests for MultilingualConfig dataclass."""

    def test_given_no_args_when_created_then_has_default_values(self):
        """Given no arguments, when MultilingualConfig created, then has default values."""
        # Given/When
        config = MultilingualConfig()

        # Then
        assert config.enable_multilingual is False
        assert config.default_language == "en"
        assert "en" in config.supported_languages
        assert config.translation_fallback is True

    def test_given_custom_values_when_created_then_has_custom_values(self):
        """Given custom values, when MultilingualConfig created, then has custom values."""
        # Given
        enable = True
        default_lang = "fr"
        supported = ["fr", "de", "es"]
        fallback = False

        # When
        config = MultilingualConfig(
            enable_multilingual=enable,
            default_language=default_lang,
            supported_languages=supported,
            translation_fallback=fallback,
        )

        # Then
        assert config.enable_multilingual is True
        assert config.default_language ==