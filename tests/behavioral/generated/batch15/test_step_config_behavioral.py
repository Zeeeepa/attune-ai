"""Behavioral tests for step_config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import Mock, patch

from empathy_os.workflows.step_config import WorkflowStepConfig
from empathy_os.models import (
    FallbackPolicy,
    ModelTier,
    RetryPolicy,
)


class TestWorkflowStepConfigCreation:
    """Test WorkflowStepConfig instance creation and initialization."""

    def test_given_minimal_required_fields_when_creating_step_then_creates_successfully(self):
        """Given minimal required fields, when creating step config, then it creates successfully."""
        # Given
        name = "test_step"
        task_type = "summarize"

        # When
        step = WorkflowStepConfig(name=name, task_type=task_type)

        # Then
        assert step.name == name
        assert step.task_type == "summarize"
        assert step.tier_hint is None
        assert step.provider_hint is None
        assert step.fallback_policy is None
        assert step.retry_policy is None
        assert step.timeout_seconds is None
        assert step.max_tokens is None
        assert step.description == ""
        assert step.metadata == {}

    def test_given_all_optional_fields_when_creating_step_then_all_fields_set(self):
        """Given all optional fields, when creating step config, then all fields are set correctly."""
        # Given
        name = "analysis"
        task_type = "fix_bug"
        tier_hint = "premium"
        provider_hint = "anthropic"
        fallback_policy = FallbackPolicy.DEGRADE_TIER
        retry_policy = RetryPolicy.EXPONENTIAL
        timeout_seconds = 60
        max_tokens = 4096
        description = "Bug fixing step"
        metadata = {"priority": "high", "version": "1.0"}

        # When
        step = WorkflowStepConfig(
            name=name,
            task_type=task_type,
            tier_hint=tier_hint,
            provider_hint=provider_hint,
            fallback_policy=fallback_policy,
            retry_policy=retry_policy,
            timeout_seconds=timeout_seconds,
            max_tokens=max_tokens,
            description=description,
            metadata=metadata,
        )

        # Then
        assert step.name == name
        assert step.task_type == "fix_bug"
        assert step.tier_hint == tier_hint
        assert step.provider_hint == provider_hint
        assert step.fallback_policy == fallback_policy
        assert step.retry_policy == retry_policy
        assert step.timeout_seconds == timeout_seconds
        assert step.max_tokens == max_tokens
        assert step.description == description
        assert step.metadata == metadata

    @patch('empathy_os.workflows.step_config.normalize_task_type')
    def test_given_non_normalized_task_type_when_creating_step_then_normalizes_task_type(self, mock_normalize):
        """Given non-normalized task type, when creating step, then task_type is normalized."""
        # Given
        mock_normalize.return_value = "normalized_task"
        name = "test"
        task_type = "SUMMARIZE"

        # When
        step = WorkflowStepConfig(name=name, task_type=task_type)

        # Then
        mock_normalize.assert_called_once_with("SUMMARIZE")
        assert step.task_type == "normalized_task"

    def test_given_empty_metadata_when_creating_step_then_metadata_is_empty_dict(self):
        """Given no metadata provided, when creating step, then metadata is empty dict."""
        # Given/When
        step = WorkflowStepConfig(name="test", task_type="summarize")

        # Then
        assert step.metadata == {}
        assert isinstance(step.metadata, dict)


class TestEffectiveTierProperty:
    """Test effective_tier property behavior."""

    def test_given_tier_hint_when_getting_effective_tier_then_returns_tier_hint(self):
        """Given tier_hint is specified, when getting effective_tier, then returns tier_hint."""
        # Given
        step = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="premium"
        )

        # When
        effective_tier = step.effective_tier

        # Then
        assert effective_tier == "premium"

    @patch('empathy_os.workflows.step_config.get_tier_for_task')
    def test_given_no_tier_hint_when_getting_effective_tier_then_derives_from_task_type(self, mock_get_tier):
        """Given no tier_hint, when getting effective_tier, then derives from task_type."""
        # Given
        mock_tier = Mock()
        mock_tier.value = "capable"
        mock_get_tier.return_value = mock_tier

        step = WorkflowStepConfig(name="test", task_type="fix_bug")

        # When
        effective_tier = step.effective_tier

        # Then
        mock_get_tier.assert_called_once_with("fix_bug")
        assert effective_tier == "capable"

    @patch('empathy_os.workflows.step_config.get_tier_for_task')
    def test_given_tier_hint_overrides_task_routing_when_getting_effective_tier_then_uses_tier_hint(self, mock_get_tier):
        """Given tier_hint overrides task routing, when getting effective_tier, then uses tier_hint."""
        # Given
        mock_tier = Mock()
        mock_tier.value = "capable"
        mock_get_tier.return_value = mock_tier

        step = WorkflowStepConfig(
            name="test",
            task_type="fix_bug",
            tier_hint="cheap"
        )

        # When
        effective_tier = step.effective_tier

        # Then
        # get_tier_for_task should not be called when tier_hint is present
        assert effective_tier == "cheap"

    @patch('empathy_os.workflows.step_config.get_tier_for_task')
    def test_given_cheap_tier_from_task_when_getting_effective_tier_then_returns_cheap(self, mock_get_tier):
        """Given cheap tier from task routing, when getting effective_tier, then returns cheap."""
        # Given
        mock_tier = Mock()
        mock_tier.value = "cheap"
        mock_get_tier.return_value = mock_tier

        step = WorkflowStepConfig(name="test", task_type="classify")

        # When
        effective_tier = step.effective_tier

        # Then
        assert effective_tier == "cheap"

    @patch('empathy_os.workflows.step_config.get_tier_for_task')
    def test_given_premium_tier_from_task_when_getting_effective_tier_then_returns_premium(self, mock_get_tier):
        """Given premium tier from task routing, when getting effective_tier, then returns premium."""
        # Given
        mock_tier = Mock()
        mock_tier.value = "premium"
        mock_get_tier.return_value = mock_tier

        step = WorkflowStepConfig(name="test", task_type="coordinate")

        # When
        effective_tier = step.effective_tier

        # Then
        assert effective_tier == "premium"


class TestEffectiveTierEnumProperty:
    """Test effective_tier_enum property behavior."""

    def test_given_tier_hint_when_getting_effective_tier_enum_then_returns_model_tier_enum(self):
        """Given tier_hint, when getting effective_tier_enum, then returns ModelTier enum."""
        # Given
        step = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="capable"
        )

        # When
        effective_tier_enum = step.effective_tier_enum

        # Then
        assert effective_tier_enum == ModelTier.CAPABLE
        assert isinstance(effective_tier_enum, ModelTier)

    @patch('empathy_os.workflows.step_config.get_tier_for_task')
    def test_given_no_tier_hint_when_getting_effective_tier_enum_then_returns_derived_tier_enum(self, mock_get_tier):
        """Given no tier_hint, when getting effective_tier_enum, then returns derived ModelTier enum."""
        # Given
        mock_tier = Mock()
        mock_tier.value = "cheap"
        mock_get_tier.return_value = mock_tier

        step = WorkflowStepConfig(name="test", task_type="classify")

        # When
        effective_tier_enum = step.effective_tier_enum

        # Then
        assert effective_tier_enum == ModelTier.CHEAP
        assert isinstance(effective_tier_enum, ModelTier)

    def test_given_premium_tier_hint_when_getting_effective_tier_enum_then_returns_premium_enum(self):
        """Given premium tier_hint, when getting effective_tier_enum, then returns PREMIUM enum."""
        # Given
        step = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="premium"
        )

        # When
        effective_tier_enum = step.effective_tier_enum

        # Then
        assert effective_tier_enum == ModelTier.PREMIUM


class TestWithOverridesMethod:
    """Test with_overrides method behavior."""

    def test_given_no_overrides_when_calling_with_overrides_then_returns_copy_with_same_values(self):
        """Given no overrides, when calling with_overrides, then returns copy with same values."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="cheap",
            timeout_seconds=30
        )

        # When
        new_step = original.with_overrides()

        # Then
        assert new_step is not original
        assert new_step.name == original.name
        assert new_step.task_type == original.task_type
        assert new_step.tier_hint == original.tier_hint
        assert new_step.timeout_seconds == original.timeout_seconds

    def test_given_tier_hint_override_when_calling_with_overrides_then_returns_step_with_new_tier(self):
        """Given tier_hint override, when calling with_overrides, then returns step with new tier."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="cheap"
        )

        # When
        new_step = original.with_overrides(tier_hint="premium")

        # Then
        assert new_step.tier_hint == "premium"
        assert original.tier_hint == "cheap"

    def test_given_provider_hint_override_when_calling_with_overrides_then_returns_step_with_new_provider(self):
        """Given provider_hint override, when calling with_overrides, then returns step with new provider."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            provider_hint="openai"
        )

        # When
        new_step = original.with_overrides(provider_hint="anthropic")

        # Then
        assert new_step.provider_hint == "anthropic"
        assert original.provider_hint == "openai"

    def test_given_fallback_policy_override_when_calling_with_overrides_then_returns_step_with_new_policy(self):
        """Given fallback_policy override, when calling with_overrides, then returns step with new policy."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            fallback_policy=FallbackPolicy.FAIL_FAST
        )

        # When
        new_step = original.with_overrides(fallback_policy=FallbackPolicy.DEGRADE_TIER)

        # Then
        assert new_step.fallback_policy == FallbackPolicy.DEGRADE_TIER
        assert original.fallback_policy == FallbackPolicy.FAIL_FAST

    def test_given_retry_policy_override_when_calling_with_overrides_then_returns_step_with_new_retry(self):
        """Given retry_policy override, when calling with_overrides, then returns step with new retry."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            retry_policy=RetryPolicy.LINEAR
        )

        # When
        new_step = original.with_overrides(retry_policy=RetryPolicy.EXPONENTIAL)

        # Then
        assert new_step.retry_policy == RetryPolicy.EXPONENTIAL
        assert original.retry_policy == RetryPolicy.LINEAR

    def test_given_timeout_override_when_calling_with_overrides_then_returns_step_with_new_timeout(self):
        """Given timeout_seconds override, when calling with_overrides, then returns step with new timeout."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            timeout_seconds=30
        )

        # When
        new_step = original.with_overrides(timeout_seconds=60)

        # Then
        assert new_step.timeout_seconds == 60
        assert original.timeout_seconds == 30

    def test_given_multiple_overrides_when_calling_with_overrides_then_returns_step_with_all_overrides(self):
        """Given multiple overrides, when calling with_overrides, then returns step with all overrides."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="cheap",
            provider_hint="openai",
            timeout_seconds=30
        )

        # When
        new_step = original.with_overrides(
            tier_hint="premium",
            provider_hint="anthropic",
            timeout_seconds=120,
            fallback_policy=FallbackPolicy.DEGRADE_TIER,
            retry_policy=RetryPolicy.EXPONENTIAL
        )

        # Then
        assert new_step.tier_hint == "premium"
        assert new_step.provider_hint == "anthropic"
        assert new_step.timeout_seconds == 120
        assert new_step.fallback_policy == FallbackPolicy.DEGRADE_TIER
        assert new_step.retry_policy == RetryPolicy.EXPONENTIAL
        # Original unchanged
        assert original.tier_hint == "cheap"
        assert original.provider_hint == "openai"
        assert original.timeout_seconds == 30

    def test_given_none_override_when_calling_with_overrides_then_preserves_original_value(self):
        """Given None as override value, when calling with_overrides, then preserves original value."""
        # Given
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            tier_hint="cheap",
            timeout_seconds=30
        )

        # When
        new_step = original.with_overrides(tier_hint=None)

        # Then
        assert new_step.tier_hint == "cheap"

    def test_given_original_with_metadata_when_calling_with_overrides_then_preserves_metadata(self):
        """Given original with metadata, when calling with_overrides, then preserves metadata."""
        # Given
        metadata = {"key": "value", "number": 42}
        original = WorkflowStepConfig(
            name="test",
            task_type="summarize",
            metadata=metadata
        )

        # When