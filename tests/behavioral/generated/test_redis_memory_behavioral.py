"""Behavioral tests for redis_memory.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from datetime import datetime
from unittest.mock import MagicMock, patch

import pytest

from attune.memory.short_term import AccessTier
from attune.redis_memory import (
    AgentCredentials,
    ConflictContext,
    RedisShortTermMemory,
    StagedPattern,
    TTLStrategy,
)

# ============================================================================
# FIXTURES
# ============================================================================


@pytest.fixture
def mock_redis():
    """Fixture providing a mocked Redis client."""
    with patch("attune.redis_memory.redis") as mock_redis_module:
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        yield mock_client


@pytest.fixture
def observer_credentials():
    """Fixture providing Observer-tier credentials."""
    return AgentCredentials(
        agent_id="observer_1",
        tier=AccessTier.OBSERVER,
        roles=["reader"],
    )


@pytest.fixture
def contributor_credentials():
    """Fixture providing Contributor-tier credentials."""
    return AgentCredentials(
        agent_id="contributor_1",
        tier=AccessTier.CONTRIBUTOR,
        roles=["writer"],
    )


@pytest.fixture
def validator_credentials():
    """Fixture providing Validator-tier credentials."""
    return AgentCredentials(
        agent_id="validator_1",
        tier=AccessTier.VALIDATOR,
        roles=["validator"],
    )


@pytest.fixture
def steward_credentials():
    """Fixture providing Steward-tier credentials."""
    return AgentCredentials(
        agent_id="steward_1",
        tier=AccessTier.STEWARD,
        roles=["admin"],
    )


@pytest.fixture
def sample_staged_pattern():
    """Fixture providing a sample staged pattern."""
    return StagedPattern(
        pattern_id="pattern_123",
        agent_id="agent_456",
        pattern_type="analysis",
        name="Test Pattern",
        description="A test pattern for validation",
        code="def test(): pass",
        context={"key": "value"},
        confidence=0.8,
        interests=["accuracy", "performance"],
    )


@pytest.fixture
def sample_conflict_context():
    """Fixture providing a sample conflict context."""
    return ConflictContext(
        conflict_id="conflict_789",
        positions={"agent_1": "position A", "agent_2": "position B"},
        interests={"agent_1": ["accuracy"], "agent_2": ["speed"]},
        batna="fallback strategy",
    )


@pytest.fixture
def redis_memory(mock_redis):
    """Fixture providing a RedisShortTermMemory instance with mocked Redis."""
    with patch("attune.redis_memory.REDIS_AVAILABLE", True):
        memory = RedisShortTermMemory(
            host="localhost",
            port=6379,
            db=0,
        )
        return memory


# ============================================================================
# TTLStrategy TESTS
# ============================================================================


class TestTTLStrategy:
    """Tests for TTLStrategy enum."""

    def test_working_results_ttl_value(self):
        """Given TTLStrategy enum
        When accessing WORKING_RESULTS
        Then it should return 3600 seconds (1 hour)
        """
        assert TTLStrategy.WORKING_RESULTS.value == 3600

    def test_staged_patterns_ttl_value(self):
        """Given TTLStrategy enum
        When accessing STAGED_PATTERNS
        Then it should return 86400 seconds (24 hours)
        """
        assert TTLStrategy.STAGED_PATTERNS.value == 86400

    def test_coordination_ttl_value(self):
        """Given TTLStrategy enum
        When accessing COORDINATION
        Then it should return 300 seconds (5 minutes)
        """
        assert TTLStrategy.COORDINATION.value == 300

    def test_conflict_context_ttl_value(self):
        """Given TTLStrategy enum
        When accessing CONFLICT_CONTEXT
        Then it should return 604800 seconds (7 days)
        """
        assert TTLStrategy.CONFLICT_CONTEXT.value == 604800

    def test_session_ttl_value(self):
        """Given TTLStrategy enum
        When accessing SESSION
        Then it should return 1800 seconds (30 minutes)
        """
        assert TTLStrategy.SESSION.value == 1800


# ============================================================================
# AgentCredentials TESTS
# ============================================================================


class TestAgentCredentials:
    """Tests for AgentCredentials class."""

    def test_observer_can_read(self, observer_credentials):
        """Given observer credentials
        When checking can_read permission
        Then it should return True
        """
        assert observer_credentials.can_read() is True

    def test_observer_cannot_stage(self, observer_credentials):
        """Given observer credentials
        When checking can_stage permission
        Then it should return False
        """
        assert observer_credentials.can_stage() is False

    def test_observer_cannot_validate(self, observer_credentials):
        """Given observer credentials
        When checking can_validate permission
        Then it should return False
        """
        assert observer_credentials.can_validate() is False

    def test_observer_cannot_administer(self, observer_credentials):
        """Given observer credentials
        When checking can_administer permission
        Then it should return False
        """
        assert observer_credentials.can_administer() is False

    def test_contributor_can_read(self, contributor_credentials):
        """Given contributor credentials
        When checking can_read permission
        Then it should return True
        """
        assert contributor_credentials.can_read() is True

    def test_contributor_can_stage(self, contributor_credentials):
        """Given contributor credentials
        When checking can_stage permission
        Then it should return True
        """
        assert contributor_credentials.can_stage() is True

    def test_contributor_cannot_validate(self, contributor_credentials):
        """Given contributor credentials
        When checking can_validate permission
        Then it should return False
        """
        assert contributor_credentials.can_validate() is False

    def test_contributor_cannot_administer(self, contributor_credentials):
        """Given contributor credentials
        When checking can_administer permission
        Then it should return False
        """
        assert contributor_credentials.can_administer() is False

    def test_validator_can_read(self, validator_credentials):
        """Given validator credentials
        When checking can_read permission
        Then it should return True
        """
        assert validator_credentials.can_read() is True

    def test_validator_can_stage(self, validator_credentials):
        """Given validator credentials
        When checking can_stage permission
        Then it should return True
        """
        assert validator_credentials.can_stage() is True

    def test_validator_can_validate(self, validator_credentials):
        """Given validator credentials
        When checking can_validate permission
        Then it should return True
        """
        assert validator_credentials.can_validate() is True

    def test_validator_cannot_administer(self, validator_credentials):
        """Given validator credentials
        When checking can_administer permission
        Then it should return False
        """
        assert validator_credentials.can_administer() is False

    def test_steward_can_read(self, steward_credentials):
        """Given steward credentials
        When checking can_read permission
        Then it should return True
        """
        assert steward_credentials.can_read() is True

    def test_steward_can_stage(self, steward_credentials):
        """Given steward credentials
        When checking can_stage permission
        Then it should return True
        """
        assert steward_credentials.can_stage() is True

    def test_steward_can_validate(self, steward_credentials):
        """Given steward credentials
        When checking can_validate permission
        Then it should return True
        """
        assert steward_credentials.can_validate() is True

    def test_steward_can_administer(self, steward_credentials):
        """Given steward credentials
        When checking can_administer permission
        Then it should return True
        """
        assert steward_credentials.can_administer() is True

    def test_credentials_default_roles(self):
        """Given new credentials without roles
        When created
        Then roles should be empty list
        """
        creds = AgentCredentials(agent_id="test", tier=AccessTier.OBSERVER)
        assert creds.roles == []

    def test_credentials_custom_roles(self):
        """Given new credentials with custom roles
        When created
        Then roles should match provided list
        """
        roles = ["role1", "role2"]
        creds = AgentCredentials(
            agent_id="test",
            tier=AccessTier.OBSERVER,
            roles=roles,
        )
        assert creds.roles == roles

    def test_credentials_created_at_is_set(self):
        """Given new credentials
        When created
        Then created_at should be set to current datetime
        """
        before = datetime.now()
        creds = AgentCredentials(agent_id="test", tier=AccessTier.OBSERVER)
        after = datetime.now()
        assert before <= creds.created_at <= after


# ============================================================================
# StagedPattern TESTS
# ============================================================================


class TestStagedPattern:
    """Tests for StagedPattern class."""

    def test_to_dict_with_all_fields(self, sample_staged_pattern):
        """Given a staged pattern with all fields
        When converting to dict
        Then all fields should be present in dict
        """
        result = sample_staged_pattern.to_dict()
        assert result["pattern_id"] == "pattern_123"
        assert result["agent_id"] == "agent_456"
        assert result["pattern_type"] == "analysis"
        assert result["name"] == "Test Pattern"
        assert result["description"] == "A test pattern for validation"
        assert result["code"] == "def test(): pass"
        assert result["context"] == {"key": "value"}
        assert result["confidence"] == 0.8
        assert result["interests"] == ["accuracy", "performance"]
        assert "staged_at" in result

    def test_to_dict_staged_at_is_isoformat(self, sample_staged_pattern):
        """Given a staged pattern
        When converting to dict
        Then staged_at should be in ISO format string
        """
        result = sample_staged_pattern.to_dict()
        # Should not raise exception
        datetime.fromisoformat(result["staged_at"])

    def test_from_dict_recreates_pattern(self, sample_staged_pattern):
        """Given a pattern dict
        When creating from dict
        Then it should recreate the pattern object
        """
        pattern_dict = sample_staged_pattern.to_dict()
        recreated = StagedPattern.from_dict(pattern_dict)
        assert recreated.pattern_id == sample_staged_pattern.pattern_id
        assert recreated.agent_id == sample_staged_pattern.agent_id
        assert recreated.pattern_type == sample_staged_pattern.pattern_type
        assert recreated.name == sample_staged_pattern.name
        assert recreated.description == sample_staged_pattern.description
        assert recreated.code == sample_staged_pattern.code
        assert recreated.context == sample_staged_pattern.context
        assert recreated.confidence == sample_staged_pattern.confidence
        assert recreated.interests == sample_staged_pattern.interests

    def test_from_dict_with_minimal_fields(self):
        """Given a minimal pattern dict
        When creating from dict
        Then it should create pattern with defaults
        """
        data = {
            "pattern_id": "p1",
            "agent_id": "a1",
            "pattern_type": "type1",
            "name": "name1",
            "description": "desc1",
            "code": None,
            "context": {},
            "confidence": 0.5,
            "staged_at": datetime.now().isoformat(),
            "interests": [],
        }
        pattern = StagedPattern.from_dict(data)
        assert pattern.pattern_id == "p1"
        assert pattern.agent_id == "a1"
        assert pattern.code is None
        assert pattern.context == {}

    def test_default_confidence(self):
        """Given a new staged pattern without confidence
        When created
        Then confidence should default to 0.5
        """
        pattern = StagedPattern(
            pattern_id="p1",
            agent_id="a1",
            pattern_type="type1",
            name="name1",
            description="desc1",
        )
        assert pattern.confidence == 0.5

    def test_default_context(self):
        """Given a new staged pattern without context
        When created
        Then context should default to empty dict
        """
        pattern = StagedPattern(
            pattern_id="p1",
            agent_id="a1",
            pattern_type="type1",
            name="name1",
            description="desc1",
        )
        assert pattern.context == {}

    def test_default_interests(self):
        """Given a new staged pattern without interests
        When created
        Then interests should default to empty list
        """
        pattern = StagedPattern(
            pattern_id="p1",
            agent_id="a1",
            pattern_type="type1",
            name="name1",
            description="desc1",
        )
        assert pattern.interests == []


# ============================================================================
# ConflictContext TESTS
# ============================================================================


class TestConflictContext:
    """Tests for ConflictContext class."""

    def test_to_dict_with_all_fields(self, sample_conflict_context):
        """Given a conflict context with all fields
        When converting to dict
        Then all fields should be present in dict
        """
        result = sample_conflict_context.to_dict()
        assert result["conflict_id"] == "conflict_789"
        assert result["positions"] == {"agent_1": "position A", "agent_2": "position B"}
        assert result["interests"] == {"agent_1": ["accuracy"], "agent_2": ["speed"]}
        assert result["batna"] == "fallback strategy"
        assert "created_at" in result
        assert result["resolved"] is False
        assert result["resolution"] is None

    def test_from_dict_recreates_context(self, sample_conflict_context):
        """Given a conflict context dict
        When creating from dict
        Then it should recreate the context object
        """
        context_dict = sample_conflict_context.to_dict()
        recreated = ConflictContext.from_dict(context_dict)
        assert recreated.conflict_id == sample_conflict_context.conflict_id
        assert recreated.positions == sample_conflict_context.positions
        assert recreated.interests == sample_conflict_context.interests
        assert recreated.batna == sample_conflict_context.batna

    def test_from_dict_with_resolution(self):
        """Given a conflict context dict with resolution
        When creating from dict
        Then resolved should be True and resolution should be set
        """
        data = {
            "conflict_id": "c1",
            "positions": {"a": "pos_a"},
            "interests": {"a": ["interest_a"]},
            "batna": None,
            "created_at": datetime.now().isoformat(),
            "resolved": True,
            "resolution": "Agreed on compromise",
        }
        ctx = ConflictContext.from_dict(data)
        assert ctx.resolved is True
        assert ctx.resolution == "Agreed on compromise"
