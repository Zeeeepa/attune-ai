"""Behavioral tests for long_term_types.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest

from attune.memory.long_term_types import (
    DEFAULT_CLASSIFICATION_RULES,
    Classification,
    ClassificationRules,
    PatternMetadata,
    PermissionError,
    SecurePattern,
    SecurityError,
)


class TestClassificationEnum:
    """Behavioral tests for Classification enum."""

    def test_given_classification_enum_when_accessing_public_then_returns_correct_value(self):
        """
        Given: Classification enum
        When: Accessing PUBLIC classification
        Then: Returns correct string value
        """
        # When
        result = Classification.PUBLIC

        # Then
        assert result.value == "PUBLIC"
        assert isinstance(result, Classification)

    def test_given_classification_enum_when_accessing_internal_then_returns_correct_value(self):
        """
        Given: Classification enum
        When: Accessing INTERNAL classification
        Then: Returns correct string value
        """
        # When
        result = Classification.INTERNAL

        # Then
        assert result.value == "INTERNAL"
        assert isinstance(result, Classification)

    def test_given_classification_enum_when_accessing_sensitive_then_returns_correct_value(self):
        """
        Given: Classification enum
        When: Accessing SENSITIVE classification
        Then: Returns correct string value
        """
        # When
        result = Classification.SENSITIVE

        # Then
        assert result.value == "SENSITIVE"
        assert isinstance(result, Classification)

    def test_given_classification_enum_when_comparing_values_then_equality_works(self):
        """
        Given: Two Classification enum instances
        When: Comparing them
        Then: Equality works correctly
        """
        # Given
        classification1 = Classification.PUBLIC
        classification2 = Classification.PUBLIC
        classification3 = Classification.INTERNAL

        # Then
        assert classification1 == classification2
        assert classification1 != classification3

    def test_given_classification_enum_when_iterating_then_contains_all_values(self):
        """
        Given: Classification enum
        When: Iterating over values
        Then: Contains all expected classifications
        """
        # When
        classifications = list(Classification)

        # Then
        assert len(classifications) == 3
        assert Classification.PUBLIC in classifications
        assert Classification.INTERNAL in classifications
        assert Classification.SENSITIVE in classifications

    def test_given_string_value_when_creating_from_string_then_returns_correct_enum(self):
        """
        Given: String value "PUBLIC"
        When: Creating Classification from string
        Then: Returns correct enum member
        """
        # When
        result = Classification("PUBLIC")

        # Then
        assert result == Classification.PUBLIC


class TestClassificationRules:
    """Behavioral tests for ClassificationRules dataclass."""

    def test_given_valid_parameters_when_creating_rules_then_initializes_correctly(self):
        """
        Given: Valid classification rule parameters
        When: Creating ClassificationRules instance
        Then: All fields are set correctly
        """
        # Given
        classification = Classification.PUBLIC
        encryption_required = False
        retention_days = 365
        access_level = "all_users"
        audit_all_access = True

        # When
        rules = ClassificationRules(
            classification=classification,
            encryption_required=encryption_required,
            retention_days=retention_days,
            access_level=access_level,
            audit_all_access=audit_all_access,
        )

        # Then
        assert rules.classification == classification
        assert rules.encryption_required == encryption_required
        assert rules.retention_days == retention_days
        assert rules.access_level == access_level
        assert rules.audit_all_access == audit_all_access

    def test_given_minimal_parameters_when_creating_rules_then_uses_default_audit(self):
        """
        Given: Minimal classification rule parameters
        When: Creating ClassificationRules without audit_all_access
        Then: Uses default value False for audit_all_access
        """
        # When
        rules = ClassificationRules(
            classification=Classification.INTERNAL,
            encryption_required=True,
            retention_days=180,
            access_level="project_team",
        )

        # Then
        assert rules.audit_all_access is False

    def test_given_classification_rules_when_accessing_fields_then_returns_correct_values(self):
        """
        Given: ClassificationRules instance
        When: Accessing individual fields
        Then: Returns correct values
        """
        # Given
        rules = ClassificationRules(
            classification=Classification.SENSITIVE,
            encryption_required=True,
            retention_days=90,
            access_level="explicit_permission",
            audit_all_access=True,
        )

        # Then
        assert rules.classification.value == "SENSITIVE"
        assert rules.encryption_required is True
        assert rules.retention_days == 90
        assert rules.access_level == "explicit_permission"
        assert rules.audit_all_access is True

    def test_given_classification_rules_when_modifying_fields_then_changes_persist(self):
        """
        Given: ClassificationRules instance
        When: Modifying mutable fields
        Then: Changes are persisted
        """
        # Given
        rules = ClassificationRules(
            classification=Classification.PUBLIC,
            encryption_required=False,
            retention_days=365,
            access_level="all_users",
        )

        # When
        rules.retention_days = 400
        rules.encryption_required = True

        # Then
        assert rules.retention_days == 400
        assert rules.encryption_required is True


class TestDefaultClassificationRules:
    """Behavioral tests for DEFAULT_CLASSIFICATION_RULES."""

    def test_given_default_rules_when_accessing_public_then_has_correct_configuration(self):
        """
        Given: DEFAULT_CLASSIFICATION_RULES
        When: Accessing PUBLIC rules
        Then: Has correct security configuration
        """
        # When
        rules = DEFAULT_CLASSIFICATION_RULES[Classification.PUBLIC]

        # Then
        assert rules.classification == Classification.PUBLIC
        assert rules.encryption_required is False
        assert rules.retention_days == 365
        assert rules.access_level == "all_users"
        assert rules.audit_all_access is False

    def test_given_default_rules_when_accessing_internal_then_has_correct_configuration(self):
        """
        Given: DEFAULT_CLASSIFICATION_RULES
        When: Accessing INTERNAL rules
        Then: Has correct security configuration
        """
        # When
        rules = DEFAULT_CLASSIFICATION_RULES[Classification.INTERNAL]

        # Then
        assert rules.classification == Classification.INTERNAL
        assert rules.encryption_required is False
        assert rules.retention_days == 180
        assert rules.access_level == "project_team"
        assert rules.audit_all_access is False

    def test_given_default_rules_when_accessing_sensitive_then_has_correct_configuration(self):
        """
        Given: DEFAULT_CLASSIFICATION_RULES
        When: Accessing SENSITIVE rules
        Then: Has correct security configuration with encryption
        """
        # When
        rules = DEFAULT_CLASSIFICATION_RULES[Classification.SENSITIVE]

        # Then
        assert rules.classification == Classification.SENSITIVE
        assert rules.encryption_required is True
        assert rules.retention_days == 90
        assert rules.access_level == "explicit_permission"
        assert rules.audit_all_access is True

    def test_given_default_rules_when_checking_all_classifications_then_all_present(self):
        """
        Given: DEFAULT_CLASSIFICATION_RULES
        When: Checking for all classification levels
        Then: All three levels are present
        """
        # Then
        assert len(DEFAULT_CLASSIFICATION_RULES) == 3
        assert Classification.PUBLIC in DEFAULT_CLASSIFICATION_RULES
        assert Classification.INTERNAL in DEFAULT_CLASSIFICATION_RULES
        assert Classification.SENSITIVE in DEFAULT_CLASSIFICATION_RULES

    def test_given_default_rules_when_comparing_retention_then_decreases_with_sensitivity(self):
        """
        Given: DEFAULT_CLASSIFICATION_RULES
        When: Comparing retention days across classifications
        Then: Retention decreases as sensitivity increases
        """
        # When
        public_retention = DEFAULT_CLASSIFICATION_RULES[Classification.PUBLIC].retention_days
        internal_retention = DEFAULT_CLASSIFICATION_RULES[Classification.INTERNAL].retention_days
        sensitive_retention = DEFAULT_CLASSIFICATION_RULES[Classification.SENSITIVE].retention_days

        # Then
        assert public_retention > internal_retention > sensitive_retention


class TestPatternMetadata:
    """Behavioral tests for PatternMetadata dataclass."""

    def test_given_valid_parameters_when_creating_metadata_then_initializes_correctly(self):
        """
        Given: Valid pattern metadata parameters
        When: Creating PatternMetadata instance
        Then: All fields are set correctly
        """
        # Given
        pattern_id = "pattern-123"
        created_by = "user@example.com"
        created_at = "2025-01-15T10:30:00Z"
        classification = "PUBLIC"
        retention_days = 365
        encrypted = False
        pattern_type = "conversation"
        sanitization_applied = True
        pii_removed = 3
        secrets_detected = 0

        # When
        metadata = PatternMetadata(
            pattern_id=pattern_id,
            created_by=created_by,
            created_at=created_at,
            classification=classification,
            retention_days=retention_days,
            encrypted=encrypted,
            pattern_type=pattern_type,
            sanitization_applied=sanitization_applied,
            pii_removed=pii_removed,
            secrets_detected=secrets_detected,
        )

        # Then
        assert metadata.pattern_id == pattern_id
        assert metadata.created_by == created_by
        assert metadata.created_at == created_at
        assert metadata.classification == classification
        assert metadata.retention_days == retention_days
        assert metadata.encrypted == encrypted
        assert metadata.pattern_type == pattern_type
        assert metadata.sanitization_applied == sanitization_applied
        assert metadata.pii_removed == pii_removed
        assert metadata.secrets_detected == secrets_detected

    def test_given_minimal_parameters_when_creating_metadata_then_uses_default_dicts(self):
        """
        Given: Minimal pattern metadata parameters
        When: Creating PatternMetadata without optional fields
        Then: Uses default empty dicts for access_control and custom_metadata
        """
        # When
        metadata = PatternMetadata(
            pattern_id="pattern-456",
            created_by="admin@example.com",
            created_at="2025-01-16T12:00:00Z",
            classification="SENSITIVE",
            retention_days=90,
            encrypted=True,
            pattern_type="document",
            sanitization_applied=False,
            pii_removed=0,
            secrets_detected=2,
        )

        # Then
        assert metadata.access_control == {}
        assert metadata.custom_metadata == {}

    def test_given_metadata_with_custom_fields_when_creating_then_stores_correctly(self):
        """
        Given: Pattern metadata with custom access control and metadata
        When: Creating PatternMetadata with custom fields
        Then: Custom fields are stored correctly
        """
        # Given
        access_control = {"users": ["user1", "user2"], "groups": ["admin"]}
        custom_metadata = {"source": "api", "version": "1.0"}

        # When
        metadata = PatternMetadata(
            pattern_id="pattern-789",
            created_by="service@example.com",
            created_at="2025-01-17T14:30:00Z",
            classification="INTERNAL",
            retention_days=180,
            encrypted=False,
            pattern_type="log",
            sanitization_applied=True,
            pii_removed=5,
            secrets_detected=1,
            access_control=access_control,
            custom_metadata=custom_metadata,
        )

        # Then
        assert metadata.access_control == access_control
        assert metadata.custom_metadata == custom_metadata
        assert "users" in metadata.access_control
        assert metadata.access_control["users"] == ["user1", "user2"]

    def test_given_metadata_when_modifying_mutable_fields_then_changes_persist(self):
        """
        Given: PatternMetadata instance
        When: Modifying mutable fields
        Then: Changes are persisted
        """
        # Given
        metadata = PatternMetadata(
            pattern_id="pattern-999",
            created_by="test@example.com",
            created_at="2025-01-18T16:00:00Z",
            classification="PUBLIC",
            retention_days=365,
            encrypted=False,
            pattern_type="note",
            sanitization_applied=False,
            pii_removed=0,
            secrets_detected=0,
        )

        # When
        metadata.access_control["owner"] = "test@example.com"
        metadata.custom_metadata["tags"] = ["important", "review"]
        metadata.pii_removed = 2

        # Then
        assert metadata.access_control["owner"] == "test@example.com"
        assert "tags" in metadata.custom_metadata
        assert metadata.pii_removed == 2

    def test_given_metadata_when_setting_high_pii_count_then_stores_correctly(self):
        """
        Given: Pattern metadata with high PII removal count
        When: Creating metadata with large pii_removed value
        Then: Stores value correctly
        """
        # When
        metadata = PatternMetadata(
            pattern_id="pattern-high-pii",
            created_by="scanner@example.com",
            created_at="2025-01-19T10:00:00Z",
            classification="SENSITIVE",
            retention_days=90,
            encrypted=True,
            pattern_type="medical",
            sanitization_applied=True,
            pii_removed=150,
            secrets_detected=5,
        )

        # Then
        assert metadata.pii_removed == 150
        assert metadata.secrets_detected == 5
        assert metadata.sanitization_applied is True


class TestSecurePattern:
    """Behavioral tests for SecurePattern dataclass."""

    def test_given_valid_parameters_when_creating_secure_pattern_then_initializes_correctly(self):
        """
        Given: Valid secure pattern parameters
        When: Creating SecurePattern instance
        Then: All fields are set correctly
        """
        # Given
        pattern_id = "secure-pattern-001"
        content = "This is secure content"
        metadata = PatternMetadata(
            pattern_id=pattern_id,
            created_by="user@example.com",
            created_at="2025-01-20T09:00:00Z",
            classification="PUBLIC",
            retention_days=365,
            encrypted=False,
            pattern_type="text",
            sanitization_applied=False,
            pii_removed=0,
            secrets_detected=0,
        )

        # When
        secure_pattern = SecurePattern(
            pattern_id=pattern_id,
            content=content,
            metadata=metadata,
        )

        # Then
        assert secure_pattern.pattern_id == pattern_id
        assert secure_pattern.content == content
        assert secure_pattern.metadata == metadata
        assert secure_pattern.metadata.pattern_id == pattern_id

    def test_given_encrypted_content_when_creating_secure_pattern_then_stores_encrypted(self):
        """
        Given: Encrypted pattern content
        When: Creating SecurePattern with encrypted flag
        Then: Metadata reflects encryption status
        """
        # Given
        pattern_id = "secure-pattern-002"
        content = "encrypted_content_base64_string"
        metadata = PatternMetadata(
            pattern_id=pattern_id,
            created_by="admin@example.com",
            created_at="2025-01-20T10:00:00Z",
            classification="SENSITIVE",
            retention_days=90,
            encrypted=True,
            pattern_type="document",
            sanitization_applied=True,
            pii_removed=10,
            secrets_detected=2,
        )

        # When
        secure_pattern = SecurePattern(
            pattern_id=pattern_id,
            content=content,
            metadata=metadata,
        )

        # Then
        assert secure_pattern.metadata.encrypted is True
        assert secure_pattern.metadata.classification == "SENSITIVE"
        assert secure_pattern.content == content

    def test_given_secure_pattern_when_accessing_metadata_fields_then_returns_correct_values(self):
        """
        Given: SecurePattern instance
        When: Accessing nested metadata fields
        Then: Returns correct values
        """
        # Given
        metadata = PatternMetadata(
            pattern_id="pattern-003",
            created_by="service@example.com",
            created_at="2025-01-20T11:00:00Z",
            classification="INTERNAL",
            retention_days=180,
            encrypted=False,
            pattern_type="log",
            sanitization_applied=True,
            pii_removed=3,
            secrets_detected=0,
            access_control={"team": "engineering"},
            custom_metadata={"priority": "high"},
        )
        secure_pattern = SecurePattern(
            pattern_id="pattern-003",
            content="log data here",
            metadata=metadata,
        )

        # Then
        assert secure_pattern.metadata.created_by == "service@example.com"
        assert secure_pattern.metadata.access_control["team"] == "engineering"
        assert secure_pattern.metadata.custom_metadata["priority"] == "high"
        assert secure_pattern.metadata.pii_removed == 3

    def test_given_secure_pattern_when_modifying_content_then_changes_persist(self):
        """
        Given: SecurePattern instance
        When: Modifying content field
        Then: Changes are persisted
        """
        # Given
        metadata = PatternMetadata(
            pattern_id="pattern-004",
            created_by="test@example.com",
            created_at="2025-01-20T12:00:00Z",
            classification="PUBLIC",
            retention_days=365,
            encrypted=False,
            pattern_type="note",
            sanitization_applied=False,
            pii_removed=0,
            secrets_detected=0,
        )
        secure_pattern = SecurePattern(
            pattern_id="pattern-004",
            content="original content",
            metadata=metadata,
        )

        # When
        secure_pattern.content = "updated content"

        # Then
        assert secure_pattern.content == "updated content"

    def test_given_empty_content_when_creating_secure_pattern_then_stores_empty_string(self):
        """
        Given: Empty string as pattern content
        When: Creating SecurePattern with empty content
        Then: Stores empty string correctly
        """
        # Given
        metadata = PatternMetadata(
            pattern_id="pattern-empty",
            created_by="test@example.com",
            created_at="2025-01-20T13:00:00Z",
            classification="PUBLIC",
            retention_days=365,
            encrypted=False,
            pattern_type="placeholder",
            sanitization_applied=False,
            pii_removed=0,
            secrets_detected=0,
        )

        # When
        secure_pattern = SecurePattern(
            pattern_id="pattern-empty",
            content="",
            metadata=metadata,
        )

        # Then
        assert secure_pattern.content == ""
        assert len(secure_pattern.content) == 0


class TestSecurityError:
    """Behavioral tests for SecurityError exception."""

    def test_given_error_message_when_raising_security_error_then_contains_message(self):
        """
        Given: Error message string
        When: Raising SecurityError
        Then: Exception contains the message
        """
        # Given
        error_message = "Security policy violated: unauthorized access"

        # When/Then
        with pytest.raises(SecurityError) as exc_info:
            raise SecurityError(error_message)

        assert str(exc_info.value) == error_message

    def test_given_security_error_when_catching_then_is_exception_instance(self):
        """
        Given: SecurityError exception
        When: Catching the exception
        Then: Is instance of Exception
        """
        # When
        try:
            raise SecurityError("Test error")
        except SecurityError as e:
            # Then
            assert isinstance(e, Exception)
            assert isinstance(e, SecurityError)

    def test_given_no_message_when_raising_security_error_then_creates_without_error(self):
        """
        Given: No error message
        When: Raising SecurityError without message
        Then: Exception is created successfully
        """
        # When/Then
        with pytest.raises(SecurityError):
            raise SecurityError()

    def test_given_complex_error_when_raising_security_error_then_preserves_context(self):
        """
        Given: Complex error message with details
        When: Raising SecurityError with detailed message
        Then: Preserves all error context
        """
        # Given
        error_details = {
            "user": "test@example.com",
            "action": "read",
            "resource": "sensitive-pattern-123",
        }
        error_message = f"Access denied: {error_details}"

        # When/Then
        with pytest.raises(SecurityError) as exc_info:
            raise SecurityError(error_message)

        assert "test@example.com" in str(exc_info.value)
        assert "sensitive-pattern-123" in str(exc_info.value)


class TestPermissionError:
    """Behavioral tests for PermissionError exception."""

    def test_given_error_message_when_raising_permission_error_then_contains_message(self):
        """
        Given: Error message string
        When: Raising PermissionError
        Then: Exception contains the message
        """
        # Given
        error_message = "Access denied: insufficient permissions"

        # When/Then
        with pytest.raises(PermissionError) as exc_info:
            raise PermissionError(error_message)

        assert str(exc_info.value) == error_message

    def test_given_permission_error_when_catching_then_is_exception_instance(self):
        """
        Given: PermissionError exception
        When: Catching the exception
        Then: Is instance of Exception
        """
        # When
        try:
            raise PermissionError("Test permission error")
        except PermissionError as e:
            # Then
            assert isinstance(e, Exception)
            assert isinstance(e, PermissionError)

    def test_given_no_message_when_raising_permission_error_then_creates_without_error(self):
        """
        Given: No error message
        When: Raising PermissionError without message
        Then: Exception is created successfully
        """
        # When/Then
        with pytest.raises(PermissionError):
            raise PermissionError()

    def test_given_user_context_when_raising_permission_error_then_includes_user_info(self):
        """
        Given: User context in error message
        When: Raising PermissionError with user details
        Then: Exception includes user information
        """
        # Given
        user_id = "user-456"
        resource_id = "pattern-789"
        error_message = f"User {user_id} lacks permission to access {resource_id}"

        # When/Then
        with pytest.raises(PermissionError) as exc_info:
            raise PermissionError(error_message)

        assert user_id in str(exc_info.value)
        assert resource_id in str(exc_info.value)

    def test_given_both_errors_when_comparing_then_are_different_types(self):
        """
        Given: SecurityError and PermissionError
        When: Comparing exception types
        Then: They are distinct types
        """
        # When
        security_error = SecurityError("security")
        permission_error = PermissionError("permission")

        # Then
        assert type(security_error) is not type(permission_error)
        assert not isinstance(security_error, PermissionError)
        assert not isinstance(permission_error, SecurityError)


class TestIntegration:
    """Integration tests combining multiple types."""

    def test_given_classification_when_creating_full_pattern_workflow_then_all_components_work(
        self,
    ):
        """
        Given: Classification level
        When: Creating a complete pattern with rules and metadata
        Then: All components work together correctly
        """
        # Given
        classification = Classification.SENSITIVE
        rules = DEFAULT_CLASSIFICATION_RULES[classification]

        # When
        metadata = PatternMetadata(
            pattern_id="integration-001",
            created_by="integration@example.com",
            created_at="2025-01-20T15:00:00Z",
            classification=classification.value,
            retention_days=rules.retention_days,
            encrypted=rules.encryption_required,
            pattern_type="integration_test",
            sanitization_applied=True,
            pii_removed=5,
            secrets_detected=1,
            access_control={"access_level": rules.access_level},
            custom_metadata={"audit": rules.audit_all_access},
        )

        secure_pattern = SecurePattern(
            pattern_id="integration-001",
            content="encrypted_sensitive_data",
            metadata=metadata,
        )

        # Then
        assert secure_pattern.metadata.classification == "SENSITIVE"
        assert secure_pattern.metadata.encrypted is True
        assert secure_pattern.metadata.retention_days == 90
        assert secure_pattern.metadata.access_control["access_level"] == "explicit_permission"
        assert secure_pattern.metadata.custom_metadata["audit"] is True

    def test_given_public_classification_when_creating_pattern_then_matches_public_rules(self):
        """
        Given: PUBLIC classification
        When: Creating pattern with public rules
        Then: Pattern matches public security configuration
        """
        # Given
        classification = Classification.PUBLIC
        rules = DEFAULT_CLASSIFICATION_RULES[classification]

        # When
        metadata = PatternMetadata(
            pattern_id="public-001",
            created_by="public@example.com",
            created_at="2025-01-20T16:00:00Z",
            classification=classification.value,
            retention_days=rules.retention_days,
            encrypted=rules.encryption_required,
            pattern_type="public_data",
            sanitization_applied=True,
            pii_removed=0,
            secrets_detected=0,
        )

        secure_pattern = SecurePattern(
            pattern_id="public-001",
            content="public information",
            metadata=metadata,
        )

        # Then
        assert secure_pattern.metadata.encrypted is False
        assert secure_pattern.metadata.retention_days == 365
        assert rules.access_level == "all_users"
        assert rules.audit_all_access is False

    def test_given_invalid_access_when_validating_permissions_then_raises_permission_error(self):
        """
        Given: User without required permissions
        When: Attempting to access sensitive pattern
        Then: Raises PermissionError
        """

        # Given
        def validate_access(user_role: str, required_level: str):
            if user_role != required_level:
                raise PermissionError(
                    f"User role '{user_role}' does not match required level '{required_level}'"
                )

        # When/Then
        with pytest.raises(PermissionError) as exc_info:
            validate_access("guest", "explicit_permission")

        assert "guest" in str(exc_info.value)
        assert "explicit_permission" in str(exc_info.value)

    def test_given_security_violation_when_checking_encryption_then_raises_security_error(self):
        """
        Given: Sensitive data without encryption
        When: Validating security requirements
        Then: Raises SecurityError
        """

        # Given
        def validate_security(metadata: PatternMetadata, rules: ClassificationRules):
            if rules.encryption_required and not metadata.encrypted:
                raise SecurityError(
                    f"Pattern {metadata.pattern_id} requires encryption but is not encrypted"
                )

        metadata = PatternMetadata(
            pattern_id="security-violation-001",
            created_by="test@example.com",
            created_at="2025-01-20T17:00:00Z",
            classification="SENSITIVE",
            retention_days=90,
            encrypted=False,  # Should be True for SENSITIVE
            pattern_type="violation",
            sanitization_applied=False,
            pii_removed=0,
            secrets_detected=0,
        )

        rules = DEFAULT_CLASSIFICATION_RULES[Classification.SENSITIVE]

        # When/Then
        with pytest.raises(SecurityError) as exc_info:
            validate_security(metadata, rules)

        assert "security-violation-001" in str(exc_info.value)
        assert "encryption" in str(exc_info.value).lower()
