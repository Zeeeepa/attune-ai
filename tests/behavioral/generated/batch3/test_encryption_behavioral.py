"""Behavioral tests for encryption.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import base64
import os
from pathlib import Path
from unittest.mock import Mock, patch

import pytest

from empathy_os.memory.encryption import HAS_ENCRYPTION, EncryptionManager
from empathy_os.memory.long_term_types import SecurityError


@pytest.fixture
def master_key():
    """Provide a valid 32-byte master key for testing."""
    return b"0" * 32


@pytest.fixture
def encryption_manager(master_key):
    """Provide an EncryptionManager instance with a test key."""
    if not HAS_ENCRYPTION:
        pytest.skip("cryptography library not available")
    return EncryptionManager(master_key=master_key)


@pytest.fixture
def encryption_manager_no_crypto():
    """Provide an EncryptionManager when cryptography is not available."""
    with patch("empathy_os.memory.encryption.HAS_ENCRYPTION", False):
        return EncryptionManager()


class TestEncryptionManagerInitialization:
    """Tests for EncryptionManager initialization behavior."""

    def test_given_cryptography_unavailable_when_initialized_then_encryption_disabled(
        self,
    ):
        """GIVEN cryptography library is not available
        WHEN EncryptionManager is initialized
        THEN encryption should be disabled
        """
        with patch("empathy_os.memory.encryption.HAS_ENCRYPTION", False):
            manager = EncryptionManager()
            assert manager.enabled is False

    def test_given_master_key_provided_when_initialized_then_uses_provided_key(
        self, master_key
    ):
        """GIVEN a master key is provided
        WHEN EncryptionManager is initialized
        THEN it should use the provided key
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        manager = EncryptionManager(master_key=master_key)
        assert manager.enabled is True
        assert manager.master_key == master_key

    def test_given_no_master_key_when_initialized_then_loads_or_generates_key(self):
        """GIVEN no master key is provided
        WHEN EncryptionManager is initialized
        THEN it should load or generate a key
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        with patch.object(
            EncryptionManager, "_load_or_generate_key", return_value=b"0" * 32
        ) as mock_load:
            manager = EncryptionManager()
            mock_load.assert_called_once()
            assert manager.enabled is True


class TestLoadOrGenerateKey:
    """Tests for master key loading and generation behavior."""

    def test_given_valid_env_key_when_loading_then_returns_decoded_key(self):
        """GIVEN EMPATHY_MASTER_KEY environment variable is set with valid base64
        WHEN loading key
        THEN it should return the decoded key
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        test_key = b"0" * 32
        encoded_key = base64.b64encode(test_key).decode()

        with patch.dict(os.environ, {"EMPATHY_MASTER_KEY": encoded_key}):
            manager = EncryptionManager()
            assert manager.master_key == test_key

    def test_given_invalid_env_key_when_loading_then_raises_value_error(self):
        """GIVEN EMPATHY_MASTER_KEY has invalid base64
        WHEN loading key
        THEN it should raise ValueError
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        with patch.dict(os.environ, {"EMPATHY_MASTER_KEY": "invalid!base64"}):
            with pytest.raises(ValueError, match="Invalid EMPATHY_MASTER_KEY format"):
                EncryptionManager()

    def test_given_key_file_exists_when_loading_then_reads_from_file(self):
        """GIVEN a master key file exists
        WHEN loading key
        THEN it should read the key from the file
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        test_key = b"0" * 32
        mock_path = Mock(spec=Path)
        mock_path.exists.return_value = True
        mock_path.read_bytes.return_value = test_key

        with patch.dict(os.environ, {}, clear=True):
            with patch("empathy_os.memory.encryption.Path.home") as mock_home:
                mock_home.return_value.__truediv__.return_value.__truediv__.return_value = (
                    mock_path
                )
                manager = EncryptionManager()
                assert manager.master_key == test_key

    def test_given_key_file_read_fails_when_loading_then_generates_ephemeral_key(self):
        """GIVEN key file exists but cannot be read
        WHEN loading key
        THEN it should generate an ephemeral key
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        mock_path = Mock(spec=Path)
        mock_path.exists.return_value = True
        mock_path.read_bytes.side_effect = PermissionError("No access")

        with patch.dict(os.environ, {}, clear=True):
            with patch("empathy_os.memory.encryption.Path.home") as mock_home:
                mock_home.return_value.__truediv__.return_value.__truediv__.return_value = (
                    mock_path
                )
                manager = EncryptionManager()
                assert manager.enabled is True
                assert len(manager.master_key) == 32

    def test_given_no_key_found_when_loading_then_generates_ephemeral_key(self):
        """GIVEN no environment variable or key file exists
        WHEN loading key
        THEN it should generate an ephemeral key
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        mock_path = Mock(spec=Path)
        mock_path.exists.return_value = False

        with patch.dict(os.environ, {}, clear=True):
            with patch("empathy_os.memory.encryption.Path.home") as mock_home:
                mock_home.return_value.__truediv__.return_value.__truediv__.return_value = (
                    mock_path
                )
                manager = EncryptionManager()
                assert manager.enabled is True
                assert len(manager.master_key) == 32


class TestEncryptMethod:
    """Tests for encryption functionality."""

    def test_given_valid_plaintext_when_encrypted_then_returns_base64_string(
        self, encryption_manager
    ):
        """GIVEN valid plaintext
        WHEN encrypt is called
        THEN it should return a base64-encoded string
        """
        plaintext = "sensitive data"
        ciphertext = encryption_manager.encrypt(plaintext)

        assert isinstance(ciphertext, str)
        # Verify it's valid base64
        try:
            base64.b64decode(ciphertext)
        except Exception:
            pytest.fail("Ciphertext is not valid base64")

    def test_given_empty_string_when_encrypted_then_returns_encrypted_string(
        self, encryption_manager
    ):
        """GIVEN an empty string
        WHEN encrypt is called
        THEN it should return an encrypted string
        """
        plaintext = ""
        ciphertext = encryption_manager.encrypt(plaintext)

        assert isinstance(ciphertext, str)
        assert len(ciphertext) > 0

    def test_given_unicode_text_when_encrypted_then_handles_correctly(
        self, encryption_manager
    ):
        """GIVEN text with unicode characters
        WHEN encrypt is called
        THEN it should handle encoding correctly
        """
        plaintext = "Hello ä¸–ç•Œ ðŸŒ"
        ciphertext = encryption_manager.encrypt(plaintext)

        assert isinstance(ciphertext, str)
        assert len(ciphertext) > 0

    def test_given_encryption_disabled_when_encrypt_called_then_raises_security_error(
        self,
    ):
        """GIVEN encryption is disabled
        WHEN encrypt is called
        THEN it should raise SecurityError
        """
        with patch("empathy_os.memory.encryption.HAS_ENCRYPTION", False):
            manager = EncryptionManager()
            with pytest.raises(SecurityError, match="Encryption not available"):
                manager.encrypt("test")

    def test_given_same_plaintext_when_encrypted_twice_then_produces_different_ciphertexts(
        self, encryption_manager
    ):
        """GIVEN the same plaintext
        WHEN encrypted twice
        THEN it should produce different ciphertexts (due to random nonce)
        """
        plaintext = "sensitive data"
        ciphertext1 = encryption_manager.encrypt(plaintext)
        ciphertext2 = encryption_manager.encrypt(plaintext)

        assert ciphertext1 != ciphertext2

    def test_given_large_plaintext_when_encrypted_then_handles_correctly(
        self, encryption_manager
    ):
        """GIVEN a large plaintext
        WHEN encrypt is called
        THEN it should handle it correctly
        """
        plaintext = "x" * 10000
        ciphertext = encryption_manager.encrypt(plaintext)

        assert isinstance(ciphertext, str)
        assert len(ciphertext) > 0


class TestDecryptMethod:
    """Tests for decryption functionality."""

    def test_given_valid_ciphertext_when_decrypted_then_returns_original_plaintext(
        self, encryption_manager
    ):
        """GIVEN a valid ciphertext
        WHEN decrypt is called
        THEN it should return the original plaintext
        """
        plaintext = "sensitive data"
        ciphertext = encryption_manager.encrypt(plaintext)
        decrypted = encryption_manager.decrypt(ciphertext)

        assert decrypted == plaintext

    def test_given_empty_string_encrypted_when_decrypted_then_returns_empty_string(
        self, encryption_manager
    ):
        """GIVEN an encrypted empty string
        WHEN decrypt is called
        THEN it should return an empty string
        """
        plaintext = ""
        ciphertext = encryption_manager.encrypt(plaintext)
        decrypted = encryption_manager.decrypt(ciphertext)

        assert decrypted == ""

    def test_given_unicode_encrypted_when_decrypted_then_returns_original_unicode(
        self, encryption_manager
    ):
        """GIVEN encrypted unicode text
        WHEN decrypt is called
        THEN it should return the original unicode text
        """
        plaintext = "Hello ä¸–ç•Œ ðŸŒ"
        ciphertext = encryption_manager.encrypt(plaintext)
        decrypted = encryption_manager.decrypt(ciphertext)

        assert decrypted == plaintext

    def test_given_invalid_ciphertext_when_decrypted_then_raises_security_error(
        self, encryption_manager
    ):
        """GIVEN invalid ciphertext
        WHEN decrypt is called
        THEN it should raise SecurityError
        """
        invalid_ciphertext = base64.b64encode(b"invalid data").decode()

        with pytest.raises(SecurityError, match="Decryption failed"):
            encryption_manager.decrypt(invalid_ciphertext)

    def test_given_tampered_ciphertext_when_decrypted_then_raises_security_error(
        self, encryption_manager
    ):
        """GIVEN tampered ciphertext (GCM authentication fails)
        WHEN decrypt is called
        THEN it should raise SecurityError
        """
        plaintext = "sensitive data"
        ciphertext = encryption_manager.encrypt(plaintext)

        # Tamper with the ciphertext
        decoded = base64.b64decode(ciphertext)
        tampered = decoded[:-1] + b"X"
        tampered_b64 = base64.b64encode(tampered).decode()

        with pytest.raises(SecurityError, match="Decryption failed"):
            encryption_manager.decrypt(tampered_b64)

    def test_given_malformed_base64_when_decrypted_then_raises_security_error(
        self, encryption_manager
    ):
        """GIVEN malformed base64 ciphertext
        WHEN decrypt is called
        THEN it should raise SecurityError
        """
        malformed_ciphertext = "not!valid!base64"

        with pytest.raises(SecurityError, match="Invalid ciphertext format"):
            encryption_manager.decrypt(malformed_ciphertext)

    def test_given_encryption_disabled_when_decrypt_called_then_raises_security_error(
        self,
    ):
        """GIVEN encryption is disabled
        WHEN decrypt is called
        THEN it should raise SecurityError
        """
        with patch("empathy_os.memory.encryption.HAS_ENCRYPTION", False):
            manager = EncryptionManager()
            with pytest.raises(SecurityError, match="Encryption not available"):
                manager.decrypt("test")

    def test_given_wrong_key_when_decrypted_then_raises_security_error(self):
        """GIVEN ciphertext encrypted with different key
        WHEN decrypt is called with wrong key
        THEN it should raise SecurityError
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        manager1 = EncryptionManager(master_key=b"0" * 32)
        manager2 = EncryptionManager(master_key=b"1" * 32)

        plaintext = "sensitive data"
        ciphertext = manager1.encrypt(plaintext)

        with pytest.raises(SecurityError, match="Decryption failed"):
            manager2.decrypt(ciphertext)

    def test_given_truncated_ciphertext_when_decrypted_then_raises_security_error(
        self, encryption_manager
    ):
        """GIVEN truncated ciphertext (missing nonce or tag)
        WHEN decrypt is called
        THEN it should raise SecurityError
        """
        plaintext = "sensitive data"
        ciphertext = encryption_manager.encrypt(plaintext)

        # Truncate ciphertext
        decoded = base64.b64decode(ciphertext)
        truncated = decoded[:10]
        truncated_b64 = base64.b64encode(truncated).decode()

        with pytest.raises(SecurityError, match="Decryption failed"):
            encryption_manager.decrypt(truncated_b64)


class TestRoundTripEncryption:
    """Tests for encrypt/decrypt round-trip behavior."""

    def test_given_multiple_values_when_encrypted_and_decrypted_then_all_match(
        self, encryption_manager
    ):
        """GIVEN multiple different plaintexts
        WHEN encrypted and then decrypted
        THEN all should match their originals
        """
        plaintexts = [
            "simple text",
            "text with spaces and punctuation!",
            "unicode: æ—¥æœ¬èªž",
            "emoji: ðŸ˜€ðŸŽ‰",
            "numbers: 1234567890",
            "special chars: !@#$%^&*()",
            "",
            "a" * 1000,
        ]

        for plaintext in plaintexts:
            ciphertext = encryption_manager.encrypt(plaintext)
            decrypted = encryption_manager.decrypt(ciphertext)
            assert decrypted == plaintext, f"Failed for: {plaintext}"

    def test_given_whitespace_variations_when_encrypted_and_decrypted_then_preserves_whitespace(
        self, encryption_manager
    ):
        """GIVEN text with various whitespace
        WHEN encrypted and decrypted
        THEN whitespace should be preserved
        """
        plaintexts = [
            "  leading spaces",
            "trailing spaces  ",
            "  both  ",
            "multiple\n\nlines\n",
            "\t\ttabs\t\t",
            "mixed \t\n whitespace",
        ]

        for plaintext in plaintexts:
            ciphertext = encryption_manager.encrypt(plaintext)
            decrypted = encryption_manager.decrypt(ciphertext)
            assert decrypted == plaintext


class TestSecurityBehavior:
    """Tests for security-related behaviors."""

    def test_given_manager_when_inspecting_key_then_key_not_in_repr(
        self, encryption_manager
    ):
        """GIVEN an EncryptionManager instance
        WHEN converting to string representation
        THEN the master key should not be exposed
        """
        repr_str = repr(encryption_manager)
        str_str = str(encryption_manager)

        # Ensure key is not accidentally exposed in string representations
        assert encryption_manager.master_key.hex() not in repr_str
        assert encryption_manager.master_key.hex() not in str_str

    def test_given_invalid_key_length_when_initializing_then_handles_gracefully(self):
        """GIVEN a master key with wrong length
        WHEN initializing EncryptionManager
        THEN it should handle it appropriately (likely fail on first encrypt)
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        # AES-256 requires 32 bytes, provide 16
        short_key = b"0" * 16
        manager = EncryptionManager(master_key=short_key)

        # Should fail when trying to use the key
        with pytest.raises(Exception):  # Could be ValueError or similar
            manager.encrypt("test")


class TestEdgeCases:
    """Tests for edge cases and unusual inputs."""

    def test_given_very_long_plaintext_when_encrypted_then_handles_correctly(
        self, encryption_manager
    ):
        """GIVEN very long plaintext (>1MB)
        WHEN encrypt is called
        THEN it should handle it correctly
        """
        plaintext = "x" * (1024 * 1024)  # 1MB
        ciphertext = encryption_manager.encrypt(plaintext)
        decrypted = encryption_manager.decrypt(ciphertext)

        assert decrypted == plaintext

    def test_given_binary_like_text_when_encrypted_then_handles_correctly(
        self, encryption_manager
    ):
        """GIVEN text that looks like binary data
        WHEN encrypted and decrypted
        THEN it should preserve the content
        """
        plaintext = "\x00\x01\x02\xff\xfe"
        ciphertext = encryption_manager.encrypt(plaintext)
        decrypted = encryption_manager.decrypt(ciphertext)

        assert decrypted == plaintext

    def test_given_newline_variations_when_encrypted_then_preserves_format(
        self, encryption_manager
    ):
        """GIVEN text with different newline styles
        WHEN encrypted and decrypted
        THEN newline format should be preserved
        """
        plaintexts = ["unix\nstyle", "windows\r\nstyle", "old\rmac\rstyle"]

        for plaintext in plaintexts:
            ciphertext = encryption_manager.encrypt(plaintext)
            decrypted = encryption_manager.decrypt(ciphertext)
            assert decrypted == plaintext


class TestLoggingBehavior:
    """Tests for logging behavior."""

    def test_given_no_cryptography_when_initialized_then_logs_warning(self):
        """GIVEN cryptography library is not available
        WHEN EncryptionManager is initialized
        THEN it should log a warning
        """
        with patch("empathy_os.memory.encryption.HAS_ENCRYPTION", False):
            with patch("empathy_os.memory.encryption.logger") as mock_logger:
                EncryptionManager()
                mock_logger.warning.assert_called_once()

    def test_given_no_master_key_when_generating_ephemeral_then_logs_warning(self):
        """GIVEN no master key is found
        WHEN generating ephemeral key
        THEN it should log a warning
        """
        if not HAS_ENCRYPTION:
            pytest.skip("cryptography library not available")

        mock_path = Mock(spec=Path)
        mock_path.exists.return_value = False

        with patch.dict(os.environ, {}, clear=True):
            with patch("empathy_os.memory.encryption.Path.home") as mock_home:
                with patch("empathy_os.memory.encryption.logger") as mock_logger:
                    mock_home.return_value.__truediv__.return_value.__truediv__.return_value = (
                        mock_path
                    )
                    EncryptionManager()
                    # Check that warning was logged about ephemeral key
                    assert any(
                        call[0][0] == "no_master_key_found"
                        for call in mock_logger.warning.call_args_list
                    )


class TestCryptographyIntegration:
    """Tests for cryptography library integration."""

    def test_given_cryptography_available_when_checking_then_returns_true(self):
        """GIVEN cryptography library is installed
        WHEN checking HAS_ENCRYPTION
        THEN it should be True
        """
        # This test assumes cryptography is installed
        # In CI/CD, ensure cryptography is in test dependencies
        if HAS_ENCRYPTION:
            assert HAS_ENCRYPTION is True
        else:
            pytest.skip("cryptography library not available")

    def test_given_aesgcm_when_encrypting_then_uses_correct_nonce_size(
        self, encryption_manager
    ):
        """GIVEN AES-GCM encryption
        WHEN encrypting data
        THEN it should use proper nonce size (12 bytes for GCM)
        """
        plaintext = "test data"
        ciphertext = encryption_manager.encrypt(plaintext)

        # Decode and check structure (nonce should be first 12 bytes)
        decoded = base64.b64decode(ciphertext)
        assert len(decoded) >= 12, "Ciphertext should include nonce"
