"""Behavioral tests for simple_storage.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from attune.memory.long_term_types import Classification
from attune.memory.simple_storage import LongTermMemory


@pytest.fixture
def temp_storage_path(tmp_path):
    """Provide a temporary storage path for testing."""
    storage_dir = tmp_path / "test_storage"
    return str(storage_dir)


@pytest.fixture
def memory_instance(temp_storage_path):
    """Provide a LongTermMemory instance with temporary storage."""
    return LongTermMemory(storage_path=temp_storage_path)


@pytest.fixture
def mock_logger():
    """Provide a mocked logger."""
    with patch("attune.memory.simple_storage.logger") as mock_log:
        yield mock_log


class TestLongTermMemoryInit:
    """Test LongTermMemory initialization behavior."""

    def test_given_valid_path_when_init_then_creates_directory(self, temp_storage_path):
        """Given a valid storage path, when initializing, then creates the directory."""
        # Given
        storage_path = temp_storage_path

        # When
        memory = LongTermMemory(storage_path=storage_path)

        # Then
        assert memory.storage_path == Path(storage_path)
        assert memory.storage_path.exists()
        assert memory.storage_path.is_dir()

    def test_given_nested_path_when_init_then_creates_parent_directories(self, tmp_path):
        """Given a nested path, when initializing, then creates all parent directories."""
        # Given
        nested_path = tmp_path / "level1" / "level2" / "storage"

        # When
        memory = LongTermMemory(storage_path=str(nested_path))

        # Then
        assert memory.storage_path.exists()
        assert memory.storage_path.is_dir()

    def test_given_existing_directory_when_init_then_reuses_directory(self, temp_storage_path):
        """Given an existing directory, when initializing, then reuses the directory."""
        # Given
        Path(temp_storage_path).mkdir(parents=True, exist_ok=True)

        # When
        memory = LongTermMemory(storage_path=temp_storage_path)

        # Then
        assert memory.storage_path.exists()
        assert memory.storage_path.is_dir()

    def test_given_default_path_when_init_then_uses_default_location(self):
        """Given no path specified, when initializing, then uses default location."""
        # Given/When
        with patch("attune.memory.simple_storage.Path") as mock_path:
            mock_path_instance = MagicMock()
            mock_path.return_value = mock_path_instance
            memory = LongTermMemory()

        # Then
        mock_path.assert_called_once_with("./long_term_storage")

    def test_given_init_when_called_then_logs_initialization(self, temp_storage_path, mock_logger):
        """Given initialization, when called, then logs the event."""
        # Given/When
        memory = LongTermMemory(storage_path=temp_storage_path)

        # Then
        mock_logger.info.assert_called_with(
            "long_term_memory_initialized", storage_path=str(memory.storage_path)
        )


class TestLongTermMemoryStore:
    """Test LongTermMemory store behavior."""

    def test_given_valid_data_when_store_then_saves_to_file(self, memory_instance):
        """Given valid data, when storing, then saves to JSON file."""
        # Given
        key = "test_key"
        data = {"value": "test"}

        # When
        result = memory_instance.store(key, data)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        assert file_path.exists()
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["data"] == data

    def test_given_empty_key_when_store_then_raises_value_error(self, memory_instance):
        """Given an empty key, when storing, then raises ValueError."""
        # Given
        key = ""
        data = {"value": "test"}

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.store(key, data)

    def test_given_whitespace_key_when_store_then_raises_value_error(self, memory_instance):
        """Given a whitespace-only key, when storing, then raises ValueError."""
        # Given
        key = "   "
        data = {"value": "test"}

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.store(key, data)

    def test_given_classification_when_store_then_saves_classification(self, memory_instance):
        """Given a classification, when storing, then saves with classification."""
        # Given
        key = "classified_key"
        data = {"value": "secret"}
        classification = "SENSITIVE"

        # When
        result = memory_instance.store(key, data, classification=classification)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["classification"] == classification

    def test_given_classification_enum_when_store_then_saves_classification(self, memory_instance):
        """Given a Classification enum, when storing, then saves classification."""
        # Given
        key = "enum_key"
        data = {"value": "internal"}
        classification = Classification.INTERNAL

        # When
        result = memory_instance.store(key, data, classification=classification)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["classification"] == "INTERNAL"

    def test_given_no_classification_when_store_then_defaults_to_internal(self, memory_instance):
        """Given no classification, when storing, then defaults to INTERNAL."""
        # Given
        key = "default_key"
        data = {"value": "data"}

        # When
        memory_instance.store(key, data)

        # Then
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["classification"] == "INTERNAL"

    def test_given_complex_data_when_store_then_serializes_correctly(self, memory_instance):
        """Given complex data structures, when storing, then serializes correctly."""
        # Given
        key = "complex_key"
        data = {
            "nested": {"level": 2},
            "list": [1, 2, 3],
            "string": "text",
            "number": 42,
            "boolean": True,
            "null": None,
        }

        # When
        result = memory_instance.store(key, data)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["data"] == data

    def test_given_non_serializable_data_when_store_then_raises_type_error(self, memory_instance):
        """Given non-JSON-serializable data, when storing, then raises TypeError."""
        # Given
        key = "bad_key"
        data = {"function": lambda x: x}

        # When/Then
        with pytest.raises(TypeError):
            memory_instance.store(key, data)

    def test_given_existing_key_when_store_then_overwrites(self, memory_instance):
        """Given an existing key, when storing new data, then overwrites."""
        # Given
        key = "overwrite_key"
        old_data = {"value": "old"}
        new_data = {"value": "new"}
        memory_instance.store(key, old_data)

        # When
        result = memory_instance.store(key, new_data)

        # Then
        assert result is True
        retrieved = memory_instance.retrieve(key)
        assert retrieved == new_data

    def test_given_store_when_called_then_includes_timestamp(self, memory_instance):
        """Given store operation, when called, then includes timestamp."""
        # Given
        key = "timestamp_key"
        data = {"value": "test"}

        # When
        memory_instance.store(key, data)

        # Then
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        # Implementation uses created_at and updated_at instead of timestamp
        assert "created_at" in saved_data
        assert "updated_at" in saved_data
        # Verify timestamps are valid ISO format
        datetime.fromisoformat(saved_data["created_at"].replace("Z", ""))
        datetime.fromisoformat(saved_data["updated_at"].replace("Z", ""))

    def test_given_path_validation_enabled_when_store_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when storing with invalid key, then returns False."""
        # Given
        key = "../../../etc/passwd"
        data = {"value": "malicious"}

        # When - Implementation does path validation internally and returns False
        result = memory_instance.store(key, data)

        # Then - Returns False for path traversal attempts
        assert result is False

    def test_given_io_error_when_store_then_returns_false(self, memory_instance):
        """Given an IO error, when storing, then returns False."""
        # Given
        key = "io_error_key"
        data = {"value": "test"}

        # When - Mock Path.open to raise OSError
        with patch("pathlib.Path.open", side_effect=OSError("Disk full")):
            result = memory_instance.store(key, data)

        # Then
        assert result is False


class TestLongTermMemoryRetrieve:
    """Test LongTermMemory retrieve behavior."""

    def test_given_existing_key_when_retrieve_then_returns_data(self, memory_instance):
        """Given an existing key, when retrieving, then returns stored data."""
        # Given
        key = "retrieve_key"
        data = {"value": "test", "number": 42}
        memory_instance.store(key, data)

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result == data

    def test_given_nonexistent_key_when_retrieve_then_returns_none(self, memory_instance):
        """Given a nonexistent key, when retrieving, then returns None."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_empty_key_when_retrieve_then_raises_value_error(self, memory_instance):
        """Given an empty key, when retrieving, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.retrieve(key)

    def test_given_corrupted_file_when_retrieve_then_returns_none(self, memory_instance):
        """Given a corrupted JSON file, when retrieving, then returns None."""
        # Given
        key = "corrupted_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text("invalid json content")

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_file_without_data_field_when_retrieve_then_returns_none(self, memory_instance):
        """Given a file without data field, when retrieving, then returns None."""
        # Given
        key = "no_data_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text(json.dumps({"classification": "PUBLIC"}))

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_path_validation_when_retrieve_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when retrieving with invalid key, then returns None."""
        # Given
        key = "../../../etc/passwd"

        # When - Implementation doesn't validate on retrieve, just checks if file exists
        result = memory_instance.retrieve(key)

        # Then - Returns None for nonexistent files
        assert result is None

    def test_given_permission_error_when_retrieve_then_returns_none(self, memory_instance):
        """Given a permission error, when retrieving, then returns None."""
        # Given
        key = "permission_key"
        memory_instance.store(key, {"value": "test"})

        # When - Mock Path.open to raise PermissionError
        with patch("pathlib.Path.open", side_effect=PermissionError("Access denied")):
            result = memory_instance.retrieve(key)

        # Then
        assert result is None


class TestLongTermMemoryDelete:
    """Test LongTermMemory delete behavior."""

    def test_given_existing_key_when_delete_then_removes_file(self, memory_instance):
        """Given an existing key, when deleting, then removes the file."""
        # Given
        key = "delete_key"
        memory_instance.store(key, {"value": "test"})
        file_path = memory_instance.storage_path / f"{key}.json"
        assert file_path.exists()

        # When
        result = memory_instance.delete(key)

        # Then
        assert result is True
        assert not file_path.exists()

    def test_given_nonexistent_key_when_delete_then_returns_false(self, memory_instance):
        """Given a nonexistent key, when deleting, then returns False."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.delete(key)

        # Then
        assert result is False

    def test_given_empty_key_when_delete_then_raises_value_error(self, memory_instance):
        """Given an empty key, when deleting, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.delete(key)

    def test_given_path_validation_when_delete_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when deleting with invalid key, then returns False."""
        # Given
        key = "../../../etc/passwd"

        # When - Implementation doesn't validate on delete, just checks if file exists
        result = memory_instance.delete(key)

        # Then - Returns False for nonexistent files
        assert result is False

    def test_given_permission_error_when_delete_then_returns_false(self, memory_instance):
        """Given a permission error, when deleting, then returns False."""
        # Given
        key = "permission_key"
        memory_instance.store(key, {"value": "test"})

        # When
        with patch("pathlib.Path.unlink", side_effect=PermissionError("Access denied")):
            result = memory_instance.delete(key)

        # Then
        assert result is False


class TestLongTermMemoryListKeys:
    """Test LongTermMemory list_keys behavior."""

    def test_given_no_files_when_list_keys_then_returns_empty_list(self, memory_instance):
        """Given no stored files, when listing keys, then returns empty list."""
        # Given/When
        result = memory_instance.list_keys()

        # Then
        assert result == []

    def test_given_multiple_files_when_list_keys_then_returns_all_keys(self, memory_instance):
        """Given multiple stored files, when listing keys, then returns all keys."""
        # Given
        keys = ["key1", "key2", "key3"]
        for key in keys:
            memory_instance.store(key, {"value": key})

        # When
        result = memory_instance.list_keys()

        # Then
        assert set(result) == set(keys)

    def test_given_classification_filter_when_list_keys_then_filters_by_classification(
        self, memory_instance
    ):
        """Given a classification filter, when listing keys, then returns filtered keys."""
        # Given
        memory_instance.store("public_key", {"value": "public"}, "PUBLIC")
        memory_instance.store("internal_key", {"value": "internal"}, "INTERNAL")
        memory_instance.store("sensitive_key", {"value": "sensitive"}, "SENSITIVE")

        # When
        result = memory_instance.list_keys(classification="INTERNAL")

        # Then
        assert result == ["internal_key"]

    def test_given_classification_enum_when_list_keys_then_filters_correctly(self, memory_instance):
        """Given a Classification enum, when listing keys, then filters correctly."""
        # Given
        memory_instance.store("public_key", {"value": "public"}, Classification.PUBLIC)
        memory_instance.store("internal_key", {"value": "internal"}, Classification.INTERNAL)

        # When
        result = memory_instance.list_keys(classification=Classification.PUBLIC)

        # Then
        assert result == ["public_key"]

    def test_given_no_matching_classification_when_list_keys_then_returns_empty_list(
        self, memory_instance
    ):
        """Given no matching classification, when listing keys, then returns empty list."""
        # Given
        memory_instance.store("key1", {"value": "test"}, "PUBLIC")

        # When
        result = memory_instance.list_keys(classification="SENSITIVE")

        # Then
        assert result == []

    def test_given_non_json_files_when_list_keys_then_ignores_them(self, memory_instance):
        """Given non-JSON files in directory, when listing keys, then ignores them."""
        # Given
        memory_instance.store("valid_key", {"value": "test"})
        (memory_instance.storage_path / "file.txt").write_text("not json")
        (memory_instance.storage_path / "no_extension").write_text("also not json")

        # When
        result = memory_instance.list_keys()

        # Then
        assert result == ["valid_key"]

    def test_given_corrupted_json_when_list_keys_then_skips_corrupted_files(self, memory_instance):
        """Given corrupted JSON files, when listing keys, then skips them."""
        # Given
        memory_instance.store("valid_key", {"value": "test"})
        (memory_instance.storage_path / "corrupted.json").write_text("invalid json")

        # When
        result = memory_instance.list_keys()

        # Then
        assert result == ["valid_key"]

    def test_given_file_without_classification_when_list_keys_then_treats_as_internal(
        self, memory_instance
    ):
        """Given file without classification field, when listing keys, then skips it."""
        # Given
        key = "no_class_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        # File needs both 'key' and 'classification' fields to be found by list_keys
        file_path.write_text(json.dumps({"key": key, "data": {"value": "test"}}))

        # When - Files without classification field are skipped when filtering
        result = memory_instance.list_keys(classification="INTERNAL")

        # Then - Implementation filters by exact classification match, no default assumed
        assert key not in result

    def test_given_io_error_when_list_keys_then_returns_empty_list(self, memory_instance):
        """Given an IO error, when listing keys, then returns empty list."""
        # Given/When
        with patch("pathlib.Path.glob", side_effect=OSError("Disk error")):
            result = memory_instance.list_keys()

        # Then
        assert result == []


class TestLongTermMemoryExists:
    """Test LongTermMemory existence checking via retrieve behavior."""

    def test_given_existing_key_when_checking_existence_then_retrieve_returns_data(
        self, memory_instance
    ):
        """Given an existing key, when checking existence via retrieve, then returns data."""
        # Given
        key = "exists_key"
        data = {"value": "test"}
        memory_instance.store(key, data)

        # When - No exists() method, use retrieve() to check existence
        result = memory_instance.retrieve(key)

        # Then
        assert result is not None
        assert result == data

    def test_given_nonexistent_key_when_checking_existence_then_retrieve_returns_none(
        self, memory_instance
    ):
        """Given a nonexistent key, when checking existence via retrieve, then returns None."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_empty_key_when_checking_existence_then_raises_value_error(self, memory_instance):
        """Given an empty key, when checking existence via retrieve, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.retrieve(key)

    def test_given_invalid_key_when_checking_existence_then_returns_none(self, memory_instance):
        """Given an invalid key, when checking existence via retrieve, then returns None."""
        # Given
        key = "../../../etc/passwd"

        # When - Invalid path will not exist
        result = memory_instance.retrieve(key)

        # Then
        assert result is None


class TestLongTermMemoryGetClassification:
    """Test LongTermMemory classification via list_keys behavior."""

    def test_given_classified_key_when_listing_by_classification_then_finds_it(
        self, memory_instance
    ):
        """Given a classified key, when listing by classification, then finds it."""
        # Given
        key = "classified_key"
        classification = "SENSITIVE"
        memory_instance.store(key, {"value": "test"}, classification=classification)

        # When - No get_classification() method, use list_keys() to verify
        result = memory_instance.list_keys(classification=classification)

        # Then
        assert key in result

    def test_given_nonexistent_key_when_listing_keys_then_not_found(self, memory_instance):
        """Given a nonexistent key, when listing keys, then not found."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.list_keys()

        # Then
        assert key not in result

    def test_given_key_with_default_classification_when_listing_then_found_in_internal(
        self, memory_instance
    ):
        """Given key with default classification, when listing INTERNAL, then found."""
        # Given
        key = "default_class_key"
        memory_instance.store(key, {"value": "test"})  # No classification = INTERNAL default

        # When
        result = memory_instance.list_keys(classification="INTERNAL")

        # Then
        assert key in result

    def test_given_multiple_classifications_when_listing_then_filters_correctly(
        self, memory_instance
    ):
        """Given multiple classifications, when listing, then filters correctly."""
        # Given
        memory_instance.store("public_key", {"value": "p"}, "PUBLIC")
        memory_instance.store("internal_key", {"value": "i"}, "INTERNAL")
        memory_instance.store("sensitive_key", {"value": "s"}, "SENSITIVE")

        # When
        public_keys = memory_instance.list_keys(classification="PUBLIC")
        internal_keys = memory_instance.list_keys(classification="INTERNAL")
        sensitive_keys = memory_instance.list_keys(classification="SENSITIVE")

        # Then
        assert "public_key" in public_keys
        assert "public_key" not in internal_keys
        assert "public_key" not in sensitive_keys

    def test_given_corrupted_file_when_listing_keys_then_skips_it(self, memory_instance):
        """Given a corrupted file, when listing keys, then skips it."""
        # Given
        key = "corrupted_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text("invalid json")

        # When
        result = memory_instance.list_keys()

        # Then
        assert key not in result


class TestLongTermMemoryIntegration:
    """Integration tests for LongTermMemory."""

    def test_given_full_workflow_when_executed_then_all_operations_succeed(self, memory_instance):
        """Given a full workflow, when executed, then all operations succeed."""
        # Given
        key = "workflow_key"
        data = {"value": "test", "number": 42}
        classification = "INTERNAL"

        # When - Store
        store_result = memory_instance.store(key, data, classification=classification)

        # Then
        assert store_result is True

        # When - Check existence via retrieve
        retrieved_data = memory_instance.retrieve(key)

        # Then
        assert retrieved_data is not None
        assert retrieved_data == data

        # When - Verify classification via list_keys
        keys_with_classification = memory_instance.list_keys(classification=classification)

        # Then
        assert key in keys_with_classification

        # When - List all keys
        all_keys = memory_instance.list_keys()

        # Then
        assert key in all_keys

        # When - Delete
        delete_result = memory_instance.delete(key)

        # Then
        assert delete_result is True

        # Verify deleted by checking retrieve returns None
        assert memory_instance.retrieve(key) is None

    def test_given_multiple_classifications_when_stored_then_filters_correctly(
        self, memory_instance
    ):
        """Given multiple classifications, when stored, then filters correctly."""
        # Given
        test_data = [
            ("public1", {"value": "p1"}, "PUBLIC"),
            ("public2", {"value": "p2"}, "PUBLIC"),
            ("internal1", {"value": "i1"}, "INTERNAL"),
            ("internal2", {"value": "i2"}, "INTERNAL"),
            ("sensitive1", {"value": "s1"}, "SENSITIVE"),
        ]

        # When
        for key, data, classification in test_data:
            memory_instance.store(key, data, classification=classification)

        # Then
        public_keys = memory_instance.list_keys(classification="PUBLIC")
        assert set(public_keys) == {"public1", "public2"}

        internal_keys = memory_instance.list_keys(classification="INTERNAL")
        assert set(internal_keys) == {"internal1", "internal2"}

        sensitive_keys = memory_instance.list_keys(classification="SENSITIVE")
        assert set(sensitive_keys) == {"sensitive1"}

    def test_given_concurrent_operations_when_executed_then_maintains_consistency(
        self, memory_instance
    ):
        """Given concurrent-like operations, when executed, then maintains consistency."""
        # Given
        keys = [f"concurrent_key_{i}" for i in range(10)]

        # When - Store multiple
        for key in keys:
            memory_instance.store(key, {"value": key})

        # Then - All exist (verify via retrieve)
        for key in keys:
            assert memory_instance.retrieve(key) is not None

        # When - Delete half
        for key in keys[:5]:
            memory_instance.delete(key)

        # Then - Half remain
        remaining = memory_instance.list_keys()
        assert len(remaining) == 5
        assert all(key in remaining for key in keys[5:])
