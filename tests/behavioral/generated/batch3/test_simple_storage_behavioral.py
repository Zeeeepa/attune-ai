"""Behavioral tests for simple_storage.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from empathy_os.memory.long_term_types import Classification
from empathy_os.memory.simple_storage import LongTermMemory


@pytest.fixture
def temp_storage_path(tmp_path):
    """Provide a temporary storage path for testing."""
    storage_dir = tmp_path / "test_storage"
    return str(storage_dir)


@pytest.fixture
def memory_instance(temp_storage_path):
    """Provide a LongTermMemory instance with temporary storage."""
    return LongTermMemory(storage_path=temp_storage_path)


@pytest.fixture
def mock_logger():
    """Provide a mocked logger."""
    with patch("empathy_os.memory.simple_storage.logger") as mock_log:
        yield mock_log


class TestLongTermMemoryInit:
    """Test LongTermMemory initialization behavior."""

    def test_given_valid_path_when_init_then_creates_directory(self, temp_storage_path):
        """Given a valid storage path, when initializing, then creates the directory."""
        # Given
        storage_path = temp_storage_path

        # When
        memory = LongTermMemory(storage_path=storage_path)

        # Then
        assert memory.storage_path == Path(storage_path)
        assert memory.storage_path.exists()
        assert memory.storage_path.is_dir()

    def test_given_nested_path_when_init_then_creates_parent_directories(self, tmp_path):
        """Given a nested path, when initializing, then creates all parent directories."""
        # Given
        nested_path = tmp_path / "level1" / "level2" / "storage"

        # When
        memory = LongTermMemory(storage_path=str(nested_path))

        # Then
        assert memory.storage_path.exists()
        assert memory.storage_path.is_dir()

    def test_given_existing_directory_when_init_then_reuses_directory(self, temp_storage_path):
        """Given an existing directory, when initializing, then reuses the directory."""
        # Given
        Path(temp_storage_path).mkdir(parents=True, exist_ok=True)

        # When
        memory = LongTermMemory(storage_path=temp_storage_path)

        # Then
        assert memory.storage_path.exists()
        assert memory.storage_path.is_dir()

    def test_given_default_path_when_init_then_uses_default_location(self):
        """Given no path specified, when initializing, then uses default location."""
        # Given/When
        with patch("empathy_os.memory.simple_storage.Path") as mock_path:
            mock_path_instance = MagicMock()
            mock_path.return_value = mock_path_instance
            memory = LongTermMemory()

        # Then
        mock_path.assert_called_once_with("./long_term_storage")

    def test_given_init_when_called_then_logs_initialization(self, temp_storage_path, mock_logger):
        """Given initialization, when called, then logs the event."""
        # Given/When
        memory = LongTermMemory(storage_path=temp_storage_path)

        # Then
        mock_logger.info.assert_called_with(
            "long_term_memory_initialized",
            storage_path=str(memory.storage_path)
        )


class TestLongTermMemoryStore:
    """Test LongTermMemory store behavior."""

    def test_given_valid_data_when_store_then_saves_to_file(self, memory_instance):
        """Given valid data, when storing, then saves to JSON file."""
        # Given
        key = "test_key"
        data = {"value": "test"}

        # When
        result = memory_instance.store(key, data)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        assert file_path.exists()
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["data"] == data

    def test_given_empty_key_when_store_then_raises_value_error(self, memory_instance):
        """Given an empty key, when storing, then raises ValueError."""
        # Given
        key = ""
        data = {"value": "test"}

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.store(key, data)

    def test_given_whitespace_key_when_store_then_raises_value_error(self, memory_instance):
        """Given a whitespace-only key, when storing, then raises ValueError."""
        # Given
        key = "   "
        data = {"value": "test"}

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.store(key, data)

    def test_given_classification_when_store_then_saves_classification(self, memory_instance):
        """Given a classification, when storing, then saves with classification."""
        # Given
        key = "classified_key"
        data = {"value": "secret"}
        classification = "SENSITIVE"

        # When
        result = memory_instance.store(key, data, classification=classification)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["classification"] == classification

    def test_given_classification_enum_when_store_then_saves_classification(self, memory_instance):
        """Given a Classification enum, when storing, then saves classification."""
        # Given
        key = "enum_key"
        data = {"value": "internal"}
        classification = Classification.INTERNAL

        # When
        result = memory_instance.store(key, data, classification=classification)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["classification"] == "INTERNAL"

    def test_given_no_classification_when_store_then_defaults_to_internal(self, memory_instance):
        """Given no classification, when storing, then defaults to INTERNAL."""
        # Given
        key = "default_key"
        data = {"value": "data"}

        # When
        memory_instance.store(key, data)

        # Then
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["classification"] == "INTERNAL"

    def test_given_complex_data_when_store_then_serializes_correctly(self, memory_instance):
        """Given complex data structures, when storing, then serializes correctly."""
        # Given
        key = "complex_key"
        data = {
            "nested": {"level": 2},
            "list": [1, 2, 3],
            "string": "text",
            "number": 42,
            "boolean": True,
            "null": None
        }

        # When
        result = memory_instance.store(key, data)

        # Then
        assert result is True
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert saved_data["data"] == data

    def test_given_non_serializable_data_when_store_then_raises_type_error(self, memory_instance):
        """Given non-JSON-serializable data, when storing, then raises TypeError."""
        # Given
        key = "bad_key"
        data = {"function": lambda x: x}

        # When/Then
        with pytest.raises(TypeError):
            memory_instance.store(key, data)

    def test_given_existing_key_when_store_then_overwrites(self, memory_instance):
        """Given an existing key, when storing new data, then overwrites."""
        # Given
        key = "overwrite_key"
        old_data = {"value": "old"}
        new_data = {"value": "new"}
        memory_instance.store(key, old_data)

        # When
        result = memory_instance.store(key, new_data)

        # Then
        assert result is True
        retrieved = memory_instance.retrieve(key)
        assert retrieved == new_data

    def test_given_store_when_called_then_includes_timestamp(self, memory_instance):
        """Given store operation, when called, then includes timestamp."""
        # Given
        key = "timestamp_key"
        data = {"value": "test"}

        # When
        memory_instance.store(key, data)

        # Then
        file_path = memory_instance.storage_path / f"{key}.json"
        with open(file_path) as f:
            saved_data = json.load(f)
        assert "timestamp" in saved_data
        # Verify timestamp is valid ISO format
        datetime.fromisoformat(saved_data["timestamp"])

    def test_given_path_validation_enabled_when_store_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when storing with invalid key, then raises error."""
        # Given
        key = "../../../etc/passwd"
        data = {"value": "malicious"}

        # When
        with patch("empathy_os.memory.simple_storage._validate_file_path") as mock_validate:
            mock_validate.side_effect = ValueError("Invalid path")

            # Then
            with pytest.raises(ValueError, match="Invalid path"):
                memory_instance.store(key, data)

    def test_given_io_error_when_store_then_returns_false(self, memory_instance):
        """Given an IO error, when storing, then returns False."""
        # Given
        key = "io_error_key"
        data = {"value": "test"}

        # When
        with patch("builtins.open", side_effect=OSError("Disk full")):
            result = memory_instance.store(key, data)

        # Then
        assert result is False


class TestLongTermMemoryRetrieve:
    """Test LongTermMemory retrieve behavior."""

    def test_given_existing_key_when_retrieve_then_returns_data(self, memory_instance):
        """Given an existing key, when retrieving, then returns stored data."""
        # Given
        key = "retrieve_key"
        data = {"value": "test", "number": 42}
        memory_instance.store(key, data)

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result == data

    def test_given_nonexistent_key_when_retrieve_then_returns_none(self, memory_instance):
        """Given a nonexistent key, when retrieving, then returns None."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_empty_key_when_retrieve_then_raises_value_error(self, memory_instance):
        """Given an empty key, when retrieving, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.retrieve(key)

    def test_given_corrupted_file_when_retrieve_then_returns_none(self, memory_instance):
        """Given a corrupted JSON file, when retrieving, then returns None."""
        # Given
        key = "corrupted_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text("invalid json content")

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_file_without_data_field_when_retrieve_then_returns_none(self, memory_instance):
        """Given a file without data field, when retrieving, then returns None."""
        # Given
        key = "no_data_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text(json.dumps({"classification": "PUBLIC"}))

        # When
        result = memory_instance.retrieve(key)

        # Then
        assert result is None

    def test_given_path_validation_when_retrieve_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when retrieving with invalid key, then raises error."""
        # Given
        key = "../../../etc/passwd"

        # When
        with patch("empathy_os.memory.simple_storage._validate_file_path") as mock_validate:
            mock_validate.side_effect = ValueError("Invalid path")

            # Then
            with pytest.raises(ValueError, match="Invalid path"):
                memory_instance.retrieve(key)

    def test_given_permission_error_when_retrieve_then_returns_none(self, memory_instance):
        """Given a permission error, when retrieving, then returns None."""
        # Given
        key = "permission_key"
        memory_instance.store(key, {"value": "test"})

        # When
        with patch("builtins.open", side_effect=PermissionError("Access denied")):
            result = memory_instance.retrieve(key)

        # Then
        assert result is None


class TestLongTermMemoryDelete:
    """Test LongTermMemory delete behavior."""

    def test_given_existing_key_when_delete_then_removes_file(self, memory_instance):
        """Given an existing key, when deleting, then removes the file."""
        # Given
        key = "delete_key"
        memory_instance.store(key, {"value": "test"})
        file_path = memory_instance.storage_path / f"{key}.json"
        assert file_path.exists()

        # When
        result = memory_instance.delete(key)

        # Then
        assert result is True
        assert not file_path.exists()

    def test_given_nonexistent_key_when_delete_then_returns_false(self, memory_instance):
        """Given a nonexistent key, when deleting, then returns False."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.delete(key)

        # Then
        assert result is False

    def test_given_empty_key_when_delete_then_raises_value_error(self, memory_instance):
        """Given an empty key, when deleting, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.delete(key)

    def test_given_path_validation_when_delete_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when deleting with invalid key, then raises error."""
        # Given
        key = "../../../etc/passwd"

        # When
        with patch("empathy_os.memory.simple_storage._validate_file_path") as mock_validate:
            mock_validate.side_effect = ValueError("Invalid path")

            # Then
            with pytest.raises(ValueError, match="Invalid path"):
                memory_instance.delete(key)

    def test_given_permission_error_when_delete_then_returns_false(self, memory_instance):
        """Given a permission error, when deleting, then returns False."""
        # Given
        key = "permission_key"
        memory_instance.store(key, {"value": "test"})

        # When
        with patch("pathlib.Path.unlink", side_effect=PermissionError("Access denied")):
            result = memory_instance.delete(key)

        # Then
        assert result is False


class TestLongTermMemoryListKeys:
    """Test LongTermMemory list_keys behavior."""

    def test_given_no_files_when_list_keys_then_returns_empty_list(self, memory_instance):
        """Given no stored files, when listing keys, then returns empty list."""
        # Given/When
        result = memory_instance.list_keys()

        # Then
        assert result == []

    def test_given_multiple_files_when_list_keys_then_returns_all_keys(self, memory_instance):
        """Given multiple stored files, when listing keys, then returns all keys."""
        # Given
        keys = ["key1", "key2", "key3"]
        for key in keys:
            memory_instance.store(key, {"value": key})

        # When
        result = memory_instance.list_keys()

        # Then
        assert set(result) == set(keys)

    def test_given_classification_filter_when_list_keys_then_filters_by_classification(
        self, memory_instance
    ):
        """Given a classification filter, when listing keys, then returns filtered keys."""
        # Given
        memory_instance.store("public_key", {"value": "public"}, "PUBLIC")
        memory_instance.store("internal_key", {"value": "internal"}, "INTERNAL")
        memory_instance.store("sensitive_key", {"value": "sensitive"}, "SENSITIVE")

        # When
        result = memory_instance.list_keys(classification="INTERNAL")

        # Then
        assert result == ["internal_key"]

    def test_given_classification_enum_when_list_keys_then_filters_correctly(
        self, memory_instance
    ):
        """Given a Classification enum, when listing keys, then filters correctly."""
        # Given
        memory_instance.store("public_key", {"value": "public"}, Classification.PUBLIC)
        memory_instance.store("internal_key", {"value": "internal"}, Classification.INTERNAL)

        # When
        result = memory_instance.list_keys(classification=Classification.PUBLIC)

        # Then
        assert result == ["public_key"]

    def test_given_no_matching_classification_when_list_keys_then_returns_empty_list(
        self, memory_instance
    ):
        """Given no matching classification, when listing keys, then returns empty list."""
        # Given
        memory_instance.store("key1", {"value": "test"}, "PUBLIC")

        # When
        result = memory_instance.list_keys(classification="SENSITIVE")

        # Then
        assert result == []

    def test_given_non_json_files_when_list_keys_then_ignores_them(self, memory_instance):
        """Given non-JSON files in directory, when listing keys, then ignores them."""
        # Given
        memory_instance.store("valid_key", {"value": "test"})
        (memory_instance.storage_path / "file.txt").write_text("not json")
        (memory_instance.storage_path / "no_extension").write_text("also not json")

        # When
        result = memory_instance.list_keys()

        # Then
        assert result == ["valid_key"]

    def test_given_corrupted_json_when_list_keys_then_skips_corrupted_files(
        self, memory_instance
    ):
        """Given corrupted JSON files, when listing keys, then skips them."""
        # Given
        memory_instance.store("valid_key", {"value": "test"})
        (memory_instance.storage_path / "corrupted.json").write_text("invalid json")

        # When
        result = memory_instance.list_keys()

        # Then
        assert result == ["valid_key"]

    def test_given_file_without_classification_when_list_keys_then_treats_as_internal(
        self, memory_instance
    ):
        """Given file without classification field, when listing keys, then treats as INTERNAL."""
        # Given
        key = "no_class_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text(json.dumps({"data": {"value": "test"}}))

        # When
        result = memory_instance.list_keys(classification="INTERNAL")

        # Then
        assert key in result

    def test_given_io_error_when_list_keys_then_returns_empty_list(self, memory_instance):
        """Given an IO error, when listing keys, then returns empty list."""
        # Given/When
        with patch("pathlib.Path.glob", side_effect=OSError("Disk error")):
            result = memory_instance.list_keys()

        # Then
        assert result == []


class TestLongTermMemoryExists:
    """Test LongTermMemory exists behavior."""

    def test_given_existing_key_when_exists_then_returns_true(self, memory_instance):
        """Given an existing key, when checking existence, then returns True."""
        # Given
        key = "exists_key"
        memory_instance.store(key, {"value": "test"})

        # When
        result = memory_instance.exists(key)

        # Then
        assert result is True

    def test_given_nonexistent_key_when_exists_then_returns_false(self, memory_instance):
        """Given a nonexistent key, when checking existence, then returns False."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.exists(key)

        # Then
        assert result is False

    def test_given_empty_key_when_exists_then_raises_value_error(self, memory_instance):
        """Given an empty key, when checking existence, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.exists(key)

    def test_given_path_validation_when_exists_with_invalid_key_then_raises_error(
        self, memory_instance
    ):
        """Given path validation, when checking existence with invalid key, then raises error."""
        # Given
        key = "../../../etc/passwd"

        # When
        with patch("empathy_os.memory.simple_storage._validate_file_path") as mock_validate:
            mock_validate.side_effect = ValueError("Invalid path")

            # Then
            with pytest.raises(ValueError, match="Invalid path"):
                memory_instance.exists(key)


class TestLongTermMemoryGetClassification:
    """Test LongTermMemory get_classification behavior."""

    def test_given_classified_key_when_get_classification_then_returns_classification(
        self, memory_instance
    ):
        """Given a classified key, when getting classification, then returns it."""
        # Given
        key = "classified_key"
        classification = "SENSITIVE"
        memory_instance.store(key, {"value": "test"}, classification=classification)

        # When
        result = memory_instance.get_classification(key)

        # Then
        assert result == classification

    def test_given_nonexistent_key_when_get_classification_then_returns_none(
        self, memory_instance
    ):
        """Given a nonexistent key, when getting classification, then returns None."""
        # Given
        key = "nonexistent_key"

        # When
        result = memory_instance.get_classification(key)

        # Then
        assert result is None

    def test_given_key_without_classification_when_get_classification_then_returns_internal(
        self, memory_instance
    ):
        """Given key without classification field, when getting it, then returns INTERNAL."""
        # Given
        key = "no_class_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text(json.dumps({"data": {"value": "test"}}))

        # When
        result = memory_instance.get_classification(key)

        # Then
        assert result == "INTERNAL"

    def test_given_empty_key_when_get_classification_then_raises_value_error(
        self, memory_instance
    ):
        """Given an empty key, when getting classification, then raises ValueError."""
        # Given
        key = ""

        # When/Then
        with pytest.raises(ValueError, match="key cannot be empty"):
            memory_instance.get_classification(key)

    def test_given_corrupted_file_when_get_classification_then_returns_none(
        self, memory_instance
    ):
        """Given a corrupted file, when getting classification, then returns None."""
        # Given
        key = "corrupted_key"
        file_path = memory_instance.storage_path / f"{key}.json"
        file_path.write_text("invalid json")

        # When
        result = memory_instance.get_classification(key)

        # Then
        assert result is None


class TestLongTermMemoryIntegration:
    """Integration tests for LongTermMemory."""

    def test_given_full_workflow_when_executed_then_all_operations_succeed(
        self, memory_instance
    ):
        """Given a full workflow, when executed, then all operations succeed."""
        # Given
        key = "workflow_key"
        data = {"value": "test", "number": 42}
        classification = "INTERNAL"

        # When - Store
        store_result = memory_instance.store(key, data, classification=classification)

        # Then
        assert store_result is True

        # When - Check existence
        exists_result = memory_instance.exists(key)

        # Then
        assert exists_result is True

        # When - Retrieve
        retrieved_data = memory_instance.retrieve(key)

        # Then
        assert retrieved_data == data

        # When - Get classification
        retrieved_class = memory_instance.get_classification(key)

        # Then
        assert retrieved_class == classification

        # When - List keys
        keys = memory_instance.list_keys(classification=classification)

        # Then
        assert key in keys

        # When - Delete
        delete_result = memory_instance.delete(key)

        # Then
        assert delete_result is True
        assert not memory_instance.exists(key)

    def test_given_multiple_classifications_when_stored_then_filters_correctly(
        self, memory_instance
    ):
        """Given multiple classifications, when stored, then filters correctly."""
        # Given
        test_data = [
            ("public1", {"value": "p1"}, "PUBLIC"),
            ("public2", {"value": "p2"}, "PUBLIC"),
            ("internal1", {"value": "i1"}, "INTERNAL"),
            ("internal2", {"value": "i2"}, "INTERNAL"),
            ("sensitive1", {"value": "s1"}, "SENSITIVE"),
        ]

        # When
        for key, data, classification in test_data:
            memory_instance.store(key, data, classification=classification)

        # Then
        public_keys = memory_instance.list_keys(classification="PUBLIC")
        assert set(public_keys) == {"public1", "public2"}

        internal_keys = memory_instance.list_keys(classification="INTERNAL")
        assert set(internal_keys) == {"internal1", "internal2"}

        sensitive_keys = memory_instance.list_keys(classification="SENSITIVE")
        assert set(sensitive_keys) == {"sensitive1"}

    def test_given_concurrent_operations_when_executed_then_maintains_consistency(
        self, memory_instance
    ):
        """Given concurrent-like operations, when executed, then maintains consistency."""
        # Given
        keys = [f"concurrent_key_{i}" for i in range(10)]

        # When - Store multiple
        for key in keys:
            memory_instance.store(key, {"value": key})

        # Then - All exist
        for key in keys:
            assert memory_instance.exists(key)

        # When - Delete half
        for key in keys[:5]:
            memory_instance.delete(key)

        # Then - Half remain
        remaining = memory_instance.list_keys()
        assert len(remaining) == 5
        assert all(key in remaining for key in keys[5:])
