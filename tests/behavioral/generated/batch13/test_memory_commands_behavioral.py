"""Behavioral tests for memory_commands.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from typer.testing import CliRunner
from typer import Typer

from empathy_os.meta_workflows.cli_commands.memory_commands import (
    search_memory,
    meta_workflow_app,
)


@pytest.fixture
def cli_runner():
    """Fixture providing a CLI test runner."""
    return CliRunner()


@pytest.fixture
def mock_console():
    """Fixture providing a mocked Rich console."""
    with patch("empathy_os.meta_workflows.cli_commands.memory_commands.console") as mock:
        yield mock


@pytest.fixture
def mock_unified_memory():
    """Fixture providing a mocked UnifiedMemory class."""
    with patch("empathy_os.meta_workflows.cli_commands.memory_commands.UnifiedMemory") as mock:
        yield mock


@pytest.fixture
def sample_pattern_results():
    """Fixture providing sample pattern search results."""
    return [
        {
            "pattern_id": "pattern_123",
            "pattern_type": "meta_workflow_execution",
            "classification": "success",
            "content": "This is a successful workflow execution with detailed information about the process.",
            "metadata": {"timestamp": "2025-01-01T00:00:00", "status": "completed"},
        },
        {
            "pattern_id": "pattern_456",
            "pattern_type": "test_pattern",
            "classification": "warning",
            "content": "This pattern contains a warning about test coverage issues that need attention.",
            "metadata": {"timestamp": "2025-01-02T00:00:00", "coverage": "75%"},
        },
    ]


class TestSearchMemoryBasicFunctionality:
    """Tests for basic search_memory functionality."""

    def test_given_valid_query_when_search_memory_called_then_searches_and_displays_results(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: A valid search query
        When: search_memory is called
        Then: Memory is searched and results are displayed
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="successful workflow")

        # Then
        mock_unified_memory.assert_called_once_with(user_id="cli_user")
        mock_memory_instance.search_patterns.assert_called_once_with(
            query="successful workflow",
            pattern_type=None,
            limit=10,
        )
        # Verify console output was called
        assert mock_console.print.call_count >= 4

    def test_given_query_with_pattern_type_when_search_memory_called_then_filters_by_type(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: A query with pattern type filter
        When: search_memory is called
        Then: Search filters by the specified pattern type
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(
            query="test query",
            pattern_type="meta_workflow_execution"
        )

        # Then
        mock_memory_instance.search_patterns.assert_called_once_with(
            query="test query",
            pattern_type="meta_workflow_execution",
            limit=10,
        )

    def test_given_custom_limit_when_search_memory_called_then_respects_limit(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: A custom result limit
        When: search_memory is called
        Then: Search respects the specified limit
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results[:1]
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test", limit=20)

        # Then
        mock_memory_instance.search_patterns.assert_called_once_with(
            query="test",
            pattern_type=None,
            limit=20,
        )

    def test_given_custom_user_id_when_search_memory_called_then_uses_user_id(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: A custom user ID
        When: search_memory is called
        Then: UnifiedMemory is initialized with the custom user ID
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test", user_id="custom_user_123")

        # Then
        mock_unified_memory.assert_called_once_with(user_id="custom_user_123")


class TestSearchMemoryNoResults:
    """Tests for search_memory with no results."""

    def test_given_no_matching_patterns_when_search_memory_called_then_displays_no_results_message(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: No matching patterns found
        When: search_memory is called
        Then: Displays a "no results" message
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="nonexistent query")

        # Then
        mock_memory_instance.search_patterns.assert_called_once()
        # Verify "no matching patterns" message was printed
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert any("No matching patterns found" in str(call) for call in print_calls)

    def test_given_empty_results_list_when_search_memory_called_then_does_not_display_results_panel(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Empty results list
        When: search_memory is called
        Then: Does not display results panel
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert not any("Result 1/" in str(call) for call in print_calls)


class TestSearchMemoryResultDisplay:
    """Tests for search_memory result display formatting."""

    def test_given_results_with_all_fields_when_search_memory_called_then_displays_complete_info(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: Results with all fields populated
        When: search_memory is called
        Then: Displays complete pattern information
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        # Check that Panel was created and printed
        print_calls = mock_console.print.call_args_list
        assert len(print_calls) >= len(sample_pattern_results)

    def test_given_results_with_missing_fields_when_search_memory_called_then_displays_na_for_missing(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Results with missing fields
        When: search_memory is called
        Then: Displays "N/A" for missing fields
        """
        # Given
        incomplete_result = [{"pattern_type": "test"}]
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = incomplete_result
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        # Verify display occurred without errors
        assert len(print_calls) > 0

    def test_given_long_content_when_search_memory_called_then_truncates_content(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Pattern with long content (>200 chars)
        When: search_memory is called
        Then: Content is truncated to 200 characters
        """
        # Given
        long_content_result = [{
            "pattern_id": "test_123",
            "pattern_type": "test",
            "classification": "info",
            "content": "x" * 500,  # 500 characters
            "metadata": {},
        }]
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = long_content_result
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        # Verify the function completed without error
        assert len(print_calls) > 0

    def test_given_multiple_results_when_search_memory_called_then_numbers_results_correctly(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: Multiple search results
        When: search_memory is called
        Then: Results are numbered sequentially
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        # Verify correct count message
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert any("Found 2 matching pattern(s)" in str(call) for call in print_calls)


class TestSearchMemoryErrorHandling:
    """Tests for search_memory error handling."""

    def test_given_import_error_when_search_memory_called_then_displays_error_and_exits(
        self, mock_console
    ):
        """
        Given: UnifiedMemory cannot be imported
        When: search_memory is called
        Then: Displays error message and exits with code 1
        """
        # Given
        with patch("empathy_os.meta_workflows.cli_commands.memory_commands.UnifiedMemory", side_effect=ImportError):
            # When/Then
            with pytest.raises(SystemExit) as exc_info:
                search_memory(query="test")
            
            # Verify error message was printed
            print_calls = [str(call) for call in mock_console.print.call_args_list]
            assert any("UnifiedMemory not available" in str(call) for call in print_calls)

    def test_given_general_exception_when_search_memory_called_then_displays_error_message(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: An unexpected exception occurs
        When: search_memory is called
        Then: Displays error message
        """
        # Given
        mock_unified_memory.side_effect = Exception("Unexpected error")

        # When/Then
        with pytest.raises(Exception):
            search_memory(query="test")

        # Verify error message was printed
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert any("Error" in str(call) for call in print_calls)

    def test_given_search_patterns_raises_exception_when_called_then_propagates_error(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: search_patterns raises an exception
        When: search_memory is called
        Then: Error is propagated and handled
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.side_effect = RuntimeError("Search failed")
        mock_unified_memory.return_value = mock_memory_instance

        # When/Then
        with pytest.raises(Exception):
            search_memory(query="test")


class TestSearchMemoryIntegrationWithTyperApp:
    """Tests for integration with Typer app."""

    def test_given_meta_workflow_app_when_search_memory_command_exists_then_command_is_registered(self):
        """
        Given: meta_workflow_app Typer application
        When: Checking registered commands
        Then: search-memory command is registered
        """
        # Given/When
        # The command is registered via decorator in the module
        
        # Then
        assert isinstance(meta_workflow_app, Typer)

    def test_given_cli_runner_when_search_memory_invoked_with_help_then_displays_help(
        self, cli_runner
    ):
        """
        Given: CLI runner
        When: search-memory is invoked with --help
        Then: Displays help information
        """
        # Given
        app = Typer()
        app.command("search-memory")(search_memory)

        # When
        result = cli_runner.invoke(app, ["search-memory", "--help"])

        # Then
        assert result.exit_code == 0
        assert "Search memory for patterns" in result.output or "query" in result.output.lower()


class TestSearchMemoryEdgeCases:
    """Tests for search_memory edge cases."""

    def test_given_empty_query_string_when_search_memory_called_then_searches_with_empty_query(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Empty query string
        When: search_memory is called
        Then: Searches with empty query without error
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="")

        # Then
        mock_memory_instance.search_patterns.assert_called_once_with(
            query="",
            pattern_type=None,
            limit=10,
        )

    def test_given_special_characters_in_query_when_search_memory_called_then_handles_correctly(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Query with special characters
        When: search_memory is called
        Then: Handles special characters correctly
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance
        special_query = "test@#$%^&*()_+-=[]{}|;:',.<>?/~`"

        # When
        search_memory(query=special_query)

        # Then
        mock_memory_instance.search_patterns.assert_called_once_with(
            query=special_query,
            pattern_type=None,
            limit=10,
        )

    def test_given_very_large_limit_when_search_memory_called_then_passes_limit_correctly(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Very large limit value
        When: search_memory is called
        Then: Passes limit value correctly
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test", limit=999999)

        # Then
        mock_memory_instance.search_patterns.assert_called_once_with(
            query="test",
            pattern_type=None,
            limit=999999,
        )

    def test_given_result_with_none_metadata_when_search_memory_called_then_handles_gracefully(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Result with None metadata
        When: search_memory is called
        Then: Handles None metadata gracefully
        """
        # Given
        result_with_none_metadata = [{
            "pattern_id": "test",
            "pattern_type": "test",
            "classification": "test",
            "content": "test content",
            "metadata": None,
        }]
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = result_with_none_metadata
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        # Should not raise an exception
        assert mock_console.print.call_count > 0

    def test_given_unicode_in_content_when_search_memory_called_then_displays_correctly(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Pattern content with unicode characters
        When: search_memory is called
        Then: Displays unicode correctly
        """
        # Given
        unicode_result = [{
            "pattern_id": "unicode_test",
            "pattern_type": "test",
            "classification": "info",
            "content": "Test with unicode: ä½ å¥½ä¸–ç•Œ ðŸš€ Ã©mojis",
            "metadata": {"lang": "multi"},
        }]
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = unicode_result
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="unicode")

        # Then
        assert mock_console.print.call_count > 0


class TestSearchMemoryConsoleOutput:
    """Tests for search_memory console output formatting."""

    def test_given_search_initiated_when_search_memory_called_then_displays_search_message(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Search is initiated
        When: search_memory is called
        Then: Displays search initiation message
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test query")

        # Then
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert any("Searching memory for" in str(call) for call in print_calls)
        assert any("test query" in str(call) for call in print_calls)

    def test_given_pattern_type_filter_when_search_memory_called_then_displays_filter_info(
        self, mock_console, mock_unified_memory
    ):
        """
        Given: Pattern type filter is specified
        When: search_memory is called
        Then: Displays filter information
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = []
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test", pattern_type="test_type")

        # Then
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert any("Pattern type" in str(call) for call in print_calls)
        assert any("test_type" in str(call) for call in print_calls)

    def test_given_results_found_when_search_memory_called_then_displays_result_count(
        self, mock_console, mock_unified_memory, sample_pattern_results
    ):
        """
        Given: Results are found
        When: search_memory is called
        Then: Displays correct result count
        """
        # Given
        mock_memory_instance = Mock()
        mock_memory_instance.search_patterns.return_value = sample_pattern_results
        mock_unified_memory.return_value = mock_memory_instance

        # When
        search_memory(query="test")

        # Then
        print_calls = [str(call) for call in mock_console.print.call_args_list]
        assert any("Found 2 matching pattern(s)" in str(call) for call in print_calls)