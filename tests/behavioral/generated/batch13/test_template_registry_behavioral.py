"""Behavioral tests for template_registry.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import logging
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.meta_workflows.models import MetaWorkflowTemplate
from empathy_os.meta_workflows.template_registry import TemplateRegistry


@pytest.fixture
def temp_storage_dir(tmp_path):
    """Create a temporary storage directory for templates."""
    storage_dir = tmp_path / "templates"
    storage_dir.mkdir(parents=True, exist_ok=True)
    return str(storage_dir)


@pytest.fixture
def registry(temp_storage_dir):
    """Create a template registry with temporary storage."""
    return TemplateRegistry(storage_dir=temp_storage_dir)


@pytest.fixture
def sample_template():
    """Create a sample MetaWorkflowTemplate for testing."""
    return MetaWorkflowTemplate(
        id="test_template",
        name="Test Template",
        description="A test template",
        version="1.0.0",
        parameters=[],
        steps=[],
        metadata={"author": "test"}
    )


@pytest.fixture
def sample_template_dict():
    """Create a sample template dictionary for JSON serialization."""
    return {
        "id": "test_template",
        "name": "Test Template",
        "description": "A test template",
        "version": "1.0.0",
        "parameters": [],
        "steps": [],
        "metadata": {"author": "test"}
    }


class TestTemplateRegistryInitialization:
    """Tests for TemplateRegistry initialization."""

    def test_given_no_storage_dir_when_initialized_then_uses_default_location(self):
        """Test that registry uses default location when no storage_dir is provided."""
        # Given: No storage directory specified
        # When: Initializing registry with default location
        with patch('empathy_os.meta_workflows.template_registry.Path') as mock_path:
            mock_home = Mock()
            mock_path.home.return_value = mock_home
            mock_dir = Mock()
            mock_home.__truediv__ = Mock(return_value=mock_dir)
            mock_dir.__truediv__ = Mock(return_value=mock_dir)
            mock_dir.mkdir = Mock()
            mock_dir.resolve.return_value = mock_dir
            
            registry = TemplateRegistry()
            
            # Then: Default path should be created
            assert registry.storage_dir is not None

    def test_given_custom_storage_dir_when_initialized_then_uses_custom_location(self, temp_storage_dir):
        """Test that registry uses custom storage directory when provided."""
        # Given: A custom storage directory
        # When: Initializing registry with custom directory
        registry = TemplateRegistry(storage_dir=temp_storage_dir)
        
        # Then: Registry uses the custom directory
        assert str(registry.storage_dir) == str(Path(temp_storage_dir).resolve())

    def test_given_nonexistent_dir_when_initialized_then_creates_directory(self, tmp_path):
        """Test that registry creates storage directory if it doesn't exist."""
        # Given: A non-existent directory path
        new_dir = tmp_path / "new_templates"
        
        # When: Initializing registry with non-existent directory
        registry = TemplateRegistry(storage_dir=str(new_dir))
        
        # Then: Directory should be created
        assert new_dir.exists()
        assert new_dir.is_dir()

    def test_given_invalid_storage_dir_when_initialized_then_raises_error(self):
        """Test that registry raises ValueError for invalid storage directory."""
        # Given: An invalid storage directory path
        invalid_dir = ""
        
        # When/Then: Initializing with invalid directory raises ValueError
        with pytest.raises(ValueError):
            TemplateRegistry(storage_dir=invalid_dir)


class TestTemplateRegistryLoadTemplate:
    """Tests for loading templates from registry."""

    def test_given_builtin_template_when_load_then_returns_builtin(self, registry):
        """Test that builtin templates are loaded correctly."""
        # Given: A built-in template exists
        builtin_template = MetaWorkflowTemplate(
            id="builtin_test",
            name="Builtin Test",
            description="Test",
            version="1.0.0",
            parameters=[],
            steps=[],
            metadata={}
        )
        
        with patch('empathy_os.meta_workflows.template_registry.get_builtin_template', return_value=builtin_template):
            # When: Loading the built-in template
            result = registry.load_template("builtin_test")
            
            # Then: Built-in template is returned
            assert result == builtin_template

    def test_given_user_template_when_load_then_returns_user_template(self, registry, sample_template_dict, temp_storage_dir):
        """Test that user templates are loaded from storage."""
        # Given: A user template exists in storage
        template_path = Path(temp_storage_dir) / "user_template.json"
        template_path.write_text(json.dumps(sample_template_dict))
        
        with patch('empathy_os.meta_workflows.template_registry.get_builtin_template', return_value=None):
            # When: Loading the user template
            result = registry.load_template("user_template")
            
            # Then: User template is loaded and returned
            assert result is not None
            assert result.id == "test_template"

    def test_given_nonexistent_template_when_load_then_returns_none(self, registry):
        """Test that loading non-existent template returns None."""
        # Given: No template exists
        with patch('empathy_os.meta_workflows.template_registry.get_builtin_template', return_value=None):
            # When: Loading non-existent template
            result = registry.load_template("nonexistent")
            
            # Then: None is returned
            assert result is None

    def test_given_corrupted_template_when_load_then_raises_error(self, registry, temp_storage_dir):
        """Test that loading corrupted template raises ValueError."""
        # Given: A corrupted template file
        template_path = Path(temp_storage_dir) / "corrupted.json"
        template_path.write_text("invalid json content {{{")
        
        with patch('empathy_os.meta_workflows.template_registry.get_builtin_template', return_value=None):
            # When/Then: Loading corrupted template raises ValueError
            with pytest.raises(ValueError):
                registry.load_template("corrupted")

    def test_given_empty_template_id_when_load_then_returns_none(self, registry):
        """Test that loading with empty ID returns None."""
        # Given: Empty template ID
        with patch('empathy_os.meta_workflows.template_registry.get_builtin_template', return_value=None):
            # When: Loading with empty ID
            result = registry.load_template("")
            
            # Then: None is returned
            assert result is None


class TestTemplateRegistrySaveTemplate:
    """Tests for saving templates to registry."""

    def test_given_valid_template_when_save_then_writes_to_storage(self, registry, sample_template, temp_storage_dir):
        """Test that valid templates are saved to storage."""
        # Given: A valid template
        # When: Saving the template
        registry.save_template(sample_template)
        
        # Then: Template file is created
        template_path = Path(temp_storage_dir) / f"{sample_template.id}.json"
        assert template_path.exists()
        
        # And: Template content is correct
        saved_data = json.loads(template_path.read_text())
        assert saved_data["id"] == sample_template.id
        assert saved_data["name"] == sample_template.name

    def test_given_existing_template_when_save_then_overwrites(self, registry, sample_template, temp_storage_dir):
        """Test that saving overwrites existing template."""
        # Given: An existing template
        registry.save_template(sample_template)
        
        # When: Saving template with same ID but different content
        modified_template = MetaWorkflowTemplate(
            id=sample_template.id,
            name="Modified Name",
            description="Modified",
            version="2.0.0",
            parameters=[],
            steps=[],
            metadata={}
        )
        registry.save_template(modified_template)
        
        # Then: Template is overwritten
        template_path = Path(temp_storage_dir) / f"{sample_template.id}.json"
        saved_data = json.loads(template_path.read_text())
        assert saved_data["name"] == "Modified Name"
        assert saved_data["version"] == "2.0.0"

    def test_given_template_with_special_chars_when_save_then_sanitizes_filename(self, registry, temp_storage_dir):
        """Test that template IDs with special characters are handled."""
        # Given: A template with special characters in ID
        template = MetaWorkflowTemplate(
            id="test/template:v1",
            name="Test",
            description="Test",
            version="1.0.0",
            parameters=[],
            steps=[],
            metadata={}
        )
        
        # When: Saving the template
        registry.save_template(template)
        
        # Then: Template is saved (may sanitize filename)
        # Note: Implementation may handle special chars differently
        template_path = Path(temp_storage_dir) / "test/template:v1.json"
        assert template_path.exists() or any(Path(temp_storage_dir).glob("*.json"))

    def test_given_template_when_save_with_io_error_then_raises_error(self, registry, sample_template):
        """Test that IO errors during save are properly raised."""
        # Given: A template and IO error condition
        with patch('pathlib.Path.write_text', side_effect=IOError("Disk full")):
            # When/Then: Saving raises IOError
            with pytest.raises(IOError):
                registry.save_template(sample_template)


class TestTemplateRegistryDeleteTemplate:
    """Tests for deleting templates from registry."""

    def test_given_existing_template_when_delete_then_removes_file(self, registry, sample_template, temp_storage_dir):
        """Test that existing templates are deleted."""
        # Given: An existing template
        registry.save_template(sample_template)
        template_path = Path(temp_storage_dir) / f"{sample_template.id}.json"
        assert template_path.exists()
        
        # When: Deleting the template
        result = registry.delete_template(sample_template.id)
        
        # Then: Template is removed and True is returned
        assert result is True
        assert not template_path.exists()

    def test_given_nonexistent_template_when_delete_then_returns_false(self, registry):
        """Test that deleting non-existent template returns False."""
        # Given: No template exists
        # When: Deleting non-existent template
        result = registry.delete_template("nonexistent")
        
        # Then: False is returned
        assert result is False

    def test_given_builtin_template_when_delete_then_returns_false(self, registry):
        """Test that built-in templates cannot be deleted."""
        # Given: A built-in template exists
        with patch('empathy_os.meta_workflows.template_registry.get_builtin_template', return_value=Mock()):
            # When: Attempting to delete built-in template
            result = registry.delete_template("builtin_template")
            
            # Then: False is returned (built-ins can't be deleted)
            assert result is False


class TestTemplateRegistryListTemplates:
    """Tests for listing available templates."""

    def test_given_no_templates_when_list_then_returns_builtins_only(self, registry):
        """Test that listing with no user templates returns only built-ins."""
        # Given: No user templates
        builtin_list = ["builtin1", "builtin2"]
        
        with patch('empathy_os.meta_workflows.template_registry.list_builtin_templates', return_value=builtin_list):
            # When: Listing templates
            result = registry.list_templates()
            
            # Then: Only built-in templates are returned
            assert "builtin1" in result
            assert "builtin2" in result

    def test_given_user_templates_when_list_then_returns_all(self, registry, sample_template, temp_storage_dir):
        """Test that listing returns both user and built-in templates."""
        # Given: User templates exist
        registry.save_template(sample_template)
        builtin_list = ["builtin1"]
        
        with patch('empathy_os.meta_workflows.template_registry.list_builtin_templates', return_value=builtin_list):
            # When: Listing templates
            result = registry.list_templates()
            
            # Then: Both user and built-in templates are returned
            assert sample_template.id in result
            assert "builtin1" in result

    def test_given_multiple_user_templates_when_list_then_returns_all_unique(self, registry, temp_storage_dir):
        """Test that listing returns all unique templates."""
        # Given: Multiple user templates
        template1 = MetaWorkflowTemplate(
            id="template1", name="T1", description="", version="1.0.0",
            parameters=[], steps=[], metadata={}
        )
        template2 = MetaWorkflowTemplate(
            id="template2", name="T2", description="", version="1.0.0",
            parameters=[], steps=[], metadata={}
        )
        registry.save_template(template1)
        registry.save_template(template2)
        
        with patch('empathy_os.meta_workflows.template_registry.list_builtin_templates', return_value=[]):
            # When: Listing templates
            result = registry.list_templates()
            
            # Then: All templates are returned without duplicates
            assert "template1" in result
            assert "template2" in result
            assert len([t for t in result if t == "template1"]) == 1

    def test_given_invalid_json_files_when_list_then_skips_invalid(self, registry, temp_storage_dir):
        """Test that invalid JSON files are skipped during listing."""
        # Given: Valid and invalid template files
        valid_template = MetaWorkflowTemplate(
            id="valid", name="Valid", description="", version="1.0.0",
            parameters=[], steps=[], metadata={}
        )
        registry.save_template(valid_template)
        
        invalid_path = Path(temp_storage_dir) / "invalid.json"
        invalid_path.write_text("invalid json {{{")
        
        with patch('empathy_os.meta_workflows.template_registry.list_builtin_templates', return_value=[]):
            # When: Listing templates
            result = registry.list_templates()
            
            # Then: Only valid templates are returned
            assert "valid" in result
            # Invalid file is skipped


class TestTemplateRegistrySearchTemplates:
    """Tests for searching templates by criteria."""

    def test_given_matching_name_when_search_then_returns_matches(self, registry, temp_storage_dir):
        """Test that search finds templates by name."""
        # Given: Templates with different names
        template1 = MetaWorkflowTemplate(
            id="t1", name="Data Processing", description="", version="1.0.0",
            parameters=[], steps=[], metadata={}
        )
        template2 = Meta