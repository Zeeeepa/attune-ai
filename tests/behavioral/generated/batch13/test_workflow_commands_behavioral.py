"""Behavioral tests for workflow_commands.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from unittest.mock import Mock, patch

import pytest
import typer

from attune.meta_workflows.cli_commands.workflow_commands import (
    console,
    run_workflow,
)
from attune.meta_workflows.models import (
    FormResponse,
    MetaWorkflowResult,
)


@pytest.fixture
def mock_template():
    """Create a mock workflow template."""
    template = Mock()
    template.name = "Test Workflow Template"
    template.description = "Test description"
    template.template_id = "test-template"
    return template


@pytest.fixture
def mock_registry(mock_template):
    """Create a mock TemplateRegistry."""
    registry = Mock()
    registry.load_template = Mock(return_value=mock_template)
    return registry


@pytest.fixture
def mock_workflow_result():
    """Create a mock MetaWorkflowResult."""
    form_response = FormResponse(
        template_id="test-template",
        responses={},
    )
    result = MetaWorkflowResult(
        run_id="test-run-123",
        template_id="test-template",
        timestamp="2026-01-31T12:00:00",
        form_responses=form_response,
        agents_created=[],
        agent_results=[],
        total_cost=0.15,
        total_duration=2.5,
        success=True,
        error=None,
    )
    return result


@pytest.fixture
def mock_meta_workflow(mock_workflow_result):
    """Create a mock MetaWorkflow."""
    workflow = Mock()
    workflow.execute = Mock(return_value=mock_workflow_result)
    return workflow


@pytest.fixture
def mock_pattern_learner():
    """Create a mock PatternLearner."""
    learner = Mock()
    learner.learn_from_execution = Mock()
    learner.memory = Mock()
    return learner


@pytest.fixture
def mock_unified_memory():
    """Create a mock UnifiedMemory."""
    memory = Mock()
    return memory


class TestRunWorkflowBasicExecution:
    """Test basic workflow execution scenarios."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_valid_template_when_run_with_defaults_then_executes_successfully(
        self,
        mock_workflow_class,
        mock_registry_class,
        mock_template,
        mock_meta_workflow,
        mock_workflow_result,
    ):
        """
        Given: A valid template ID exists in the registry
        When: Running the workflow with default options
        Then: The workflow executes successfully and displays results
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print") as mock_print:
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_registry_class.return_value.load_template.assert_called_once_with("test-template")
        mock_meta_workflow.execute.assert_called_once()
        assert mock_print.call_count > 0

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    def test_given_invalid_template_when_run_then_exits_with_error(self, mock_registry_class):
        """
        Given: An invalid template ID is provided
        When: Running the workflow
        Then: Exits with error code 1 and displays error message
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = None

        # When/Then
        with pytest.raises(typer.Exit) as exc_info:
            with patch.object(console, "print"):
                run_workflow(
                    template_id="invalid-template",
                    mock=True,
                    use_memory=False,
                    use_defaults=True,
                    user_id="cli_user",
                    json_output=False,
                )

        assert exc_info.value.exit_code == 1

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_mock_flag_true_when_run_then_uses_mock_execution(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: Mock flag is set to True
        When: Running the workflow
        Then: Uses mock execution mode
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_meta_workflow.execute.assert_called_once()

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_mock_flag_false_when_run_then_uses_real_execution(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: Mock flag is set to False
        When: Running the workflow
        Then: Uses real execution mode
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=False,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_meta_workflow.execute.assert_called_once()


class TestRunWorkflowMemoryIntegration:
    """Test workflow execution with memory integration."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    @patch("attune.memory.unified.UnifiedMemory")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.PatternLearner")
    def test_given_use_memory_flag_when_run_then_initializes_memory_integration(
        self,
        mock_learner_class,
        mock_memory_class,
        mock_workflow_class,
        mock_registry_class,
        mock_template,
        mock_meta_workflow,
        mock_pattern_learner,
        mock_unified_memory,
    ):
        """
        Given: use_memory flag is True
        When: Running the workflow
        Then: Initializes UnifiedMemory and PatternLearner
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow
        mock_memory_class.return_value = mock_unified_memory
        mock_learner_class.return_value = mock_pattern_learner

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=True,
                use_defaults=True,
                user_id="test_user",
                json_output=False,
            )

        # Then
        mock_memory_class.assert_called_once_with(user_id="test_user")
        mock_learner_class.assert_called_once_with(memory=mock_unified_memory)

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_use_memory_false_when_run_then_no_memory_initialization(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: use_memory flag is False
        When: Running the workflow
        Then: Does not initialize memory components
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            with patch("attune.memory.unified.UnifiedMemory") as mock_mem:
                run_workflow(
                    template_id="test-template",
                    mock=True,
                    use_memory=False,
                    use_defaults=True,
                    user_id="test_user",
                    json_output=False,
                )

        # Then - UnifiedMemory should not be imported/called
        mock_mem.assert_not_called()

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    @patch("attune.memory.unified.UnifiedMemory")
    def test_given_memory_initialization_fails_when_run_then_handles_gracefully(
        self,
        mock_memory_class,
        mock_workflow_class,
        mock_registry_class,
        mock_template,
        mock_meta_workflow,
    ):
        """
        Given: Memory initialization raises an exception
        When: Running the workflow with use_memory=True
        Then: Handles the error gracefully and continues without memory
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow
        mock_memory_class.side_effect = Exception("Memory initialization failed")

        # When - Should NOT raise exception, should continue without memory
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=True,
                use_defaults=True,
                user_id="test_user",
                json_output=False,
            )

        # Then - Workflow should still execute
        mock_meta_workflow.execute.assert_called_once()


class TestRunWorkflowJsonOutput:
    """Test JSON output mode for programmatic use."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    @patch("builtins.print")
    def test_given_json_output_flag_when_run_successfully_then_outputs_json(
        self,
        mock_print,
        mock_workflow_class,
        mock_registry_class,
        mock_template,
        mock_meta_workflow,
        mock_workflow_result,
    ):
        """
        Given: json_output flag is True and workflow succeeds
        When: Running the workflow
        Then: Outputs result as JSON to stdout
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        run_workflow(
            template_id="test-template",
            mock=True,
            use_memory=False,
            use_defaults=True,
            user_id="cli_user",
            json_output=True,
        )

        # Then
        # Should print JSON to stdout
        assert mock_print.called
        # Check that JSON was printed (contains run_id, template_id, etc.)
        json_output = str(mock_print.call_args_list)
        assert "run_id" in json_output or "test-run-123" in json_output

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("builtins.print")
    def test_given_invalid_template_and_json_output_when_run_then_outputs_error_json(
        self, mock_print, mock_registry_class
    ):
        """
        Given: Invalid template and json_output flag is True
        When: Running the workflow
        Then: Outputs error as JSON
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = None

        # When/Then
        with pytest.raises(typer.Exit):
            run_workflow(
                template_id="invalid-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=True,
            )

        # Then - Should output JSON error
        json_output_calls = [
            call for call in mock_print.call_args_list if call[0] and isinstance(call[0][0], str)
        ]
        assert len(json_output_calls) > 0

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_json_output_false_when_run_then_uses_console_output(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: json_output flag is False
        When: Running the workflow
        Then: Uses rich console for output
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print") as mock_console_print:
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        assert mock_console_print.call_count > 0


class TestRunWorkflowInteractiveMode:
    """Test interactive vs non-interactive mode."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_use_defaults_true_when_run_then_non_interactive_mode(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: use_defaults flag is True
        When: Running the workflow
        Then: Runs in non-interactive mode without prompts
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_meta_workflow.execute.assert_called_once()

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_use_defaults_false_when_run_then_interactive_mode(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: use_defaults flag is False
        When: Running the workflow
        Then: Runs in interactive mode (may prompt user)
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=False,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_meta_workflow.execute.assert_called_once()


class TestRunWorkflowUserIdParameter:
    """Test user ID parameter handling."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    @patch("attune.memory.unified.UnifiedMemory")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.PatternLearner")
    def test_given_custom_user_id_when_run_with_memory_then_uses_custom_user_id(
        self,
        mock_learner_class,
        mock_memory_class,
        mock_workflow_class,
        mock_registry_class,
        mock_template,
        mock_meta_workflow,
    ):
        """
        Given: A custom user_id is provided
        When: Running workflow with memory enabled
        Then: Uses the custom user_id for memory initialization
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow
        custom_user_id = "custom_user_123"

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=True,
                use_defaults=True,
                user_id=custom_user_id,
                json_output=False,
            )

        # Then
        mock_memory_class.assert_called_once_with(user_id=custom_user_id)

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_default_user_id_when_run_without_memory_then_no_impact(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: Default user_id is used
        When: Running workflow without memory
        Then: Workflow executes normally without memory dependency
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_meta_workflow.execute.assert_called_once()


class TestRunWorkflowErrorHandling:
    """Test error handling scenarios."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    def test_given_registry_fails_when_run_then_handles_exception(self, mock_registry_class):
        """
        Given: TemplateRegistry raises an exception
        When: Running the workflow
        Then: Exception is propagated or handled appropriately
        """
        # Given
        mock_registry_class.side_effect = Exception("Registry error")

        # When/Then
        with pytest.raises(Exception):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_workflow_execution_fails_when_run_then_handles_exception(
        self, mock_workflow_class, mock_registry_class, mock_template
    ):
        """
        Given: Workflow execution raises an exception
        When: Running the workflow
        Then: Exception is handled or propagated
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow = Mock()
        mock_workflow.execute.side_effect = Exception("Execution error")
        mock_workflow_class.return_value = mock_workflow

        # When/Then
        with pytest.raises(Exception):
            with patch.object(console, "print"):
                run_workflow(
                    template_id="test-template",
                    mock=True,
                    use_memory=False,
                    use_defaults=True,
                    user_id="cli_user",
                    json_output=False,
                )

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    def test_given_none_template_when_run_then_exits_with_error_code(self, mock_registry_class):
        """
        Given: Template registry returns None
        When: Running the workflow
        Then: Exits with error code 1
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = None

        # When/Then
        with pytest.raises(typer.Exit) as exc_info:
            with patch.object(console, "print"):
                run_workflow(
                    template_id="nonexistent",
                    mock=True,
                    use_memory=False,
                    use_defaults=True,
                    user_id="cli_user",
                    json_output=False,
                )

        assert exc_info.value.exit_code == 1


class TestRunWorkflowTemplateLoading:
    """Test template loading behavior."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_template_id_when_run_then_loads_correct_template(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: A specific template_id is provided
        When: Running the workflow
        Then: Loads the correct template by ID
        """
        # Given
        template_id = "release-prep"
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id=template_id,
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_registry_class.return_value.load_template.assert_called_once_with(template_id)

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_valid_template_when_run_then_displays_template_name(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: A valid template is loaded
        When: Running the workflow in non-JSON mode
        Then: Displays the template name
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print") as mock_print:
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=True,
                user_id="cli_user",
                json_output=False,
            )

        # Then - Should display template name
        assert (
            any(mock_template.name in str(call) for call in mock_print.call_args_list)
            or mock_print.called
        )


class TestRunWorkflowComplexScenarios:
    """Test complex multi-flag scenarios."""

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    @patch("attune.memory.unified.UnifiedMemory")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.PatternLearner")
    @patch("builtins.print")
    def test_given_all_flags_enabled_when_run_then_executes_with_all_features(
        self,
        mock_print,
        mock_learner_class,
        mock_memory_class,
        mock_workflow_class,
        mock_registry_class,
        mock_template,
        mock_meta_workflow,
        mock_pattern_learner,
        mock_unified_memory,
    ):
        """
        Given: All optional flags are enabled
        When: Running the workflow
        Then: All features work together correctly
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow
        mock_memory_class.return_value = mock_unified_memory
        mock_learner_class.return_value = mock_pattern_learner

        # When
        run_workflow(
            template_id="test-template",
            mock=False,
            use_memory=True,
            use_defaults=True,
            user_id="test_user",
            json_output=True,
        )

        # Then
        mock_registry_class.return_value.load_template.assert_called_once()
        mock_memory_class.assert_called_once()
        mock_learner_class.assert_called_once()
        mock_meta_workflow.execute.assert_called_once()

    @patch("attune.meta_workflows.cli_commands.workflow_commands.TemplateRegistry")
    @patch("attune.meta_workflows.cli_commands.workflow_commands.MetaWorkflow")
    def test_given_minimal_flags_when_run_then_executes_basic_workflow(
        self, mock_workflow_class, mock_registry_class, mock_template, mock_meta_workflow
    ):
        """
        Given: Only required parameters provided
        When: Running the workflow
        Then: Executes with default behavior
        """
        # Given
        mock_registry_class.return_value.load_template.return_value = mock_template
        mock_workflow_class.return_value = mock_meta_workflow

        # When
        with patch.object(console, "print"):
            run_workflow(
                template_id="test-template",
                mock=True,
                use_memory=False,
                use_defaults=False,
                user_id="cli_user",
                json_output=False,
            )

        # Then
        mock_meta_workflow.execute.assert_called_once()
