"""Behavioral tests for base.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import time
from datetime import datetime
from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest

from attune.memory.short_term.base import REDIS_AVAILABLE, BaseOperations
from attune.memory.types import RedisConfig, RedisMetrics


# ============================================================================
# FIXTURES
# ============================================================================


@pytest.fixture
def mock_redis_config():
    """Provide a mock Redis configuration for testing."""
    return RedisConfig(
        use_mock=True,
        host="localhost",
        port=6379,
        db=0,
        socket_timeout=5.0,
        socket_connect_timeout=5.0,
        retry_on_timeout=True,
        max_connections=10,
    )


@pytest.fixture
def real_redis_config():
    """Provide a real Redis configuration (when Redis is available)."""
    return RedisConfig(
        use_mock=False,
        host="localhost",
        port=6379,
        db=0,
        socket_timeout=5.0,
        socket_connect_timeout=5.0,
        retry_on_timeout=True,
        max_connections=10,
    )


@pytest.fixture
def base_operations_mock(mock_redis_config):
    """Provide a BaseOperations instance with mock storage."""
    return BaseOperations(config=mock_redis_config)


@pytest.fixture
def mock_redis_client():
    """Provide a mock Redis client for testing."""
    client = MagicMock()
    client.ping.return_value = True
    client.get.return_value = None
    client.set.return_value = True
    client.delete.return_value = 1
    client.keys.return_value = []
    client.dbsize.return_value = 0
    client.info.return_value = {"used_memory": 1024}
    return client


# ============================================================================
# INITIALIZATION TESTS
# ============================================================================


class TestBaseOperationsInitialization:
    """Test BaseOperations initialization behavior."""

    def test_initialization_with_mock_config(self, mock_redis_config):
        """
        GIVEN a mock Redis configuration
        WHEN BaseOperations is initialized
        THEN it should use mock storage and not create a Redis client
        """
        # When
        base_ops = BaseOperations(config=mock_redis_config)

        # Then
        assert base_ops.use_mock is True
        assert base_ops._client is None
        assert isinstance(base_ops._mock_storage, dict)
        assert len(base_ops._mock_storage) == 0
        assert isinstance(base_ops._metrics, RedisMetrics)

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    def test_initialization_with_real_config(self, mock_redis_module, real_redis_config):
        """
        GIVEN a real Redis configuration and Redis is available
        WHEN BaseOperations is initialized
        THEN it should create a Redis client connection
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.return_value = True

        # When
        base_ops = BaseOperations(config=real_redis_config)

        # Then
        assert base_ops.use_mock is False
        assert base_ops._client is not None
        mock_redis_module.Redis.assert_called_once()

    def test_initialization_creates_metrics(self, mock_redis_config):
        """
        GIVEN a Redis configuration
        WHEN BaseOperations is initialized
        THEN it should create a RedisMetrics instance
        """
        # When
        base_ops = BaseOperations(config=mock_redis_config)

        # Then
        assert isinstance(base_ops._metrics, RedisMetrics)
        assert base_ops._metrics.operations_total == 0
        assert base_ops._metrics.operations_success == 0
        assert base_ops._metrics.operations_failed == 0

    @patch.dict("os.environ", {"REDIS_ENABLED": "false"}, clear=False)
    def test_initialization_with_default_config(self):
        """
        GIVEN no configuration provided and REDIS_ENABLED is false
        WHEN BaseOperations is initialized
        THEN it should use default mock configuration
        """
        # When
        base_ops = BaseOperations()

        # Then
        assert base_ops.use_mock is True
        assert base_ops._client is None
        assert isinstance(base_ops._mock_storage, dict)


# ============================================================================
# CLIENT PROPERTY TESTS
# ============================================================================


class TestClientProperty:
    """Test client property behavior."""

    def test_client_property_returns_none_for_mock(self, base_operations_mock):
        """
        GIVEN a BaseOperations instance with mock storage
        WHEN accessing the client property
        THEN it should return None
        """
        # When
        client = base_operations_mock.client

        # Then
        assert client is None

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    def test_client_property_returns_redis_client(self, mock_redis_module, real_redis_config):
        """
        GIVEN a BaseOperations instance with real Redis
        WHEN accessing the client property
        THEN it should return the Redis client
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.return_value = True
        base_ops = BaseOperations(config=real_redis_config)

        # When
        client = base_ops.client

        # Then
        assert client is mock_client


# ============================================================================
# METRICS PROPERTY TESTS
# ============================================================================


class TestMetricsProperty:
    """Test metrics property behavior."""

    def test_metrics_property_returns_metrics_instance(self, base_operations_mock):
        """
        GIVEN a BaseOperations instance
        WHEN accessing the metrics property
        THEN it should return the RedisMetrics instance
        """
        # When
        metrics = base_operations_mock.metrics

        # Then
        assert isinstance(metrics, RedisMetrics)
        assert metrics.operations_total == 0

    def test_metrics_tracks_operations_via_execute_with_retry(self, base_operations_mock):
        """
        GIVEN a BaseOperations instance
        WHEN performing operations via _execute_with_retry
        THEN metrics should track the operations
        """
        # When - _execute_with_retry is what records metrics
        base_operations_mock._execute_with_retry(
            lambda: base_operations_mock._set("key1", "value1"), op_name="set"
        )
        base_operations_mock._execute_with_retry(
            lambda: base_operations_mock._get("key1"), op_name="get"
        )
        base_operations_mock._execute_with_retry(
            lambda: base_operations_mock._get("nonexistent"), op_name="get"
        )

        # Then
        metrics = base_operations_mock.metrics
        assert metrics.operations_total == 3
        assert metrics.operations_success == 3
        assert metrics.operations_failed == 0


# ============================================================================
# CREATE CLIENT WITH RETRY TESTS
# ============================================================================


class TestCreateClientWithRetry:
    """Test _create_client_with_retry behavior."""

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    def test_create_client_success_first_attempt(self, mock_redis_module, real_redis_config):
        """
        GIVEN Redis is available
        WHEN creating a client with retry
        THEN it should succeed on the first attempt
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.return_value = True

        # When
        base_ops = BaseOperations(config=real_redis_config)

        # Then
        assert base_ops._client is mock_client
        mock_redis_module.Redis.assert_called_once()

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    @patch("attune.memory.short_term.base.time.sleep")
    @patch("attune.memory.short_term.base.RedisConnectionError", Exception)
    @patch("attune.memory.short_term.base.RedisTimeoutError", Exception)
    def test_create_client_retry_on_connection_error(
        self, mock_sleep, mock_redis_module, real_redis_config
    ):
        """
        GIVEN Redis connection fails initially
        WHEN creating a client with retry
        THEN it should retry with exponential backoff
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        # Fail first two times, succeed on third
        mock_client.ping.side_effect = [
            Exception("Connection failed"),
            Exception("Connection failed"),
            True,
        ]

        # When
        base_ops = BaseOperations(config=real_redis_config)

        # Then
        assert base_ops._client is mock_client
        assert mock_sleep.call_count == 2  # Sleep between retries

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    @patch("attune.memory.short_term.base.time.sleep")
    @patch("attune.memory.short_term.base.RedisConnectionError", Exception)
    @patch("attune.memory.short_term.base.RedisTimeoutError", Exception)
    def test_create_client_max_retries_exceeded(
        self, mock_sleep, mock_redis_module, real_redis_config
    ):
        """
        GIVEN Redis connection always fails
        WHEN creating a client with retry
        THEN it should raise an exception after max retries
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.side_effect = Exception("Connection failed")

        # When/Then - source raises the last error after all retries exhausted
        with pytest.raises(Exception, match="Connection failed"):
            BaseOperations(config=real_redis_config)

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", False)
    def test_create_client_redis_not_available(self, real_redis_config):
        """
        GIVEN Redis is not available
        WHEN creating a client
        THEN it should fall back to mock storage
        """
        # When
        base_ops = BaseOperations(config=real_redis_config)

        # Then
        assert base_ops.use_mock is True
        assert base_ops._client is None
        assert isinstance(base_ops._mock_storage, dict)


# ============================================================================
# EXECUTE WITH RETRY TESTS
# ============================================================================


class TestExecuteWithRetry:
    """Test _execute_with_retry behavior."""

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    def test_execute_with_retry_success(self, mock_redis_module, real_redis_config):
        """
        GIVEN a Redis operation
        WHEN executing with retry
        THEN it should succeed on the first attempt
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.return_value = True
        mock_client.get.return_value = "value"
        base_ops = BaseOperations(config=real_redis_config)

        # When - operation is a zero-arg callable that captures client
        result = base_ops._execute_with_retry(lambda: mock_client.get("key"))

        # Then
        assert result == "value"
        mock_client.get.assert_called_once_with("key")

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    @patch("attune.memory.short_term.base.time.sleep")
    @patch("attune.memory.short_term.base.RedisConnectionError", Exception)
    @patch("attune.memory.short_term.base.RedisTimeoutError", Exception)
    def test_execute_with_retry_recovers_from_error(
        self, mock_sleep, mock_redis_module, real_redis_config
    ):
        """
        GIVEN a Redis operation that fails initially
        WHEN executing with retry
        THEN it should retry and succeed
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.return_value = True
        # Fail first time, succeed second time
        mock_client.get.side_effect = [Exception("Timeout"), "value"]
        base_ops = BaseOperations(config=real_redis_config)

        # When - operation is a zero-arg callable
        result = base_ops._execute_with_retry(lambda: mock_client.get("key"))

        # Then
        assert result == "value"
        assert mock_client.get.call_count == 2

    @patch("attune.memory.short_term.base.REDIS_AVAILABLE", True)
    @patch("attune.memory.short_term.base.redis")
    @patch("attune.memory.short_term.base.time.sleep")
    @patch("attune.memory.short_term.base.RedisConnectionError", Exception)
    @patch("attune.memory.short_term.base.RedisTimeoutError", Exception)
    def test_execute_with_retry_max_retries_exceeded(
        self, mock_sleep, mock_redis_module, real_redis_config
    ):
        """
        GIVEN a Redis operation that always fails
        WHEN executing with retry
        THEN it should raise an exception after max retries
        """
        # Given
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_client.ping.return_value = True
        mock_client.get.side_effect = Exception("Always fails")
        base_ops = BaseOperations(config=real_redis_config)

        # When/Then - no max_retries param; retries come from config.retry_max_attempts
        with pytest.raises(Exception, match="Always fails"):
            base_ops._execute_with_retry(lambda: mock_client.get("key"), op_name="get")

    def test_execute_with_retry_in_mock_mode(self, base_operations_mock):
        """
        GIVEN mock mode is enabled
        WHEN executing with retry
        THEN it should execute the operation without retry logic
        """
        # Given
        operation = Mock(return_value="mock_result")

        # When
        result = base_operations_mock._execute_with_retry(operation)

        # Then
        assert result == "mock_result"
        operation.assert_called_once()


# ============================================================================
# GET OPERATION TESTS
# ============================================================================


class TestGetOperation:
    """Test _get operation behavior."""

    def test_get_existing_key_in_mock(self, base_operations_mock):
        """
        GIVEN a key exists in mock storage
        WHEN getting the key
        THEN it should return the value
        """
        # Given - mock storage uses (value, expires) tuples
        base_operations_mock._mock_storage["test_key"] = ("test_value", None)

        # When
        result = base_operations_mock._get("test_key")

        # Then
        assert result == "test_value"

    def test_get_nonexistent_key_in_mock(self, base_operations_mock):
        """
        GIVEN a key does not exist in mock storage
        WHEN getting the key
        THEN it should return None
        """
        # When
        result = base_operations_mock._get("nonexistent_key")

        # Then
        assert result is None

