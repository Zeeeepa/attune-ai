"""Behavioral tests for coordination.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from datetime import datetime, timedelta
from unittest.mock import Mock, patch, MagicMock

from empathy_os.coordination import (
    ConflictResolver,
    ResolutionResult,
    ResolutionStrategy,
    TeamPriorities,
)
from empathy_os.pattern_library import Pattern


# Fixtures


@pytest.fixture
def basic_pattern():
    """Given a basic pattern with standard attributes."""
    return Pattern(
        id="test_pattern_1",
        agent_id="agent_1",
        pattern_type="best_practice",
        name="Test Pattern",
        description="A test pattern",
        context={"file": "test.py"},
        example="example code",
        anti_pattern="bad code",
        tags=["testing"],
        confidence=0.8,
        discovered_at=datetime.now(),
    )


@pytest.fixture
def high_confidence_pattern():
    """Given a pattern with high confidence score."""
    return Pattern(
        id="high_conf",
        agent_id="agent_2",
        pattern_type="performance",
        name="High Confidence Pattern",
        description="Very confident pattern",
        context={"file": "test.py"},
        example="optimized code",
        anti_pattern="slow code",
        tags=["performance"],
        confidence=0.95,
        discovered_at=datetime.now(),
    )


@pytest.fixture
def low_confidence_pattern():
    """Given a pattern with low confidence score."""
    return Pattern(
        id="low_conf",
        agent_id="agent_3",
        pattern_type="style",
        name="Low Confidence Pattern",
        description="Less confident pattern",
        context={"file": "test.py"},
        example="styled code",
        anti_pattern="unstyled code",
        tags=["style"],
        confidence=0.4,
        discovered_at=datetime.now(),
    )


@pytest.fixture
def recent_pattern():
    """Given a recently discovered pattern."""
    return Pattern(
        id="recent",
        agent_id="agent_4",
        pattern_type="security",
        name="Recent Pattern",
        description="Just discovered",
        context={"file": "test.py"},
        example="secure code",
        anti_pattern="insecure code",
        tags=["security"],
        confidence=0.7,
        discovered_at=datetime.now(),
    )


@pytest.fixture
def old_pattern():
    """Given an old pattern discovered long ago."""
    return Pattern(
        id="old",
        agent_id="agent_5",
        pattern_type="warning",
        name="Old Pattern",
        description="Discovered long ago",
        context={"file": "test.py"},
        example="old code",
        anti_pattern="very old code",
        tags=["legacy"],
        confidence=0.7,
        discovered_at=datetime.now() - timedelta(days=365),
    )


@pytest.fixture
def team_priorities():
    """Given standard team priorities configuration."""
    return TeamPriorities(
        readability_weight=0.3,
        performance_weight=0.2,
        security_weight=0.3,
        maintainability_weight=0.2,
        type_preferences={
            "security": 1.0,
            "best_practice": 0.8,
            "performance": 0.7,
            "style": 0.5,
            "warning": 0.6,
        },
        preferred_tags=["security", "performance"],
    )


@pytest.fixture
def conflict_resolver(team_priorities):
    """Given a configured conflict resolver."""
    return ConflictResolver(team_priorities=team_priorities)


# Tests for ResolutionStrategy Enum


class TestResolutionStrategy:
    """Tests for ResolutionStrategy enum."""

    def test_given_resolution_strategy_when_accessing_values_then_returns_correct_strings(
        self,
    ):
        """Given resolution strategies, when accessing their values, then correct strings are returned."""
        # When/Then
        assert ResolutionStrategy.HIGHEST_CONFIDENCE.value == "highest_confidence"
        assert ResolutionStrategy.MOST_RECENT.value == "most_recent"
        assert ResolutionStrategy.BEST_CONTEXT_MATCH.value == "best_context_match"
        assert ResolutionStrategy.TEAM_PRIORITY.value == "team_priority"
        assert ResolutionStrategy.WEIGHTED_SCORE.value == "weighted_score"

    def test_given_resolution_strategy_when_checking_count_then_has_all_strategies(
        self,
    ):
        """Given resolution strategies, when counting them, then all five strategies exist."""
        # When
        strategies = list(ResolutionStrategy)

        # Then
        assert len(strategies) == 5


# Tests for ResolutionResult


class TestResolutionResult:
    """Tests for ResolutionResult dataclass."""

    def test_given_patterns_when_creating_resolution_result_then_all_fields_set(
        self, basic_pattern, high_confidence_pattern
    ):
        """Given patterns, when creating a resolution result, then all fields are properly set."""
        # When
        result = ResolutionResult(
            winning_pattern=high_confidence_pattern,
            losing_patterns=[basic_pattern],
            strategy_used=ResolutionStrategy.HIGHEST_CONFIDENCE,
            confidence=0.95,
            reasoning="Highest confidence score",
            factors={"confidence": 0.95},
        )

        # Then
        assert result.winning_pattern == high_confidence_pattern
        assert result.losing_patterns == [basic_pattern]
        assert result.strategy_used == ResolutionStrategy.HIGHEST_CONFIDENCE
        assert result.confidence == 0.95
        assert result.reasoning == "Highest confidence score"
        assert result.factors == {"confidence": 0.95}

    def test_given_no_factors_when_creating_resolution_result_then_factors_default_empty(
        self, basic_pattern, high_confidence_pattern
    ):
        """Given no factors, when creating resolution result, then factors default to empty dict."""
        # When
        result = ResolutionResult(
            winning_pattern=high_confidence_pattern,
            losing_patterns=[basic_pattern],
            strategy_used=ResolutionStrategy.HIGHEST_CONFIDENCE,
            confidence=0.95,
            reasoning="Test",
        )

        # Then
        assert result.factors == {}


# Tests for TeamPriorities


class TestTeamPriorities:
    """Tests for TeamPriorities dataclass."""

    def test_given_no_args_when_creating_team_priorities_then_defaults_set(self):
        """Given no arguments, when creating team priorities, then default values are set."""
        # When
        priorities = TeamPriorities()

        # Then
        assert priorities.readability_weight == 0.3
        assert priorities.performance_weight == 0.2
        assert priorities.security_weight == 0.3
        assert priorities.maintainability_weight == 0.2
        assert priorities.type_preferences["security"] == 1.0
        assert priorities.type_preferences["best_practice"] == 0.8
        assert priorities.preferred_tags == []

    def test_given_custom_weights_when_creating_team_priorities_then_custom_values_set(
        self,
    ):
        """Given custom weights, when creating team priorities, then custom values are used."""
        # When
        priorities = TeamPriorities(
            readability_weight=0.5,
            performance_weight=0.5,
            security_weight=0.0,
            maintainability_weight=0.0,
        )

        # Then
        assert priorities.readability_weight == 0.5
        assert priorities.performance_weight == 0.5
        assert priorities.security_weight == 0.0
        assert priorities.maintainability_weight == 0.0

    def test_given_custom_preferences_when_creating_team_priorities_then_preferences_set(
        self,
    ):
        """Given custom preferences, when creating team priorities, then preferences are set."""
        # When
        custom_prefs = {"security": 2.0, "custom": 0.5}
        priorities = TeamPriorities(
            type_preferences=custom_prefs, preferred_tags=["security", "custom"]
        )

        # Then
        assert priorities.type_preferences == custom_prefs
        assert priorities.preferred_tags == ["security", "custom"]


# Tests for ConflictResolver


class TestConflictResolverInitialization:
    """Tests for ConflictResolver initialization."""

    def test_given_no_priorities_when_creating_resolver_then_defaults_used(self):
        """Given no priorities, when creating resolver, then default priorities are used."""
        # When
        resolver = ConflictResolver()

        # Then
        assert resolver.team_priorities is not None
        assert isinstance(resolver.team_priorities, TeamPriorities)

    def test_given_custom_priorities_when_creating_resolver_then_custom_priorities_used(
        self, team_priorities
    ):
        """Given custom priorities, when creating resolver, then custom priorities are used."""
        # When
        resolver = ConflictResolver(team_priorities=team_priorities)

        # Then
        assert resolver.team_priorities == team_priorities

    def test_given_custom_strategy_when_creating_resolver_then_strategy_set(self):
        """Given custom default strategy, when creating resolver, then strategy is set."""
        # When
        resolver = ConflictResolver(
            default_strategy=ResolutionStrategy.MOST_RECENT
        )

        # Then
        assert resolver.default_strategy == ResolutionStrategy.MOST_RECENT


class TestConflictResolverHighestConfidence:
    """Tests for HIGHEST_CONFIDENCE resolution strategy."""

    def test_given_patterns_with_different_confidence_when_resolving_then_highest_confidence_wins(
        self, conflict_resolver, high_confidence_pattern, low_confidence_pattern
    ):
        """Given patterns with different confidence, when resolving by highest confidence, then highest wins."""
        # When
        result = conflict_resolver.resolve(
            [high_confidence_pattern, low_confidence_pattern],
            strategy=ResolutionStrategy.HIGHEST_CONFIDENCE,
        )

        # Then
        assert result.winning_pattern == high_confidence_pattern
        assert low_confidence_pattern in result.losing_patterns
        assert result.strategy_used == ResolutionStrategy.HIGHEST_CONFIDENCE
        assert result.confidence > 0

    def test_given_single_pattern_when_resolving_then_that_pattern_wins(
        self, conflict_resolver, basic_pattern
    ):
        """Given single pattern, when resolving by highest confidence, then that pattern wins."""
        # When
        result = conflict_resolver.resolve(
            [basic_pattern], strategy=ResolutionStrategy.HIGHEST_CONFIDENCE
        )

        # Then
        assert result.winning_pattern == basic_pattern
        assert result.losing_patterns == []

    def test_given_patterns_with_same_confidence_when_resolving_then_first_wins(
        self, conflict_resolver
    ):
        """Given patterns with same confidence, when resolving, then first pattern wins."""
        # Given
        pattern1 = Pattern(
            id="p1",
            agent_id="a1",
            pattern_type="test",
            name="P1",
            description="First",
            context={},
            example="",
            anti_pattern="",
            tags=[],
            confidence=0.8,
            discovered_at=datetime.now(),
        )
        pattern2 = Pattern(
            id="p2",
            agent_id="a2",
            pattern_type="test",
            name="P2",
            description="Second",
            context={},
            example="",
            anti_pattern="",
            tags=[],
            confidence=0.8,
            discovered_at=datetime.now(),
        )

        # When
        result = conflict_resolver.resolve(
            [pattern1, pattern2], strategy=ResolutionStrategy.HIGHEST_CONFIDENCE
        )

        # Then
        assert result.winning_pattern == pattern1


class TestConflictResolverMostRecent:
    """Tests for MOST_RECENT resolution strategy."""

    def test_given_patterns_with_different_dates_when_resolving_then_most_recent_wins(
        self, conflict_resolver, recent_pattern, old_pattern
    ):
        """Given patterns with different dates, when resolving by most recent, then newest wins."""
        # When
        result = conflict_resolver.resolve(
            [old_pattern, recent_pattern], strategy=ResolutionStrategy.MOST_RECENT
        )

        # Then
        assert result.winning_pattern == recent_pattern
        assert old_pattern in result.losing_patterns
        assert result.strategy_used == ResolutionStrategy.MOST_RECENT

    def test_given_patterns_with_same_date_when_resolving_then_first_wins(
        self, conflict_resolver
    ):
        """Given patterns with same date, when resolving by most recent, then first wins."""
        # Given
        now = datetime.now()
        pattern1 = Pattern(
            id="p1",
            agent_id="a1",
            pattern_type="test",
            name="P1",
            description="First",
            context={},
            example="",
            anti_pattern="",
            tags=[],
            confidence=0.8,
            discovered_at=now,
        )
        pattern2 = Pattern(
            id="p2",
            agent_id="a2",
            pattern_type="test",
            name="P2",
            description="Second",
            context={},
            example="",
            anti_pattern="",
            tags=[],
            confidence=0.8,
            discovered_at=now,
        )

        # When
        result = conflict_resolver.resolve(
            [pattern1, pattern2], strategy=ResolutionStrategy.MOST_RECENT
        )

        # Then
        assert result.winning_pattern == pattern1


class TestConflictResolverBestContextMatch:
    """Tests for BEST_CONTEXT_MATCH resolution strategy."""

    def test_given_patterns_and_context_when_resolving_then_best_match_wins(
        self, conflict_resolver
    ):
        """Given patterns and context, when resolving by context match, then best match wins."""
        # Given
        pattern1 = Pattern(
            id="p1",
            agent_id="a1",
            pattern_type="test",
            name="P1",
            description="First",
            context={"file": "test.py", "function": "foo"},
            example="",
            anti_pattern="",
            tags=[],
            confidence=0.8,
            discovered_at=datetime.now(),
        )
        pattern2 = Pattern(
            id="p2",
            agent_id="a2",
            pattern_type="test",
            name="P2",
            description="Second",
            context={"file": "other.py"},
            example="",
            anti_pattern="",
            tags=[],
            confidence=0.8,
            discovered_at=datetime.now(),
        )
        current_context = {"file": "test.py", "function": "foo"}

        # When
        result = conflict_resolver.resolve(
            [pattern1, pattern2],
            strategy=ResolutionStrategy.BEST_CONTEXT_MATCH,
            context=current_context,
        )

        # Then
        assert result.winning_pattern == pattern1
        assert result.strategy_used == ResolutionStrategy.BEST_CONTEXT_MATCH

    def test_given_no_context_when_resolving_then_falls_back_to_highest_confidence(
        self, conflict_resolver, high_confidence_pattern, low_confidence_pattern
    ):
        """Given no context, when resolving by context match, then falls back to highest confidence."""
        # When
        result = conflict_resolver.resolve(
            [high_