"""Behavioral tests for graph.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import tempfile
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, mock_open, patch

import pytest

from empathy_os.memory.edges import Edge, EdgeType
from empathy_os.memory.graph import MemoryGraph
from empathy_os.memory.nodes import Node, NodeType


@pytest.fixture
def temp_graph_path():
    """Provide a temporary path for graph storage."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir) / "memory_graph.json"


@pytest.fixture
def sample_bug_finding():
    """Provide a sample bug finding."""
    return {
        "type": "bug",
        "name": "Null reference in auth.py",
        "description": "Missing null check on user object",
        "file": "src/auth.py",
        "line": 42,
        "severity": "high",
    }


@pytest.fixture
def sample_fix_finding():
    """Provide a sample fix finding."""
    return {
        "type": "fix",
        "name": "Add null check",
        "description": "Added guard clause for user object",
        "file": "src/auth.py",
        "line": 42,
    }


@pytest.fixture
def sample_pattern_finding():
    """Provide a sample pattern finding."""
    return {
        "type": "pattern",
        "name": "Auth pattern",
        "description": "Authentication flow pattern",
        "pattern": "user_auth",
    }


@pytest.fixture
def populated_graph(temp_graph_path):
    """Provide a graph with pre-populated test data."""
    graph = MemoryGraph(temp_graph_path)
    
    # Add multiple findings
    bug_id = graph.add_finding(
        workflow="bug-predict",
        finding={
            "type": "bug",
            "name": "Null reference",
            "description": "Missing null check",
            "file": "src/auth.py",
            "line": 42,
        },
    )
    
    fix_id = graph.add_finding(
        workflow="bug-predict",
        finding={
            "type": "fix",
            "name": "Add null check",
            "description": "Added guard clause",
        },
    )
    
    pattern_id = graph.add_finding(
        workflow="pattern-learn",
        finding={
            "type": "pattern",
            "name": "Auth pattern",
            "description": "Authentication flow",
        },
    )
    
    # Add edges
    graph.add_edge(bug_id, fix_id, EdgeType.FIXED_BY)
    graph.add_edge(bug_id, pattern_id, EdgeType.MATCHES)
    
    return graph


class TestMemoryGraphInitialization:
    """Test MemoryGraph initialization behavior."""

    def test_given_new_path_when_init_then_creates_empty_graph(self, temp_graph_path):
        """Test: Initialize graph with new path creates empty graph."""
        # Given: A new path that doesn't exist
        # When: Initializing MemoryGraph
        graph = MemoryGraph(temp_graph_path)
        
        # Then: Graph is empty and file is created
        assert len(graph.nodes) == 0
        assert len(graph.edges) == 0
        assert temp_graph_path.exists()

    def test_given_existing_file_when_init_then_loads_data(self, temp_graph_path):
        """Test: Initialize graph with existing file loads data."""
        # Given: A graph with existing data
        graph1 = MemoryGraph(temp_graph_path)
        node_id = graph1.add_finding(
            workflow="test",
            finding={"type": "bug", "name": "Test bug"},
        )
        
        # When: Creating new graph instance with same path
        graph2 = MemoryGraph(temp_graph_path)
        
        # Then: Data is loaded
        assert len(graph2.nodes) == 1
        assert node_id in graph2.nodes

    def test_given_string_path_when_init_then_converts_to_pathlib(self):
        """Test: Initialize graph with string path converts to Path."""
        # Given: A string path
        path_str = "patterns/test_graph.json"
        
        # When: Initializing with string
        with tempfile.TemporaryDirectory() as tmpdir:
            full_path = Path(tmpdir) / path_str
            full_path.parent.mkdir(parents=True, exist_ok=True)
            graph = MemoryGraph(str(full_path))
            
            # Then: Path is converted to Path object
            assert isinstance(graph.path, Path)


class TestAddFinding:
    """Test add_finding behavior."""

    def test_given_valid_finding_when_add_then_creates_node(self, temp_graph_path, sample_bug_finding):
        """Test: Adding valid finding creates node."""
        # Given: A valid finding
        graph = MemoryGraph(temp_graph_path)
        
        # When: Adding the finding
        node_id = graph.add_finding(workflow="bug-predict", finding=sample_bug_finding)
        
        # Then: Node is created with correct properties
        assert node_id in graph.nodes
        node = graph.nodes[node_id]
        assert node.workflow == "bug-predict"
        assert node.data["name"] == sample_bug_finding["name"]
        assert node.node_type == NodeType.BUG

    def test_given_finding_when_add_then_generates_unique_id(self, temp_graph_path):
        """Test: Adding finding generates unique ID."""
        # Given: A graph and finding
        graph = MemoryGraph(temp_graph_path)
        finding = {"type": "bug", "name": "Test"}
        
        # When: Adding same finding twice
        id1 = graph.add_finding(workflow="test", finding=finding)
        id2 = graph.add_finding(workflow="test", finding=finding)
        
        # Then: IDs are different (due to timestamp)
        assert id1 != id2

    def test_given_finding_with_file_when_add_then_indexes_by_file(
        self, temp_graph_path, sample_bug_finding
    ):
        """Test: Adding finding with file indexes by file path."""
        # Given: A finding with file path
        graph = MemoryGraph(temp_graph_path)
        
        # When: Adding the finding
        node_id = graph.add_finding(workflow="test", finding=sample_bug_finding)
        
        # Then: Node is indexed by file
        assert node_id in graph._nodes_by_file["src/auth.py"]

    def test_given_finding_when_add_then_indexes_by_workflow(
        self, temp_graph_path, sample_bug_finding
    ):
        """Test: Adding finding indexes by workflow."""
        # Given: A finding
        graph = MemoryGraph(temp_graph_path)
        
        # When: Adding the finding
        node_id = graph.add_finding(workflow="bug-predict", finding=sample_bug_finding)
        
        # Then: Node is indexed by workflow
        assert node_id in graph._nodes_by_workflow["bug-predict"]

    def test_given_finding_when_add_then_indexes_by_type(
        self, temp_graph_path, sample_bug_finding
    ):
        """Test: Adding finding indexes by node type."""
        # Given: A finding
        graph = MemoryGraph(temp_graph_path)
        
        # When: Adding the finding
        node_id = graph.add_finding(workflow="test", finding=sample_bug_finding)
        
        # Then: Node is indexed by type
        assert node_id in graph._nodes_by_type[NodeType.BUG]

    def test_given_finding_when_add_then_persists_to_file(
        self, temp_graph_path, sample_bug_finding
    ):
        """Test: Adding finding persists to file."""
        # Given: A finding
        graph = MemoryGraph(temp_graph_path)
        
        # When: Adding the finding
        node_id = graph.add_finding(workflow="test", finding=sample_bug_finding)
        
        # Then: File contains the node
        with open(temp_graph_path) as f:
            data = json.load(f)
        assert len(data["nodes"]) == 1
        assert data["nodes"][0]["id"] == node_id


class TestAddEdge:
    """Test add_edge behavior."""

    def test_given_valid_nodes_when_add_edge_then_creates_edge(self, populated_graph):
        """Test: Adding edge between valid nodes creates edge."""
        # Given: A graph with nodes
        node1_id = populated_graph.add_finding(
            workflow="test", finding={"type": "bug", "name": "Bug1"}
        )
        node2_id = populated_graph.add_finding(
            workflow="test", finding={"type": "fix", "name": "Fix1"}
        )
        
        # When: Adding edge
        edge = populated_graph.add_edge(node1_id, node2_id, EdgeType.FIXED_BY)
        
        # Then: Edge is created
        assert edge in populated_graph.edges
        assert edge.source_id == node1_id
        assert edge.target_id == node2_id
        assert edge.edge_type == EdgeType.FIXED_BY

    def test_given_edge_when_add_then_indexes_by_source(self, populated_graph):
        """Test: Adding edge indexes by source."""
        # Given: Two nodes
        node1_id = populated_graph.add_finding(
            workflow="test", finding={"type": "bug", "name": "Bug"}
        )
        node2_id = populated_graph.add_finding(
            workflow="test", finding={"type": "fix", "name": "Fix"}
        )
        
        # When: Adding edge
        edge = populated_graph.add_edge(node1_id, node2_id, EdgeType.FIXED_BY)
        
        # Then: Edge is indexed by source
        assert edge in populated_graph._edges_by_source[node1_id]

    def test_given_edge_when_add_then_indexes_by_target(self, populated_graph):
        """Test: Adding edge indexes by target."""
        # Given: Two nodes
        node1_id = populated_graph.add_finding(
            workflow="test", finding={"type": "bug", "name": "Bug"}
        )
        node2_id = populated_graph.add_finding(
            workflow="test", finding={"type": "fix", "name": "Fix"}
        )
        
        # When: Adding edge
        edge = populated_graph.add_edge(node1_id, node2_id, EdgeType.FIXED_BY)
        
        # Then: Edge is indexed by target
        assert edge in populated_graph._edges_by_target[node2_id]

    def test_given_edge_with_metadata_when_add_then_stores_metadata(self, populated_graph):
        """Test: Adding edge with metadata stores metadata."""
        # Given: Two nodes and metadata
        node1_id = populated_graph.add_finding(
            workflow="test", finding={"type": "bug", "name": "Bug"}
        )
        node2_id = populated_graph.add_finding(
            workflow="test", finding={"type": "fix", "name": "Fix"}
        )
        metadata = {"confidence": 0.95, "source": "test"}
        
        # When: Adding edge with metadata
        edge = populated_graph.add_edge(
            node1_id, node2_id, EdgeType.FIXED_BY, metadata=metadata
        )
        
        # Then: Metadata is stored
        assert edge.metadata == metadata

    def test_given_nonexistent_source_when_add_edge_then_raises_error(self, populated_graph):
        """Test: Adding edge with nonexistent source raises error."""
        # Given: A nonexistent source node
        node2_id = populated_graph.add_finding(
            workflow="test", finding={"type": "fix", "name": "Fix"}
        )
        
        # When/Then: Adding edge raises KeyError
        with pytest.raises(KeyError):
            populated_graph.add_edge("nonexistent", node2_id, EdgeType.FIXED_BY)

    def test_given_nonexistent_target_when_add_edge_then_raises_error(self, populated_graph):
        """Test: Adding edge with nonexistent target raises error."""
        # Given: A nonexistent target node
        node1_id = populated_graph.add_finding(
            workflow="test", finding={"type": "bug", "name": "Bug"}
        )
        
        # When/Then: Adding edge raises KeyError
        with pytest.raises(KeyError):
            populated_graph.add_edge(node1_id, "nonexistent", EdgeType.FIXED_BY)

    def test_given_edge_when_add_then_persists_to_file(self, temp_graph_path):
        """Test: Adding edge persists to file."""
        # Given: A graph with nodes
        graph = MemoryGraph(temp_graph_path)
        node1_id = graph.add_finding(workflow="test", finding={"type": "bug", "name": "Bug"})
        node2_id = graph.add_finding(workflow="test", finding={"type": "fix", "name": "Fix"})
        
        # When: Adding edge
        graph.add_edge(node1_id, node2_id, EdgeType.FIXED_BY)
        
        # Then: File contains the edge
        with open(temp_graph_path) as f:
            data = json.load(f)
        assert len(data["edges"]) == 1


class TestFindSimilar:
    """Test find_similar behavior."""

    def test_given_matching_name_when_find_similar_then_returns_nodes(self, populated_graph):
        """Test: Finding similar nodes by name returns matches."""
        # Given: A graph with nodes
        # When: Searching for similar nodes
        similar = populated_graph.find_similar({"name": "Null reference"})
        
        # Then: Returns matching nodes
        assert len(similar) > 0
        assert any("Null reference" in node.data.get("name", "") for node in similar)

    def test_given_matching_description_when_find_similar_then_returns_nodes(
        self, populated_graph
    ):
        """Test: Finding similar nodes by description returns matches."""
        # Given: A graph with nodes
        # When: Searching by description
        similar = populated_graph.find_similar({"description": "null check"})
        
        # Then: Returns matching nodes
        assert len(similar) > 0

    def test_given_matching_file_when_find_similar_then_returns_nodes(self, populated_graph):
        """Test: Finding similar nodes by file returns matches."""
        # Given: A graph with nodes
        # When: Searching by file
        similar = populated_graph.find_similar({"file": "src/auth.py"})
        
        # Then: Returns matching nodes
        assert len(similar) > 0
        assert all("src/auth.py" in node.data.get("file", "") for node in similar)

    def test_given_limit_when_find_similar_then_returns_limited_results(
        self, populated_graph
    ):
        """Test: Finding similar nodes with limit returns limited results."""
        # Given: A graph with multiple nodes
        for i in range(5):
            populated_graph.add_finding(
                workflow="test",
                finding={"type": "bug", "name": f