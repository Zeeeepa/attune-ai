"""Behavioral tests for short_term.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import time
from datetime import datetime, timedelta
from typing import Any
from unittest.mock import MagicMock, Mock, call, patch

import pytest

from empathy_os.memory.short_term import (
    REDIS_AVAILABLE,
    RedisShortTermMemory,
)
from empathy_os.memory.types import (
    AccessTier,
    AgentCredentials,
    ConflictContext,
    PaginatedResult,
    RedisConfig,
    RedisMetrics,
    SecurityError,
    StagedPattern,
    TimeWindowQuery,
    TTLStrategy,
)


# Fixtures
@pytest.fixture
def redis_config():
    """Provides a test Redis configuration."""
    return RedisConfig(
        host="localhost",
        port=6379,
        db=0,
        password=None,
        ssl=False,
        socket_timeout=5,
        connection_pool_size=10,
        retry_on_timeout=True,
        max_retries=3,
        retry_backoff_base=0.1,
    )


@pytest.fixture
def contributor_creds():
    """Provides contributor-level credentials."""
    return AgentCredentials(agent_id="agent_1", tier=AccessTier.CONTRIBUTOR)


@pytest.fixture
def steward_creds():
    """Provides steward-level credentials."""
    return AgentCredentials(agent_id="steward_1", tier=AccessTier.STEWARD)


@pytest.fixture
def observer_creds():
    """Provides observer-level credentials."""
    return AgentCredentials(agent_id="observer_1", tier=AccessTier.OBSERVER)


@pytest.fixture
def mock_redis_client():
    """Provides a mocked Redis client."""
    mock_client = MagicMock()
    mock_client.get.return_value = None
    mock_client.set.return_value = True
    mock_client.delete.return_value = 1
    mock_client.exists.return_value = 1
    mock_client.ttl.return_value = 3600
    mock_client.keys.return_value = []
    mock_client.scan.return_value = (0, [])
    mock_client.zadd.return_value = 1
    mock_client.zrangebyscore.return_value = []
    mock_client.lpush.return_value = 1
    mock_client.rpop.return_value = None
    mock_client.pipeline.return_value = mock_client
    mock_client.execute.return_value = []
    mock_client.xadd.return_value = b"1234567890-0"
    mock_client.xrange.return_value = []
    return mock_client


@pytest.fixture
def mock_redis_connection(mock_redis_client):
    """Patches redis.Redis to return a mocked client."""
    with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_redis_client):
        yield mock_redis_client


@pytest.fixture
def memory_instance(redis_config, mock_redis_connection):
    """Provides a RedisShortTermMemory instance with mocked Redis."""
    return RedisShortTermMemory(config=redis_config)


# Test: Initialization
class TestInitialization:
    """Tests for RedisShortTermMemory initialization."""

    def test_init_with_default_config(self, mock_redis_connection):
        """
        Given: No configuration provided
        When: Creating RedisShortTermMemory instance
        Then: Should use default configuration
        """
        memory = RedisShortTermMemory()
        assert memory.config.host == "localhost"
        assert memory.config.port == 6379
        assert memory.config.db == 0

    def test_init_with_custom_config(self, redis_config, mock_redis_connection):
        """
        Given: Custom Redis configuration
        When: Creating RedisShortTermMemory instance
        Then: Should use provided configuration
        """
        custom_config = RedisConfig(host="redis.example.com", port=6380, db=2)
        with patch("empathy_os.memory.short_term.redis.Redis") as mock_redis:
            memory = RedisShortTermMemory(config=custom_config)
            assert memory.config.host == "redis.example.com"
            assert memory.config.port == 6380
            assert memory.config.db == 2

    def test_init_redis_not_available(self):
        """
        Given: Redis library not available
        When: Creating RedisShortTermMemory instance
        Then: Should raise ImportError
        """
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", False):
            with pytest.raises(ImportError, match="redis-py library is required"):
                RedisShortTermMemory()

    def test_init_connection_failure(self, redis_config):
        """
        Given: Redis connection fails
        When: Creating RedisShortTermMemory instance
        Then: Should raise ConnectionError
        """
        with patch("empathy_os.memory.short_term.redis.Redis") as mock_redis:
            mock_redis.side_effect = Exception("Connection failed")
            with pytest.raises(Exception, match="Connection failed"):
                RedisShortTermMemory(config=redis_config)


# Test: Stash operations
class TestStashOperations:
    """Tests for stashing data in short-term memory."""

    def test_stash_basic_data(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid data and contributor credentials
        When: Stashing data with default TTL
        Then: Should store data with correct key and TTL
        """
        key = "test_key"
        value = {"result": "success"}
        
        memory_instance.stash(key, value, contributor_creds)
        
        expected_key = "stm:test_key"
        mock_redis_connection.set.assert_called_once()
        call_args = mock_redis_connection.set.call_args
        assert call_args[0][0] == expected_key
        stored_data = json.loads(call_args[0][1])
        assert stored_data["value"] == value
        assert stored_data["agent_id"] == "agent_1"
        assert stored_data["tier"] == "contributor"

    def test_stash_with_custom_ttl(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid data with custom TTL
        When: Stashing data
        Then: Should store data with specified TTL
        """
        key = "test_key"
        value = {"result": "success"}
        custom_ttl = 7200
        
        memory_instance.stash(key, value, contributor_creds, ttl_seconds=custom_ttl)
        
        call_args = mock_redis_connection.set.call_args
        assert call_args[1]["ex"] == custom_ttl

    def test_stash_with_observer_credentials(self, memory_instance, observer_creds):
        """
        Given: Observer-level credentials
        When: Attempting to stash data
        Then: Should raise PermissionError
        """
        key = "test_key"
        value = {"result": "success"}
        
        with pytest.raises(PermissionError, match="Observer tier cannot write"):
            memory_instance.stash(key, value, observer_creds)

    def test_stash_with_pii_data(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Data containing PII
        When: Stashing data with PII scrubbing enabled
        Then: Should scrub PII before storing
        """
        key = "test_key"
        value = {"email": "test@example.com", "ssn": "123-45-6789"}
        
        with patch.object(memory_instance.pii_scrubber, "scrub", return_value={"email": "[EMAIL]", "ssn": "[SSN]"}):
            memory_instance.stash(key, value, contributor_creds)
            
            call_args = mock_redis_connection.set.call_args
            stored_data = json.loads(call_args[0][1])
            assert stored_data["value"]["email"] == "[EMAIL]"
            assert stored_data["value"]["ssn"] == "[SSN]"

    def test_stash_with_secrets(self, memory_instance, contributor_creds):
        """
        Given: Data containing secrets
        When: Stashing data
        Then: Should raise SecurityError
        """
        key = "test_key"
        value = {"api_key": "sk_live_123456789"}
        
        mock_finding = Mock()
        mock_finding.severity = SecretSeverity.CRITICAL
        
        with patch.object(memory_instance.secrets_detector, "scan", return_value=[mock_finding]):
            with pytest.raises(SecurityError, match="Critical secrets detected"):
                memory_instance.stash(key, value, contributor_creds)

    def test_stash_connection_error(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Redis connection error
        When: Attempting to stash data
        Then: Should raise ConnectionError
        """
        mock_redis_connection.set.side_effect = Exception("Connection lost")
        
        with pytest.raises(Exception, match="Connection lost"):
            memory_instance.stash("test_key", {"data": 1}, contributor_creds)


# Test: Retrieve operations
class TestRetrieveOperations:
    """Tests for retrieving data from short-term memory."""

    def test_retrieve_existing_key(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Data exists in memory
        When: Retrieving data with valid credentials
        Then: Should return stored data
        """
        key = "test_key"
        stored_value = {"result": "success"}
        stored_data = {
            "value": stored_value,
            "agent_id": "agent_1",
            "tier": "contributor",
            "timestamp": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(stored_data).encode()
        
        result = memory_instance.retrieve(key, contributor_creds)
        
        assert result == stored_value
        mock_redis_connection.get.assert_called_once_with("stm:test_key")

    def test_retrieve_nonexistent_key(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Key does not exist in memory
        When: Retrieving data
        Then: Should return None
        """
        mock_redis_connection.get.return_value = None
        
        result = memory_instance.retrieve("nonexistent", contributor_creds)
        
        assert result is None

    def test_retrieve_with_observer_credentials(self, memory_instance, observer_creds, mock_redis_connection):
        """
        Given: Data exists and observer credentials provided
        When: Retrieving data
        Then: Should successfully retrieve data
        """
        stored_data = {
            "value": {"data": 1},
            "agent_id": "agent_1",
            "tier": "contributor",
            "timestamp": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(stored_data).encode()
        
        result = memory_instance.retrieve("test_key", observer_creds)
        
        assert result == {"data": 1}

    def test_retrieve_invalid_json(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Stored data is not valid JSON
        When: Retrieving data
        Then: Should raise ValueError
        """
        mock_redis_connection.get.return_value = b"invalid json"
        
        with pytest.raises(json.JSONDecodeError):
            memory_instance.retrieve("test_key", contributor_creds)

    def test_retrieve_connection_error(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Redis connection error
        When: Attempting to retrieve data
        Then: Should raise ConnectionError
        """
        mock_redis_connection.get.side_effect = Exception("Connection lost")
        
        with pytest.raises(Exception, match="Connection lost"):
            memory_instance.retrieve("test_key", contributor_creds)


# Test: Delete operations
class TestDeleteOperations:
    """Tests for deleting data from short-term memory."""

    def test_delete_existing_key(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Key exists in memory
        When: Deleting with contributor credentials
        Then: Should successfully delete key
        """
        mock_redis_connection.delete.return_value = 1
        
        result = memory_instance.delete("test_key", contributor_creds)
        
        assert result is True
        mock_redis_connection.delete.assert_called_once_with("stm:test_key")

    def test_delete_nonexistent_key(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Key does not exist in memory
        When: Deleting key
        Then: Should return False
        """
        mock_redis_connection.delete.return_value = 0
        
        result = memory_instance.delete("nonexistent", contributor_creds)
        
        assert result is False

    def test_delete_with_observer_credentials(self, memory_instance, observer_creds):
        """
        Given: Observer credentials provided
        When: Attempting to delete key
        Then: Should raise PermissionError
        """
        with pytest.raises(PermissionError, match="Observer tier cannot delete"):
            memory_instance.delete("test_key", observer_creds)

    def test_delete_connection_error(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Redis connection error
        When: Attempting to delete key
        Then: Should raise ConnectionError
        """
        mock_redis_connection.delete.side_effect = Exception("Connection lost")
        
        with pytest.raises(Exception, match="Connection lost"):
            memory_instance.delete("test_key", contributor_creds)


# Test: Batch operations
class TestBatchOperations:
    """Tests for batch stash and retrieve operations."""

    def test_stash_batch_success(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Multiple key-value pairs
        When: Stashing batch with contributor credentials
        Then: Should store all items
        """
        items = [
            ("key1", {"data": 1}),
            ("key2", {"data": 2}),
            ("key3", {"data": 3})
        ]
        mock_redis_connection.execute.return_value = [True, True, True]
        
        memory_instance.stash_batch(items, contributor_creds)
        
        mock_redis_connection.pipeline.assert_called_once()
        assert mock_redis_connection.set.call_count == 3

    def test_stash_batch_with_observer(self, memory_instance, observer_creds):
        """
        Given: Observer credentials
        When: Attempting to stash batch
        Then: Should raise PermissionError
        """
        items = [("key1", {"data": 1})]
        
        with pytest.raises(PermissionError, match="Observer tier cannot write"):
            memory_instance.stash_batch(items, observer_creds)

    def test_retrieve_batch_success(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Multiple keys exist in memory
        When: Retrieving batch
        Then: Should return all values
        """
        keys = ["key1", "key2", "key3"]
        stored_data = [
            json.dumps({"value": {"data": 1}, "agent_id": "agent_1", "tier": "contributor", "timestamp": datetime.utcnow().isoformat()}).encode(),
            json.dumps({"value": {"data": 2}, "agent_id": "agent_1", "tier": "contributor", "timestamp": datetime.utcnow().isoformat()}).encode(),
            None
        ]
        mock_redis_connection.execute.return_value = stored_data
        
        results = memory_instance.retrieve_batch(keys, contributor_creds)
        
        assert len(results) == 3
        assert results["key1"] == {"data": 1}
        assert results["key2"] == {"data": 2}
        assert results["key3"] is None

    def test_retrieve_batch_empty_keys(self, memory_instance, contributor_creds):
        """
        Given: Empty keys list
        When: Retrieving batch
        Then: Should return empty dict
        """
        results = memory_instance.retrieve_batch([], contributor_creds)
        
        assert results == {}


# Test: Pattern operations
class TestPatternOperations:
    """Tests for listing keys by pattern."""

    def test_list_keys_by_pattern(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Keys matching pattern exist
        When: Listing keys by pattern
        Then: Should return matching keys
        """
        mock_redis_connection.keys.return_value = [b"stm:test_1", b"stm:test_2"]
        
        results = memory_instance.list_keys("test_*", contributor_creds)
        
        assert len(results) == 2
        assert "test_1" in results
        assert "test_2" in results

    def test_list_keys_no_matches(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: No keys match pattern
        When: Listing keys by pattern
        Then: Should return empty list
        """
        mock_redis_connection.keys.return_value = []
        
        results = memory_instance.list_keys("nonexistent_*", contributor_creds)
        
        assert results == []

    def test_list_keys_with_scan(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Using SCAN for pagination
        When: Listing keys by pattern
        Then: Should use SCAN instead of KEYS
        """
        mock_redis_connection.scan.return_value = (0, [b"stm:test_1", b"stm:test_2"])
        
        results = memory_instance.list_keys_paginated("test_*", contributor_creds)
        
        assert results.items == ["test_1", "test_2"]
        assert results.cursor == 0
        assert results.total_scanned == 2


# Test: Stage pattern operations
class TestStagePatternOperations:
    """Tests for staging patterns before validation."""

    def test_stage_pattern_success(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid pattern data
        When: Staging pattern with contributor credentials
        Then: Should store pattern with pending status
        """
        pattern_id = "pattern_1"
        pattern_data = {"type": "code_smell", "severity": "medium"}
        
        memory_instance.stage_pattern(pattern_id, pattern_data, contributor_creds)
        
        mock_redis_connection.set.assert_called()
        call_args = mock_redis_connection.set.call_args
        stored_data = json.loads(call_args[0][1])
        assert stored_data["pattern_id"] == pattern_id
        assert stored_data["pattern_data"] == pattern_data
        assert stored_data["status"] == "pending"

    def test_stage_pattern_observer_denied(self, memory_instance, observer_creds):
        """
        Given: Observer credentials
        When: Attempting to stage pattern
        Then: Should raise PermissionError
        """
        with pytest.raises(PermissionError, match="Observer tier cannot stage"):
            memory_instance.stage_pattern("pattern_1", {}, observer_creds)

    def test_retrieve_staged_pattern(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Staged pattern exists
        When: Retrieving staged pattern
        Then: Should return pattern data
        """
        pattern_data = {
            "pattern_id": "pattern_1",
            "pattern_data": {"type": "code_smell"},
            "status": "pending",
            "staged_by": "agent_1",
            "staged_at": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(pattern_data).encode()
        
        result = memory_instance.retrieve_staged_pattern("pattern_1", contributor_creds)
        
        assert result.pattern_id == "pattern_1"
        assert result.status == "pending"

    def test_approve_staged_pattern(self, memory_instance, steward_creds, mock_redis_connection):
        """
        Given: Staged pattern exists
        When: Approving with steward credentials
        Then: Should update status to approved
        """
        pattern_data = {
            "pattern_id": "pattern_1",
            "pattern_data": {"type": "code_smell"},
            "status": "pending",
            "staged_by": "agent_1",
            "staged_at": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(pattern_data).encode()
        
        memory_instance.approve_pattern("pattern_1", steward_creds)
        
        call_args = mock_redis_connection.set.call_args
        updated_data = json.loads(call_args[0][1])
        assert updated_data["status"] == "approved"

    def test_approve_pattern_contributor_denied(self, memory_instance, contributor_creds):
        """
        Given: Contributor credentials
        When: Attempting to approve pattern
        Then: Should raise PermissionError
        """
        with pytest.raises(PermissionError, match="Only stewards can approve"):
            memory_instance.approve_pattern("pattern_1", contributor_creds)

    def test_reject_staged_pattern(self, memory_instance, steward_creds, mock_redis_connection):
        """
        Given: Staged pattern exists
        When: Rejecting with steward credentials
        Then: Should update status to rejected
        """
        pattern_data = {
            "pattern_id": "pattern_1",
            "pattern_data": {"type": "code_smell"},
            "status": "pending",
            "staged_by": "agent_1",
            "staged_at": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(pattern_data).encode()
        
        memory_instance.reject_pattern("pattern_1", "Insufficient evidence", steward_creds)
        
        call_args = mock_redis_connection.set.call_args
        updated_data = json.loads(call_args[0][1])
        assert updated_data["status"] == "rejected"
        assert updated_data["rejection_reason"] == "Insufficient evidence"


# Test: Conflict negotiation
class TestConflictNegotiation:
    """Tests for conflict negotiation context."""

    def test_store_conflict_context(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Conflict context data
        When: Storing conflict context
        Then: Should store context with correct structure
        """
        conflict_id = "conflict_1"
        context = ConflictContext(
            conflict_id=conflict_id,
            agents=["agent_1", "agent_2"],
            data={"issue": "disagreement"},
            proposals={},
            status="open",
            created_at=datetime.utcnow()
        )
        
        memory_instance.store_conflict_context(context, contributor_creds)
        
        mock_redis_connection.set.assert_called()
        call_args = mock_redis_connection.set.call_args
        assert "conflict:conflict_1" in call_args[0][0]

    def test_retrieve_conflict_context(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Conflict context exists
        When: Retrieving conflict context
        Then: Should return context data
        """
        context_data = {
            "conflict_id": "conflict_1",
            "agents": ["agent_1", "agent_2"],
            "data": {"issue": "disagreement"},
            "proposals": {},
            "status": "open",
            "created_at": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(context_data).encode()
        
        result = memory_instance.retrieve_conflict_context("conflict_1", contributor_creds)
        
        assert result.conflict_id == "conflict_1"
        assert result.status == "open"

    def test_add_conflict_proposal(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Conflict context exists
        When: Adding proposal
        Then: Should add proposal to context
        """
        context_data = {
            "conflict_id": "conflict_1",
            "agents": ["agent_1", "agent_2"],
            "data": {"issue": "disagreement"},
            "proposals": {},
            "status": "open",
            "created_at": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(context_data).encode()
        
        proposal = {"solution": "compromise", "rationale": "mutual benefit"}
        memory_instance.add_conflict_proposal("conflict_1", "agent_1", proposal, contributor_creds)
        
        call_args = mock_redis_connection.set.call_args
        updated_data = json.loads(call_args[0][1])
        assert "agent_1" in updated_data["proposals"]

    def test_resolve_conflict(self, memory_instance, steward_creds, mock_redis_connection):
        """
        Given: Conflict context exists
        When: Resolving conflict with steward credentials
        Then: Should update status to resolved
        """
        context_data = {
            "conflict_id": "conflict_1",
            "agents": ["agent_1", "agent_2"],
            "data": {"issue": "disagreement"},
            "proposals": {},
            "status": "open",
            "created_at": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(context_data).encode()
        
        memory_instance.resolve_conflict("conflict_1", "accepted_proposal", steward_creds)
        
        call_args = mock_redis_connection.set.call_args
        updated_data = json.loads(call_args[0][1])
        assert updated_data["status"] == "resolved"


# Test: Pub/Sub operations
class TestPubSubOperations:
    """Tests for Redis Pub/Sub functionality."""

    def test_publish_message(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid channel and message
        When: Publishing message
        Then: Should publish to Redis channel
        """
        channel = "agent_signals"
        message = {"event": "task_complete"}
        mock_redis_connection.publish.return_value = 1
        
        result = memory_instance.publish(channel, message, contributor_creds)
        
        assert result == 1
        mock_redis_connection.publish.assert_called_once()

    def test_publish_observer_denied(self, memory_instance, observer_creds):
        """
        Given: Observer credentials
        When: Attempting to publish
        Then: Should raise PermissionError
        """
        with pytest.raises(PermissionError, match="Observer tier cannot publish"):
            memory_instance.publish("channel", {}, observer_creds)

    def test_subscribe_to_channel(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid channel and callback
        When: Subscribing to channel
        Then: Should set up subscription
        """
        mock_pubsub = MagicMock()
        mock_redis_connection.pubsub.return_value = mock_pubsub
        
        callback = Mock()
        memory_instance.subscribe("agent_signals", callback, contributor_creds)
        
        mock_pubsub.subscribe.assert_called_once_with("agent_signals")

    def test_unsubscribe_from_channel(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Subscribed to channel
        When: Unsubscribing from channel
        Then: Should remove subscription
        """
        mock_pubsub = MagicMock()
        mock_redis_connection.pubsub.return_value = mock_pubsub
        memory_instance.subscribe("agent_signals", Mock(), contributor_creds)
        
        memory_instance.unsubscribe("agent_signals", contributor_creds)
        
        mock_pubsub.unsubscribe.assert_called_once_with("agent_signals")


# Test: Time-window queries
class TestTimeWindowQueries:
    """Tests for time-window query operations."""

    def test_add_timestamped_entry(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid key and data with timestamp
        When: Adding timestamped entry
        Then: Should store in sorted set with score
        """
        key = "events"
        data = {"event": "user_login"}
        timestamp = datetime.utcnow()
        
        memory_instance.add_timestamped_entry(key, data, timestamp, contributor_creds)
        
        mock_redis_connection.zadd.assert_called_once()

    def test_query_time_window(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Timestamped entries exist
        When: Querying time window
        Then: Should return entries within time range
        """
        start_time = datetime.utcnow() - timedelta(hours=1)
        end_time = datetime.utcnow()
        query = TimeWindowQuery(
            key="events",
            start_time=start_time,
            end_time=end_time
        )
        
        mock_data = [json.dumps({"event": "login"}).encode()]
        mock_redis_connection.zrangebyscore.return_value = mock_data
        
        results = memory_instance.query_time_window(query, contributor_creds)
        
        assert len(results) == 1
        assert results[0]["event"] == "login"

    def test_query_time_window_empty_results(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: No entries in time window
        When: Querying time window
        Then: Should return empty list
        """
        query = TimeWindowQuery(
            key="events",
            start_time=datetime.utcnow() - timedelta(hours=1),
            end_time=datetime.utcnow()
        )
        mock_redis_connection.zrangebyscore.return_value = []
        
        results = memory_instance.query_time_window(query, contributor_creds)
        
        assert results == []


# Test: Task queue operations
class TestTaskQueueOperations:
    """Tests for task queue functionality."""

    def test_push_task(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid queue and task data
        When: Pushing task to queue
        Then: Should add task to Redis list
        """
        queue = "processing_queue"
        task = {"task_id": "task_1", "action": "process"}
        
        memory_instance.push_task(queue, task, contributor_creds)
        
        mock_redis_connection.lpush.assert_called_once()

    def test_pop_task(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Tasks exist in queue
        When: Popping task from queue
        Then: Should retrieve and remove task
        """
        task_data = {"task_id": "task_1", "action": "process"}
        mock_redis_connection.rpop.return_value = json.dumps(task_data).encode()
        
        result = memory_instance.pop_task("processing_queue", contributor_creds)
        
        assert result == task_data

    def test_pop_task_empty_queue(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Queue is empty
        When: Popping task from queue
        Then: Should return None
        """
        mock_redis_connection.rpop.return_value = None
        
        result = memory_instance.pop_task("processing_queue", contributor_creds)
        
        assert result is None

    def test_push_task_observer_denied(self, memory_instance, observer_creds):
        """
        Given: Observer credentials
        When: Attempting to push task
        Then: Should raise PermissionError
        """
        with pytest.raises(PermissionError, match="Observer tier cannot push"):
            memory_instance.push_task("queue", {}, observer_creds)


# Test: Audit trail operations
class TestAuditTrailOperations:
    """Tests for Redis Streams audit trail."""

    def test_log_audit_event(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Valid audit event data
        When: Logging audit event
        Then: Should add entry to Redis stream
        """
        event = {
            "action": "data_access",
            "agent_id": "agent_1",
            "resource": "test_key"
        }
        
        memory_instance.log_audit_event(event, contributor_creds)
        
        mock_redis_connection.xadd.assert_called_once()

    def test_retrieve_audit_trail(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Audit events exist
        When: Retrieving audit trail
        Then: Should return list of events
        """
        mock_stream_data = [
            (b"1234567890-0", {b"action": b"data_access", b"agent_id": b"agent_1"})
        ]
        mock_redis_connection.xrange.return_value = mock_stream_data
        
        results = memory_instance.retrieve_audit_trail(limit=10, credentials=contributor_creds)
        
        assert len(results) == 1

    def test_retrieve_audit_trail_steward_only(self, memory_instance, contributor_creds):
        """
        Given: Non-steward credentials
        When: Attempting to retrieve audit trail
        Then: Should raise PermissionError
        """
        with pytest.raises(PermissionError, match="Only stewards can access"):
            memory_instance.retrieve_audit_trail(limit=10, credentials=contributor_creds)


# Test: Metrics tracking
class TestMetricsTracking:
    """Tests for metrics tracking functionality."""

    def test_get_metrics(self, memory_instance, mock_redis_connection):
        """
        Given: Operations have been performed
        When: Getting metrics
        Then: Should return current metrics
        """
        mock_redis_connection.dbsize.return_value = 100
        mock_redis_connection.info.return_value = {"used_memory": 1024000}
        
        metrics = memory_instance.get_metrics()
        
        assert isinstance(metrics, RedisMetrics)
        assert metrics.total_keys >= 0

    def test_increment_operation_count(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Operations being tracked
        When: Performing operations
        Then: Should increment operation counts
        """
        memory_instance.stash("key1", {"data": 1}, contributor_creds)
        
        metrics = memory_instance.get_metrics()
        assert metrics.writes > 0

    def test_track_error_count(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Operations resulting in errors
        When: Errors occur
        Then: Should increment error count
        """
        mock_redis_connection.set.side_effect = Exception("Error")
        
        try:
            memory_instance.stash("key1", {"data": 1}, contributor_creds)
        except Exception:
            pass
        
        metrics = memory_instance.get_metrics()
        assert metrics.errors > 0


# Test: Connection retry logic
class TestConnectionRetry:
    """Tests for connection retry with exponential backoff."""

    def test_retry_on_timeout(self, redis_config, mock_redis_connection):
        """
        Given: Redis timeout error occurs
        When: Performing operation with retry enabled
        Then: Should retry with exponential backoff
        """
        with patch("empathy_os.memory.short_term.redis.Redis") as mock_redis:
            mock_client = MagicMock()
            mock_redis.return_value = mock_client
            
            # First call fails, second succeeds
            mock_client.get.side_effect = [Exception("Timeout"), b"success"]
            
            memory = RedisShortTermMemory(config=redis_config)
            
            with patch("time.sleep"):  # Don't actually sleep in tests
                # This would retry internally if retry logic is implemented
                pass

    def test_max_retries_exceeded(self, redis_config):
        """
        Given: All retry attempts fail
        When: Performing operation
        Then: Should raise exception after max retries
        """
        with patch("empathy_os.memory.short_term.redis.Redis") as mock_redis:
            mock_client = MagicMock()
            mock_redis.return_value = mock_client
            mock_client.get.side_effect = Exception("Persistent error")
            
            memory = RedisShortTermMemory(config=redis_config)
            # Would test retry exhaustion if implemented


# Test: TTL strategy
class TestTTLStrategy:
    """Tests for different TTL strategies."""

    def test_ttl_strategy_fixed(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Fixed TTL strategy
        When: Stashing data
        Then: Should use fixed TTL value
        """
        key = "test_key"
        value = {"data": 1}
        ttl = 3600
        
        memory_instance.stash(key, value, contributor_creds, ttl_seconds=ttl)
        
        call_args = mock_redis_connection.set.call_args
        assert call_args[1]["ex"] == ttl

    def test_ttl_strategy_sliding(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Sliding TTL strategy (TTL resets on access)
        When: Retrieving data
        Then: Should reset TTL
        """
        key = "test_key"
        stored_data = {
            "value": {"data": 1},
            "agent_id": "agent_1",
            "tier": "contributor",
            "timestamp": datetime.utcnow().isoformat()
        }
        mock_redis_connection.get.return_value = json.dumps(stored_data).encode()
        
        # Retrieve with sliding TTL would call expire
        memory_instance.retrieve(key, contributor_creds)
        
        # In a real implementation, this would call EXPIRE


# Test: Paginated results
class TestPaginatedResults:
    """Tests for pagination with SCAN."""

    def test_list_keys_paginated_first_page(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Multiple pages of keys exist
        When: Getting first page
        Then: Should return first page with cursor
        """
        mock_redis_connection.scan.return_value = (10, [b"stm:key1", b"stm:key2"])
        
        result = memory_instance.list_keys_paginated("key*", contributor_creds, cursor=0, count=2)
        
        assert len(result.items) == 2
        assert result.cursor == 10
        assert result.has_more is True

    def test_list_keys_paginated_last_page(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: On last page of results
        When: Getting page
        Then: Should return items with cursor 0
        """
        mock_redis_connection.scan.return_value = (0, [b"stm:key3"])
        
        result = memory_instance.list_keys_paginated("key*", contributor_creds, cursor=10, count=2)
        
        assert len(result.items) == 1
        assert result.cursor == 0
        assert result.has_more is False


# Test: Atomic transactions
class TestAtomicTransactions:
    """Tests for atomic transactions with MULTI/EXEC."""

    def test_atomic_batch_stash(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Multiple operations to perform atomically
        When: Using pipeline for batch stash
        Then: Should execute all operations in transaction
        """
        items = [("key1", {"data": 1}), ("key2", {"data": 2})]
        mock_pipeline = MagicMock()
        mock_redis_connection.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [True, True]
        
        memory_instance.stash_batch(items, contributor_creds)
        
        mock_pipeline.execute.assert_called_once()

    def test_transaction_rollback_on_error(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Transaction with error
        When: Executing pipeline
        Then: Should rollback on error
        """
        mock_pipeline = MagicMock()
        mock_redis_connection.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.side_effect = Exception("Transaction failed")
        
        items = [("key1", {"data": 1})]
        
        with pytest.raises(Exception, match="Transaction failed"):
            memory_instance.stash_batch(items, contributor_creds)


# Test: Security scanning
class TestSecurityScanning:
    """Tests for PII scrubbing and secrets detection."""

    def test_pii_scrubbing_enabled(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: PII scrubbing is enabled
        When: Stashing data with PII
        Then: Should scrub PII before storing
        """
        with patch.object(memory_instance.pii_scrubber, "scrub") as mock_scrub:
            mock_scrub.return_value = {"email": "[EMAIL]"}
            
            memory_instance.stash("key", {"email": "test@example.com"}, contributor_creds)
            
            mock_scrub.assert_called_once()

    def test_secrets_detection_blocks_storage(self, memory_instance, contributor_creds):
        """
        Given: Data contains secrets
        When: Attempting to stash
        Then: Should block and raise SecurityError
        """
        mock_finding = Mock()
        mock_finding.severity = SecretSeverity.CRITICAL
        mock_finding.secret_type = "API_KEY"
        
        with patch.object(memory_instance.secrets_detector, "scan", return_value=[mock_finding]):
            with pytest.raises(SecurityError, match="Critical secrets detected"):
                memory_instance.stash("key", {"api_key": "secret"}, contributor_creds)

    def test_low_severity_secrets_warning(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Data contains low-severity secrets
        When: Stashing data
        Then: Should log warning but allow storage
        """
        mock_finding = Mock()
        mock_finding.severity = SecretSeverity.LOW
        
        with patch.object(memory_instance.secrets_detector, "scan", return_value=[mock_finding]):
            with patch("empathy_os.memory.short_term.logger") as mock_logger:
                memory_instance.stash("key", {"data": 1}, contributor_creds)
                mock_logger.warning.assert_called()


# Test: Edge cases
class TestEdgeCases:
    """Tests for edge cases and boundary conditions."""

    def test_empty_key(self, memory_instance, contributor_creds):
        """
        Given: Empty string as key
        When: Attempting to stash
        Then: Should raise ValueError
        """
        with pytest.raises(ValueError, match="Key cannot be empty"):
            memory_instance.stash("", {"data": 1}, contributor_creds)

    def test_none_value(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: None as value
        When: Stashing data
        Then: Should store None successfully
        """
        memory_instance.stash("key", None, contributor_creds)
        
        call_args = mock_redis_connection.set.call_args
        stored_data = json.loads(call_args[0][1])
        assert stored_data["value"] is None

    def test_very_large_value(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Very large data value
        When: Stashing data
        Then: Should handle large values
        """
        large_value = {"data": "x" * 1000000}  # 1MB of data
        
        memory_instance.stash("key", large_value, contributor_creds)
        
        mock_redis_connection.set.assert_called_once()

    def test_special_characters_in_key(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Key with special characters
        When: Stashing data
        Then: Should handle special characters
        """
        key = "key:with:colons/and/slashes"
        
        memory_instance.stash(key, {"data": 1}, contributor_creds)
        
        call_args = mock_redis_connection.set.call_args
        assert "stm:key:with:colons/and/slashes" in call_args[0][0]

    def test_unicode_in_value(self, memory_instance, contributor_creds, mock_redis_connection):
        """
        Given: Value with unicode characters
        When: Stashing data
        Then: Should handle unicode properly
        """
        value = {"message": "Hello ‰∏ñÁïå üåç"}
        
        memory_instance.stash("key", value, contributor_creds)
        
        call_args = mock_redis_connection.set.call_args
        stored_data = json.loads(call_args[0][1])
        assert stored_data["value"]["message"] == "Hello ‰∏ñÁïå üåç"

    def test_circular_reference_in_value(self, memory_instance, contributor_creds):
        """
        Given: Value with circular reference
        When: Attempting to stash
        Then: Should raise ValueError
        """
        circular = {"key": None}
        circular["key"] = circular
        
        with pytest.raises(ValueError):
            memory_instance.stash("key", circular, contributor_creds)


# Test: Cleanup and resource management
class TestCleanupAndResourceManagement:
    """Tests for proper cleanup and resource management."""

    def test_close_connection(self, memory_instance, mock_redis_connection):
        """
        Given: Active Redis connection
        When: Closing memory instance
        Then: Should close connection properly
        """
        memory_instance.close()
        
        mock_redis_connection.close.assert_called_once()

    def test_context_manager_support(self, redis_config):
        """
        Given: Using memory as context manager
        When: Exiting context
        Then: Should automatically close connection
        """
        with patch("empathy_os.memory.short_term.redis.Redis") as mock_redis:
            mock_client = MagicMock()
            mock_redis.return_value = mock_client
            
            with RedisShortTermMemory(config=redis_config) as memory:
                pass
            
            mock_client.close.assert_called_once()

    def test_cleanup_expired_patterns(self, memory_instance, steward_creds, mock_redis_connection):
        """
        Given: Expired staged patterns exist
        When: Running cleanup
        Then: Should remove expired patterns
        """
        mock_redis_connection.keys.return_value = [b"stm:staged:pattern_1"]
        mock_redis_connection.ttl.return_value = -1  # Expired
        
        memory_instance.cleanup_expired_patterns(steward_creds)
        
        mock_redis_connection.delete.assert_called()