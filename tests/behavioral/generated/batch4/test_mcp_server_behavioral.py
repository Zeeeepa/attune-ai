"""Behavioral tests for mcp_server.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import json
import logging
import pytest
from unittest.mock import AsyncMock, Mock, patch, MagicMock
from typing import Any, Dict

from empathy_os.socratic.mcp_server import (
    MCP_VERSION,
    SOCRATIC_TOOLS,
    handle_initialize,
    handle_tools_list,
    handle_tools_call,
    handle_stdin,
    send_response,
    send_error,
    main,
)


# Fixtures
@pytest.fixture
def mock_stdin():
    """Given a mocked stdin reader."""
    mock = AsyncMock()
    return mock


@pytest.fixture
def mock_stdout():
    """Given a mocked stdout writer."""
    mock = Mock()
    mock.write = Mock()
    mock.flush = Mock()
    return mock


@pytest.fixture
def mock_session_manager():
    """Given a mocked session manager."""
    with patch('empathy_os.socratic.mcp_server.SessionManager') as mock:
        instance = Mock()
        mock.return_value = instance
        instance.create_session = AsyncMock(return_value={
            'session_id': 'test-session-123',
            'state': 'AWAITING_GOAL',
            'goal': None
        })
        instance.set_goal = AsyncMock(return_value={
            'session_id': 'test-session-123',
            'state': 'ASKING_QUESTIONS',
            'goal': 'Test goal',
            'domain': 'test-domain'
        })
        instance.get_questions = AsyncMock(return_value={
            'questions': [
                {'field_id': 'q1', 'text': 'Question 1?', 'type': 'text'}
            ]
        })
        instance.submit_answers = AsyncMock(return_value={
            'state': 'READY_TO_GENERATE',
            'all_answered': True
        })
        instance.generate_workflow = AsyncMock(return_value={
            'agents': [{'name': 'TestAgent', 'role': 'test'}],
            'success_criteria': ['Criteria 1']
        })
        instance.get_session = AsyncMock(return_value={
            'session_id': 'test-session-123',
            'state': 'AWAITING_GOAL'
        })
        yield instance


@pytest.fixture
def sample_request():
    """Given a sample MCP request."""
    return {
        'jsonrpc': '2.0',
        'id': 1,
        'method': 'initialize',
        'params': {
            'protocolVersion': MCP_VERSION,
            'capabilities': {}
        }
    }


@pytest.fixture
def sample_tools_call_request():
    """Given a sample tools/call request."""
    return {
        'jsonrpc': '2.0',
        'id': 2,
        'method': 'tools/call',
        'params': {
            'name': 'socratic_start_session',
            'arguments': {}
        }
    }


# Tests for handle_initialize
class TestHandleInitialize:
    """Tests for handle_initialize function."""

    def test_handle_initialize_with_valid_request(self, sample_request):
        """
        Given a valid initialize request
        When handle_initialize is called
        Then it returns proper initialization response with capabilities
        """
        result = handle_initialize(sample_request)
        
        assert result['jsonrpc'] == '2.0'
        assert result['id'] == sample_request['id']
        assert 'result' in result
        assert result['result']['protocolVersion'] == MCP_VERSION
        assert 'capabilities' in result['result']
        assert 'tools' in result['result']['capabilities']

    def test_handle_initialize_preserves_request_id(self):
        """
        Given an initialize request with specific id
        When handle_initialize is called
        Then the response preserves the request id
        """
        request = {
            'jsonrpc': '2.0',
            'id': 42,
            'method': 'initialize',
            'params': {}
        }
        result = handle_initialize(request)
        
        assert result['id'] == 42

    def test_handle_initialize_returns_server_info(self, sample_request):
        """
        Given a valid initialize request
        When handle_initialize is called
        Then it returns server information
        """
        result = handle_initialize(sample_request)
        
        assert 'serverInfo' in result['result']
        assert result['result']['serverInfo']['name'] == 'socratic-mcp-server'
        assert 'version' in result['result']['serverInfo']


# Tests for handle_tools_list
class TestHandleToolsList:
    """Tests for handle_tools_list function."""

    def test_handle_tools_list_returns_all_tools(self):
        """
        Given a tools/list request
        When handle_tools_list is called
        Then it returns all defined Socratic tools
        """
        request = {'jsonrpc': '2.0', 'id': 1, 'method': 'tools/list'}
        result = handle_tools_list(request)
        
        assert result['jsonrpc'] == '2.0'
        assert result['id'] == 1
        assert 'result' in result
        assert 'tools' in result['result']
        assert len(result['result']['tools']) == len(SOCRATIC_TOOLS)

    def test_handle_tools_list_includes_required_tool_properties(self):
        """
        Given a tools/list request
        When handle_tools_list is called
        Then each tool has name, description, and inputSchema
        """
        request = {'jsonrpc': '2.0', 'id': 1, 'method': 'tools/list'}
        result = handle_tools_list(request)
        
        for tool in result['result']['tools']:
            assert 'name' in tool
            assert 'description' in tool
            assert 'inputSchema' in tool

    def test_handle_tools_list_includes_all_socratic_tools(self):
        """
        Given a tools/list request
        When handle_tools_list is called
        Then it includes all expected Socratic tool names
        """
        request = {'jsonrpc': '2.0', 'id': 1, 'method': 'tools/list'}
        result = handle_tools_list(request)
        
        tool_names = [tool['name'] for tool in result['result']['tools']]
        expected_names = [
            'socratic_start_session',
            'socratic_set_goal',
            'socratic_get_questions',
            'socratic_submit_answers',
            'socratic_generate_workflow',
            'socratic_get_session'
        ]
        for name in expected_names:
            assert name in tool_names


# Tests for handle_tools_call
class TestHandleToolsCall:
    """Tests for handle_tools_call function."""

    @pytest.mark.asyncio
    async def test_handle_tools_call_start_session_without_goal(self, mock_session_manager):
        """
        Given a socratic_start_session call without goal
        When handle_tools_call is called
        Then it creates a session in AWAITING_GOAL state
        """
        request = {
            'jsonrpc': '2.0',
            'id': 1,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_start_session',
                'arguments': {}
            }
        }
        
        result = await handle_tools_call(request)
        
        assert result['jsonrpc'] == '2.0'
        assert result['id'] == 1
        assert 'result' in result
        assert 'content' in result['result']
        mock_session_manager.create_session.assert_called_once_with(None)

    @pytest.mark.asyncio
    async def test_handle_tools_call_start_session_with_goal(self, mock_session_manager):
        """
        Given a socratic_start_session call with goal
        When handle_tools_call is called
        Then it creates a session with the provided goal
        """
        request = {
            'jsonrpc': '2.0',
            'id': 1,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_start_session',
                'arguments': {'goal': 'Build a chatbot'}
            }
        }
        
        result = await handle_tools_call(request)
        
        mock_session_manager.create_session.assert_called_once_with('Build a chatbot')
        assert 'result' in result

    @pytest.mark.asyncio
    async def test_handle_tools_call_set_goal(self, mock_session_manager):
        """
        Given a socratic_set_goal call with session_id and goal
        When handle_tools_call is called
        Then it sets the goal for the session
        """
        request = {
            'jsonrpc': '2.0',
            'id': 2,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_set_goal',
                'arguments': {
                    'session_id': 'test-session-123',
                    'goal': 'Create an API'
                }
            }
        }
        
        result = await handle_tools_call(request)
        
        mock_session_manager.set_goal.assert_called_once_with('test-session-123', 'Create an API')
        assert 'result' in result

    @pytest.mark.asyncio
    async def test_handle_tools_call_get_questions(self, mock_session_manager):
        """
        Given a socratic_get_questions call
        When handle_tools_call is called
        Then it returns questions for the session
        """
        request = {
            'jsonrpc': '2.0',
            'id': 3,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_get_questions',
                'arguments': {'session_id': 'test-session-123'}
            }
        }
        
        result = await handle_tools_call(request)
        
        mock_session_manager.get_questions.assert_called_once_with('test-session-123')
        assert 'result' in result

    @pytest.mark.asyncio
    async def test_handle_tools_call_submit_answers(self, mock_session_manager):
        """
        Given a socratic_submit_answers call with answers
        When handle_tools_call is called
        Then it submits the answers to the session
        """
        request = {
            'jsonrpc': '2.0',
            'id': 4,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_submit_answers',
                'arguments': {
                    'session_id': 'test-session-123',
                    'answers': {'q1': 'answer1', 'q2': 'answer2'}
                }
            }
        }
        
        result = await handle_tools_call(request)
        
        mock_session_manager.submit_answers.assert_called_once_with(
            'test-session-123',
            {'q1': 'answer1', 'q2': 'answer2'}
        )
        assert 'result' in result

    @pytest.mark.asyncio
    async def test_handle_tools_call_generate_workflow(self, mock_session_manager):
        """
        Given a socratic_generate_workflow call
        When handle_tools_call is called
        Then it generates the workflow for the session
        """
        request = {
            'jsonrpc': '2.0',
            'id': 5,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_generate_workflow',
                'arguments': {'session_id': 'test-session-123'}
            }
        }
        
        result = await handle_tools_call(request)
        
        mock_session_manager.generate_workflow.assert_called_once_with('test-session-123')
        assert 'result' in result

    @pytest.mark.asyncio
    async def test_handle_tools_call_get_session(self, mock_session_manager):
        """
        Given a socratic_get_session call
        When handle_tools_call is called
        Then it returns the session state
        """
        request = {
            'jsonrpc': '2.0',
            'id': 6,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_get_session',
                'arguments': {'session_id': 'test-session-123'}
            }
        }
        
        result = await handle_tools_call(request)
        
        mock_session_manager.get_session.assert_called_once_with('test-session-123')
        assert 'result' in result

    @pytest.mark.asyncio
    async def test_handle_tools_call_unknown_tool(self, mock_session_manager):
        """
        Given a tools/call request with unknown tool name
        When handle_tools_call is called
        Then it returns an error response
        """
        request = {
            'jsonrpc': '2.0',
            'id': 7,
            'method': 'tools/call',
            'params': {
                'name': 'unknown_tool',
                'arguments': {}
            }
        }
        
        result = await handle_tools_call(request)
        
        assert 'error' in result
        assert result['error']['code'] == -32601

    @pytest.mark.asyncio
    async def test_handle_tools_call_missing_required_argument(self, mock_session_manager):
        """
        Given a tools/call request missing required arguments
        When handle_tools_call is called
        Then it returns an error response
        """
        request = {
            'jsonrpc': '2.0',
            'id': 8,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_set_goal',
                'arguments': {'session_id': 'test-session-123'}
            }
        }
        
        result = await handle_tools_call(request)
        
        assert 'error' in result
        assert result['error']['code'] == -32602

    @pytest.mark.asyncio
    async def test_handle_tools_call_exception_handling(self, mock_session_manager):
        """
        Given a tools/call that raises an exception
        When handle_tools_call is called
        Then it returns an error response
        """
        mock_session_manager.create_session.side_effect = Exception("Test error")
        
        request = {
            'jsonrpc': '2.0',
            'id': 9,
            'method': 'tools/call',
            'params': {
                'name': 'socratic_start_session',
                'arguments': {}
            }
        }
        
        result = await handle_tools_call(request)
        
        assert 'error' in result
        assert result['error']['code'] == -32603
        assert 'Test error' in result['error']['message']


# Tests for handle_stdin
class TestHandleStdin:
    """Tests for handle_stdin function."""

    @pytest.mark.asyncio
    async def test_handle_stdin_with_initialize_request(self):
        """
        Given an initialize request message
        When handle_stdin is called
        Then it processes and returns the appropriate response
        """
        message = json.dumps({
            '