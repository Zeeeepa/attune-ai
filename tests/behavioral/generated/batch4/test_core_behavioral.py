"""Behavioral tests for core.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from datetime import datetime, timedelta
from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.core import CollaborationState, EmpathyOS
from empathy_os.exceptions import ValidationError
from empathy_os.leverage_points import LeveragePoint
from empathy_os.memory import Classification
from empathy_os.redis_memory import AccessTier, AgentCredentials, StagedPattern


class TestCollaborationState:
    """Test suite for CollaborationState dataclass."""

    def test_given_default_initialization_when_created_then_has_expected_defaults(self):
        """Given: No parameters
        When: CollaborationState is initialized
        Then: Default values are set correctly
        """
        # When
        state = CollaborationState()

        # Then
        assert state.trust_level == 0.5
        assert state.shared_context == {}
        assert state.successful_interventions == 0
        assert state.failed_interventions == 0
        assert state.trust_building_rate == 0.05
        assert state.trust_erosion_rate == 0.10
        assert state.context_accumulation_rate == 0.1
        assert state.total_interactions == 0
        assert state.trust_trajectory == []
        assert isinstance(state.session_start, datetime)

    def test_given_custom_values_when_initialized_then_overrides_defaults(self):
        """Given: Custom initialization parameters
        When: CollaborationState is created with custom values
        Then: Custom values are used instead of defaults
        """
        # Given
        custom_trust = 0.8
        custom_context = {"key": "value"}
        custom_success = 5
        custom_start = datetime(2025, 1, 1)

        # When
        state = CollaborationState(
            trust_level=custom_trust,
            shared_context=custom_context,
            successful_interventions=custom_success,
            session_start=custom_start,
        )

        # Then
        assert state.trust_level == custom_trust
        assert state.shared_context == custom_context
        assert state.successful_interventions == custom_success
        assert state.session_start == custom_start

    def test_given_success_outcome_when_update_trust_then_trust_increases(self):
        """Given: A CollaborationState with default trust
        When: update_trust is called with 'success'
        Then: Trust level increases by trust_building_rate
        """
        # Given
        state = CollaborationState(trust_level=0.5)
        initial_trust = state.trust_level

        # When
        state.update_trust("success")

        # Then
        assert state.trust_level == initial_trust + state.trust_building_rate
        assert state.successful_interventions == 1
        assert state.failed_interventions == 0
        assert state.total_interactions == 1
        assert len(state.trust_trajectory) == 1
        assert state.trust_trajectory[0] == state.trust_level

    def test_given_failure_outcome_when_update_trust_then_trust_decreases(self):
        """Given: A CollaborationState with default trust
        When: update_trust is called with 'failure'
        Then: Trust level decreases by trust_erosion_rate
        """
        # Given
        state = CollaborationState(trust_level=0.5)
        initial_trust = state.trust_level

        # When
        state.update_trust("failure")

        # Then
        assert state.trust_level == initial_trust - state.trust_erosion_rate
        assert state.successful_interventions == 0
        assert state.failed_interventions == 1
        assert state.total_interactions == 1
        assert len(state.trust_trajectory) == 1
        assert state.trust_trajectory[0] == state.trust_level

    def test_given_high_trust_when_success_then_clamped_at_one(self):
        """Given: Trust level at 0.98
        When: update_trust is called with 'success'
        Then: Trust level is clamped to maximum 1.0
        """
        # Given
        state = CollaborationState(trust_level=0.98)

        # When
        state.update_trust("success")

        # Then
        assert state.trust_level == 1.0
        assert state.successful_interventions == 1

    def test_given_low_trust_when_failure_then_clamped_at_zero(self):
        """Given: Trust level at 0.05
        When: update_trust is called with 'failure'
        Then: Trust level is clamped to minimum 0.0
        """
        # Given
        state = CollaborationState(trust_level=0.05)

        # When
        state.update_trust("failure")

        # Then
        assert state.trust_level == 0.0
        assert state.failed_interventions == 1

    def test_given_multiple_outcomes_when_update_trust_then_trajectory_tracked(self):
        """Given: A CollaborationState
        When: update_trust is called multiple times with different outcomes
        Then: All trust levels are tracked in trajectory
        """
        # Given
        state = CollaborationState(trust_level=0.5)

        # When
        state.update_trust("success")
        state.update_trust("success")
        state.update_trust("failure")

        # Then
        assert len(state.trust_trajectory) == 3
        assert state.total_interactions == 3
        assert state.successful_interventions == 2
        assert state.failed_interventions == 1
        assert state.trust_trajectory[0] == 0.55  # 0.5 + 0.05
        assert state.trust_trajectory[1] == 0.60  # 0.55 + 0.05
        assert state.trust_trajectory[2] == 0.50  # 0.60 - 0.10

    def test_given_unknown_outcome_when_update_trust_then_only_interactions_updated(self):
        """Given: A CollaborationState
        When: update_trust is called with unknown outcome
        Then: Only total_interactions is updated, trust remains unchanged
        """
        # Given
        state = CollaborationState(trust_level=0.5)
        initial_trust = state.trust_level

        # When
        state.update_trust("unknown")

        # Then
        assert state.trust_level == initial_trust
        assert state.successful_interventions == 0
        assert state.failed_interventions == 0
        assert state.total_interactions == 1

    def test_given_erosion_faster_than_building_when_comparing_rates_then_erosion_higher(self):
        """Given: Default CollaborationState
        When: Comparing trust_building_rate and trust_erosion_rate
        Then: Erosion rate is higher than building rate
        """
        # Given
        state = CollaborationState()

        # Then
        assert state.trust_erosion_rate > state.trust_building_rate


class TestEmpathyOS:
    """Test suite for EmpathyOS class."""

    @pytest.fixture
    def mock_redis_memory(self):
        """Fixture providing mocked RedisShortTermMemory."""
        with patch("empathy_os.core.RedisShortTermMemory") as mock:
            instance = Mock()
            mock.return_value = instance
            yield instance

    @pytest.fixture
    def mock_unified_memory(self):
        """Fixture providing mocked UnifiedMemory."""
        with patch("empathy_os.core.UnifiedMemory") as mock:
            instance = Mock()
            mock.return_value = instance
            yield instance

    @pytest.fixture
    def mock_feedback_detector(self):
        """Fixture providing mocked FeedbackLoopDetector."""
        with patch("empathy_os.core.FeedbackLoopDetector") as mock:
            instance = Mock()
            mock.return_value = instance
            yield instance

    @pytest.fixture
    def mock_emergence_detector(self):
        """Fixture providing mocked EmergenceDetector."""
        with patch("empathy_os.core.EmergenceDetector") as mock:
            instance = Mock()
            mock.return_value = instance
            yield instance

    @pytest.fixture
    def mock_leverage_analyzer(self):
        """Fixture providing mocked LeveragePointAnalyzer."""
        with patch("empathy_os.core.LeveragePointAnalyzer") as mock:
            instance = Mock()
            mock.return_value = instance
            yield instance

    @pytest.fixture
    def empathy_os_instance(
        self,
        mock_redis_memory,
        mock_unified_memory,
        mock_feedback_detector,
        mock_emergence_detector,
        mock_leverage_analyzer,
    ):
        """Fixture providing configured EmpathyOS instance."""
        return EmpathyOS(user_id="test_user", target_level=3)

    def test_given_user_id_when_initialized_then_creates_instance(
        self,
        mock_redis_memory,
        mock_unified_memory,
        mock_feedback_detector,
        mock_emergence_detector,
        mock_leverage_analyzer,
    ):
        """Given: A user_id parameter
        When: EmpathyOS is initialized
        Then: Instance is created with correct attributes
        """
        # Given
        user_id = "test_user_123"
        target_level = 4

        # When
        empathy = EmpathyOS(user_id=user_id, target_level=target_level)

        # Then
        assert empathy.user_id == user_id
        assert empathy.target_level == target_level
        assert isinstance(empathy.collaboration_state, CollaborationState)

    def test_given_no_target_level_when_initialized_then_uses_default(
        self,
        mock_redis_memory,
        mock_unified_memory,
        mock_feedback_detector,
        mock_emergence_detector,
        mock_leverage_analyzer,
    ):
        """Given: No target_level parameter
        When: EmpathyOS is initialized
        Then: Default target level is used
        """
        # When
        empathy = EmpathyOS(user_id="test_user")

        # Then
        assert empathy.target_level == 3  # Default from implementation

    def test_given_optional_components_when_initialized_then_uses_provided_instances(
        self,
        mock_redis_memory,
        mock_unified_memory,
    ):
        """Given: Optional component instances
        When: EmpathyOS is initialized with custom components
        Then: Uses provided instances instead of creating new ones
        """
        # Given
        custom_feedback = Mock()
        custom_emergence = Mock()
        custom_leverage = Mock()

        # When
        empathy = EmpathyOS(
            user_id="test_user",
            feedback_detector=custom_feedback,
            emergence_detector=custom_emergence,
            leverage_analyzer=custom_leverage,
        )

        # Then
        assert empathy.feedback_detector == custom_feedback
        assert empathy.emergence_detector == custom_emergence
        assert empathy.leverage_analyzer == custom_leverage

    def test_given_agent_credentials_when_initialized_then_passes_to_redis(
        self, mock_redis_memory, mock_unified_memory
    ):
        """Given: AgentCredentials
        When: EmpathyOS is initialized with credentials
        Then: Credentials are passed to RedisShortTermMemory
        """
        # Given
        credentials = AgentCredentials(
            agent_id="agent_123",
            api_key="secret_key",
            access_tier=AccessTier.DEVELOPER,
        )

        # When
        with patch("empathy_os.core.RedisShortTermMemory") as mock_redis_class:
            empathy = EmpathyOS(user_id="test_user", agent_credentials=credentials)

            # Then
            mock_redis_class.assert_called_once()
            call_kwargs = mock_redis_class.call_args[1]
            assert call_kwargs["agent_credentials"] == credentials

    def test_given_empathy_instance_when_accessing_memory_then_returns_unified_memory(
        self, empathy_os_instance, mock_unified_memory
    ):
        """Given: An EmpathyOS instance
        When: Accessing memory attribute
        Then: Returns UnifiedMemory instance
        """
        # Then
        assert empathy_os_instance.memory is not None

    def test_given_empathy_instance_when_accessing_short_term_then_returns_redis_memory(
        self, empathy_os_instance, mock_redis_memory
    ):
        """Given: An EmpathyOS instance
        When: Accessing short_term attribute
        Then: Returns RedisShortTermMemory instance
        """
        # Then
        assert empathy_os_instance.short_term is not None

    def test_given_empathy_instance_when_str_representation_then_contains_user_id(
        self, empathy_os_instance
    ):
        """Given: An EmpathyOS instance
        When: Converting to string
        Then: String representation contains user_id
        """
        # When
        result = str(empathy_os_instance)

        # Then
        assert "test_user" in result
        assert "EmpathyOS" in result

    def test_given_empathy_instance_when_repr_then_contains_full_info(
        self, empathy_os_instance
    ):
        """Given: An EmpathyOS instance
        When: Getting repr
        Then: Representation contains user_id and target_level
        """
        # When
        result = repr(empathy_os_instance)

        # Then
        assert "test_user" in result
        assert "3" in result or "target_level=3" in result

    @patch("empathy_os.core.logging.getLogger")
    def test_given_initialization_when_logger_created_then_uses_module_name(
        self, mock_get_logger
    ):
        """Given: EmpathyOS initialization
        When: Logger is created
        Then: Uses correct module name
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user")

        # Then
        mock_get_logger.assert_called_with("empathy_os.core")

    def test_given_multiple_instances_when_created_then_independent_states(self):
        """Given: Multiple EmpathyOS instances
        When: Created with different user_ids
        Then: Each has independent CollaborationState
        """
        # Given/When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy1 = EmpathyOS(user_id="user1")
            empathy2 = EmpathyOS(user_id="user2")

            # Modify one state
            empathy1.collaboration_state.update_trust("success")

        # Then
        assert empathy1.collaboration_state.trust_level != empathy2.collaboration_state.trust_level
        assert empathy1.user_id != empathy2.user_id

    def test_given_target_level_zero_when_initialized_then_accepts_value(self):
        """Given: target_level of 0
        When: EmpathyOS is initialized
        Then: Accepts zero as valid level
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user", target_level=0)

        # Then
        assert empathy.target_level == 0

    def test_given_high_target_level_when_initialized_then_accepts_value(self):
        """Given: target_level of 5 (maximum in model)
        When: EmpathyOS is initialized
        Then: Accepts high value as valid level
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user", target_level=5)

        # Then
        assert empathy.target_level == 5

    def test_given_special_characters_in_user_id_when_initialized_then_handles_correctly(
        self,
    ):
        """Given: user_id with special characters
        When: EmpathyOS is initialized
        Then: Handles special characters correctly
        """
        # Given
        special_user_id = "user@test.com_123-456"

        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id=special_user_id)

        # Then
        assert empathy.user_id == special_user_id

    def test_given_empty_user_id_when_initialized_then_creates_instance(self):
        """Given: Empty string as user_id
        When: EmpathyOS is initialized
        Then: Creates instance (validation is upstream responsibility)
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="")

        # Then
        assert empathy.user_id == ""

    def test_given_negative_target_level_when_initialized_then_accepts_value(self):
        """Given: Negative target_level
        When: EmpathyOS is initialized
        Then: Accepts value (validation may be downstream)
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user", target_level=-1)

        # Then
        assert empathy.target_level == -1

    def test_given_none_components_when_initialized_then_creates_default_instances(
        self,
    ):
        """Given: None values for optional components
        When: EmpathyOS is initialized
        Then: Creates default instances for all components
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory") as mock_redis, patch(
            "empathy_os.core.UnifiedMemory"
        ) as mock_unified, patch(
            "empathy_os.core.FeedbackLoopDetector"
        ) as mock_feedback, patch(
            "empathy_os.core.EmergenceDetector"
        ) as mock_emergence, patch(
            "empathy_os.core.LeveragePointAnalyzer"
        ) as mock_leverage:
            empathy = EmpathyOS(
                user_id="test_user",
                feedback_detector=None,
                emergence_detector=None,
                leverage_analyzer=None,
            )

        # Then
        assert mock_redis.called
        assert mock_unified.called
        assert mock_feedback.called
        assert mock_emergence.called
        assert mock_leverage.called

    def test_given_collaboration_state_when_multiple_trust_updates_then_state_persists(
        self, empathy_os_instance
    ):
        """Given: An EmpathyOS instance with collaboration state
        When: Multiple trust updates are performed
        Then: State changes persist across updates
        """
        # Given
        initial_trust = empathy_os_instance.collaboration_state.trust_level

        # When
        empathy_os_instance.collaboration_state.update_trust("success")
        empathy_os_instance.collaboration_state.update_trust("success")

        # Then
        assert empathy_os_instance.collaboration_state.trust_level > initial_trust
        assert empathy_os_instance.collaboration_state.successful_interventions == 2
        assert len(empathy_os_instance.collaboration_state.trust_trajectory) == 2

    def test_given_new_instance_when_session_start_checked_then_recent_timestamp(
        self, empathy_os_instance
    ):
        """Given: Newly created EmpathyOS instance
        When: Checking session_start timestamp
        Then: Timestamp is recent (within last minute)
        """
        # When
        session_start = empathy_os_instance.collaboration_state.session_start
        now = datetime.now()

        # Then
        time_diff = now - session_start
        assert time_diff < timedelta(minutes=1)

    def test_given_instance_when_accessing_detectors_then_available(
        self, empathy_os_instance
    ):
        """Given: An EmpathyOS instance
        When: Accessing detector attributes
        Then: All detectors are available and not None
        """
        # Then
        assert empathy_os_instance.feedback_detector is not None
        assert empathy_os_instance.emergence_detector is not None
        assert empathy_os_instance.leverage_analyzer is not None


class TestCollaborationStateIntegration:
    """Integration tests for CollaborationState with EmpathyOS."""

    @pytest.fixture
    def empathy_with_modified_state(self):
        """Fixture providing EmpathyOS with pre-modified collaboration state."""
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="integration_test")
            empathy.collaboration_state.update_trust("success")
            empathy.collaboration_state.update_trust("success")
            empathy.collaboration_state.update_trust("failure")
            return empathy

    def test_given_modified_state_when_checking_trajectory_then_reflects_history(
        self, empathy_with_modified_state
    ):
        """Given: EmpathyOS with multiple trust updates
        When: Checking trust trajectory
        Then: Trajectory reflects all historical updates
        """
        # When
        trajectory = empathy_with_modified_state.collaboration_state.trust_trajectory

        # Then
        assert len(trajectory) == 3
        assert trajectory[0] > 0.5  # First success
        assert trajectory[1] > trajectory[0]  # Second success
        assert trajectory[2] < trajectory[1]  # Failure decreases

    def test_given_modified_state_when_checking_metrics_then_accurate_counts(
        self, empathy_with_modified_state
    ):
        """Given: EmpathyOS with multiple trust updates
        When: Checking intervention metrics
        Then: Counts are accurate
        """
        # When
        state = empathy_with_modified_state.collaboration_state

        # Then
        assert state.successful_interventions == 2
        assert state.failed_interventions == 1
        assert state.total_interactions == 3

    def test_given_fresh_instance_when_no_updates_then_empty_trajectory(self):
        """Given: Fresh EmpathyOS instance
        When: No trust updates performed
        Then: Trajectory is empty
        """
        # Given/When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="fresh_user")

        # Then
        assert empathy.collaboration_state.trust_trajectory == []
        assert empathy.collaboration_state.total_interactions == 0


class TestEmpathyOSEdgeCases:
    """Edge case tests for EmpathyOS."""

    def test_given_very_long_user_id_when_initialized_then_handles_correctly(self):
        """Given: Very long user_id string
        When: EmpathyOS is initialized
        Then: Handles long string without error
        """
        # Given
        long_user_id = "a" * 10000

        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id=long_user_id)

        # Then
        assert empathy.user_id == long_user_id
        assert len(empathy.user_id) == 10000

    def test_given_unicode_user_id_when_initialized_then_handles_correctly(self):
        """Given: user_id with unicode characters
        When: EmpathyOS is initialized
        Then: Handles unicode correctly
        """
        # Given
        unicode_user_id = "user_æµ‹è¯•_ðŸ”¥_Î±Î²Î³"

        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id=unicode_user_id)

        # Then
        assert empathy.user_id == unicode_user_id

    def test_given_float_target_level_when_initialized_then_accepts_value(self):
        """Given: Float value for target_level
        When: EmpathyOS is initialized
        Then: Accepts float value
        """
        # When
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user", target_level=3.5)

        # Then
        assert empathy.target_level == 3.5

    def test_given_many_trust_updates_when_performed_then_trajectory_grows(self):
        """Given: EmpathyOS instance
        When: Many trust updates are performed
        Then: Trajectory list grows accordingly
        """
        # Given
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user")

        # When
        for _ in range(100):
            empathy.collaboration_state.update_trust("success")

        # Then
        assert len(empathy.collaboration_state.trust_trajectory) == 100
        assert empathy.collaboration_state.total_interactions == 100
        assert empathy.collaboration_state.trust_level == 1.0  # Clamped at max

    def test_given_alternating_outcomes_when_updating_trust_then_correct_final_state(
        self,
    ):
        """Given: EmpathyOS instance
        When: Alternating success and failure outcomes
        Then: Final trust level reflects net effect
        """
        # Given
        with patch("empathy_os.core.RedisShortTermMemory"), patch(
            "empathy_os.core.UnifiedMemory"
        ):
            empathy = EmpathyOS(user_id="test_user")
            state = empathy.collaboration_state

        # When - 10 successes (+0.50) and 5 failures (-0.50) = net 0
        for _ in range(10):
            state.update_trust("success")
        for _ in range(5):
            state.update_trust("failure")

        # Then
        expected_trust = 0.5 + (10 * 0.05) - (5 * 0.10)
        assert abs(state.trust_level - expected_trust) < 0.01
        assert state.successful_interventions == 10
        assert state.failed_interventions == 5


class TestCollaborationStateStockFlow:
    """Tests focusing on stock-flow dynamics of CollaborationState."""

    def test_given_default_rates_when_comparing_then_erosion_faster(self):
        """Given: Default CollaborationState
        When: Comparing flow rates
        Then: Erosion rate is double the building rate (as designed)
        """
        # Given
        state = CollaborationState()

        # Then
        assert state.trust_erosion_rate == 0.10
        assert state.trust_building_rate == 0.05
        assert state.trust_erosion_rate == 2 * state.trust_building_rate

    def test_given_custom_rates_when_initialized_then_uses_custom_values(self):
        """Given: Custom flow rates
        When: CollaborationState is initialized
        Then: Uses custom rates for trust updates
        """
        # Given
        custom_build = 0.15
        custom_erode = 0.25

        # When
        state = CollaborationState(
            trust_building_rate=custom_build, trust_erosion_rate=custom_erode
        )
        initial_trust = state.trust_level
        state.update_trust("success")

        # Then
        assert state.trust_level == initial_trust + custom_build

    def test_given_shared_context_when_updated_then_accumulates(self):
        """Given: CollaborationState with shared_context
        When: Context is updated
        Then: Accumulates over time
        """
        # Given
        state = CollaborationState()

        # When
        state.shared_context["topic1"] = "value1"
        state.shared_context["topic2"] = "value2"

        # Then
        assert len(state.shared_context) == 2
        assert "topic1" in state.shared_context
        assert "topic2" in state.shared_context

    def test_given_zero_building_rate_when_success_then_no_trust_increase(self):
        """Given: trust_building_rate of 0
        When: Success outcome is recorded
        Then: Trust level doesn't increase
        """
        # Given
        state = CollaborationState(trust_building_rate=0.0)
        initial_trust = state.trust_level

        # When
        state.update_trust("success")

        # Then
        assert state.trust_level == initial_trust
        assert state.successful_interventions == 1  # Still counted

    def test_given_zero_erosion_rate_when_failure_then_no_trust_decrease(self):
        """Given: trust_erosion_rate of 0
        When: Failure outcome is recorded
        Then: Trust level doesn't decrease
        """
        # Given
        state = CollaborationState(trust_erosion_rate=0.0)
        initial_trust = state.trust_level

        # When
        state.update_trust("failure")

        # Then
        assert state.trust_level == initial_trust
        assert state.failed_interventions == 1  # Still counted