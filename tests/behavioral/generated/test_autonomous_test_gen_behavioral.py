"""Behavioral tests for autonomous_test_gen.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from pathlib import Path
from unittest.mock import patch

import pytest

from attune.workflows.autonomous_test_gen import (
    AutonomousTestGenerator,
    CoverageResult,
    ValidationResult,
)


@pytest.fixture
def mock_generator_config():
    """Fixture providing standard configuration for AutonomousTestGenerator."""
    return {
        "agent_id": "test-agent-001",
        "batch_num": 1,
        "modules": [{"file": "src/attune/test_module.py", "total": 10, "missing": 5}],
        "enable_refinement": True,
        "max_refinement_iterations": 3,
        "enable_coverage_guided": False,
        "target_coverage": 0.80,
    }


def test_autonomous_test_generator_initialization(mock_generator_config):
    """Test successful initialization of AutonomousTestGenerator.

    Scenario:
    - When valid configuration is provided
    - Then object is created with correct attributes
    """
    generator = AutonomousTestGenerator(**mock_generator_config)

    assert generator.agent_id == "test-agent-001"
    assert generator.batch_num == 1
    assert generator.enable_refinement is True
    assert generator.max_refinement_iterations == 3
    assert generator.enable_coverage_guided is False
    assert generator.target_coverage == 0.80


def test_validation_result_creation():
    """Test ValidationResult dataclass creation."""
    result = ValidationResult(
        passed=False,
        failures="Test failures occurred",
        error_count=2,
        output="Detailed test output",
    )

    assert result.passed is False
    assert result.failures == "Test failures occurred"
    assert result.error_count == 2
    assert result.output == "Detailed test output"


def test_coverage_result_creation():
    """Test CoverageResult dataclass creation."""
    result = CoverageResult(
        coverage=0.75, missing_lines=[10, 15, 20], total_statements=100, covered_statements=75
    )

    assert result.coverage == 0.75
    assert result.missing_lines == [10, 15, 20]
    assert result.total_statements == 100
    assert result.covered_statements == 75


@patch("attune.workflows.autonomous_test_gen.AutonomousTestGenerator._generate_module_tests")
def test_generate_all_method(mock_generate_module_tests, mock_generator_config):
    """Test generate_all method behavior.

    Scenario:
    - When generate_all is called
    - Then _generate_module_tests is called for each module
    """
    generator = AutonomousTestGenerator(**mock_generator_config)

    generator.generate_all()

    assert mock_generate_module_tests.call_count == len(mock_generator_config["modules"])


def test_is_workflow_module():
    """Test _is_workflow_module method logic.

    Scenario:
    - When source code contains workflow indicators (class ...Workflow, tier_routing, etc.)
    - Then returns True
    - When source code has no workflow indicators
    - Then returns False
    """
    generator = AutonomousTestGenerator(agent_id="test", batch_num=1, modules=[])

    workflow_source = "class MyWorkflow:\n    pass\n"
    assert generator._is_workflow_module(workflow_source, "attune.workflows.my_workflow") is True

    plain_source = "def helper():\n    return 42\n"
    assert generator._is_workflow_module(plain_source, "attune.utils.helper") is False


@patch("attune.workflows.autonomous_test_gen.AutonomousTestGenerator._run_pytest_validation")
@patch("attune.workflows.autonomous_test_gen.AutonomousTestGenerator._generate_with_llm")
@patch("attune.workflows.autonomous_test_gen._validate_file_path")
@patch.dict("os.environ", {"ANTHROPIC_API_KEY": "fake-key"})
def test_generate_with_refinement(
    mock_validate_path, mock_generate_with_llm, mock_run_pytest, mock_generator_config, tmp_path
):
    """Test multi-turn test generation refinement.

    Scenario:
    - When refinement is enabled and initial generation succeeds
    - And pytest validation passes on first iteration
    - Then _generate_with_llm is called once for initial generation
    - And the result is the generated content
    """
    generator = AutonomousTestGenerator(**mock_generator_config)
    test_content = "# Generated test content\nimport pytest\n"
    mock_generate_with_llm.return_value = test_content

    # Use tmp_path so the temp file can actually be created and cleaned up
    test_file = tmp_path / "test_test_module.py"
    temp_test_file = tmp_path / "_temp_test_test_module.py"

    # Mock _validate_file_path to return a real writable path for the temp file
    mock_validate_path.return_value = temp_test_file

    # Mock pytest validation to pass on first iteration
    mock_run_pytest.return_value = ValidationResult(
        passed=True, failures="", error_count=0, output="all passed"
    )

    result = generator._generate_with_refinement(
        module_name="test_module",
        module_path="attune.test_module",
        source_file=Path("/mock/src/attune/test_module.py"),
        source_code="def hello(): pass",
        test_file=test_file,
    )

    # _generate_with_llm called once for initial generation
    assert mock_generate_with_llm.call_count == 1
    assert result is not None
