"""Behavioral tests for batch.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime
from typing import Any
from unittest.mock import MagicMock, Mock, call, patch

import pytest

from attune.memory.short_term.batch import BatchOperations
from attune.memory.types import AccessTier, AgentCredentials, TTLStrategy


@pytest.fixture
def mock_base_operations():
    """Create a mock BaseOperations instance.

    Returns:
        Mock BaseOperations with Redis client and required methods
    """
    base = Mock()
    base.use_mock = False
    base._client = Mock()
    base._mock_storage = {}
    base._metrics = Mock()
    return base


@pytest.fixture
def batch_operations(mock_base_operations):
    """Create BatchOperations instance with mocked dependencies.

    Args:
        mock_base_operations: Mocked BaseOperations fixture

    Returns:
        BatchOperations instance for testing
    """
    return BatchOperations(mock_base_operations)


@pytest.fixture
def agent_credentials():
    """Create standard agent credentials for testing.

    Returns:
        AgentCredentials with contributor access
    """
    return AgentCredentials("test_agent", AccessTier.CONTRIBUTOR)


class TestBatchOperationsInit:
    """Tests for BatchOperations initialization."""

    def test_init_stores_base_operations(self, mock_base_operations):
        """
        GIVEN: A BaseOperations instance
        WHEN: BatchOperations is initialized
        THEN: The base operations instance is stored
        """
        # When
        batch_ops = BatchOperations(mock_base_operations)

        # Then
        assert batch_ops._base is mock_base_operations

    def test_init_preserves_prefix_working(self, mock_base_operations):
        """
        GIVEN: A BaseOperations instance
        WHEN: BatchOperations is initialized
        THEN: PREFIX_WORKING is accessible
        """
        # When
        batch_ops = BatchOperations(mock_base_operations)

        # Then
        assert batch_ops.PREFIX_WORKING == "empathy:working:"


class TestStashBatch:
    """Tests for stash_batch method."""

    def test_stash_batch_with_empty_list(self, batch_operations, agent_credentials):
        """
        GIVEN: An empty list of items
        WHEN: stash_batch is called
        THEN: Returns 0 without attempting Redis operations
        """
        # When
        result = batch_operations.stash_batch([], agent_credentials)

        # Then
        assert result == 0
        batch_operations._base._client.pipeline.assert_not_called()

    def test_stash_batch_with_single_item(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: A list with a single item
        WHEN: stash_batch is called
        THEN: Item is stored via Redis pipeline and returns 1
        """
        # Given
        items = [("key1", {"data": "value1"})]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        result = batch_operations.stash_batch(items, agent_credentials)

        # Then
        assert result == 1
        mock_pipeline.setex.assert_called_once()
        mock_pipeline.execute.assert_called_once()

    def test_stash_batch_with_multiple_items(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: A list with multiple items
        WHEN: stash_batch is called
        THEN: All items are stored via Redis pipeline
        """
        # Given
        items = [
            ("key1", {"data": "value1"}),
            ("key2", {"data": "value2"}),
            ("key3", {"data": "value3"}),
        ]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True, True, True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        result = batch_operations.stash_batch(items, agent_credentials)

        # Then
        assert result == 3
        assert mock_pipeline.setex.call_count == 3
        mock_pipeline.execute.assert_called_once()

    def test_stash_batch_constructs_correct_keys(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Items with specific keys
        WHEN: stash_batch is called
        THEN: Redis keys are constructed with correct prefix and agent_id
        """
        # Given
        items = [("analysis", {"score": 95})]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        batch_operations.stash_batch(items, agent_credentials)

        # Then
        expected_key = "empathy:working:test_agent:analysis"
        mock_pipeline.setex.assert_called_once()
        call_args = mock_pipeline.setex.call_args[0]
        assert call_args[0] == expected_key

    def test_stash_batch_serializes_data_to_json(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Items with complex data structures
        WHEN: stash_batch is called
        THEN: Data is serialized to JSON before storage
        """
        # Given
        items = [("key1", {"nested": {"data": [1, 2, 3]}, "text": "test"})]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        batch_operations.stash_batch(items, agent_credentials)

        # Then
        call_args = mock_pipeline.setex.call_args[0]
        # setex args: (key, ttl_seconds, json_string)
        stored_value = call_args[2]
        # Verify it's valid JSON
        parsed = json.loads(stored_value)
        assert parsed["data"]["nested"]["data"] == [1, 2, 3]

    def test_stash_batch_applies_ttl_strategy(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: A custom TTL strategy
        WHEN: stash_batch is called with TTL parameter
        THEN: Correct TTL seconds are applied to all items
        """
        # Given
        items = [("key1", {"data": "value1"})]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        batch_operations.stash_batch(items, agent_credentials, ttl=TTLStrategy.STAGED_PATTERNS)

        # Then
        call_args = mock_pipeline.setex.call_args[0]
        # setex args: (key, ttl_seconds, json_string)
        assert call_args[1] == TTLStrategy.STAGED_PATTERNS.value  # 86400

    def test_stash_batch_adds_metadata(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Items to store
        WHEN: stash_batch is called
        THEN: Metadata (stashed_at, agent_id) is added to stored data
        """
        # Given
        items = [("key1", {"user_data": "test"})]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        batch_operations.stash_batch(items, agent_credentials)

        # Then
        call_args = mock_pipeline.setex.call_args[0]
        # setex args: (key, ttl_seconds, json_string)
        stored_data = json.loads(call_args[2])
        assert "stashed_at" in stored_data
        assert stored_data["agent_id"] == "test_agent"
        assert stored_data["data"] == {"user_data": "test"}

    def test_stash_batch_handles_partial_failure(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Multiple items where some fail to store
        WHEN: stash_batch is called
        THEN: Returns count of successfully stored items
        """
        # Given
        items = [
            ("key1", {"data": "value1"}),
            ("key2", {"data": "value2"}),
            ("key3", {"data": "value3"}),
        ]
        mock_pipeline = Mock()
        # Simulate second item failing
        mock_pipeline.execute.return_value = [True, False, True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        result = batch_operations.stash_batch(items, agent_credentials)

        # Then
        assert result == 2

    def test_stash_batch_checks_access_permissions(self, batch_operations, mock_base_operations):
        """
        GIVEN: Credentials that lack write access
        WHEN: stash_batch is called
        THEN: PermissionError is raised
        """
        # Given
        items = [("key1", {"data": "value1"})]
        read_only_creds = AgentCredentials("test_agent", AccessTier.OBSERVER)

        # When / Then
        with pytest.raises(PermissionError):
            batch_operations.stash_batch(items, read_only_creds)

    def test_stash_batch_with_none_values(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Items with None as data value
        WHEN: stash_batch is called
        THEN: None values are properly serialized and stored
        """
        # Given
        items = [("key1", None)]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        result = batch_operations.stash_batch(items, agent_credentials)

        # Then
        assert result == 1
        call_args = mock_pipeline.setex.call_args[0]
        # setex args: (key, ttl_seconds, json_string)
        stored_data = json.loads(call_args[2])
        assert stored_data["data"] is None

    def test_stash_batch_with_special_characters_in_keys(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Items with special characters in keys
        WHEN: stash_batch is called
        THEN: Keys are properly constructed without errors
        """
        # Given
        items = [("key:with:colons", {"data": "value"}), ("key/with/slashes", {"data": "value2"})]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True, True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        result = batch_operations.stash_batch(items, agent_credentials)

        # Then
        assert result == 2
        calls = mock_pipeline.setex.call_args_list
        assert "empathy:working:test_agent:key:with:colons" in calls[0][0][0]
        assert "empathy:working:test_agent:key/with/slashes" in calls[1][0][0]

    def test_stash_batch_with_large_data(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Items with large data structures
        WHEN: stash_batch is called
        THEN: Large data is properly serialized and stored
        """
        # Given
        large_data = {"items": [{"id": i, "value": f"data_{i}"} for i in range(1000)]}
        items = [("large_key", large_data)]
        mock_pipeline = Mock()
        mock_pipeline.execute.return_value = [True]
        mock_base_operations._client.pipeline.return_value = mock_pipeline

        # When
        result = batch_operations.stash_batch(items, agent_credentials)

        # Then
        assert result == 1
        mock_pipeline.setex.assert_called_once()


class TestRetrieveBatch:
    """Tests for retrieve_batch method."""

    def test_retrieve_batch_with_empty_list(self, batch_operations, agent_credentials):
        """
        GIVEN: An empty list of keys
        WHEN: retrieve_batch is called
        THEN: Returns empty dictionary without Redis operations
        """
        # When
        result = batch_operations.retrieve_batch([], agent_credentials)

        # Then
        assert result == {}
        batch_operations._base._client.mget.assert_not_called()

    def test_retrieve_batch_with_single_key(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: A single key to retrieve
        WHEN: retrieve_batch is called
        THEN: Data is retrieved via Redis mget
        """
        # Given
        keys = ["key1"]
        stored_data = {
            "data": {"value": "test"},
            "agent_id": "test_agent",
            "stashed_at": "2026-01-29T12:00:00",
        }
        mock_base_operations._client.mget.return_value = [json.dumps(stored_data)]

        # When
        result = batch_operations.retrieve_batch(keys, agent_credentials)

        # Then
        assert result == {"key1": {"value": "test"}}
        mock_base_operations._client.mget.assert_called_once()

    def test_retrieve_batch_with_multiple_keys(
        self, batch_operations, agent_credentials, mock_base_operations
    ):
        """
        GIVEN: Multiple keys to retrieve
        WHEN: retrieve_batch is called
        THEN: All available data is retrieved via single mget call
        """
        # Given
        keys = ["key1", "key2", "key3"]

        stored_data1 = {
            "data": {"value": "test1"},
            "agent_id": "test_agent",
            "stashed_at": "2026-01-29T12:00:00",
        }
        stored_data2 = {
            "data": {"value": "test2"},
            "agent_id": "test_agent",
            "stashed_at": "2026-01-29T12:00:01",
        }
        # key3 is missing (returns None from mget)
        mock_base_operations._client.mget.return_value = [
            json.dumps(stored_data1),
            json.dumps(stored_data2),
            None,
        ]

        # When
        result = batch_operations.retrieve_batch(keys, agent_credentials)

        # Then
        assert result == {
            "key1": {"value": "test1"},
            "key2": {"value": "test2"},
        }
        assert "key3" not in result
        mock_base_operations._client.mget.assert_called_once()
        # Verify full keys were constructed correctly
        call_args = mock_base_operations._client.mget.call_args[0][0]
        assert call_args == [
            "empathy:working:test_agent:key1",
            "empathy:working:test_agent:key2",
            "empathy:working:test_agent:key3",
        ]
