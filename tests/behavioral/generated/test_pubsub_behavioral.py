"""Behavioral tests for pubsub.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import threading
from typing import TYPE_CHECKING
from unittest.mock import Mock, patch

import pytest

from attune.memory.short_term.pubsub import PubSubManager
from attune.memory.types import AccessTier, AgentCredentials

if TYPE_CHECKING:
    pass

# Check if Redis is actually running (it may be in the cloud, not localhost)
try:
    import redis as _redis_mod

    _r = _redis_mod.Redis(host="localhost", port=6379, socket_connect_timeout=1)
    _r.ping()
    _REDIS_RUNNING = True
except Exception:
    _REDIS_RUNNING = False

_skip_no_redis = pytest.mark.skipif(not _REDIS_RUNNING, reason="Redis not running on localhost")


@pytest.fixture
def mock_base_ops() -> Mock:
    """Provide a mock BaseOperations instance.

    Returns:
        Mock BaseOperations with configured _client, use_mock, and _metrics
    """
    base = Mock()
    base.use_mock = False
    base._client = Mock()
    base._client.pubsub.return_value = Mock()
    base._config = Mock()
    base._config.to_redis_kwargs.return_value = {"host": "localhost", "port": 6379}
    base._metrics = Mock()
    return base


@pytest.fixture
def pubsub_manager(mock_base_ops: Mock) -> PubSubManager:
    """Provide a PubSubManager instance with mocked base operations.

    Args:
        mock_base_ops: Mocked BaseOperations instance

    Returns:
        PubSubManager instance for testing
    """
    return PubSubManager(mock_base_ops)


@pytest.fixture
def contributor_creds() -> AgentCredentials:
    """Provide contributor-level credentials.

    Returns:
        AgentCredentials with CONTRIBUTOR access tier
    """
    return AgentCredentials("agent_1", AccessTier.CONTRIBUTOR)


@pytest.fixture
def observer_creds() -> AgentCredentials:
    """Provide observer-level credentials.

    Returns:
        AgentCredentials with OBSERVER access tier
    """
    return AgentCredentials("agent_observer", AccessTier.OBSERVER)


@pytest.fixture
def steward_creds() -> AgentCredentials:
    """Provide steward-level credentials.

    Returns:
        AgentCredentials with STEWARD access tier
    """
    return AgentCredentials("agent_steward", AccessTier.STEWARD)


class TestPubSubManagerInit:
    """Test PubSubManager initialization behavior."""

    def test_init_sets_base_operations(self, mock_base_ops: Mock) -> None:
        """Given a BaseOperations instance,
        When initializing PubSubManager,
        Then it should store the base operations reference.
        """
        # When
        manager = PubSubManager(mock_base_ops)

        # Then
        assert manager._base is mock_base_ops

    def test_init_initializes_pubsub_to_none(self, mock_base_ops: Mock) -> None:
        """Given a new PubSubManager,
        When initialized,
        Then pubsub should be None.
        """
        # When
        manager = PubSubManager(mock_base_ops)

        # Then
        assert manager._pubsub is None

    def test_init_initializes_empty_subscriptions(self, mock_base_ops: Mock) -> None:
        """Given a new PubSubManager,
        When initialized,
        Then subscriptions dictionary should be empty.
        """
        # When
        manager = PubSubManager(mock_base_ops)

        # Then
        assert manager._subscriptions == {}

    def test_init_sets_pubsub_running_to_false(self, mock_base_ops: Mock) -> None:
        """Given a new PubSubManager,
        When initialized,
        Then pubsub_running flag should be False.
        """
        # When
        manager = PubSubManager(mock_base_ops)

        # Then
        assert manager._pubsub_running is False

    def test_init_initializes_pubsub_thread_to_none(self, mock_base_ops: Mock) -> None:
        """Given a new PubSubManager,
        When initialized,
        Then pubsub thread should be None.
        """
        # When
        manager = PubSubManager(mock_base_ops)

        # Then
        assert manager._pubsub_thread is None

    def test_init_initializes_mock_handlers(self, mock_base_ops: Mock) -> None:
        """Given a new PubSubManager,
        When initialized,
        Then mock pubsub handlers should be empty.
        """
        # When
        manager = PubSubManager(mock_base_ops)

        # Then
        assert manager._mock_pubsub_handlers == {}


class TestPubSubManagerPublish:
    """Test PubSubManager publish behavior."""

    def test_publish_with_contributor_credentials_succeeds(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given a channel and message with contributor credentials,
        When publishing,
        Then the message should be sent and subscriber count returned.
        """
        # Given
        channel = "test_channel"
        message = {"event": "test", "data": "value"}
        mock_base_ops._client.publish.return_value = 2

        # When
        result = pubsub_manager.publish(channel, message, contributor_creds)

        # Then
        assert result == 2
        expected_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        mock_base_ops._client.publish.assert_called_once()
        args = mock_base_ops._client.publish.call_args[0]
        assert args[0] == expected_channel
        published_msg = json.loads(args[1])
        assert published_msg["channel"] == channel
        assert published_msg["data"] == message
        assert published_msg["from_agent"] == contributor_creds.agent_id

    def test_publish_with_steward_credentials_succeeds(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        steward_creds: AgentCredentials,
    ) -> None:
        """Given a channel and message with steward credentials,
        When publishing,
        Then the message should be sent successfully.
        """
        # Given
        channel = "steward_channel"
        message = {"action": "shutdown"}
        mock_base_ops._client.publish.return_value = 5

        # When
        result = pubsub_manager.publish(channel, message, steward_creds)

        # Then
        assert result == 5

    def test_publish_with_observer_credentials_raises_permission_error(
        self,
        pubsub_manager: PubSubManager,
        observer_creds: AgentCredentials,
    ) -> None:
        """Given observer-level credentials,
        When attempting to publish,
        Then a PermissionError should be raised.
        """
        # Given
        channel = "test_channel"
        message = {"event": "test"}

        # When/Then
        with pytest.raises(PermissionError, match="CONTRIBUTOR"):
            pubsub_manager.publish(channel, message, observer_creds)

    def test_publish_includes_timestamp_in_message(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given a message to publish,
        When publishing,
        Then the published message should include a timestamp.
        """
        # Given
        channel = "test_channel"
        message = {"data": "test"}
        mock_base_ops._client.publish.return_value = 1

        # When
        with patch("attune.memory.short_term.pubsub.datetime") as mock_datetime:
            mock_datetime.now.return_value.isoformat.return_value = "2024-01-01T00:00:00"
            pubsub_manager.publish(channel, message, contributor_creds)

        # Then
        args = mock_base_ops._client.publish.call_args[0]
        published_msg = json.loads(args[1])
        assert "timestamp" in published_msg
        assert published_msg["timestamp"] == "2024-01-01T00:00:00"

    def test_publish_returns_zero_when_no_subscribers(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given a channel with no subscribers,
        When publishing,
        Then zero should be returned.
        """
        # Given
        channel = "empty_channel"
        message = {"data": "test"}
        mock_base_ops._client.publish.return_value = 0

        # When
        result = pubsub_manager.publish(channel, message, contributor_creds)

        # Then
        assert result == 0

    def test_publish_adds_channel_prefix(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given a channel name,
        When publishing,
        Then the PREFIX_PUBSUB should be prepended.
        """
        # Given
        channel = "my_channel"
        message = {"data": "test"}
        mock_base_ops._client.publish.return_value = 1

        # When
        pubsub_manager.publish(channel, message, contributor_creds)

        # Then
        expected_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        mock_base_ops._client.publish.assert_called_once()
        assert mock_base_ops._client.publish.call_args[0][0] == expected_channel

    def test_publish_with_complex_message_structure(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given a complex nested message structure,
        When publishing,
        Then it should be serialized correctly.
        """
        # Given
        channel = "test_channel"
        message = {
            "event": "complex",
            "data": {"nested": {"value": 123}, "list": [1, 2, 3]},
            "metadata": {"source": "test"},
        }
        mock_base_ops._client.publish.return_value = 1

        # When
        pubsub_manager.publish(channel, message, contributor_creds)

        # Then
        args = mock_base_ops._client.publish.call_args[0]
        published_msg = json.loads(args[1])
        assert published_msg["data"] == message


class TestPubSubManagerSubscribe:
    """Test PubSubManager subscribe behavior."""

    @_skip_no_redis
    def test_subscribe_registers_handler_in_subscriptions(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given a channel and handler function,
        When subscribing (real mode),
        Then the handler should be registered in _subscriptions with prefixed key.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_base_ops._client.pubsub.return_value = mock_pubsub

        # When
        pubsub_manager.subscribe(channel, handler)

        # Then
        full_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        assert full_channel in pubsub_manager._subscriptions
        assert handler in pubsub_manager._subscriptions[full_channel]

    @_skip_no_redis
    def test_subscribe_multiple_handlers_to_same_channel(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given multiple handlers for the same channel,
        When subscribing each,
        Then all handlers should be registered.
        """
        # Given
        channel = "test_channel"
        handler1 = Mock()
        handler2 = Mock()
        mock_pubsub = Mock()
        mock_base_ops._client.pubsub.return_value = mock_pubsub

        # When
        pubsub_manager.subscribe(channel, handler1)
        pubsub_manager.subscribe(channel, handler2)

        # Then
        full_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        assert len(pubsub_manager._subscriptions[full_channel]) == 2
        assert handler1 in pubsub_manager._subscriptions[full_channel]
        assert handler2 in pubsub_manager._subscriptions[full_channel]

    @_skip_no_redis
    def test_subscribe_to_different_channels(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given handlers for different channels,
        When subscribing,
        Then each channel should have its own handler list.
        """
        # Given
        channel1 = "channel1"
        channel2 = "channel2"
        handler1 = Mock()
        handler2 = Mock()
        mock_pubsub = Mock()
        mock_base_ops._client.pubsub.return_value = mock_pubsub

        # When
        pubsub_manager.subscribe(channel1, handler1)
        pubsub_manager.subscribe(channel2, handler2)

        # Then
        full_channel1 = f"{PubSubManager.PREFIX_PUBSUB}{channel1}"
        full_channel2 = f"{PubSubManager.PREFIX_PUBSUB}{channel2}"
        assert handler1 in pubsub_manager._subscriptions[full_channel1]
        assert handler2 in pubsub_manager._subscriptions[full_channel2]
        assert handler1 not in pubsub_manager._subscriptions[full_channel2]
        assert handler2 not in pubsub_manager._subscriptions[full_channel1]

    def test_subscribe_creates_pubsub_client_on_first_subscription(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given no existing pubsub client,
        When subscribing for the first time,
        Then a pubsub client should be created.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub

        # When - source creates new redis.Redis() for pubsub, not _client.pubsub()
        with patch("redis.Redis", return_value=mock_redis_instance):
            pubsub_manager.subscribe(channel, handler)

        # Then
        mock_redis_instance.pubsub.assert_called_once()
        assert pubsub_manager._pubsub is mock_pubsub

    def test_subscribe_starts_listener_thread_on_first_subscription(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given no active listener thread,
        When subscribing for the first time,
        Then a listener thread should be started and _pubsub_running set True.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub

        # When
        with patch("redis.Redis", return_value=mock_redis_instance):
            with patch.object(threading, "Thread") as mock_thread_cls:
                mock_thread_instance = Mock()
                mock_thread_cls.return_value = mock_thread_instance
                pubsub_manager.subscribe(channel, handler)

        # Then
        mock_thread_cls.assert_called_once()
        mock_thread_instance.start.assert_called_once()
        assert pubsub_manager._pubsub_running is True

    def test_subscribe_subscribes_to_redis_channel_with_kwargs(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given a channel to subscribe to,
        When subscribing,
        Then the Redis pubsub should subscribe using keyword arguments with the prefixed channel.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub

        # When
        with patch("redis.Redis", return_value=mock_redis_instance):
            pubsub_manager.subscribe(channel, handler)

        # Then
        expected_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        mock_pubsub.subscribe.assert_called_once()
        # The source uses keyword args: subscribe(**{full_channel: handler})
        call_kwargs = mock_pubsub.subscribe.call_args[1]
        assert expected_channel in call_kwargs

    def test_subscribe_does_not_create_new_pubsub_on_second_subscription(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given an existing pubsub client,
        When subscribing to another channel,
        Then the existing pubsub client should be reused.
        """
        # Given
        channel1 = "channel1"
        channel2 = "channel2"
        handler1 = Mock()
        handler2 = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub

        # When - source creates redis.Redis() only on first subscribe
        with patch("redis.Redis", return_value=mock_redis_instance) as mock_redis_cls:
            pubsub_manager.subscribe(channel1, handler1)
            pubsub_manager.subscribe(channel2, handler2)

        # Then
        # Redis() should only be called once (on first subscribe)
        mock_redis_cls.assert_called_once()

    def test_subscribe_returns_true_on_success(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given a valid channel and handler,
        When subscribing,
        Then True should be returned.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub

        # When
        with patch("redis.Redis", return_value=mock_redis_instance):
            result = pubsub_manager.subscribe(channel, handler)

        # Then
        assert result is True

    def test_subscribe_returns_false_when_client_is_none(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given no Redis client available,
        When subscribing,
        Then False should be returned.
        """
        # Given
        mock_base_ops._client = None
        channel = "test_channel"
        handler = Mock()

        # When
        result = pubsub_manager.subscribe(channel, handler)

        # Then
        assert result is False


class TestPubSubManagerSubscribeMockMode:
    """Test PubSubManager subscribe behavior in mock mode."""

    def test_subscribe_mock_mode_stores_in_mock_handlers(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode is enabled,
        When subscribing,
        Then handler should be stored in _mock_pubsub_handlers.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        handler = Mock()

        # When
        result = manager.subscribe(channel, handler)

        # Then
        full_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        assert result is True
        assert full_channel in manager._mock_pubsub_handlers
        assert handler in manager._mock_pubsub_handlers[full_channel]

    def test_subscribe_mock_mode_does_not_create_pubsub_client(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode is enabled,
        When subscribing,
        Then no Redis pubsub client should be created.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        handler = Mock()

        # When
        manager.subscribe(channel, handler)

        # Then
        assert manager._pubsub is None
        mock_base_ops._client.pubsub.assert_not_called()

    def test_subscribe_mock_mode_does_not_start_thread(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode is enabled,
        When subscribing,
        Then no listener thread should be started.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        handler = Mock()

        # When
        manager.subscribe(channel, handler)

        # Then
        assert manager._pubsub_running is False
        assert manager._pubsub_thread is None


class TestPubSubManagerPublishMockMode:
    """Test PubSubManager publish behavior in mock mode."""

    def test_publish_mock_mode_calls_registered_handlers(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode with registered handlers,
        When publishing,
        Then registered handlers should be called with the payload.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        handler = Mock()
        creds = AgentCredentials("agent_1", AccessTier.CONTRIBUTOR)

        manager.subscribe(channel, handler)
        message = {"event": "test"}

        # When
        result = manager.publish(channel, message, creds)

        # Then
        assert result == 1
        handler.assert_called_once()
        payload = handler.call_args[0][0]
        assert payload["channel"] == channel
        assert payload["data"] == message
        assert payload["from_agent"] == "agent_1"

    def test_publish_mock_mode_returns_zero_with_no_handlers(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode with no registered handlers,
        When publishing,
        Then zero should be returned.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        creds = AgentCredentials("agent_1", AccessTier.CONTRIBUTOR)
        message = {"event": "test"}

        # When
        result = manager.publish(channel, message, creds)

        # Then
        assert result == 0

    def test_publish_mock_mode_records_metrics(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode,
        When publishing,
        Then metrics should be recorded.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        creds = AgentCredentials("agent_1", AccessTier.CONTRIBUTOR)
        message = {"event": "test"}

        # When
        manager.publish(channel, message, creds)

        # Then
        mock_base_ops._metrics.record_operation.assert_called_once()
        call_args = mock_base_ops._metrics.record_operation.call_args[0]
        assert call_args[0] == "publish"


class TestPubSubManagerUnsubscribe:
    """Test PubSubManager unsubscribe behavior."""

    def test_unsubscribe_removes_channel_subscriptions(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given an active subscription,
        When unsubscribing,
        Then the channel should be removed from subscriptions.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub
        with patch("redis.Redis", return_value=mock_redis_instance):
            pubsub_manager.subscribe(channel, handler)

        # When
        result = pubsub_manager.unsubscribe(channel)

        # Then
        assert result is True
        full_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        assert full_channel not in pubsub_manager._subscriptions

    def test_unsubscribe_calls_redis_unsubscribe(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given an active subscription with a pubsub client,
        When unsubscribing,
        Then Redis pubsub.unsubscribe should be called with prefixed channel.
        """
        # Given
        channel = "test_channel"
        handler = Mock()
        mock_pubsub = Mock()
        mock_redis_instance = Mock()
        mock_redis_instance.pubsub.return_value = mock_pubsub
        with patch("redis.Redis", return_value=mock_redis_instance):
            pubsub_manager.subscribe(channel, handler)

        # When
        pubsub_manager.unsubscribe(channel)

        # Then
        expected_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        mock_pubsub.unsubscribe.assert_called_once_with(expected_channel)

    def test_unsubscribe_returns_false_when_no_pubsub(
        self,
        pubsub_manager: PubSubManager,
    ) -> None:
        """Given no active pubsub client,
        When unsubscribing,
        Then False should be returned.
        """
        # Given
        channel = "test_channel"

        # When
        result = pubsub_manager.unsubscribe(channel)

        # Then
        assert result is False

    def test_unsubscribe_mock_mode_removes_from_mock_handlers(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode with a subscription,
        When unsubscribing,
        Then handler should be removed from _mock_pubsub_handlers.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        handler = Mock()
        manager.subscribe(channel, handler)

        # When
        result = manager.unsubscribe(channel)

        # Then
        assert result is True
        full_channel = f"{PubSubManager.PREFIX_PUBSUB}{channel}"
        assert full_channel not in manager._mock_pubsub_handlers


class TestPubSubManagerClose:
    """Test PubSubManager close behavior."""

    def test_close_stops_pubsub_running(
        self,
        pubsub_manager: PubSubManager,
    ) -> None:
        """Given a running pubsub manager,
        When closing,
        Then _pubsub_running should be set to False.
        """
        # Given
        pubsub_manager._pubsub_running = True

        # When
        pubsub_manager.close()

        # Then
        assert pubsub_manager._pubsub_running is False

    def test_close_closes_pubsub_connection(
        self,
        pubsub_manager: PubSubManager,
    ) -> None:
        """Given an active pubsub connection,
        When closing,
        Then the pubsub connection should be closed and set to None.
        """
        # Given
        mock_pubsub = Mock()
        pubsub_manager._pubsub = mock_pubsub

        # When
        pubsub_manager.close()

        # Then
        mock_pubsub.close.assert_called_once()
        assert pubsub_manager._pubsub is None

    @_skip_no_redis
    def test_close_clears_subscriptions(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
    ) -> None:
        """Given active subscriptions,
        When closing,
        Then all subscriptions should be cleared.
        """
        # Given
        mock_pubsub = Mock()
        mock_base_ops._client.pubsub.return_value = mock_pubsub
        pubsub_manager.subscribe("channel1", Mock())
        pubsub_manager.subscribe("channel2", Mock())

        # When
        pubsub_manager.close()

        # Then
        assert pubsub_manager._subscriptions == {}

    def test_close_clears_mock_handlers(
        self,
        mock_base_ops: Mock,
    ) -> None:
        """Given mock mode with subscriptions,
        When closing,
        Then mock handlers should be cleared.
        """
        # Given
        mock_base_ops.use_mock = True
        manager = PubSubManager(mock_base_ops)
        manager.subscribe("channel1", Mock())

        # When
        manager.close()

        # Then
        assert manager._mock_pubsub_handlers == {}

    def test_close_without_active_pubsub_does_not_error(
        self,
        pubsub_manager: PubSubManager,
    ) -> None:
        """Given no active pubsub connection,
        When closing,
        Then no error should be raised.
        """
        # Given - _pubsub is None by default

        # When/Then - should not raise
        pubsub_manager.close()
        assert pubsub_manager._pubsub is None


class TestPubSubManagerPublishMetrics:
    """Test that publish records metrics in real mode."""

    def test_publish_real_mode_records_metrics(
        self,
        pubsub_manager: PubSubManager,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given real mode,
        When publishing,
        Then metrics should be recorded with publish operation name.
        """
        # Given
        channel = "test_channel"
        message = {"event": "test"}
        mock_base_ops._client.publish.return_value = 1

        # When
        pubsub_manager.publish(channel, message, contributor_creds)

        # Then
        mock_base_ops._metrics.record_operation.assert_called_once()
        call_args = mock_base_ops._metrics.record_operation.call_args[0]
        assert call_args[0] == "publish"

    def test_publish_returns_zero_when_client_is_none(
        self,
        mock_base_ops: Mock,
        contributor_creds: AgentCredentials,
    ) -> None:
        """Given no Redis client available,
        When publishing,
        Then zero should be returned.
        """
        # Given
        mock_base_ops._client = None
        manager = PubSubManager(mock_base_ops)
        channel = "test_channel"
        message = {"event": "test"}

        # When
        result = manager.publish(channel, message, contributor_creds)

        # Then
        assert result == 0
