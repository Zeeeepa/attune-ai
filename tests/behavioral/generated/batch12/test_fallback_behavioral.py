"""Behavioral tests for fallback.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import logging
from unittest.mock import AsyncMock, Mock, patch

import pytest

from empathy_os.resilience.fallback import Fallback, fallback


class TestFallbackClass:
    """Behavioral tests for Fallback class."""

    def test_given_empty_fallback_when_execute_then_raises_runtime_error(self):
        """
        Given: An empty Fallback with no functions
        When: execute() is called
        Then: RuntimeError is raised with appropriate message
        """
        # Given
        fb = Fallback(name="test_fallback")

        # When/Then
        with pytest.raises(RuntimeError, match="no functions to execute"):
            asyncio.run(fb.execute())

    def test_given_fallback_with_default_when_all_fail_then_returns_default(self):
        """
        Given: A Fallback with functions that all fail and a default value
        When: execute() is called
        Then: The default value is returned
        """
        # Given
        def failing_func():
            raise ValueError("Failed")

        fb = Fallback(name="test_fallback", default_value="default_result")
        fb.add(failing_func)

        # When
        result = asyncio.run(fb.execute())

        # Then
        assert result == "default_result"

    def test_given_sync_function_when_execute_then_returns_result(self):
        """
        Given: A Fallback with a synchronous function
        When: execute() is called
        Then: The function result is returned
        """
        # Given
        def success_func():
            return "success"

        fb = Fallback(name="test_fallback")
        fb.add(success_func)

        # When
        result = asyncio.run(fb.execute())

        # Then
        assert result == "success"

    @pytest.mark.asyncio
    async def test_given_async_function_when_execute_then_returns_result(self):
        """
        Given: A Fallback with an async function
        When: execute() is called
        Then: The function result is awaited and returned
        """
        # Given
        async def async_success():
            return "async_success"

        fb = Fallback(name="test_fallback")
        fb.add(async_success)

        # When
        result = await fb.execute()

        # Then
        assert result == "async_success"

    @pytest.mark.asyncio
    async def test_given_multiple_functions_when_first_fails_then_tries_second(self):
        """
        Given: A Fallback with multiple functions where first fails
        When: execute() is called
        Then: Second function is called and returns result
        """
        # Given
        def failing_func():
            raise ValueError("First failed")

        def success_func():
            return "second_success"

        fb = Fallback(name="test_fallback")
        fb.add(failing_func)
        fb.add(success_func)

        # When
        result = await fb.execute()

        # Then
        assert result == "second_success"

    @pytest.mark.asyncio
    async def test_given_functions_with_args_when_execute_then_args_passed(self):
        """
        Given: A Fallback with functions that accept arguments
        When: execute() is called with args and kwargs
        Then: Arguments are properly passed to functions
        """
        # Given
        def func_with_args(a, b, c=None):
            return f"{a}-{b}-{c}"

        fb = Fallback(name="test_fallback")
        fb.add(func_with_args)

        # When
        result = await fb.execute("arg1", "arg2", c="kwarg")

        # Then
        assert result == "arg1-arg2-kwarg"

    @pytest.mark.asyncio
    async def test_given_all_functions_fail_when_no_default_then_raises_last_exception(
        self,
    ):
        """
        Given: A Fallback with functions that all fail and no default
        When: execute() is called
        Then: The last exception is raised
        """
        # Given
        def fail1():
            raise ValueError("First error")

        def fail2():
            raise TypeError("Second error")

        fb = Fallback(name="test_fallback")
        fb.add(fail1)
        fb.add(fail2)

        # When/Then
        with pytest.raises(TypeError, match="Second error"):
            await fb.execute()

    def test_given_fallback_when_add_function_then_returns_self(self):
        """
        Given: A Fallback instance
        When: add() is called with a function
        Then: The Fallback instance is returned for chaining
        """
        # Given
        fb = Fallback(name="test_fallback")

        def dummy_func():
            pass

        # When
        result = fb.add(dummy_func)

        # Then
        assert result is fb
        assert dummy_func in fb.functions

    @pytest.mark.asyncio
    async def test_given_fallback_when_functions_fail_then_logs_warnings(self, caplog):
        """
        Given: A Fallback with failing functions
        When: execute() is called
        Then: Warning messages are logged for failures
        """
        # Given
        def fail1():
            raise ValueError("Error 1")

        def fail2():
            raise ValueError("Error 2")

        fb = Fallback(name="test_fallback", default_value="default")
        fb.add(fail1)
        fb.add(fail2)

        # When
        with caplog.at_level(logging.WARNING):
            await fb.execute()

        # Then
        assert "function 1 failed" in caplog.text
        assert "function 2 failed" in caplog.text

    @pytest.mark.asyncio
    async def test_given_mixed_sync_async_when_execute_then_handles_both(self):
        """
        Given: A Fallback with both sync and async functions
        When: execute() is called
        Then: Both types are handled correctly
        """
        # Given
        def sync_fail():
            raise ValueError("Sync failed")

        async def async_success():
            return "async_worked"

        fb = Fallback(name="test_fallback")
        fb.add(sync_fail)
        fb.add(async_success)

        # When
        result = await fb.execute()

        # Then
        assert result == "async_worked"


class TestFallbackDecorator:
    """Behavioral tests for fallback decorator."""

    @pytest.mark.asyncio
    async def test_given_async_function_when_succeeds_then_returns_result(self):
        """
        Given: An async function decorated with fallback
        When: The function succeeds
        Then: The primary function result is returned
        """
        # Given
        @fallback()
        async def primary_func():
            return "primary_result"

        # When
        result = await primary_func()

        # Then
        assert result == "primary_result"

    @pytest.mark.asyncio
    async def test_given_sync_function_when_succeeds_then_returns_result(self):
        """
        Given: A sync function decorated with fallback
        When: The function succeeds
        Then: The primary function result is returned
        """
        # Given
        @fallback()
        async def primary_func():
            return "sync_result"

        # When
        result = await primary_func()

        # Then
        assert result == "sync_result"

    @pytest.mark.asyncio
    async def test_given_primary_fails_when_fallback_succeeds_then_returns_fallback_result(
        self,
    ):
        """
        Given: A function that fails with a fallback function
        When: Primary fails but fallback succeeds
        Then: Fallback result is returned
        """
        # Given
        def fallback_func():
            return "fallback_result"

        @fallback(fallback_func)
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        result = await primary_func()

        # Then
        assert result == "fallback_result"

    @pytest.mark.asyncio
    async def test_given_all_fail_when_default_provided_then_returns_default(self):
        """
        Given: Primary and fallback functions that all fail with default value
        When: All functions fail
        Then: Default value is returned
        """
        # Given
        def fallback_func():
            raise ValueError("Fallback failed")

        @fallback(fallback_func, default="default_value")
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        result = await primary_func()

        # Then
        assert result == "default_value"

    @pytest.mark.asyncio
    async def test_given_all_fail_when_no_default_then_raises_exception(self):
        """
        Given: Primary and fallback functions that all fail without default
        When: All functions fail
        Then: The last exception is raised
        """
        # Given
        def fallback_func():
            raise TypeError("Fallback failed")

        @fallback(fallback_func)
        async def primary_func():
            raise ValueError("Primary failed")

        # When/Then
        with pytest.raises(TypeError, match="Fallback failed"):
            await primary_func()

    @pytest.mark.asyncio
    async def test_given_multiple_fallbacks_when_execute_then_tries_in_order(self):
        """
        Given: Multiple fallback functions
        When: Primary and first fallback fail
        Then: Functions are tried in order until one succeeds
        """
        # Given
        def fallback1():
            raise ValueError("Fallback 1 failed")

        def fallback2():
            return "fallback2_success"

        def fallback3():
            return "fallback3_success"

        @fallback(fallback1, fallback2, fallback3)
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        result = await primary_func()

        # Then
        assert result == "fallback2_success"

    @pytest.mark.asyncio
    async def test_given_function_with_args_when_execute_then_args_passed_to_fallbacks(
        self,
    ):
        """
        Given: Functions that accept arguments
        When: Decorated function is called with args
        Then: Arguments are passed to fallback functions
        """
        # Given
        def fallback_func(a, b):
            return f"fallback-{a}-{b}"

        @fallback(fallback_func)
        async def primary_func(a, b):
            raise ValueError("Primary failed")

        # When
        result = await primary_func("x", "y")

        # Then
        assert result == "fallback-x-y"

    @pytest.mark.asyncio
    async def test_given_log_failures_false_when_fails_then_no_warning_logged(
        self, caplog
    ):
        """
        Given: Fallback decorator with log_failures=False
        When: Primary function fails
        Then: No warning is logged
        """
        # Given
        def fallback_func():
            return "fallback"

        @fallback(fallback_func, log_failures=False)
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        with caplog.at_level(logging.WARNING):
            await primary_func()

        # Then
        assert "Primary function" not in caplog.text

    @pytest.mark.asyncio
    async def test_given_log_failures_true_when_fails_then_warning_logged(self, caplog):
        """
        Given: Fallback decorator with log_failures=True (default)
        When: Primary function fails
        Then: Warning is logged
        """
        # Given
        def fallback_func():
            return "fallback"

        @fallback(fallback_func, log_failures=True)
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        with caplog.at_level(logging.WARNING):
            await primary_func()

        # Then
        assert "Primary function primary_func failed" in caplog.text

    @pytest.mark.asyncio
    async def test_given_async_fallback_when_execute_then_awaits_correctly(self):
        """
        Given: An async fallback function
        When: Primary fails and fallback is called
        Then: Async fallback is properly awaited
        """
        # Given
        async def async_fallback():
            await asyncio.sleep(0.01)
            return "async_fallback_result"

        @fallback(async_fallback)
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        result = await primary_func()

        # Then
        assert result == "async_fallback_result"

    @pytest.mark.asyncio
    async def test_given_no_fallbacks_when_primary_fails_then_raises_exception(self):
        """
        Given: Decorator with no fallback functions
        When: Primary function fails
        Then: Primary exception is raised
        """
        # Given
        @fallback()
        async def primary_func():
            raise ValueError("Primary failed")

        # When/Then
        with pytest.raises(ValueError, match="Primary failed"):
            await primary_func()

    @pytest.mark.asyncio
    async def test_given_decorator_when_applied_then_preserves_function_name(self):
        """
        Given: A function decorated with fallback
        When: Accessing function metadata
        Then: Original function name is preserved
        """
        # Given
        @fallback()
        async def my_special_function():
            return "result"

        # When/Then
        assert my_special_function.__name__ == "my_special_function"

    @pytest.mark.asyncio
    async def test_given_mixed_sync_async_fallbacks_when_execute_then_handles_both(self):
        """
        Given: Mix of sync and async fallback functions
        When: Primary fails
        Then: Both sync and async fallbacks are handled correctly
        """
        # Given
        def sync_fallback():
            raise ValueError("Sync fallback failed")

        async def async_fallback():
            return "async_success"

        @fallback(sync_fallback, async_fallback)
        async def primary_func():
            raise ValueError("Primary failed")

        # When
        result = await primary_func()

        # Then
        assert result == "async_success"

    @pytest.mark.asyncio
    async def test_given_fallback_with_kwargs_when_execute_then_kwargs_passed(self):
        """
        Given: Functions that accept keyword arguments
        When: Decorated function is called with kwargs
        Then: Kwargs are passed to fallback functions
        """
        # Given
        def fallback_func(*, key1, key2):
            return f"{key1}-{key2}"

        @fallback(fallback_func)
        async def primary_func(*, key1, key2):
            raise ValueError("Primary failed")

        # When
        result = await primary_func(key1="a", key2="b")

        # Then
        assert result == "a-b"

    @pytest.mark.asyncio
    async def test_given_exception_in_fallback_when_more_fallbacks_then_continues(self):
        """
        Given: Multiple fallbacks where some raise exceptions
        When: Fallbacks are tried in sequence
        Then: Continues to next fallback after exception
        """
        # Given
        call_order = []

        def fallback1():
            call_order.append(1)
            raise ValueError("Fallback 1 failed")

        def fallback2():
            call_order