"""Behavioral tests for templates.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from pathlib import Path
from unittest.mock import Mock, patch, mock_open, call
from typing import Any

from empathy_os.templates import (
    TEMPLATES,
    create_project_from_template,
    get_template_info,
    list_templates,
    render_template,
    write_template_files,
)


class TestTemplateDefinitions:
    """Tests for TEMPLATES constant structure."""

    def test_given_templates_when_accessed_then_contains_expected_keys(self):
        """GIVEN the TEMPLATES dictionary
        WHEN we access it
        THEN it contains all expected template keys
        """
        assert "minimal" in TEMPLATES
        assert "python-cli" in TEMPLATES
        assert "python-fastapi" in TEMPLATES
        assert "python-agent" in TEMPLATES

    def test_given_template_when_checked_then_has_required_fields(self):
        """GIVEN any template in TEMPLATES
        WHEN we check its structure
        THEN it has name, description, and files fields
        """
        for template_name, template_data in TEMPLATES.items():
            assert "name" in template_data, f"{template_name} missing 'name'"
            assert "description" in template_data, f"{template_name} missing 'description'"
            assert "files" in template_data, f"{template_name} missing 'files'"
            assert isinstance(template_data["files"], dict)

    def test_given_minimal_template_when_inspected_then_has_config_file(self):
        """GIVEN the minimal template
        WHEN we inspect its files
        THEN it includes empathy.config.yml
        """
        assert "empathy.config.yml" in TEMPLATES["minimal"]["files"]

    def test_given_template_files_when_checked_then_contain_valid_yaml(self):
        """GIVEN template files
        WHEN we check config files
        THEN they contain valid YAML structure markers
        """
        minimal_config = TEMPLATES["minimal"]["files"]["empathy.config.yml"]
        assert "user_id:" in minimal_config
        assert "target_level:" in minimal_config
        assert "model_routing:" in minimal_config


class TestListTemplates:
    """Tests for list_templates function."""

    def test_given_no_args_when_list_templates_then_returns_all_templates(self):
        """GIVEN no arguments
        WHEN list_templates is called
        THEN it returns all available templates
        """
        result = list_templates()
        
        assert isinstance(result, dict)
        assert len(result) >= 4
        assert "minimal" in result
        assert "python-cli" in result

    def test_given_templates_when_listed_then_each_has_name_and_description(self):
        """GIVEN the template list
        WHEN we iterate through results
        THEN each has name and description
        """
        result = list_templates()
        
        for template_id, info in result.items():
            assert "name" in info
            assert "description" in info
            assert isinstance(info["name"], str)
            assert isinstance(info["description"], str)
            assert len(info["name"]) > 0
            assert len(info["description"]) > 0


class TestGetTemplateInfo:
    """Tests for get_template_info function."""

    def test_given_valid_template_name_when_get_info_then_returns_template_data(self):
        """GIVEN a valid template name
        WHEN get_template_info is called
        THEN it returns the template data
        """
        result = get_template_info("minimal")
        
        assert result is not None
        assert result["name"] == "Minimal"
        assert "description" in result
        assert "files" in result

    def test_given_invalid_template_name_when_get_info_then_returns_none(self):
        """GIVEN an invalid template name
        WHEN get_template_info is called
        THEN it returns None
        """
        result = get_template_info("nonexistent-template")
        
        assert result is None

    def test_given_empty_string_when_get_info_then_returns_none(self):
        """GIVEN an empty string
        WHEN get_template_info is called
        THEN it returns None
        """
        result = get_template_info("")
        
        assert result is None

    def test_given_python_cli_template_when_get_info_then_returns_correct_data(self):
        """GIVEN the python-cli template name
        WHEN get_template_info is called
        THEN it returns the correct template data
        """
        result = get_template_info("python-cli")
        
        assert result is not None
        assert result["name"] == "Python CLI Tool"
        assert "cli" in result["description"].lower()


class TestRenderTemplate:
    """Tests for render_template function."""

    def test_given_simple_template_when_rendered_then_replaces_placeholders(self):
        """GIVEN a simple template string with placeholders
        WHEN render_template is called with context
        THEN placeholders are replaced correctly
        """
        template_str = "Hello {{name}}, welcome to {{project_name}}!"
        context = {"name": "Alice", "project_name": "MyProject"}
        
        result = render_template(template_str, context)
        
        assert result == "Hello Alice, welcome to MyProject!"
        assert "{{" not in result

    def test_given_template_without_placeholders_when_rendered_then_returns_unchanged(self):
        """GIVEN a template string without placeholders
        WHEN render_template is called
        THEN it returns the string unchanged
        """
        template_str = "Plain text without placeholders"
        context = {"name": "Alice"}
        
        result = render_template(template_str, context)
        
        assert result == template_str

    def test_given_template_with_missing_context_when_rendered_then_keeps_placeholder(self):
        """GIVEN a template with placeholders not in context
        WHEN render_template is called
        THEN unmatched placeholders remain
        """
        template_str = "Hello {{name}}, {{missing}} here"
        context = {"name": "Bob"}
        
        result = render_template(template_str, context)
        
        assert "Hello Bob" in result
        assert "{{missing}}" in result

    def test_given_empty_template_when_rendered_then_returns_empty_string(self):
        """GIVEN an empty template string
        WHEN render_template is called
        THEN it returns empty string
        """
        result = render_template("", {"key": "value"})
        
        assert result == ""

    def test_given_template_with_multiple_same_placeholder_when_rendered_then_replaces_all(self):
        """GIVEN a template with repeated placeholder
        WHEN render_template is called
        THEN all occurrences are replaced
        """
        template_str = "{{name}} loves {{name}}'s work"
        context = {"name": "Charlie"}
        
        result = render_template(template_str, context)
        
        assert result == "Charlie loves Charlie's work"

    def test_given_template_with_special_characters_when_rendered_then_preserves_them(self):
        """GIVEN a template with special characters
        WHEN render_template is called
        THEN special characters are preserved
        """
        template_str = "File: {{project_name}}/__init__.py\nVersion: 0.1.0"
        context = {"project_name": "my_app"}
        
        result = render_template(template_str, context)
        
        assert "my_app/__init__.py" in result
        assert "\n" in result


class TestWriteTemplateFiles:
    """Tests for write_template_files function."""

    @patch("empathy_os.templates.Path")
    def test_given_template_files_when_written_then_creates_directories(self, mock_path):
        """GIVEN template files with nested paths
        WHEN write_template_files is called
        THEN it creates necessary directories
        """
        mock_target = Mock()
        mock_file_path = Mock()
        mock_file_path.parent = Mock()
        mock_target.__truediv__ = Mock(return_value=mock_file_path)
        
        files = {
            "nested/dir/file.txt": "content",
        }
        context = {}
        
        write_template_files(files, mock_target, context)
        
        mock_file_path.parent.mkdir.assert_called()

    @patch("empathy_os.templates.Path")
    @patch("builtins.open", new_callable=mock_open)
    def test_given_files_when_written_then_writes_rendered_content(self, mock_file, mock_path):
        """GIVEN template files with placeholders
        WHEN write_template_files is called
        THEN files are written with rendered content
        """
        mock_target = Mock(spec=Path)
        mock_file_path = Mock(spec=Path)
        mock_file_path.parent = Mock()
        mock_target.__truediv__ = Mock(return_value=mock_file_path)
        
        files = {
            "config.yml": "user: {{user_name}}",
        }
        context = {"user_name": "test_user"}
        
        write_template_files(files, mock_target, context)
        
        mock_file.assert_called()
        written_content = "".join(
            call.args[0] for call in mock_file().write.call_args_list
        )
        assert "test_user" in written_content

    @patch("empathy_os.templates.Path")
    def test_given_empty_files_dict_when_written_then_no_files_created(self, mock_path):
        """GIVEN an empty files dictionary
        WHEN write_template_files is called
        THEN no files are created
        """
        mock_target = Mock(spec=Path)
        
        files = {}
        context = {}
        
        # Should not raise an error
        write_template_files(files, mock_target, context)

    @patch("empathy_os.templates.Path")
    @patch("builtins.open", new_callable=mock_open)
    def test_given_file_with_special_chars_when_written_then_preserves_content(
        self, mock_file, mock_path
    ):
        """GIVEN file content with special characters
        WHEN write_template_files is called
        THEN special characters are preserved
        """
        mock_target = Mock(spec=Path)
        mock_file_path = Mock(spec=Path)
        mock_file_path.parent = Mock()
        mock_target.__truediv__ = Mock(return_value=mock_file_path)
        
        files = {
            "script.sh": "#!/bin/bash\necho 'Hello {{name}}'",
        }
        context = {"name": "World"}
        
        write_template_files(files, mock_target, context)
        
        mock_file.assert_called()


class TestCreateProjectFromTemplate:
    """Tests for create_project_from_template function."""

    @patch("empathy_os.templates.write_template_files")
    @patch("empathy_os.templates.get_template_info")
    def test_given_valid_template_when_create_project_then_writes_files(
        self, mock_get_info, mock_write_files
    ):
        """GIVEN a valid template name and target directory
        WHEN create_project_from_template is called
        THEN it writes template files to target
        """
        mock_get_info.return_value = {
            "name": "Test",
            "files": {"file.txt": "content"},
        }
        target_dir = Path("/tmp/test_project")
        
        result = create_project_from_template("minimal", target_dir, "MyProject")
        
        assert result is True
        mock_write_files.assert_called_once()

    @patch("empathy_os.templates.get_template_info")
    def test_given_invalid_template_when_create_project_then_returns_false(
        self, mock_get_info
    ):
        """GIVEN an invalid template name
        WHEN create_project_from_template is called
        THEN it returns False
        """
        mock_get_info.return_value = None
        target_dir = Path("/tmp/test_project")
        
        result = create_project_from_template("invalid", target_dir, "Project")
        
        assert result is False

    @patch("empathy_os.templates.write_template_files")
    @patch("empathy_os.templates.get_template_info")
    def test_given_template_when_create_project_then_passes_context(
        self, mock_get_info, mock_write_files
    ):
        """GIVEN a template and project name
        WHEN create_project_from_template is called
        THEN it passes correct context to write_template_files
        """
        mock_get_info.return_value = {
            "name": "Test",
            "files": {"file.txt": "{{project_name}}"},
        }
        target_dir = Path("/tmp/test_project")
        
        create_project_from_template("minimal", target_dir, "MyProject")
        
        call_args = mock_write_files.call_args
        context = call_args[0][2]
        assert context["project_name"] == "MyProject"

    @patch("empathy_os.templates.write_template_files")
    @patch("empathy_os.templates.get_template_info")
    def test_given_all_templates_when_create_project_then_succeeds(
        self, mock_get_info, mock_write_files
    ):
        """GIVEN each available template
        WHEN create_project_from_template is called
        THEN it succeeds for each template
        """
        for template_name in TEMPLATES.keys():
            mock_get_info.return_value = TEMPLATES[template_name]
            target_dir = Path(f"/tmp/test_{template_name}")
            
            result = create_project_from_template(
                template_name, target_dir, "TestProject"
            )
            
            assert result is True

    @patch("empathy_os.templates.write_template_files")
    @patch("empathy_os.templates.get_template_info")
    def test_given_exception_during_write_when_create_project_then_returns_false(
        self, mock_get_info, mock_write_files
    ):
        """GIVEN an exception occurs during file writing
        WHEN create_project_from_template is called
        THEN it returns False and handles the exception
        """
        mock_get_info.return_value = {
            "name": "Test",
            "files": {"file.txt": "content"},
        }
        mock_write_files.side_effect = OSError("Permission denied")
        target_dir = Path("/tmp/test_project")
        
        result = create_project_from_template("minimal", target_dir, "Project")
        
        assert result is False


class TestTemplateFileContent:
    """Tests for template file content validation."""

    def test_given_minimal_template_when_checked_then_has_valid_structure(self):
        """GIVEN the minimal template
        WHEN we check its config file
        THEN it has valid YAML structure
        """
        config = TEMPLATES["minimal"]["files"]["empathy.config.yml"]
        
        assert "user_id:" in config
        assert "target_level:" in config
        assert "confidence_threshold:" in config
        assert "model_routing:" in config

    def test_given_python_cli_template_when_checked_then_has_python_files(self