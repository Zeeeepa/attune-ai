"""Behavioral tests for sync.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from argparse import Namespace
from pathlib import Path
from unittest.mock import MagicMock, mock_open, patch

import pytest

from empathy_os.cli.commands.sync import _generate_claude_rule, cmd_sync_claude


@pytest.fixture
def mock_patterns_dir(tmp_path):
    """Given a temporary patterns directory with sample pattern files."""
    patterns_dir = tmp_path / "patterns"
    patterns_dir.mkdir(parents=True, exist_ok=True)
    return patterns_dir


@pytest.fixture
def mock_output_dir(tmp_path):
    """Given a temporary output directory for Claude rules."""
    output_dir = tmp_path / "claude_rules"
    return output_dir


@pytest.fixture
def sample_debugging_patterns():
    """Given sample debugging patterns."""
    return {
        "patterns": [
            {
                "pattern": "Use logger.debug() instead of print()",
                "confidence": 0.95,
                "occurrences": 10,
            },
            {
                "pattern": "Add error context in exceptions",
                "confidence": 0.88,
                "occurrences": 7,
            },
        ]
    }


@pytest.fixture
def sample_security_patterns():
    """Given sample security patterns."""
    return {
        "items": [
            {
                "pattern": "Validate user input before processing",
                "confidence": 0.92,
                "occurrences": 15,
            },
        ]
    }


@pytest.fixture
def sample_tech_debt_patterns():
    """Given sample tech debt patterns."""
    return {
        "patterns": [
            {
                "pattern": "Remove deprecated function calls",
                "confidence": 0.85,
                "occurrences": 5,
            },
        ]
    }


@pytest.fixture
def sample_inspection_patterns():
    """Given sample inspection patterns."""
    return {
        "patterns": [
            {
                "pattern": "Add type hints to function signatures",
                "confidence": 0.90,
                "occurrences": 12,
            },
        ]
    }


class TestCmdSyncClaude:
    """Behavioral tests for cmd_sync_claude function."""

    def test_sync_success_with_all_pattern_files(
        self,
        mock_patterns_dir,
        mock_output_dir,
        sample_debugging_patterns,
        sample_security_patterns,
        sample_tech_debt_patterns,
        sample_inspection_patterns,
        capsys,
    ):
        """Given all pattern files exist.
        When cmd_sync_claude is called.
        Then all patterns are synced successfully.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(
            json.dumps(sample_debugging_patterns)
        )
        (mock_patterns_dir / "security.json").write_text(
            json.dumps(sample_security_patterns)
        )
        (mock_patterns_dir / "tech_debt.json").write_text(
            json.dumps(sample_tech_debt_patterns)
        )
        (mock_patterns_dir / "inspection.json").write_text(
            json.dumps(sample_inspection_patterns)
        )

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            result = cmd_sync_claude(args)

        # Then
        assert result == 0
        assert (mock_output_dir / "debugging.md").exists()
        assert (mock_output_dir / "security.md").exists()
        assert (mock_output_dir / "tech_debt.md").exists()
        assert (mock_output_dir / "inspection.md").exists()

        captured = capsys.readouterr()
        assert "SYNC PATTERNS TO CLAUDE CODE" in captured.out
        assert "5 patterns synced" in captured.out

    def test_sync_patterns_dir_not_exists(self, tmp_path, capsys):
        """Given patterns directory does not exist.
        When cmd_sync_claude is called.
        Then an error message is displayed and returns 1.
        """
        # Given
        non_existent_dir = tmp_path / "non_existent"
        output_dir = tmp_path / "output"

        args = Namespace(
            patterns_dir=str(non_existent_dir), output_dir=str(output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.return_value = output_dir
            result = cmd_sync_claude(args)

        # Then
        assert result == 1
        captured = capsys.readouterr()
        assert "Patterns directory not found" in captured.out
        assert "Run 'empathy learn --analyze 20' first" in captured.out

    def test_sync_no_pattern_files(self, mock_patterns_dir, mock_output_dir, capsys):
        """Given patterns directory exists but has no pattern files.
        When cmd_sync_claude is called.
        Then a message indicates no patterns to sync and returns 1.
        """
        # Given
        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            result = cmd_sync_claude(args)

        # Then
        assert result == 1
        captured = capsys.readouterr()
        assert "No patterns to sync" in captured.out

    def test_sync_empty_pattern_files(
        self, mock_patterns_dir, mock_output_dir, capsys
    ):
        """Given pattern files exist but are empty.
        When cmd_sync_claude is called.
        Then returns 1 with no patterns synced message.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(json.dumps({"patterns": []}))
        (mock_patterns_dir / "security.json").write_text(json.dumps({"items": []}))

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            result = cmd_sync_claude(args)

        # Then
        assert result == 1
        captured = capsys.readouterr()
        assert "No patterns to sync" in captured.out

    def test_sync_invalid_json_file(
        self, mock_patterns_dir, mock_output_dir, sample_debugging_patterns, capsys
    ):
        """Given one pattern file has invalid JSON.
        When cmd_sync_claude is called.
        Then other files are processed and error is reported.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(
            json.dumps(sample_debugging_patterns)
        )
        (mock_patterns_dir / "security.json").write_text("invalid json {")

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            result = cmd_sync_claude(args)

        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "Failed to process security.json" in captured.out
        assert "debugging: 2 patterns" in captured.out

    def test_sync_output_dir_creation(
        self, mock_patterns_dir, tmp_path, sample_debugging_patterns
    ):
        """Given output directory does not exist.
        When cmd_sync_claude is called.
        Then output directory is created.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(
            json.dumps(sample_debugging_patterns)
        )
        output_dir = tmp_path / "nested" / "claude_rules"

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            result = cmd_sync_claude(args)

        # Then
        assert result == 0
        assert output_dir.exists()
        assert (output_dir / "debugging.md").exists()

    def test_sync_with_items_key(
        self, mock_patterns_dir, mock_output_dir, sample_security_patterns, capsys
    ):
        """Given patterns use 'items' key instead of 'patterns'.
        When cmd_sync_claude is called.
        Then patterns are processed correctly.
        """
        # Given
        (mock_patterns_dir / "security.json").write_text(
            json.dumps(sample_security_patterns)
        )

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            result = cmd_sync_claude(args)

        # Then
        assert result == 0
        captured = capsys.readouterr()
        assert "security: 1 patterns" in captured.out

    def test_sync_validation_error_on_output_dir(self, mock_patterns_dir):
        """Given output directory validation fails.
        When cmd_sync_claude is called.
        Then ValueError is raised.
        """
        # Given
        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir="/invalid/path"
        )

        # When/Then
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = ValueError("Invalid path")
            with pytest.raises(ValueError, match="Invalid path"):
                cmd_sync_claude(args)

    def test_sync_validation_error_on_rule_file(
        self, mock_patterns_dir, mock_output_dir, sample_debugging_patterns
    ):
        """Given rule file validation fails.
        When cmd_sync_claude is called.
        Then ValueError is raised.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(
            json.dumps(sample_debugging_patterns)
        )

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When/Then
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = [
                mock_output_dir,
                ValueError("Invalid rule file path"),
            ]
            with pytest.raises(ValueError, match="Invalid rule file path"):
                cmd_sync_claude(args)

    def test_sync_file_write_error(
        self, mock_patterns_dir, mock_output_dir, sample_debugging_patterns, capsys
    ):
        """Given file write operation fails.
        When cmd_sync_claude is called.
        Then error is reported and other files continue processing.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(
            json.dumps(sample_debugging_patterns)
        )

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            with patch("builtins.open", side_effect=OSError("Write failed")):
                result = cmd_sync_claude(args)

        # Then
        assert result == 1
        captured = capsys.readouterr()
        assert "Failed to process debugging.json" in captured.out

    def test_sync_prints_formatted_output(
        self, mock_patterns_dir, mock_output_dir, sample_debugging_patterns, capsys
    ):
        """Given patterns exist.
        When cmd_sync_claude is called.
        Then formatted output is displayed with separators.
        """
        # Given
        (mock_patterns_dir / "debugging.json").write_text(
            json.dumps(sample_debugging_patterns)
        )

        args = Namespace(
            patterns_dir=str(mock_patterns_dir), output_dir=str(mock_output_dir)
        )

        # When
        with patch("empathy_os.cli.commands.sync._validate_file_path") as mock_validate:
            mock_validate.side_effect = lambda path, allowed_dir=None: Path(path)
            cmd_sync_claude(args)

        # Then
        captured = capsys.readouterr()
        assert "=" * 60 in captured.out
        assert "─" * 60 in captured.out
        assert "✓" in captured.out


class TestGenerateClaudeRule:
    """Behavioral tests for _generate_claude_rule function."""

    def test_generate_rule_basic(self):
        """Given a category and patterns.
        When _generate_claude_rule is called.
        Then a markdown rule is generated with proper formatting.
        """
        # Given
        category = "debugging"
        patterns = [
            {"pattern": "Use logger.debug()", "confidence": 0.95, "occurrences": 10}
        ]

        # When
        result = _generate_claude_rule(category, patterns)

        # Then
        assert "# Debugging Patterns" in result
        assert "Use logger.debug()" in result
        assert "Confidence: 0.95" in result
        assert "Occurrences: 10" in result

    def test_generate_rule_with_underscores(self):
        """Given a category with underscores.
        When _generate_claude_rule is called.
        Then category name is formatted with spaces and title case.
        """
        # Given
        category = "tech_debt"
        patterns = [{"pattern": "Refactor code", "confidence": 0.80, "occurrences": 5}]

        # When
        result = _generate_claude_rule(category, patterns)

        # Then
        assert "# Tech Debt Patterns" in result

    def test_generate_rule_multiple_patterns(self):
        """Given multiple patterns.
        When _generate_claude_rule is called.
        Then all patterns are included in the output.
        """
        # Given
        category = "security"
        patterns = [
            {"pattern": "Validate input", "confidence": 0.92, "occurrences": 15},
            {"pattern": "Use prepared statements", "confidence": 0.88, "occurrences": 8},
            {"pattern": "Sanitize output", "confidence":