"""Behavioral tests for config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

# Import config module to access DOC_GEN_STEPS and TOKEN_COSTS
import attune.workflows.document_gen.config as config_module
from attune.workflows.base import ModelTier
from attune.workflows.step_config import WorkflowStepConfig

DOC_GEN_STEPS = config_module.DOC_GEN_STEPS
TOKEN_COSTS = config_module.TOKEN_COSTS


class TestTokenCostsStructure:
    """Tests for TOKEN_COSTS dictionary structure and values."""

    def test_token_costs_contains_all_model_tiers(self):
        """
        Given the TOKEN_COSTS configuration
        When checking for model tier coverage
        Then all ModelTier enum values should be present
        """
        # Given / When
        available_tiers = set(TOKEN_COSTS.keys())

        # Then
        assert ModelTier.CHEAP in available_tiers
        assert ModelTier.CAPABLE in available_tiers
        assert ModelTier.PREMIUM in available_tiers

    def test_token_costs_has_input_and_output_for_each_tier(self):
        """
        Given the TOKEN_COSTS configuration
        When checking each tier's cost structure
        Then each tier should have both 'input' and 'output' costs
        """
        # Given / When / Then
        for tier, costs in TOKEN_COSTS.items():
            assert "input" in costs, f"{tier} missing input cost"
            assert "output" in costs, f"{tier} missing output cost"

    def test_token_costs_are_numeric_and_positive(self):
        """
        Given the TOKEN_COSTS configuration
        When validating cost values
        Then all costs should be numeric and positive
        """
        # Given / When / Then
        for tier, costs in TOKEN_COSTS.items():
            assert isinstance(costs["input"], int | float), f"{tier} input cost is not numeric"
            assert isinstance(costs["output"], int | float), f"{tier} output cost is not numeric"
            assert costs["input"] > 0, f"{tier} input cost must be positive"
            assert costs["output"] > 0, f"{tier} output cost must be positive"

    def test_token_costs_output_more_expensive_than_input(self):
        """
        Given the TOKEN_COSTS configuration
        When comparing input and output costs
        Then output costs should be higher than input costs for each tier
        """
        # Given / When / Then
        for tier, costs in TOKEN_COSTS.items():
            assert costs["output"] > costs["input"], f"{tier} output cost should exceed input cost"

    def test_token_costs_tier_pricing_hierarchy(self):
        """
        Given the TOKEN_COSTS configuration
        When comparing costs across tiers
        Then CHEAP < CAPABLE < PREMIUM for both input and output
        """
        # Given
        cheap_costs = TOKEN_COSTS[ModelTier.CHEAP]
        capable_costs = TOKEN_COSTS[ModelTier.CAPABLE]
        premium_costs = TOKEN_COSTS[ModelTier.PREMIUM]

        # When / Then
        assert cheap_costs["input"] < capable_costs["input"]
        assert capable_costs["input"] < premium_costs["input"]
        assert cheap_costs["output"] < capable_costs["output"]
        assert capable_costs["output"] < premium_costs["output"]

    def test_token_costs_cheap_tier_values(self):
        """
        Given the TOKEN_COSTS configuration
        When checking CHEAP tier costs
        Then it should have expected Haiku pricing
        """
        # Given / When
        cheap_costs = TOKEN_COSTS[ModelTier.CHEAP]

        # Then
        assert cheap_costs["input"] == 0.00025
        assert cheap_costs["output"] == 0.00125

    def test_token_costs_capable_tier_values(self):
        """
        Given the TOKEN_COSTS configuration
        When checking CAPABLE tier costs
        Then it should have expected Sonnet pricing
        """
        # Given / When
        capable_costs = TOKEN_COSTS[ModelTier.CAPABLE]

        # Then
        assert capable_costs["input"] == 0.003
        assert capable_costs["output"] == 0.015

    def test_token_costs_premium_tier_values(self):
        """
        Given the TOKEN_COSTS configuration
        When checking PREMIUM tier costs
        Then it should have expected Opus pricing
        """
        # Given / When
        premium_costs = TOKEN_COSTS[ModelTier.PREMIUM]

        # Then
        assert premium_costs["input"] == 0.015
        assert premium_costs["output"] == 0.075


class TestDocGenStepsStructure:
    """Tests for DOC_GEN_STEPS configuration dictionary."""

    def test_doc_gen_steps_contains_polish_step(self):
        """
        Given the DOC_GEN_STEPS configuration
        When checking for required steps
        Then the 'polish' step should be present
        """
        # Given / When / Then
        assert "polish" in DOC_GEN_STEPS

    def test_doc_gen_steps_polish_is_workflow_step_config(self):
        """
        Given the DOC_GEN_STEPS configuration
        When checking the polish step type
        Then it should be a WorkflowStepConfig instance
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert isinstance(polish_step, WorkflowStepConfig)

    def test_doc_gen_steps_polish_has_correct_name(self):
        """
        Given the polish step configuration
        When checking its name property
        Then it should be 'polish'
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert polish_step.name == "polish"

    def test_doc_gen_steps_polish_has_correct_task_type(self):
        """
        Given the polish step configuration
        When checking its task_type property
        Then it should be 'final_review'
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert polish_step.task_type == "final_review"

    def test_doc_gen_steps_polish_has_premium_tier_hint(self):
        """
        Given the polish step configuration
        When checking its tier_hint property
        Then it should be 'premium'
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert polish_step.tier_hint == "premium"

    def test_doc_gen_steps_polish_has_description(self):
        """
        Given the polish step configuration
        When checking its description
        Then it should have a non-empty description
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert polish_step.description
        assert len(polish_step.description) > 0
        assert "polish" in polish_step.description.lower()

    def test_doc_gen_steps_polish_has_max_tokens(self):
        """
        Given the polish step configuration
        When checking its max_tokens property
        Then it should have a positive max_tokens value
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert hasattr(polish_step, "max_tokens")
        assert polish_step.max_tokens > 0

    def test_doc_gen_steps_polish_max_tokens_is_high_for_large_docs(self):
        """
        Given the polish step configuration
        When checking max_tokens for handling large documents
        Then it should be set to 20000 to handle chunked documents
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert polish_step.max_tokens == 20000


class TestConfigImmutability:
    """Tests for configuration immutability and safety."""

    def test_token_costs_dictionary_is_accessible(self):
        """
        Given the TOKEN_COSTS configuration
        When accessing the dictionary
        Then it should be readable without errors
        """
        # Given / When
        costs = TOKEN_COSTS

        # Then
        assert costs is not None
        assert isinstance(costs, dict)

    def test_doc_gen_steps_dictionary_is_accessible(self):
        """
        Given the DOC_GEN_STEPS configuration
        When accessing the dictionary
        Then it should be readable without errors
        """
        # Given / When
        steps = DOC_GEN_STEPS

        # Then
        assert steps is not None
        assert isinstance(steps, dict)


class TestConfigurationIntegration:
    """Integration tests for configuration consistency."""

    def test_polish_step_tier_matches_premium_cost_tier(self):
        """
        Given the polish step configuration with premium tier hint
        When checking against TOKEN_COSTS
        Then the PREMIUM tier should exist in TOKEN_COSTS
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When
        tier_hint = polish_step.tier_hint

        # Then
        assert tier_hint == "premium"
        assert ModelTier.PREMIUM in TOKEN_COSTS

    def test_all_workflow_steps_have_valid_tier_hints(self):
        """
        Given all DOC_GEN_STEPS configurations
        When checking tier_hint values
        Then all tier hints should correspond to valid ModelTier values
        """
        # Given
        valid_tiers = {"cheap", "capable", "premium"}

        # When / Then
        for step_name, step_config in DOC_GEN_STEPS.items():
            assert (
                step_config.tier_hint in valid_tiers
            ), f"Step {step_name} has invalid tier hint: {step_config.tier_hint}"

    def test_configuration_can_estimate_costs(self):
        """
        Given TOKEN_COSTS and a sample token count
        When calculating estimated costs
        Then the calculation should work without errors
        """
        # Given
        input_tokens = 1000
        output_tokens = 2000
        tier = ModelTier.CAPABLE

        # When
        input_cost = (input_tokens / 1000) * TOKEN_COSTS[tier]["input"]
        output_cost = (output_tokens / 1000) * TOKEN_COSTS[tier]["output"]
        total_cost = input_cost + output_cost

        # Then
        assert total_cost > 0
        assert total_cost == 0.003 * 1 + 0.015 * 2
        assert total_cost == 0.033

    def test_polish_step_max_tokens_sufficient_for_large_documents(self):
        """
        Given the polish step configuration
        When handling a large document scenario
        Then max_tokens should be sufficient (>= 20000)
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]
        expected_min_tokens = 20000  # For large chunked documents

        # When / Then
        assert polish_step.max_tokens >= expected_min_tokens


class TestConfigurationMetadata:
    """Tests for configuration metadata and documentation."""

    def test_module_has_docstring(self):
        """
        Given the config module
        When checking for documentation
        Then it should have a module docstring
        """
        # Given
        import attune.workflows.document_gen.config as config_module

        # When / Then
        assert config_module.__doc__ is not None
        assert len(config_module.__doc__.strip()) > 0

    def test_token_costs_are_documented_as_estimates(self):
        """
        Given the config module documentation
        When checking TOKEN_COSTS documentation
        Then it should note these are estimates
        """
        # Given
        import attune.workflows.document_gen.config as config_module

        # When / Then
        docstring = config_module.__doc__
        assert "Token costs" in docstring or "cost" in docstring.lower()


class TestEdgeCases:
    """Tests for edge cases and boundary conditions."""

    def test_token_costs_precision_for_small_calculations(self):
        """
        Given TOKEN_COSTS with decimal values
        When calculating costs for small token counts
        Then precision should be maintained
        """
        # Given
        tokens = 1  # 1 token
        tier = ModelTier.CHEAP

        # When
        cost = (tokens / 1000) * TOKEN_COSTS[tier]["input"]

        # Then
        assert cost > 0
        assert cost == 0.00025 / 1000

    def test_token_costs_can_handle_large_token_counts(self):
        """
        Given TOKEN_COSTS configuration
        When calculating costs for very large token counts
        Then the calculation should work correctly
        """
        # Given
        large_token_count = 1_000_000  # 1 million tokens
        tier = ModelTier.PREMIUM

        # When
        cost = (large_token_count / 1000) * TOKEN_COSTS[tier]["output"]

        # Then
        assert cost > 0
        assert cost == 75.0  # 0.075 * 1000

    def test_doc_gen_steps_is_not_empty(self):
        """
        Given the DOC_GEN_STEPS configuration
        When checking the dictionary
        Then it should contain at least one step
        """
        # Given / When / Then
        assert len(DOC_GEN_STEPS) > 0

    def test_workflow_step_config_attributes_are_accessible(self):
        """
        Given a WorkflowStepConfig from DOC_GEN_STEPS
        When accessing all defined attributes
        Then none should raise AttributeError
        """
        # Given
        polish_step = DOC_GEN_STEPS["polish"]

        # When / Then
        assert hasattr(polish_step, "name")
        assert hasattr(polish_step, "task_type")
        assert hasattr(polish_step, "tier_hint")
        assert hasattr(polish_step, "description")
        assert hasattr(polish_step, "max_tokens")
