"""Behavioral tests for config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import os
import pytest
from pathlib import Path
from unittest.mock import Mock, mock_open, patch

from empathy_os.config import (
    _validate_file_path,
    EmpathyConfig,
    load_config,
    YAML_AVAILABLE,
)


class TestValidateFilePath:
    """Tests for _validate_file_path function."""

    def test_validates_simple_file_path_successfully(self):
        """Given a valid file path, when validating, then returns Path object."""
        # Given
        path = "test_file.txt"

        # When
        result = _validate_file_path(path)

        # Then
        assert isinstance(result, Path)
        assert result.name == "test_file.txt"

    def test_rejects_empty_string_path(self):
        """Given an empty string, when validating, then raises ValueError."""
        # Given
        path = ""

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_rejects_none_path(self):
        """Given None, when validating, then raises ValueError."""
        # Given
        path = None

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_rejects_non_string_path(self):
        """Given non-string type, when validating, then raises ValueError."""
        # Given
        path = 123

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_rejects_path_with_null_bytes(self):
        """Given path with null bytes, when validating, then raises ValueError."""
        # Given
        path = "file\x00name.txt"

        # When/Then
        with pytest.raises(ValueError, match="path contains null bytes"):
            _validate_file_path(path)

    def test_validates_path_within_allowed_directory(self):
        """Given path within allowed dir, when validating, then returns Path."""
        # Given
        path = "subdir/file.txt"
        allowed_dir = os.getcwd()

        # When
        result = _validate_file_path(path, allowed_dir=allowed_dir)

        # Then
        assert isinstance(result, Path)

    def test_rejects_path_outside_allowed_directory(self):
        """Given path outside allowed dir, when validating, then raises ValueError."""
        # Given
        path = "/tmp/outside/file.txt"
        allowed_dir = os.getcwd()

        # When/Then
        with pytest.raises(ValueError, match="path must be within"):
            _validate_file_path(path, allowed_dir=allowed_dir)

    def test_rejects_dangerous_system_paths(self):
        """Given system path, when validating, then raises ValueError."""
        # Given
        dangerous_paths = ["/etc/passwd", "/sys/kernel", "/proc/self", "/dev/null"]

        # When/Then
        for path in dangerous_paths:
            # Mock Path.resolve to ensure it returns the dangerous path
            with patch("pathlib.Path.resolve") as mock_resolve:
                mock_resolved = Mock(spec=Path)
                mock_resolved.__str__ = Mock(return_value=path)
                mock_resolve.return_value = mock_resolved
                
                with pytest.raises(ValueError, match="Cannot write to system directory"):
                    _validate_file_path(path)


class TestEmpathyConfigInit:
    """Tests for EmpathyConfig initialization."""

    def test_creates_config_with_default_values(self):
        """Given no parameters, when creating config, then uses defaults."""
        # Given/When
        config = EmpathyConfig()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3
        assert config.confidence_threshold == 0.75
        assert config.persistence_enabled is True
        assert config.metrics_enabled is True

    def test_creates_config_with_custom_values(self):
        """Given custom values, when creating config, then uses them."""
        # Given
        user_id = "alice"
        target_level = 5

        # When
        config = EmpathyConfig(user_id=user_id, target_level=target_level)

        # Then
        assert config.user_id == user_id
        assert config.target_level == target_level

    def test_validates_default_model_exists_in_models(self):
        """Given default_model not in models, when initializing, then raises ValueError."""
        # Given
        # ModelConfig is only used for type hints at runtime, create compatible object
        Model = type('Model', (), {})
        model = Model()
        model.name = "model1"
        models = [model]
        default_model = "nonexistent"

        # When/Then
        with pytest.raises(ValueError, match="Default model 'nonexistent' not in models"):
            EmpathyConfig(models=models, default_model=default_model)

    def test_allows_valid_default_model(self):
        """Given default_model in models, when initializing, then succeeds."""
        # Given
        # ModelConfig is only used for type hints at runtime, create compatible object
        Model = type('Model', (), {})
        model = Model()
        model.name = "model1"
        models = [model]
        default_model = "model1"

        # When
        config = EmpathyConfig(models=models, default_model=default_model)

        # Then
        assert config.default_model == default_model
        assert len(config.models) == 1


class TestEmpathyConfigFromYaml:
    """Tests for EmpathyConfig.from_yaml method."""

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_loads_config_from_yaml_file(self):
        """Given valid YAML file, when loading, then returns config."""
        # Given
        yaml_content = """
user_id: test_user
target_level: 4
confidence_threshold: 0.8
"""
        m = mock_open(read_data=yaml_content)

        # When
        with patch("builtins.open", m):
            config = EmpathyConfig.from_yaml("test.yml")

        # Then
        assert config.user_id == "test_user"
        assert config.target_level == 4
        assert config.confidence_threshold == 0.8

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_ignores_unknown_fields_in_yaml(self):
        """Given YAML with unknown fields, when loading, then ignores them."""
        # Given
        yaml_content = """
user_id: test_user
unknown_field: some_value
provider: openai
"""
        m = mock_open(read_data=yaml_content)

        # When
        with patch("builtins.open", m):
            config = EmpathyConfig.from_yaml("test.yml")

        # Then
        assert config.user_id == "test_user"
        assert not hasattr(config, "unknown_field")
        assert not hasattr(config, "provider")

    def test_raises_import_error_when_yaml_not_available(self, monkeypatch):
        """Given PyYAML not installed, when loading YAML, then raises ImportError."""
        # Given
        monkeypatch.setattr("empathy_os.config.YAML_AVAILABLE", False)

        # When/Then
        with pytest.raises(ImportError, match="PyYAML is required"):
            EmpathyConfig.from_yaml("test.yml")

    def test_raises_file_not_found_for_missing_file(self):
        """Given non-existent file, when loading, then raises FileNotFoundError."""
        # Given
        filepath = "nonexistent.yml"

        # When/Then
        with pytest.raises(FileNotFoundError):
            EmpathyConfig.from_yaml(filepath)


class TestEmpathyConfigFromDict:
    """Tests for EmpathyConfig.from_dict method."""

    def test_creates_config_from_dict(self):
        """Given valid dict, when creating from dict, then returns config."""
        # Given
        data = {
            "user_id": "alice",
            "target_level": 5,
            "confidence_threshold": 0.9,
        }

        # When
        config = EmpathyConfig.from_dict(data)

        # Then
        assert config.user_id == "alice"
        assert config.target_level == 5
        assert config.confidence_threshold == 0.9

    def test_filters_unknown_fields_from_dict(self):
        """Given dict with unknown fields, when creating, then filters them."""
        # Given
        data = {
            "user_id": "bob",
            "unknown_field": "value",
            "another_unknown": 123,
        }

        # When
        config = EmpathyConfig.from_dict(data)

        # Then
        assert config.user_id == "bob"
        assert not hasattr(config, "unknown_field")

    def test_handles_nested_model_config(self):
        """Given dict with models, when creating, then converts to ModelConfig."""
        # Given
        data = {
            "user_id": "test",
            "models": [{"name": "gpt-4", "provider": "openai"}],
        }

        # When
        try:
            config = EmpathyConfig.from_dict(data)

            # Then
            assert len(config.models) == 1
            assert config.models[0].name == "gpt-4"
        except ImportError:
            # If ModelConfig can't be imported, skip this test
            pytest.skip("ModelConfig not available")


class TestEmpathyConfigFromJson:
    """Tests for EmpathyConfig.from_json method."""

    def test_loads_config_from_json_file(self):
        """Given valid JSON file, when loading, then returns config."""
        # Given
        json_content = json.dumps({
            "user_id": "json_user",
            "target_level": 2,
            "confidence_threshold": 0.6,
        })
        m = mock_open(read_data=json_content)

        # When
        with patch("builtins.open", m):
            config = EmpathyConfig.from_json("test.json")

        # Then
        assert config.user_id == "json_user"
        assert config.target_level == 2
        assert config.confidence_threshold == 0.6

    def test_ignores_unknown_fields_in_json(self):
        """Given JSON with unknown fields, when loading, then ignores them."""
        # Given
        json_content = json.dumps({
            "user_id": "test",
            "extra_field": "ignored",
            "workflows": {"key": "value"},
        })
        m = mock_open(read_data=json_content)

        # When
        with patch("builtins.open", m):
            config = EmpathyConfig.from_json("test.json")

        # Then
        assert config.user_id == "test"
        assert not hasattr(config, "extra_field")

    def test_raises_file_not_found_for_missing_json(self):
        """Given non-existent file, when loading JSON, then raises FileNotFoundError."""
        # Given
        filepath = "nonexistent.json"

        # When/Then
        with pytest.raises(FileNotFoundError):
            EmpathyConfig.from_json(filepath)


class TestEmpathyConfigFromEnv:
    """Tests for EmpathyConfig.from_env method."""

    def test_loads_config_from_environment_variables(self):
        """Given env vars, when loading, then returns config with env values."""
        # Given
        env_vars = {
            "EMPATHY_USER_ID": "env_user",
            "EMPATHY_TARGET_LEVEL": "5",
            "EMPATHY_CONFIDENCE_THRESHOLD": "0.85",
        }

        # When
        with patch.dict(os.environ, env_vars, clear=True):
            config = EmpathyConfig.from_env()

        # Then
        assert config.user_id == "env_user"
        assert config.target_level == 5
        assert config.confidence_threshold == 0.85

    def test_converts_boolean_environment_variables(self):
        """Given boolean env vars, when loading, then converts correctly."""
        # Given
        env_vars = {
            "EMPATHY_PERSISTENCE_ENABLED": "true",
            "EMPATHY_METRICS_ENABLED": "false",
            "EMPATHY_ASYNC_ENABLED": "1",
            "EMPATHY_PATTERN_SHARING": "yes",
        }

        # When
        with patch.dict(os.environ, env_vars, clear=True):
            config = EmpathyConfig.from_env()

        # Then
        assert config.persistence_enabled is True
        assert config.metrics_enabled is False
        assert config.async_enabled is True
        assert config.pattern_sharing is True

    def test_ignores_unknown_environment_variables(self):
        """Given unknown env vars, when loading, then ignores them."""
        # Given
        env_vars = {
            "EMPATHY_USER_ID": "test",
            "EMPATHY_MASTER_KEY": "secret",
            "EMPATHY_UNKNOWN_FIELD": "value",
        }

        # When
        with patch.dict(os.environ, env_vars, clear=True):
            config = EmpathyConfig.from_env()

        # Then
        assert config.user_id == "test"
        assert not hasattr(config, "master_key")
        assert not hasattr(config, "unknown_field")

    def test_uses_custom_prefix(self):
        """Given custom prefix, when loading, then uses it."""
        # Given
        env_vars = {
            "CUSTOM_USER_ID": "custom_user",
        }

        # When
        with patch.dict(os.environ, env_vars, clear=True):
            config = EmpathyConfig.from_env(prefix="CUSTOM_")

        # Then
        assert config.user_id == "custom_user"

    def test_returns_defaults_when_no_env_vars(self):
        """Given no env vars, when loading, then returns defaults."""
        # Given/When
        with patch.dict(os.environ, {}, clear=True):
            config = EmpathyConfig.from_env()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3


class TestEmpathyConfigFromFile:
    """Tests for EmpathyConfig.from_file method."""

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_loads_yaml_config_when_found(self):
        """Given .empathy.yml exists, when loading, then uses it."""
        # Given
        yaml_content = "user_id: file_user\ntarget_level: 4\n"
        m = mock_open(read_data=yaml_content)

        # When
        with patch("pathlib.Path.exists") as mock_exists:
            def side_effect(self):
                return str(self) == ".empathy.yml"
            mock_exists.side_effect = side_effect
            with patch("builtins.open", m):
                config = EmpathyConfig.from_file()

        # Then
        assert config.user_id == "file_user"
        assert config.target_level == 4

    def test_loads_json_config_when_found(self):
        """Given .empathy.json exists, when loading, then uses it."""
        # Given
        json_content = json.dumps({"user_id": "json_file_user", "target_level": 3})
        m = mock_open(read_data=json_content)

        # When
        with patch("pathlib.Path.exists") as mock_exists:
            def side_effect(self):
                return str(self) == ".empathy.json"
            mock_exists.side_effect = side_effect
            with patch("builtins.open", m):
                config = EmpathyConfig.from_file()

        # Then
        assert config.user_id == "json_file_user"

    def test_returns_defaults_when_no_config_file(self):
        """Given no config file, when loading, then returns defaults."""
        # Given/When
        with patch("pathlib.Path.exists", return_value=False):
            config = EmpathyConfig.from_file()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3

    def test_loads_explicit_filepath_when_provided(self):
        """Given explicit filepath, when loading, then uses it."""
        # Given
        json_content = json.dumps({"user_id": "explicit_user"})
        m = mock_open(read_data=json_content)

        # When
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", m):
                config = EmpathyConfig.from_file("custom.json")

        # Then
        assert config.user_id == "explicit_user"


class TestEmpathyConfigToYaml:
    """Tests for EmpathyConfig.to_yaml method."""

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_saves_config_to_yaml_file(self):
        """Given config, when saving to YAML, then writes file."""
        # Given
        config = EmpathyConfig(user_id="save_user", target_level=4)
        m = mock_open()

        # When
        with patch("builtins.open", m):
            with patch("empathy_os.config._validate_file_path") as mock_validate:
                mock_validate.return_value = Path("output.yml")
                config.to_yaml("output.yml")

        # Then
        m.assert_called_once()
        mock_validate.assert_called_once_with("output.yml")

    def test_raises_import_error_when_yaml_unavailable(self, monkeypatch):
        """Given PyYAML not available, when saving to YAML, then raises ImportError."""
        # Given
        config = EmpathyConfig()
        monkeypatch.setattr("empathy_os.config.YAML_AVAILABLE", False)

        # When/Then
        with pytest.raises(ImportError, match="PyYAML is required"):
            config.to_yaml("output.yml")

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_validates_file_path_before_writing(self):
        """Given dangerous path, when saving, then validates path."""
        # Given
        config = EmpathyConfig()

        # When/Then
        with pytest.raises(ValueError):
            config.to_yaml("/etc/passwd")


class TestEmpathyConfigToJson:
    """Tests for EmpathyConfig.to_json method."""

    def test_saves_config_to_json_file(self):
        """Given config, when saving to JSON, then writes file."""
        # Given
        config = EmpathyConfig(user_id="json_save", target_level=3)
        m = mock_open()

        # When
        with patch("builtins.open", m):
            with patch("empathy_os.config._validate_file_path") as mock_validate:
                mock_validate.return_value = Path("output.json")
                config.to_json("output.json")

        # Then
        m.assert_called_once()
        mock_validate.assert_called_once_with("output.json")

    def test_uses_custom_indent(self):
        """Given custom indent, when saving, then uses it."""
        # Given
        config = EmpathyConfig()
        m = mock_open()

        # When
        with patch("builtins.open", m):
            with patch("empathy_os.config._validate_file_path") as mock_validate:
                mock_validate.return_value = Path("output.json")
                with patch("json.dump") as mock_dump:
                    config.to_json("output.json", indent=4)
                    # Then
                    assert mock_dump.call_args[1]["indent"] == 4

    def test_validates_file_path_before_writing_json(self):
        """Given dangerous path, when saving JSON, then validates path."""
        # Given
        config = EmpathyConfig()

        # When/Then
        with pytest.raises(ValueError):
            config.to_json("/etc/shadow")


class TestEmpathyConfigToDict:
    """Tests for EmpathyConfig.to_dict method."""

    def test_converts_config_to_dictionary(self):
        """Given config, when converting to dict, then returns dict."""
        # Given
        config = EmpathyConfig(user_id="dict_user", target_level=5)

        # When
        result = config.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["user_id"] == "dict_user"
        assert result["target_level"] == 5

    def test_includes_all_fields_in_dict(self):
        """Given config, when converting to dict, then includes all fields."""
        # Given
        config = EmpathyConfig()

        # When
        result = config.to_dict()

        # Then
        assert "user_id" in result
        assert "target_level" in result
        assert "confidence_threshold" in result
        assert "metadata" in result


class TestEmpathyConfigUpdate:
    """Tests for EmpathyConfig.update method."""

    def test_updates_config_fields(self):
        """Given config, when updating fields, then changes values."""
        # Given
        config = EmpathyConfig(user_id="original")

        # When
        config.update(user_id="updated", target_level=5)

        # Then
        assert config.user_id == "updated"
        assert config.target_level == 5

    def test_ignores_unknown_fields_in_update(self):
        """Given unknown field, when updating, then ignores it."""
        # Given
        config = EmpathyConfig()

        # When
        config.update(user_id="test", unknown_field="value")

        # Then
        assert config.user_id == "test"
        assert not hasattr(config, "unknown_field")

    def test_update_preserves_unmodified_fields(self):
        """Given partial update, when updating, then preserves other fields."""
        # Given
        config = EmpathyConfig(user_id="original", target_level=3)

        # When
        config.update(target_level=5)

        # Then
        assert config.user_id == "original"
        assert config.target_level == 5


class TestEmpathyConfigMerge:
    """Tests for EmpathyConfig.merge method."""

    def test_merges_two_configs(self):
        """Given two configs, when merging, then combines them."""
        # Given
        base = EmpathyConfig(user_id="base", target_level=3)
        override = EmpathyConfig(target_level=5, confidence_threshold=0.9)

        # When
        result = base.merge(override)

        # Then
        assert result.user_id == "base"
        assert result.target_level == 5
        assert result.confidence_threshold == 0.9

    def test_only_overrides_non_default_values(self):
        """Given override with defaults, when merging, then keeps base values."""
        # Given
        base = EmpathyConfig(user_id="base_user", target_level=4)
        override = EmpathyConfig()

        # When
        result = base.merge(override)

        # Then
        assert result.user_id == "base_user"
        assert result.target_level == 4

    def test_merge_returns_new_instance(self):
        """Given two configs, when merging, then returns new instance."""
        # Given
        base = EmpathyConfig(user_id="base")
        override = EmpathyConfig(target_level=5)

        # When
        result = base.merge(override)

        # Then
        assert result is not base
        assert result is not override


class TestEmpathyConfigValidate:
    """Tests for EmpathyConfig.validate method."""

    def test_validates_correct_config(self):
        """Given valid config, when validating, then returns True."""
        # Given
        config = EmpathyConfig()

        # When
        result = config.validate()

        # Then
        assert result is True

    def test_rejects_invalid_target_level(self):
        """Given invalid target_level, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(target_level=10)

        # When/Then
        with pytest.raises(ValueError, match="target_level must be 1-5"):
            config.validate()

    def test_rejects_target_level_zero(self):
        """Given target_level 0, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(target_level=0)

        # When/Then
        with pytest.raises(ValueError, match="target_level must be 1-5"):
            config.validate()

    def test_rejects_confidence_threshold_above_one(self):
        """Given confidence_threshold > 1, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(confidence_threshold=1.5)

        # When/Then
        with pytest.raises(ValueError, match="confidence_threshold must be 0.0-1.0"):
            config.validate()

    def test_rejects_confidence_threshold_below_zero(self):
        """Given confidence_threshold < 0, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(confidence_threshold=-0.1)

        # When/Then
        with pytest.raises(ValueError, match="confidence_threshold must be 0.0-1.0"):
            config.validate()

    def test_rejects_invalid_pattern_confidence_threshold(self):
        """Given invalid pattern_confidence_threshold, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(pattern_confidence_threshold=2.0)

        # When/Then
        with pytest.raises(ValueError, match="pattern_confidence_threshold must be 0.0-1.0"):
            config.validate()

    def test_rejects_invalid_persistence_backend(self):
        """Given invalid persistence_backend, when validating, then raises ValueError."""
        # Given
        config = EmpathyConfig(persistence_backend="invalid")

        # When/Then
        with pytest.raises(ValueError, match="persistence_backend must be"):
            config.validate()

    def test_accepts_all_valid_persistence_backends(self):
        """Given valid backends, when validating, then succeeds."""
        # Given
        backends = ["sqlite", "json", "none"]

        # When/Then
        for backend in backends:
            config = EmpathyConfig(persistence_backend=backend)
            assert config.validate() is True


class TestEmpathyConfigRepr:
    """Tests for EmpathyConfig.__repr__ method."""

    def test_repr_contains_key_fields(self):
        """Given config, when getting repr, then includes key fields."""
        # Given
        config = EmpathyConfig(user_id="test_user", target_level=4)

        # When
        result = repr(config)

        # Then
        assert "test_user" in result
        assert "target_level=4" in result
        assert "EmpathyConfig" in result


class TestLoadConfig:
    """Tests for load_config function."""

    def test_loads_with_all_defaults(self):
        """Given no parameters, when loading config, then returns defaults."""
        # Given/When
        with patch("pathlib.Path.exists", return_value=False):
            with patch.dict(os.environ, {}, clear=True):
                config = load_config()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3

    def test_applies_custom_defaults(self):
        """Given custom defaults, when loading, then applies them."""
        # Given
        defaults = {"user_id": "custom_default", "target_level": 4}

        # When
        with patch("pathlib.Path.exists", return_value=False):
            with patch.dict(os.environ, {}, clear=True):
                config = load_config(defaults=defaults)

        # Then
        assert config.user_id == "custom_default"
        assert config.target_level == 4

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_loads_from_file_when_provided(self):
        """Given filepath, when loading, then uses file."""
        # Given
        yaml_content = "user_id: file_user\ntarget_level: 5\n"
        m = mock_open(read_data=yaml_content)

        # When
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", m):
                with patch.dict(os.environ, {}, clear=True):
                    config = load_config(filepath="test.yml", use_env=False)

        # Then
        assert config.user_id == "file_user"
        assert config.target_level == 5

    def test_overrides_with_environment_variables(self):
        """Given env vars, when loading with use_env=True, then overrides."""
        # Given
        env_vars = {
            "EMPATHY_USER_ID": "env_user",
            "EMPATHY_TARGET_LEVEL": "5",
        }

        # When
        with patch("pathlib.Path.exists", return_value=False):
            with patch.dict(os.environ, env_vars, clear=True):
                config = load_config(use_env=True)

        # Then
        assert config.user_id == "env_user"
        assert config.target_level == 5

    def test_skips_environment_when_use_env_false(self):
        """Given use_env=False, when loading, then ignores env vars."""
        # Given
        env_vars = {"EMPATHY_USER_ID": "env_user"}
        defaults = {"user_id": "default"}

        # When
        with patch("pathlib.Path.exists", return_value=False):
            with patch.dict(os.environ, env_vars, clear=True):
                config = load_config(use_env=False, defaults=defaults)

        # Then
        assert config.user_id == "default"

    def test_validates_final_configuration(self):
        """Given invalid config, when loading, then raises ValueError."""
        # Given
        defaults = {"target_level": 10}

        # When/Then
        with patch("pathlib.Path.exists", return_value=False):
            with patch.dict(os.environ, {}, clear=True):
                with pytest.raises(ValueError, match="target_level must be 1-5"):
                    load_config(defaults=defaults)

    def test_handles_file_loading_errors_gracefully(self):
        """Given file error, when loading, then falls back to defaults."""
        # Given/When
        with patch("pathlib.Path.exists", return_value=True):
            with patch("empathy_os.config.EmpathyConfig.from_file", side_effect=FileNotFoundError):
                with patch.dict(os.environ, {}, clear=True):
                    config = load_config(use_env=False)

        # Then
        assert config.user_id == "default_user"

    def test_handles_env_parsing_errors_gracefully(self):
        """Given invalid env vars, when loading, then falls back."""
        # Given/When
        with patch("pathlib.Path.exists", return_value=False):
            with patch("empathy_os.config.EmpathyConfig.from_env", side_effect=ValueError):
                config = load_config(use_env=True)

        # Then
        assert config.user_id == "default_user"

    @pytest.mark.skipif(not YAML_AVAILABLE, reason="PyYAML not available")
    def test_precedence_env_over_file(self):
        """Given file and env, when loading, then env takes precedence."""
        # Given
        yaml_content = "user_id: file_user\n"
        m = mock_open(read_data=yaml_content)
        env_vars = {"EMPATHY_USER_ID": "env_user"}

        # When
        with patch("pathlib.Path.exists", return_value=True):
            with patch("builtins.open", m):
                with patch.dict(os.environ, env_vars, clear=True):
                    config = load_config(filepath="test.yml", use_env=True)

        # Then
        assert config.user_id == "env_user"

    def test_checks_default_config_locations(self):
        """Given no filepath, when loading, then checks default locations."""
        # Given
        json_content = json.dumps({"user_id": "found_user"})
        m = mock_open(read_data=json_content)

        # When
        with patch("pathlib.Path.exists") as mock_exists:
            def side_effect(self):
                return str(self) == ".empathy.json"
            mock_exists.side_effect = side_effect
            with patch("builtins.open", m):
                with patch.dict(os.environ, {}, clear=True):
                    config = load_config(use_env=False)

        # Then
        assert config.user_id == "found_user"