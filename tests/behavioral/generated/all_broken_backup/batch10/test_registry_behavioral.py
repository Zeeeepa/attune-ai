"""Behavioral tests for registry.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import logging
from unittest.mock import Mock, MagicMock, patch
import pytest

from empathy_os.plugins.base import BasePlugin, BaseWorkflow, PluginValidationError, PluginMetadata
from empathy_os.plugins.registry import PluginRegistry


class MockPlugin(BasePlugin):
    """Mock plugin for testing."""
    
    def __init__(self, name="test_plugin", domain="test_domain", version="1.0.0"):
        self._name = name
        self._domain = domain
        self._version = version
    
    def get_metadata(self):
        return PluginMetadata(
            name=self._name,
            domain=self._domain,
            version=self._version,
            description="Test plugin",
        )
    
    def get_workflows(self):
        return {}
    
    def get_extractors(self):
        return {}


class InvalidPlugin:
    """Plugin that doesn't inherit from BasePlugin."""
    
    def get_metadata(self):
        return None


class BrokenMetadataPlugin(BasePlugin):
    """Plugin with broken metadata."""
    
    def get_metadata(self):
        raise ValueError("Metadata error")
    
    def get_workflows(self):
        return {}
    
    def get_extractors(self):
        return {}


class MissingNamePlugin(BasePlugin):
    """Plugin with missing name in metadata."""
    
    def get_metadata(self):
        return PluginMetadata(
            name="",
            domain="test",
            version="1.0.0",
            description="Missing name",
        )
    
    def get_workflows(self):
        return {}
    
    def get_extractors(self):
        return {}


class MissingDomainPlugin(BasePlugin):
    """Plugin with missing domain in metadata."""
    
    def get_metadata(self):
        return PluginMetadata(
            name="test",
            domain="",
            version="1.0.0",
            description="Missing domain",
        )
    
    def get_workflows(self):
        return {}
    
    def get_extractors(self):
        return {}


@pytest.fixture
def registry():
    """Create a fresh plugin registry for each test."""
    return PluginRegistry()


@pytest.fixture
def mock_plugin():
    """Create a mock plugin instance."""
    return MockPlugin()


@pytest.fixture
def mock_entry_point():
    """Create a mock entry point."""
    ep = MagicMock()
    ep.name = "test_plugin"
    ep.load.return_value = MockPlugin
    return ep


class TestPluginRegistryInitialization:
    """Tests for PluginRegistry initialization."""
    
    def test_given_new_registry_when_created_then_initializes_empty(self):
        """Given: A new PluginRegistry
        When: It is created
        Then: It should initialize with empty plugins and auto_discovered flag False
        """
        # Given/When
        registry = PluginRegistry()
        
        # Then
        assert registry._plugins == {}
        assert registry._auto_discovered is False
        assert registry.logger is not None
        assert registry.logger.name == "empathy.plugins.registry"


class TestPluginRegistration:
    """Tests for manual plugin registration."""
    
    def test_given_valid_plugin_when_registered_then_succeeds(self, registry, mock_plugin):
        """Given: A valid plugin
        When: It is registered manually
        Then: It should be stored in the registry
        """
        # Given
        plugin_name = "test_plugin"
        
        # When
        registry.register_plugin(plugin_name, mock_plugin)
        
        # Then
        assert plugin_name in registry._plugins
        assert registry._plugins[plugin_name] == mock_plugin
    
    def test_given_plugin_with_metadata_when_registered_then_logs_details(self, registry, mock_plugin, caplog):
        """Given: A plugin with metadata
        When: It is registered
        Then: It should log the registration details
        """
        # Given
        plugin_name = "test_plugin"
        
        # When
        with caplog.at_level(logging.INFO):
            registry.register_plugin(plugin_name, mock_plugin)
        
        # Then
        assert "Registered plugin 'test_plugin'" in caplog.text
        assert "domain: test_domain" in caplog.text
        assert "version: 1.0.0" in caplog.text
    
    def test_given_plugin_without_name_when_registered_then_raises_error(self, registry):
        """Given: A plugin with missing name
        When: Registration is attempted
        Then: It should raise PluginValidationError
        """
        # Given
        plugin = MissingNamePlugin()
        
        # When/Then
        with pytest.raises(PluginValidationError, match="Plugin metadata missing 'name'"):
            registry.register_plugin("invalid", plugin)
    
    def test_given_plugin_without_domain_when_registered_then_raises_error(self, registry):
        """Given: A plugin with missing domain
        When: Registration is attempted
        Then: It should raise PluginValidationError
        """
        # Given
        plugin = MissingDomainPlugin()
        
        # When/Then
        with pytest.raises(PluginValidationError, match="Plugin metadata missing 'domain'"):
            registry.register_plugin("invalid", plugin)
    
    def test_given_plugin_with_broken_metadata_when_registered_then_raises_error(self, registry):
        """Given: A plugin that raises error on get_metadata
        When: Registration is attempted
        Then: It should raise PluginValidationError with details
        """
        # Given
        plugin = BrokenMetadataPlugin()
        
        # When/Then
        with pytest.raises(PluginValidationError, match="Invalid plugin metadata"):
            registry.register_plugin("broken", plugin)
    
    def test_given_multiple_plugins_when_registered_then_all_stored(self, registry):
        """Given: Multiple valid plugins
        When: They are all registered
        Then: All should be stored in the registry
        """
        # Given
        plugin1 = MockPlugin("plugin1", "domain1")
        plugin2 = MockPlugin("plugin2", "domain2")
        plugin3 = MockPlugin("plugin3", "domain3")
        
        # When
        registry.register_plugin("p1", plugin1)
        registry.register_plugin("p2", plugin2)
        registry.register_plugin("p3", plugin3)
        
        # Then
        assert len(registry._plugins) == 3
        assert registry._plugins["p1"] == plugin1
        assert registry._plugins["p2"] == plugin2
        assert registry._plugins["p3"] == plugin3
    
    def test_given_same_name_when_registered_twice_then_overwrites(self, registry):
        """Given: Two plugins with same registration name
        When: They are registered sequentially
        Then: The second should overwrite the first
        """
        # Given
        plugin1 = MockPlugin("plugin1", "domain1")
        plugin2 = MockPlugin("plugin2", "domain2")
        name = "same_name"
        
        # When
        registry.register_plugin(name, plugin1)
        registry.register_plugin(name, plugin2)
        
        # Then
        assert len(registry._plugins) == 1
        assert registry._plugins[name] == plugin2


class TestAutoDiscovery:
    """Tests for automatic plugin discovery via entry points."""
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_entry_points_when_auto_discover_then_loads_plugins(self, mock_entry_points, registry):
        """Given: Entry points configured
        When: auto_discover is called
        Then: Plugins should be loaded and registered
        """
        # Given
        ep = MagicMock()
        ep.name = "test_plugin"
        ep.load.return_value = MockPlugin
        mock_entry_points.return_value = [ep]
        
        # When
        registry.auto_discover()
        
        # Then
        assert registry._auto_discovered is True
        assert "test_plugin" in registry._plugins
        mock_entry_points.assert_called_once_with(group="empathy_framework.plugins")
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_multiple_entry_points_when_auto_discover_then_loads_all(self, mock_entry_points, registry):
        """Given: Multiple entry points
        When: auto_discover is called
        Then: All plugins should be loaded
        """
        # Given
        ep1 = MagicMock()
        ep1.name = "plugin1"
        ep1.load.return_value = lambda: MockPlugin("plugin1", "domain1")
        
        ep2 = MagicMock()
        ep2.name = "plugin2"
        ep2.load.return_value = lambda: MockPlugin("plugin2", "domain2")
        
        mock_entry_points.return_value = [ep1, ep2]
        
        # When
        registry.auto_discover()
        
        # Then
        assert len(registry._plugins) == 2
        assert "plugin1" in registry._plugins
        assert "plugin2" in registry._plugins
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_already_discovered_when_auto_discover_called_again_then_skips(self, mock_entry_points, registry):
        """Given: Auto-discovery already performed
        When: auto_discover is called again
        Then: It should skip discovery
        """
        # Given
        ep = MagicMock()
        ep.name = "test_plugin"
        ep.load.return_value = MockPlugin
        mock_entry_points.return_value = [ep]
        registry.auto_discover()
        first_call_count = mock_entry_points.call_count
        
        # When
        registry.auto_discover()
        
        # Then
        assert mock_entry_points.call_count == first_call_count
        assert registry._auto_discovered is True
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_failing_plugin_when_auto_discover_then_continues_gracefully(self, mock_entry_points, registry, caplog):
        """Given: One plugin that fails to load
        When: auto_discover is called
        Then: It should log warning and continue with other plugins
        """
        # Given
        ep1 = MagicMock()
        ep1.name = "broken_plugin"
        ep1.load.side_effect = ImportError("Module not found")
        
        ep2 = MagicMock()
        ep2.name = "good_plugin"
        ep2.load.return_value = MockPlugin
        
        mock_entry_points.return_value = [ep1, ep2]
        
        # When
        with caplog.at_level(logging.WARNING):
            registry.auto_discover()
        
        # Then
        assert "Failed to load plugin 'broken_plugin'" in caplog.text
        assert "good_plugin" in registry._plugins
        assert "broken_plugin" not in registry._plugins
        assert len(registry._plugins) == 1
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_plugin_with_invalid_metadata_when_auto_discover_then_handles_gracefully(self, mock_entry_points, registry, caplog):
        """Given: A plugin with invalid metadata during auto-discovery
        When: auto_discover is called
        Then: It should log warning and continue
        """
        # Given
        ep = MagicMock()
        ep.name = "invalid_plugin"
        ep.load.return_value = MissingNamePlugin
        
        mock_entry_points.return_value = [ep]
        
        # When
        with caplog.at_level(logging.WARNING):
            registry.auto_discover()
        
        # Then
        assert "Failed to load plugin 'invalid_plugin'" in caplog.text
        assert "invalid_plugin" not in registry._plugins
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_no_entry_points_when_auto_discover_then_completes_with_empty_registry(self, mock_entry_points, registry, caplog):
        """Given: No entry points configured
        When: auto_discover is called
        Then: It should complete with empty registry
        """
        # Given
        mock_entry_points.return_value = []
        
        # When
        with caplog.at_level(logging.INFO):
            registry.auto_discover()
        
        # Then
        assert registry._auto_discovered is True
        assert len(registry._plugins) == 0
        assert "0 plugins loaded" in caplog.text
    
    @patch('empathy_os.plugins.registry.entry_points')
    def test_given_entry_points_when_auto_discover_then_logs_progress(self, mock_entry_points, registry, caplog):
        """Given: Entry points to discover
        When: auto_discover is called
        Then: It should log discovery progress
        """
        # Given
        ep = MagicMock()
        ep.name = "test_plugin"
        ep.load.return_value = MockPlugin
        mock_entry_points.return_value = [ep]
        
        # When
        with caplog.at_level(logging.INFO):
            registry.auto_discover()
        
        # Then
        assert "Auto-discovering plugins" in caplog.text
        assert "Loading plugin 'test_plugin'" in caplog.text
        assert "Successfully loaded plugin: test_plugin" in caplog.text
        assert "Auto-discovery complete" in caplog.text
        assert "1 plugins loaded" in caplog.text


class TestPluginRetrieval:
    """Tests for retrieving plugins from the registry."""
    
    def test_given_registered_plugin_when_get_plugin_then_returns_plugin(self, registry, mock_plugin):
        """Given: A registered plugin
        When: get_plugin is called with the name
        Then: It should return the plugin instance
        """
        # Given
        plugin_name = "test_plugin"
        registry.register_plugin(plugin_name, mock_plugin)
        
        # When
        result = registry.get_plugin(plugin_name)
        
        # Then
        assert result == mock_plugin
    
    def test_given_unregistered_plugin_when_get_plugin_then_returns_none(self, registry):
        """Given: No plugin registered with the name
        When: get_plugin is called
        Then: It should return None
        """
        # Given/When
        result = registry.get_plugin("nonexistent")
        
        # Then
        assert result is None
    
    def test_given_multiple_plugins_when_list_plugins_then_returns_all_names(self, registry):
        """Given: Multiple registered plugins
        When: list_plugins is called
        Then: It should return all plugin names
        """
        # Given
        registry.register_plugin("plugin1", MockPlugin("p1", "d1"))
        registry.register_plugin("plugin2", MockPlugin("p2", "d2"))
        registry.register_plugin("plugin3", MockPlugin("p3", "d3"))
        
        # When
        result = registry.list_plugins()
        
        # Then
        assert len(result) == 3
        assert "plugin1" in result
        assert "plugin2" in result
        assert "plugin3" in result
    
    def test_given_empty_registry_when_list_plugins_then_returns_empty_list(self, registry):
        """