"""Behavioral tests for test_gen_behavioral.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import ast
import json
from pathlib import Path
from typing import Any
from unittest.mock import AsyncMock, MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.workflows.test_gen_behavioral import (
    BehavioralTestGenerationWorkflow,
    ClassInfo,
    FunctionInfo,
    ModuleAnalyzer,
    ModuleInfo,
)


# Fixtures


@pytest.fixture
def sample_source_code():
    """Sample Python source code for testing."""
    return '''
"""Sample module."""
from typing import Optional

class SampleClass:
    """A sample class."""
    
    def __init__(self, value: int):
        self.value = value
    
    def sync_method(self, x: int) -> int:
        """Synchronous method."""
        return x + self.value
    
    async def async_method(self, y: str) -> str:
        """Asynchronous method."""
        return f"{y}_{self.value}"

def standalone_function(a: int, b: int = 10) -> int:
    """Standalone function."""
    return a + b

async def async_standalone(data: dict) -> dict:
    """Async standalone."""
    return data
'''


@pytest.fixture
def sample_ast_tree(sample_source_code):
    """Parsed AST tree from sample code."""
    return ast.parse(sample_source_code)


@pytest.fixture
def module_analyzer(sample_source_code):
    """ModuleAnalyzer instance with sample code."""
    return ModuleAnalyzer(sample_source_code)


@pytest.fixture
def function_info():
    """Sample FunctionInfo instance."""
    return FunctionInfo(
        name="test_function",
        is_async=False,
        args=["self", "x", "y"],
        returns="int",
        docstring="Test function.",
        line_number=10,
    )


@pytest.fixture
def class_info(function_info):
    """Sample ClassInfo instance."""
    return ClassInfo(
        name="TestClass",
        methods=[
            {
                "name": "method1",
                "is_async": False,
                "args": ["self", "x"],
                "returns": "str",
                "docstring": "Method 1",
                "line_number": 15,
            }
        ],
        is_abstract=False,
        bases=["BaseClass"],
        line_number=10,
    )


@pytest.fixture
def module_info(class_info, function_info):
    """Sample ModuleInfo instance."""
    return ModuleInfo(
        file_path="src/test_module.py",
        classes=[
            {
                "name": "TestClass",
                "methods": [],
                "is_abstract": False,
                "bases": [],
                "line_number": 10,
            }
        ],
        functions=[
            {
                "name": "test_func",
                "is_async": False,
                "args": ["x"],
                "returns": "int",
                "docstring": "Test",
                "line_number": 20,
            }
        ],
        imports=["import os", "from typing import Any"],
        total_lines=100,
    )


@pytest.fixture
def workflow():
    """BehavioralTestGenerationWorkflow instance."""
    return BehavioralTestGenerationWorkflow()


# FunctionInfo Tests


class TestFunctionInfo:
    """Tests for FunctionInfo dataclass."""

    def test_given_function_info_when_created_then_has_all_attributes(self, function_info):
        """
        Given: FunctionInfo parameters
        When: Creating a FunctionInfo instance
        Then: All attributes are set correctly
        """
        assert function_info.name == "test_function"
        assert function_info.is_async is False
        assert function_info.args == ["self", "x", "y"]
        assert function_info.returns == "int"
        assert function_info.docstring == "Test function."
        assert function_info.line_number == 10

    def test_given_async_function_when_created_then_is_async_true(self):
        """
        Given: Async function parameters
        When: Creating FunctionInfo with is_async=True
        Then: is_async flag is set correctly
        """
        func_info = FunctionInfo(
            name="async_func",
            is_async=True,
            args=["x"],
            returns="None",
            docstring=None,
            line_number=5,
        )
        assert func_info.is_async is True
        assert func_info.name == "async_func"

    def test_given_function_without_docstring_when_created_then_docstring_none(self):
        """
        Given: Function without docstring
        When: Creating FunctionInfo with docstring=None
        Then: docstring attribute is None
        """
        func_info = FunctionInfo(
            name="no_doc",
            is_async=False,
            args=[],
            returns=None,
            docstring=None,
            line_number=1,
        )
        assert func_info.docstring is None


# ClassInfo Tests


class TestClassInfo:
    """Tests for ClassInfo dataclass."""

    def test_given_class_info_when_created_then_has_all_attributes(self, class_info):
        """
        Given: ClassInfo parameters
        When: Creating a ClassInfo instance
        Then: All attributes are set correctly
        """
        assert class_info.name == "TestClass"
        assert len(class_info.methods) == 1
        assert class_info.is_abstract is False
        assert class_info.bases == ["BaseClass"]
        assert class_info.line_number == 10

    def test_given_abstract_class_when_created_then_is_abstract_true(self):
        """
        Given: Abstract class parameters
        When: Creating ClassInfo with is_abstract=True
        Then: is_abstract flag is set correctly
        """
        class_info = ClassInfo(
            name="AbstractClass",
            methods=[],
            is_abstract=True,
            bases=["ABC"],
            line_number=5,
        )
        assert class_info.is_abstract is True

    def test_given_class_with_multiple_methods_when_created_then_all_methods_stored(self):
        """
        Given: Class with multiple methods
        When: Creating ClassInfo with method list
        Then: All methods are stored correctly
        """
        methods = [
            {"name": "method1", "is_async": False, "args": [], "returns": None, "docstring": None, "line_number": 1},
            {"name": "method2", "is_async": True, "args": ["x"], "returns": "str", "docstring": "Doc", "line_number": 5},
        ]
        class_info = ClassInfo(
            name="MultiMethod",
            methods=methods,
            is_abstract=False,
            bases=[],
            line_number=1,
        )
        assert len(class_info.methods) == 2
        assert class_info.methods[0]["name"] == "method1"
        assert class_info.methods[1]["is_async"] is True


# ModuleInfo Tests


class TestModuleInfo:
    """Tests for ModuleInfo dataclass."""

    def test_given_module_info_when_created_then_has_all_attributes(self, module_info):
        """
        Given: ModuleInfo parameters
        When: Creating a ModuleInfo instance
        Then: All attributes are set correctly
        """
        assert module_info.file_path == "src/test_module.py"
        assert len(module_info.classes) == 1
        assert len(module_info.functions) == 1
        assert len(module_info.imports) == 2
        assert module_info.total_lines == 100

    def test_given_empty_module_when_created_then_empty_collections(self):
        """
        Given: Empty module parameters
        When: Creating ModuleInfo with empty lists
        Then: All collections are empty
        """
        module_info = ModuleInfo(
            file_path="empty.py",
            classes=[],
            functions=[],
            imports=[],
            total_lines=0,
        )
        assert len(module_info.classes) == 0
        assert len(module_info.functions) == 0
        assert len(module_info.imports) == 0


# ModuleAnalyzer Tests


class TestModuleAnalyzer:
    """Tests for ModuleAnalyzer class."""

    def test_given_source_code_when_analyzer_created_then_initialized(self, sample_source_code):
        """
        Given: Source code string
        When: Creating ModuleAnalyzer
        Then: Analyzer is initialized with empty collections
        """
        analyzer = ModuleAnalyzer(sample_source_code)
        assert analyzer.source_code == sample_source_code
        assert analyzer.classes == []
        assert analyzer.functions == []
        assert analyzer.imports == []

    def test_given_ast_tree_when_visiting_then_classes_extracted(self, module_analyzer, sample_ast_tree):
        """
        Given: AST tree with class definitions
        When: Visiting the tree
        Then: Classes are extracted correctly
        """
        module_analyzer.visit(sample_ast_tree)
        assert len(module_analyzer.classes) == 1
        assert module_analyzer.classes[0].name == "SampleClass"
        assert len(module_analyzer.classes[0].methods) == 3  # __init__, sync_method, async_method

    def test_given_ast_tree_when_visiting_then_functions_extracted(self, module_analyzer, sample_ast_tree):
        """
        Given: AST tree with function definitions
        When: Visiting the tree
        Then: Functions are extracted correctly
        """
        module_analyzer.visit(sample_ast_tree)
        assert len(module_analyzer.functions) == 2
        function_names = [f.name for f in module_analyzer.functions]
        assert "standalone_function" in function_names
        assert "async_standalone" in function_names

    def test_given_async_function_when_visiting_then_is_async_flag_set(self, module_analyzer, sample_ast_tree):
        """
        Given: AST tree with async function
        When: Visiting the tree
        Then: is_async flag is set correctly
        """
        module_analyzer.visit(sample_ast_tree)
        async_funcs = [f for f in module_analyzer.functions if f.is_async]
        assert len(async_funcs) == 1
        assert async_funcs[0].name == "async_standalone"

    def test_given_class_def_when_visiting_then_methods_extracted(self):
        """
        Given: ClassDef node
        When: Visiting the node
        Then: Methods are extracted
        """
        source = '''
class TestClass:
    def method1(self):
        pass
    
    async def method2(self, x: int) -> str:
        return str(x)
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        assert len(analyzer.classes) == 1
        assert len(analyzer.classes[0].methods) == 2
        assert analyzer.classes[0].methods[0]["name"] == "method1"
        assert analyzer.classes[0].methods[1]["is_async"] is True

    def test_given_abstract_class_when_visiting_then_is_abstract_detected(self):
        """
        Given: Abstract class inheriting from ABC
        When: Visiting the class
        Then: is_abstract flag is True
        """
        source = '''
from abc import ABC

class AbstractClass(ABC):
    pass
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        assert len(analyzer.classes) == 1
        assert analyzer.classes[0].is_abstract is True

    def test_given_function_with_args_when_extracted_then_args_list_correct(self):
        """
        Given: Function with multiple arguments
        When: Extracting function info
        Then: Args list contains all arguments
        """
        source = '''
def func(a, b, c=10, *args, **kwargs):
    pass
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        assert len(analyzer.functions) == 1
        func = analyzer.functions[0]
        assert "a" in func.args
        assert "b" in func.args
        assert "c" in func.args

    def test_given_function_with_return_annotation_when_extracted_then_returns_set(self):
        """
        Given: Function with return type annotation
        When: Extracting function info
        Then: returns field is set
        """
        source = '''
def func() -> int:
    return 42
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        assert len(analyzer.functions) == 1
        assert analyzer.functions[0].returns == "int"

    def test_given_function_with_docstring_when_extracted_then_docstring_captured(self):
        """
        Given: Function with docstring
        When: Extracting function info
        Then: docstring is captured
        """
        source = '''
def func():
    """This is a docstring."""
    pass
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        assert len(analyzer.functions) == 1
        assert analyzer.functions[0].docstring == "This is a docstring."

    def test_given_nested_class_when_visiting_then_not_extracted_as_top_level(self):
        """
        Given: Nested class definition
        When: Visiting the tree
        Then: Only top-level class is extracted
        """
        source = '''
class OuterClass:
    class InnerClass:
        pass
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        # Only OuterClass should be extracted as top-level
        assert len(analyzer.classes) == 1
        assert analyzer.classes[0].name == "OuterClass"

    def test_given_class_with_bases_when_visiting_then_bases_extracted(self):
        """
        Given: Class with base classes
        When: Visiting the class
        Then: Base class names are extracted
        """
        source = '''
class Child(Parent1, Parent2):
    pass
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        assert len(analyzer.classes) == 1
        assert "Parent1" in analyzer.classes[0].bases
        assert "Parent2" in analyzer.classes[0].bases

    def test_given_import_statements_when_visiting_then_imports_extracted(self):
        """
        Given: Various import statements
        When: Visiting the tree
        Then: Imports are extracted
        """
        source = '''
import os
import sys
from typing import Any, Optional
from pathlib import Path
'''
        analyzer = ModuleAnalyzer(source)
        tree = ast.parse(source)
        analyzer.visit(tree)
        
        # Note: The current implementation may need to handle ImportFrom
        # This test documents expected behavior
        assert isinstance(analyzer.imports, list)

    def test_given_empty_source_when_visiting_then_no_elements_extracted(self):
        """
        Given: Empty source code
        When: Visiting the tree
        Then: No