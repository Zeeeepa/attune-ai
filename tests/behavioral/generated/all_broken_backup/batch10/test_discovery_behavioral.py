"""Behavioral tests for discovery.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.discovery import DISCOVERY_TIPS, DiscoveryEngine, _days_since_sync


# Fixtures


@pytest.fixture
def temp_discovery_file(tmp_path):
    """Given a temporary directory for discovery state."""
    discovery_file = tmp_path / "discovery_state.json"
    return discovery_file


@pytest.fixture
def mock_state():
    """Given a mock discovery state."""
    return {
        "command_counts": {"inspect": 5, "ship": 3, "health": 2},
        "tips_shown": ["after_first_inspect"],
        "last_claude_sync": (datetime.now() - timedelta(days=3)).isoformat(),
        "patterns_learned": 10,
        "total_commands": 15,
        "api_requests": 20,
        "tech_debt_trend": "stable",
    }


@pytest.fixture
def discovery_engine(temp_discovery_file):
    """Given a DiscoveryEngine instance."""
    return DiscoveryEngine(state_file=str(temp_discovery_file))


# Tests for _days_since_sync


def test_days_since_sync_with_valid_date():
    """
    Given a stats dict with a valid last_claude_sync date
    When calculating days since sync
    Then return the correct number of days
    """
    # Given
    three_days_ago = (datetime.now() - timedelta(days=3)).isoformat()
    stats = {"last_claude_sync": three_days_ago}

    # When
    result = _days_since_sync(stats)

    # Then
    assert result == 3


def test_days_since_sync_with_no_sync():
    """
    Given a stats dict without last_claude_sync
    When calculating days since sync
    Then return 999 as default
    """
    # Given
    stats = {}

    # When
    result = _days_since_sync(stats)

    # Then
    assert result == 999


def test_days_since_sync_with_invalid_date():
    """
    Given a stats dict with invalid date format
    When calculating days since sync
    Then return 999 as fallback
    """
    # Given
    stats = {"last_claude_sync": "invalid-date"}

    # When
    result = _days_since_sync(stats)

    # Then
    assert result == 999


def test_days_since_sync_with_none_value():
    """
    Given a stats dict with None as last_claude_sync
    When calculating days since sync
    Then return 999 as fallback
    """
    # Given
    stats = {"last_claude_sync": None}

    # When
    result = _days_since_sync(stats)

    # Then
    assert result == 999


# Tests for DiscoveryEngine initialization


def test_discovery_engine_initialization_creates_new_state(temp_discovery_file):
    """
    Given a non-existent state file
    When initializing DiscoveryEngine
    Then create new empty state
    """
    # Given / When
    engine = DiscoveryEngine(state_file=str(temp_discovery_file))

    # Then
    assert engine.state["command_counts"] == {}
    assert engine.state["tips_shown"] == []
    assert not temp_discovery_file.exists()


def test_discovery_engine_initialization_loads_existing_state(
    temp_discovery_file, mock_state
):
    """
    Given an existing state file
    When initializing DiscoveryEngine
    Then load the existing state
    """
    # Given
    temp_discovery_file.write_text(json.dumps(mock_state))

    # When
    engine = DiscoveryEngine(state_file=str(temp_discovery_file))

    # Then
    assert engine.state["command_counts"] == mock_state["command_counts"]
    assert engine.state["tips_shown"] == mock_state["tips_shown"]


def test_discovery_engine_initialization_with_corrupted_state(temp_discovery_file):
    """
    Given a corrupted state file
    When initializing DiscoveryEngine
    Then create new empty state
    """
    # Given
    temp_discovery_file.write_text("invalid json{")

    # When
    engine = DiscoveryEngine(state_file=str(temp_discovery_file))

    # Then
    assert engine.state["command_counts"] == {}
    assert engine.state["tips_shown"] == []


def test_discovery_engine_initialization_with_default_path():
    """
    Given no state file path provided
    When initializing DiscoveryEngine
    Then use default path
    """
    # Given / When
    with patch("pathlib.Path.exists", return_value=False):
        with patch("builtins.open", mock_open(read_data="{}")):
            engine = DiscoveryEngine()

    # Then
    assert engine.state_file == Path.home() / ".empathy" / "discovery_state.json"


# Tests for record_command


def test_record_command_increments_count(discovery_engine):
    """
    Given a DiscoveryEngine instance
    When recording a command
    Then increment the command count
    """
    # Given
    assert "inspect" not in discovery_engine.state["command_counts"]

    # When
    discovery_engine.record_command("inspect")

    # Then
    assert discovery_engine.state["command_counts"]["inspect"] == 1


def test_record_command_increments_existing_count(discovery_engine):
    """
    Given a command with existing count
    When recording the command again
    Then increment the existing count
    """
    # Given
    discovery_engine.state["command_counts"]["inspect"] = 5

    # When
    discovery_engine.record_command("inspect")

    # Then
    assert discovery_engine.state["command_counts"]["inspect"] == 6


def test_record_command_saves_state(discovery_engine, temp_discovery_file):
    """
    Given a DiscoveryEngine instance
    When recording a command
    Then save state to file
    """
    # Given / When
    discovery_engine.record_command("inspect")

    # Then
    assert temp_discovery_file.exists()
    saved_state = json.loads(temp_discovery_file.read_text())
    assert saved_state["command_counts"]["inspect"] == 1


def test_record_command_with_stats(discovery_engine):
    """
    Given additional stats to record
    When recording a command with stats
    Then update state with stats
    """
    # Given
    stats = {"patterns_learned": 5, "tech_debt_trend": "increasing"}

    # When
    discovery_engine.record_command("inspect", stats)

    # Then
    assert discovery_engine.state["patterns_learned"] == 5
    assert discovery_engine.state["tech_debt_trend"] == "increasing"


# Tests for get_pending_tips


def test_get_pending_tips_returns_trigger_based_tip(discovery_engine):
    """
    Given command counts meeting trigger conditions
    When getting pending tips
    Then return trigger-based tips not yet shown
    """
    # Given
    discovery_engine.state["command_counts"]["inspect"] = 1

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert len(tips) > 0
    assert any("empathy ship" in tip for tip in tips)


def test_get_pending_tips_filters_already_shown(discovery_engine):
    """
    Given tips that have been shown
    When getting pending tips
    Then exclude already shown tips
    """
    # Given
    discovery_engine.state["command_counts"]["inspect"] = 1
    discovery_engine.state["tips_shown"] = ["after_first_inspect"]

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert not any("empathy ship" in tip for tip in tips)


def test_get_pending_tips_returns_condition_based_tip(discovery_engine):
    """
    Given stats meeting condition-based triggers
    When getting pending tips
    Then return condition-based tips
    """
    # Given
    discovery_engine.state["patterns_learned"] = 0
    discovery_engine.state["total_commands"] = 10

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert any("empathy learn" in tip for tip in tips)


def test_get_pending_tips_returns_multiple_tips(discovery_engine):
    """
    Given multiple tips meeting conditions
    When getting pending tips
    Then return all eligible tips sorted by priority
    """
    # Given
    discovery_engine.state["command_counts"]["inspect"] = 10
    discovery_engine.state["command_counts"]["ship"] = 5
    discovery_engine.state["patterns_learned"] = 5
    discovery_engine.state["api_requests"] = 15

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert len(tips) >= 2


def test_get_pending_tips_respects_max_tips(discovery_engine):
    """
    Given many tips eligible
    When getting pending tips with max_tips limit
    Then return only max_tips number
    """
    # Given
    discovery_engine.state["command_counts"]["inspect"] = 10
    discovery_engine.state["command_counts"]["ship"] = 5
    discovery_engine.state["api_requests"] = 15
    discovery_engine.state["patterns_learned"] = 0
    discovery_engine.state["total_commands"] = 10

    # When
    tips = discovery_engine.get_pending_tips(max_tips=2)

    # Then
    assert len(tips) <= 2


def test_get_pending_tips_sorts_by_priority(discovery_engine):
    """
    Given tips with different priorities
    When getting pending tips
    Then return tips sorted by priority (1 before 2)
    """
    # Given
    discovery_engine.state["command_counts"]["inspect"] = 10  # priority 1
    discovery_engine.state["command_counts"]["health"] = 1  # priority 2

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    # Priority 1 tips should come before priority 2
    if len(tips) >= 2:
        assert "sync-claude" in tips[0] or "empathy status" in tips[0]


def test_get_pending_tips_weekly_sync_reminder(discovery_engine):
    """
    Given more than 7 days since last sync
    When getting pending tips
    Then include weekly sync reminder
    """
    # Given
    discovery_engine.state["last_claude_sync"] = (
        datetime.now() - timedelta(days=8)
    ).isoformat()

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert any("Weekly reminder" in tip for tip in tips)


def test_get_pending_tips_no_sync_date(discovery_engine):
    """
    Given no last_claude_sync date
    When getting pending tips
    Then include weekly sync reminder
    """
    # Given
    discovery_engine.state["last_claude_sync"] = None

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert any("Weekly reminder" in tip for tip in tips)


def test_get_pending_tips_empty_when_no_conditions_met(discovery_engine):
    """
    Given no conditions met for any tips
    When getting pending tips
    Then return empty list
    """
    # Given - fresh state with no commands

    # When
    tips = discovery_engine.get_pending_tips()

    # Then
    assert tips == []


# Tests for mark_tip_shown


def test_mark_tip_shown_adds_to_shown_list(discovery_engine):
    """
    Given a tip key
    When marking tip as shown
    Then add to tips_shown list
    """
    # Given
    tip_key = "after_first_inspect"

    # When
    discovery_engine.mark_tip_shown(tip_key)

    # Then
    assert tip_key in discovery_engine.state["tips_shown"]


def test_mark_tip_shown_saves_state(discovery_engine, temp_discovery_file):
    """
    Given a tip key
    When marking tip as shown
    Then save state to file
    """
    # Given
    tip_key = "after_first_inspect"

    # When
    discovery_engine.mark_tip_shown(tip_key)

    # Then
    assert temp_discovery_file.exists()
    saved_state = json.loads(temp_discovery_file.read_text())
    assert tip_key in saved_state["tips_shown"]


def test_mark_tip_shown_prevents_duplicate(discovery_engine):
    """
    Given a tip already in shown list
    When marking tip as shown again
    Then don't duplicate in list
    """
    # Given
    tip_key = "after_first_inspect"
    discovery_engine.state["tips_shown"] = [tip_key]

    # When
    discovery_engine.mark_tip_shown(tip_key)

    # Then
    assert discovery_engine.state["tips_shown"].count(tip_key) == 1


# Tests for _save_state


def test_save_state_creates_directory(discovery_engine, tmp_path):
    """
    Given a state file in non-existent directory
    When saving state
    Then create parent directory
    """
    # Given
    nested_path = tmp_path / "nested" / "dir" / "state.json"
    discovery_engine.state_file = nested_path

    # When
    discovery_engine._save_state()

    # Then
    assert nested_path.parent.exists()
    assert nested_path.exists()


def test_save_state_writes_valid_json(discovery_engine, temp_discovery_file):
    """
    Given a discovery engine with state
    When saving state
    Then write valid JSON
    """
    # Given
    discovery_engine.state["command_counts"]["test"] = 5

    # When
    discovery_engine._save_state()

    # Then
    saved_data = json.loads(temp_discovery_file.read_text())
    assert saved_data["command_counts"]["test"] == 5


def test_save_state_handles_write_error(discovery_engine, temp_discovery_file):
    """
    Given a write error occurs
    When saving state
    Then handle gracefully without raising
    """
    # Given
    discovery_engine.state_file = Path("/invalid/path/state.json")

    # When / Then - should not raise
    try:
        discovery_engine._save_state()
    except Exception as e:
        pytest.fail(f"_save_state raised exception: {e}")


# Tests for _load_state


def test_load_state_with_missing_file(discovery_engine):
    """
    Given a non-existent state file
    When loading state
    Then return empty state
    """
    # Given
    discovery_engine.state_file = Path("/nonexistent/state.json")

    # When
    state = discovery_engine._load_state()

    # Then
    assert state["command_counts"] == {}
    assert state["tips_shown"] == []


def test_load_state_with_invalid_json(discovery_engine, temp_discovery_file):
    """
    Given a file with invalid JSON
    When loading state
    Then return empty state
    """
    # Given
    temp_discovery_file.write_text("invalid json")
    discovery_engine.state_file = temp_discovery_file

    # When
    state = discovery_engine._load_state()

    # Then
    assert state["command_counts"] == {}
    assert state["tips_shown"] == []


def test_load_state_with