"""Behavioral tests for history.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import sqlite3
import tempfile
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any
from unittest.mock import Mock, patch

import pytest

from empathy_os.workflows.history import WorkflowHistoryStore


@pytest.fixture
def temp_db_path():
    """Create a temporary database path for testing."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test_history.db"
        yield str(db_path)


@pytest.fixture
def history_store(temp_db_path):
    """Create a WorkflowHistoryStore instance for testing."""
    store = WorkflowHistoryStore(db_path=temp_db_path)
    yield store
    store.close()


@pytest.fixture
def sample_workflow_result():
    """Create a sample WorkflowResult for testing."""
    result = Mock()
    result.success = True
    result.started_at = datetime(2025, 1, 1, 12, 0, 0)
    result.completed_at = datetime(2025, 1, 1, 12, 1, 30)
    result.total_cost = 0.05
    result.baseline_cost = 0.10
    result.savings = 0.05
    result.savings_percent = 50.0
    result.error = None
    result.error_type = None
    result.transient = False
    result.xml_parsed = True
    result.summary = "Test workflow completed successfully"
    result.stages = []
    return result


@pytest.fixture
def sample_workflow_result_with_stages():
    """Create a sample WorkflowResult with stages for testing."""
    result = Mock()
    result.success = True
    result.started_at = datetime(2025, 1, 1, 12, 0, 0)
    result.completed_at = datetime(2025, 1, 1, 12, 1, 30)
    result.total_cost = 0.05
    result.baseline_cost = 0.10
    result.savings = 0.05
    result.savings_percent = 50.0
    result.error = None
    result.error_type = None
    result.transient = False
    result.xml_parsed = True
    result.summary = "Test workflow with stages"
    
    stage1 = Mock()
    stage1.stage_name = "stage1"
    stage1.started_at = datetime(2025, 1, 1, 12, 0, 0)
    stage1.completed_at = datetime(2025, 1, 1, 12, 0, 30)
    stage1.cost = 0.02
    stage1.tokens_used = 100
    stage1.success = True
    stage1.error = None
    
    stage2 = Mock()
    stage2.stage_name = "stage2"
    stage2.started_at = datetime(2025, 1, 1, 12, 0, 30)
    stage2.completed_at = datetime(2025, 1, 1, 12, 1, 30)
    stage2.cost = 0.03
    stage2.tokens_used = 150
    stage2.success = True
    stage2.error = None
    
    result.stages = [stage1, stage2]
    return result


@pytest.fixture
def failed_workflow_result():
    """Create a failed WorkflowResult for testing."""
    result = Mock()
    result.success = False
    result.started_at = datetime(2025, 1, 1, 12, 0, 0)
    result.completed_at = datetime(2025, 1, 1, 12, 0, 10)
    result.total_cost = 0.01
    result.baseline_cost = 0.10
    result.savings = 0.0
    result.savings_percent = 0.0
    result.error = "Connection timeout"
    result.error_type = "TimeoutError"
    result.transient = True
    result.xml_parsed = False
    result.summary = None
    result.stages = []
    return result


class TestWorkflowHistoryStoreInitialization:
    """Test WorkflowHistoryStore initialization behavior."""

    def test_given_valid_db_path_when_initializing_then_creates_store(self, temp_db_path):
        """GIVEN a valid database path
        WHEN initializing WorkflowHistoryStore
        THEN store is created successfully with database file
        """
        # When
        store = WorkflowHistoryStore(db_path=temp_db_path)
        
        # Then
        assert Path(temp_db_path).exists()
        assert store.db_path == temp_db_path
        assert store.conn is not None
        store.close()

    def test_given_nested_path_when_initializing_then_creates_parent_directories(self):
        """GIVEN a nested database path
        WHEN initializing WorkflowHistoryStore
        THEN parent directories are created
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            nested_path = Path(tmpdir) / "nested" / "dir" / "history.db"
            
            # When
            store = WorkflowHistoryStore(db_path=str(nested_path))
            
            # Then
            assert nested_path.exists()
            assert nested_path.parent.exists()
            store.close()

    def test_given_no_path_when_initializing_then_uses_default_path(self):
        """GIVEN no database path specified
        WHEN initializing WorkflowHistoryStore
        THEN uses default path
        """
        # When
        with patch('pathlib.Path.mkdir'):
            with patch('sqlite3.connect') as mock_connect:
                mock_connect.return_value = Mock()
                store = WorkflowHistoryStore()
                
                # Then
                assert store.db_path == WorkflowHistoryStore.DEFAULT_DB
                store.conn = None  # Prevent close() from failing


class TestWorkflowHistoryStoreMigration:
    """Test database migration behavior."""

    def test_given_new_database_when_migrating_then_creates_schema(self, history_store):
        """GIVEN a new database
        WHEN migration runs
        THEN creates workflow_runs and workflow_stages tables
        """
        # Given/When (migration runs during initialization)
        cursor = history_store.conn.cursor()
        
        # Then - Check workflow_runs table
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='workflow_runs'
        """)
        assert cursor.fetchone() is not None
        
        # Then - Check workflow_stages table
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='workflow_stages'
        """)
        assert cursor.fetchone() is not None

    def test_given_existing_database_when_migrating_then_idempotent(self, history_store):
        """GIVEN an existing database
        WHEN migration runs again
        THEN operation is idempotent and doesn't fail
        """
        # Given - database already exists
        
        # When - run migration again
        history_store._migrate()
        
        # Then - no errors and tables still exist
        cursor = history_store.conn.cursor()
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='workflow_runs'
        """)
        assert cursor.fetchone() is not None

    def test_given_new_database_when_migrating_then_creates_indexes(self, history_store):
        """GIVEN a new database
        WHEN migration runs
        THEN creates appropriate indexes for performance
        """
        # Given/When (migration runs during initialization)
        cursor = history_store.conn.cursor()
        
        # Then - Check indexes exist
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='index' AND name LIKE 'idx_%'
        """)
        indexes = cursor.fetchall()
        assert len(indexes) > 0  # At least some indexes created


class TestWorkflowHistoryStoreRecordRun:
    """Test recording workflow runs."""

    def test_given_successful_result_when_recording_run_then_stores_data(
        self, history_store, sample_workflow_result
    ):
        """GIVEN a successful workflow result
        WHEN recording the run
        THEN data is stored in database
        """
        # Given
        run_id = "test-run-123"
        workflow_name = "test-workflow"
        provider = "anthropic"
        
        # When
        history_store.record_run(run_id, workflow_name, provider, sample_workflow_result)
        
        # Then
        cursor = history_store.conn.cursor()
        cursor.execute("SELECT * FROM workflow_runs WHERE run_id = ?", (run_id,))
        row = cursor.fetchone()
        
        assert row is not None
        assert row["run_id"] == run_id
        assert row["workflow_name"] == workflow_name
        assert row["provider"] == provider
        assert row["success"] == 1
        assert row["total_cost"] == 0.05
        assert row["baseline_cost"] == 0.10
        assert row["savings"] == 0.05
        assert row["savings_percent"] == 50.0

    def test_given_failed_result_when_recording_run_then_stores_error_info(
        self, history_store, failed_workflow_result
    ):
        """GIVEN a failed workflow result
        WHEN recording the run
        THEN error information is stored
        """
        # Given
        run_id = "failed-run-123"
        workflow_name = "test-workflow"
        provider = "anthropic"
        
        # When
        history_store.record_run(run_id, workflow_name, provider, failed_workflow_result)
        
        # Then
        cursor = history_store.conn.cursor()
        cursor.execute("SELECT * FROM workflow_runs WHERE run_id = ?", (run_id,))
        row = cursor.fetchone()
        
        assert row is not None
        assert row["success"] == 0
        assert row["error"] == "Connection timeout"
        assert row["error_type"] == "TimeoutError"
        assert row["transient"] == 1

    def test_given_result_with_stages_when_recording_run_then_stores_stages(
        self, history_store, sample_workflow_result_with_stages
    ):
        """GIVEN a workflow result with stages
        WHEN recording the run
        THEN stages are stored in workflow_stages table
        """
        # Given
        run_id = "run-with-stages"
        workflow_name = "test-workflow"
        provider = "anthropic"
        
        # When
        history_store.record_run(
            run_id, workflow_name, provider, sample_workflow_result_with_stages
        )
        
        # Then
        cursor = history_store.conn.cursor()
        cursor.execute("SELECT * FROM workflow_stages WHERE run_id = ?", (run_id,))
        stages = cursor.fetchall()
        
        assert len(stages) == 2
        assert stages[0]["stage_name"] == "stage1"
        assert stages[0]["cost"] == 0.02
        assert stages[0]["tokens_used"] == 100
        assert stages[1]["stage_name"] == "stage2"
        assert stages[1]["cost"] == 0.03
        assert stages[1]["tokens_used"] == 150

    def test_given_duplicate_run_id_when_recording_run_then_raises_error(
        self, history_store, sample_workflow_result
    ):
        """GIVEN a duplicate run_id
        WHEN recording the run
        THEN raises IntegrityError
        """
        # Given
        run_id = "duplicate-run"
        workflow_name = "test-workflow"
        provider = "anthropic"
        history_store.record_run(run_id, workflow_name, provider, sample_workflow_result)
        
        # When/Then
        with pytest.raises(sqlite3.IntegrityError):
            history_store.record_run(run_id, workflow_name, provider, sample_workflow_result)

    def test_given_result_without_stages_when_recording_run_then_no_stages_stored(
        self, history_store, sample_workflow_result
    ):
        """GIVEN a workflow result without stages
        WHEN recording the run
        THEN no stages are stored
        """
        # Given
        run_id = "run-no-stages"
        workflow_name = "test-workflow"
        provider = "anthropic"
        
        # When
        history_store.record_run(run_id, workflow_name, provider, sample_workflow_result)
        
        # Then
        cursor = history_store.conn.cursor()
        cursor.execute("SELECT * FROM workflow_stages WHERE run_id = ?", (run_id,))
        stages = cursor.fetchall()
        
        assert len(stages) == 0


class TestWorkflowHistoryStoreQueryRuns:
    """Test querying workflow runs."""

    def test_given_multiple_runs_when_querying_all_then_returns_all_runs(
        self, history_store, sample_workflow_result
    ):
        """GIVEN multiple workflow runs
        WHEN querying without filters
        THEN returns all runs
        """
        # Given
        for i in range(5):
            history_store.record_run(
                f"run-{i}", "test-workflow", "anthropic", sample_workflow_result
            )
        
        # When
        runs = history_store.query_runs()
        
        # Then
        assert len(runs) == 5

    def test_given_runs_when_querying_with_limit_then_returns_limited_results(
        self, history_store, sample_workflow_result
    ):
        """GIVEN multiple workflow runs
        WHEN querying with limit
        THEN returns limited number of runs
        """
        # Given
        for i in range(10):
            history_store.record_run(
                f"run-{i}", "test-workflow", "anthropic", sample_workflow_result
            )
        
        # When
        runs = history_store.query_runs(limit=5)
        
        # Then
        assert len(runs) == 5

    def test_given_mixed_workflows_when_querying_by_workflow_then_filters_correctly(
        self, history_store, sample_workflow_result
    ):
        """GIVEN runs from different workflows
        WHEN querying by workflow_name
        THEN returns only matching workflow runs
        """
        # Given
        for i in range(3):
            history_store.record_run(
                f"run-a-{i}", "workflow-a", "anthropic", sample_workflow_result
            )
        for i in range(2):
            history_store.record_run(
                f"run-b-{i}", "workflow-b", "anthropic", sample_workflow_result
            )
        
        # When
        runs = history_store.query_runs(workflow_name="workflow-a")
        
        # Then
        assert len(runs) == 3
        assert all(run["workflow_name"] == "workflow-a" for run in runs)

    def test_given_mixed_providers_when_querying_by_provider_then_filters_correctly(
        self, history_store, sample_workflow_result
    ):
        """GIVEN runs from different providers
        WHEN querying by provider
        THEN returns only matching provider runs
        """
        # Given
        for i in range(3):
            history_store.record_run(
                f"run-anthrop