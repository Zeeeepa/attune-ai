"""Behavioral tests for cli.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import argparse
import json
import logging
import sys
from io import StringIO
from pathlib import Path
from unittest.mock import MagicMock, Mock, call, mock_open, patch

import pytest

from empathy_os.test_generator.cli import (
    cmd_analyze,
    cmd_generate,
    main,
    parse_args,
    setup_logging,
)


@pytest.fixture
def mock_test_generator():
    """Mock TestGenerator class."""
    with patch("empathy_os.test_generator.cli.TestGenerator") as mock:
        instance = Mock()
        instance.generate_tests.return_value = {
            "unit": "# Unit test content",
            "integration": "# Integration test content",
            "fixtures": "# Fixtures content",
        }
        mock.return_value = instance
        yield instance


@pytest.fixture
def mock_risk_analyzer():
    """Mock RiskAnalyzer class."""
    with patch("empathy_os.test_generator.cli.RiskAnalyzer") as mock:
        instance = Mock()
        instance.analyze.return_value = {
            "overall_risk": "medium",
            "risk_score": 0.6,
            "risks": [
                {"type": "complexity", "severity": "high", "description": "Complex workflow"},
                {"type": "state", "severity": "medium", "description": "Multiple states"},
            ],
            "recommendations": [
                "Add error handling tests",
                "Test state transitions",
            ],
        }
        mock.return_value = instance
        yield instance


@pytest.fixture
def mock_validate_file_path():
    """Mock _validate_file_path function."""
    with patch("empathy_os.test_generator.cli._validate_file_path") as mock:
        mock.side_effect = lambda x: x
        yield mock


@pytest.fixture
def temp_output_dir(tmp_path):
    """Provide a temporary output directory."""
    output_dir = tmp_path / "tests" / "unit" / "workflows"
    output_dir.mkdir(parents=True, exist_ok=True)
    return output_dir


@pytest.fixture
def mock_logger():
    """Mock logger for testing."""
    with patch("empathy_os.test_generator.cli.logger") as mock:
        yield mock


@pytest.fixture
def capture_stdout():
    """Capture stdout for testing print statements."""
    old_stdout = sys.stdout
    sys.stdout = StringIO()
    yield sys.stdout
    sys.stdout = old_stdout


class TestCmdGenerate:
    """Tests for cmd_generate function."""

    def test_generates_tests_with_patterns(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given a workflow ID and pattern list
        When cmd_generate is called
        Then it should generate tests with specified patterns
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow,approval,structured_fields",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            cmd_generate(args)

        # Then
        mock_test_generator.generate_tests.assert_called_once_with(
            workflow_id="soap_note",
            pattern_ids=["linear_flow", "approval", "structured_fields"],
            workflow_module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
        )

    def test_generates_tests_without_patterns(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given a workflow ID without patterns
        When cmd_generate is called
        Then it should generate tests with empty pattern list
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns=None,
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            cmd_generate(args)

        # Then
        mock_test_generator.generate_tests.assert_called_once_with(
            workflow_id="soap_note",
            pattern_ids=[],
            workflow_module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
        )

    def test_writes_unit_test_file(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given generated test content
        When cmd_generate writes files
        Then it should write unit test file to correct location
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            cmd_generate(args)

        # Then
        expected_path = temp_output_dir / "test_soap_note_workflow.py"
        mock_file.assert_any_call(str(expected_path), "w")
        handle = mock_file()
        handle.write.assert_any_call("# Unit test content")

    def test_writes_integration_test_file(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given generated integration test content
        When cmd_generate writes files
        Then it should write integration test file to correct location
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            with patch("pathlib.Path.mkdir"):
                cmd_generate(args)

        # Then
        expected_path = (
            temp_output_dir.parent.parent / "integration" / "test_soap_note_integration.py"
        )
        mock_file.assert_any_call(str(expected_path), "w")
        handle = mock_file()
        handle.write.assert_any_call("# Integration test content")

    def test_writes_fixtures_file(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given generated fixtures content
        When cmd_generate writes files
        Then it should write fixtures file to correct location
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            cmd_generate(args)

        # Then
        expected_path = temp_output_dir / "fixtures_soap_note.py"
        mock_file.assert_any_call(str(expected_path), "w")
        handle = mock_file()
        handle.write.assert_any_call("# Fixtures content")

    def test_uses_default_output_directory(
        self, mock_test_generator, mock_validate_file_path, mock_logger
    ):
        """
        Given no output directory specified
        When cmd_generate is called
        Then it should use default tests/unit/workflows directory
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=None,
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            with patch("pathlib.Path.mkdir") as mock_mkdir:
                cmd_generate(args)

        # Then
        mock_mkdir.assert_called()
        assert any("tests/unit/workflows" in str(call) for call in mock_mkdir.call_args_list)

    def test_creates_output_directories(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given output directories that don't exist
        When cmd_generate is called
        Then it should create necessary directories
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir / "new_dir"),
        )

        # When
        with patch("builtins.open", mock_open()):
            with patch("pathlib.Path.mkdir") as mock_mkdir:
                cmd_generate(args)

        # Then
        assert mock_mkdir.called

    def test_validates_file_paths(
        self, mock_test_generator, temp_output_dir, mock_logger
    ):
        """
        Given file paths to write
        When cmd_generate is called
        Then it should validate all file paths
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()):
            with patch("empathy_os.test_generator.cli._validate_file_path") as mock_validate:
                mock_validate.side_effect = lambda x: x
                cmd_generate(args)

        # Then
        assert mock_validate.call_count >= 3  # unit, integration, fixtures

    def test_logs_generation_progress(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given a test generation process
        When cmd_generate runs
        Then it should log progress information
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()):
            cmd_generate(args)

        # Then
        assert mock_logger.info.called
        calls = [str(call) for call in mock_logger.info.call_args_list]
        assert any("Generating tests" in str(call) for call in calls)
        assert any("written to" in str(call) for call in calls)

    def test_prints_completion_message(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given successful test generation
        When cmd_generate completes
        Then it should print completion message and next steps
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()):
            with patch("builtins.print") as mock_print:
                cmd_generate(args)

        # Then
        assert mock_print.called
        print_calls = [str(call) for call in mock_print.call_args_list]
        assert any("Test generation complete" in str(call) for call in print_calls)
        assert any("Next steps" in str(call) for call in print_calls)

    def test_handles_no_integration_tests(
        self, mock_test_generator, mock_validate_file_path, temp_output_dir, mock_logger
    ):
        """
        Given no integration tests generated
        When cmd_generate writes files
        Then it should skip integration test file
        """
        # Given
        mock_test_generator.generate_tests.return_value = {
            "unit": "# Unit test content",
            "integration": "",
            "fixtures": "# Fixtures content",
        }
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=str(temp_output_dir),
        )

        # When
        with patch("builtins.open", mock_open()) as mock_file:
            cmd_generate(args)

        # Then
        # Should not write integration test file
        calls = [str(call) for call in mock_file.call_args_list]
        assert not any("integration" in str(call) for call in calls)


class TestCmdAnalyze:
    """Tests for cmd_analyze function."""

    def test_analyzes_workflow_with_patterns(
        self, mock_risk_analyzer, mock_logger
    ):
        """
        Given a workflow ID and pattern list
        When cmd_analyze is called
        Then it should analyze workflow with specified patterns
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns="linear_flow,approval",
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=None,
        )

        # When
        with patch("builtins.print"):
            cmd_analyze(args)

        # Then
        mock_risk_analyzer.analyze.assert_called_once_with(
            workflow_id="soap_note",
            pattern_ids=["linear_flow", "approval"],
            workflow_module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
        )

    def test_analyzes_workflow_without_patterns(
        self, mock_risk_analyzer, mock_logger
    ):
        """
        Given a workflow ID without patterns
        When cmd_analyze is called
        Then it should analyze workflow with empty pattern list
        """
        # Given
        args = argparse.Namespace(
            workflow_id="soap_note",
            patterns=None,
            module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
            output=None,
        )

        # When
        with patch("builtins.print"):
            cmd_analyze(args)

        # Then
        mock_risk_analyzer.analyze.assert_called_once_with(
            workflow_id="soap_note",
            pattern_ids=[],
            workflow_module="empathy_os.workflows.soap_note",
            workflow_class="SoapNoteWorkflow",
        )

    def test_prints_risk_analysis_results(
        self, mock_risk_analyzer, mock_logger
    ):
        """
        Given risk analysis results
        When cmd_analyze completes
        Then it should print formatted analysis results