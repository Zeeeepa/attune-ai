"""Behavioral tests for output.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from typing import Any
from dataclasses import is_dataclass

from empathy_os.workflow_patterns.output import ResultDataclassPattern
from empathy_os.workflow_patterns.core import (
    CodeSection,
    PatternCategory,
    WorkflowComplexity,
)


class TestResultDataclassPattern:
    """Behavioral tests for ResultDataclassPattern class."""

    @pytest.fixture
    def pattern(self) -> ResultDataclassPattern:
        """Given a ResultDataclassPattern instance."""
        return ResultDataclassPattern()

    @pytest.fixture
    def basic_context(self) -> dict[str, Any]:
        """Given a basic context dictionary."""
        return {
            "workflow_name": "test-workflow",
            "class_name": "TestWorkflow",
        }

    @pytest.fixture
    def context_with_custom_fields(self) -> dict[str, Any]:
        """Given a context with custom result fields."""
        return {
            "workflow_name": "advanced-workflow",
            "class_name": "AdvancedWorkflow",
            "result_fields": [
                {
                    "name": "message",
                    "type": "str",
                    "description": "Status message",
                },
                {
                    "name": "count",
                    "type": "int",
                    "description": "Item count",
                },
            ],
        }

    def test_pattern_id_is_correct(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the id attribute
        Then it should return 'result-dataclass'
        """
        assert pattern.id == "result-dataclass"

    def test_pattern_name_is_correct(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the name attribute
        Then it should return 'Result Dataclass'
        """
        assert pattern.name == "Result Dataclass"

    def test_pattern_category_is_output(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the category attribute
        Then it should be PatternCategory.OUTPUT
        """
        assert pattern.category == PatternCategory.OUTPUT

    def test_pattern_description_is_set(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the description attribute
        Then it should have a meaningful description
        """
        assert pattern.description == "Structured output format with dataclass"
        assert isinstance(pattern.description, str)
        assert len(pattern.description) > 0

    def test_pattern_complexity_is_simple(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the complexity attribute
        Then it should be WorkflowComplexity.SIMPLE
        """
        assert pattern.complexity == WorkflowComplexity.SIMPLE

    def test_use_cases_are_defined(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the use_cases attribute
        Then it should contain a list of use cases
        """
        assert isinstance(pattern.use_cases, list)
        assert len(pattern.use_cases) > 0
        assert "Type-safe results" in pattern.use_cases
        assert "Structured output" in pattern.use_cases
        assert "API integration" in pattern.use_cases

    def test_examples_are_defined(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the examples attribute
        Then it should contain example workflow names
        """
        assert isinstance(pattern.examples, list)
        assert len(pattern.examples) > 0
        assert "health-check" in pattern.examples
        assert "release-prep" in pattern.examples

    def test_risk_weight_is_one(self, pattern: ResultDataclassPattern):
        """
        Given a ResultDataclassPattern instance
        When accessing the risk_weight attribute
        Then it should be 1.0
        """
        assert pattern.risk_weight == 1.0

    def test_generate_code_sections_returns_list(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern and a basic context
        When calling generate_code_sections
        Then it should return a list of CodeSection objects
        """
        sections = pattern.generate_code_sections(basic_context)
        
        assert isinstance(sections, list)
        assert len(sections) > 0
        assert all(isinstance(section, CodeSection) for section in sections)

    def test_generate_code_sections_creates_three_sections(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern and a basic context
        When calling generate_code_sections
        Then it should return exactly three code sections
        """
        sections = pattern.generate_code_sections(basic_context)
        
        assert len(sections) == 3

    def test_generate_code_sections_has_imports_section(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern and a basic context
        When calling generate_code_sections
        Then it should include an imports section with dataclass imports
        """
        sections = pattern.generate_code_sections(basic_context)
        
        import_sections = [s for s in sections if s.location == "imports"]
        assert len(import_sections) == 1
        
        import_section = import_sections[0]
        assert "dataclass" in import_section.code
        assert "field" in import_section.code
        assert import_section.priority == 1

    def test_generate_code_sections_has_dataclass_section(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern and a basic context
        When calling generate_code_sections
        Then it should include a dataclasses section with the result class
        """
        sections = pattern.generate_code_sections(basic_context)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        assert len(dataclass_sections) == 1
        
        dataclass_section = dataclass_sections[0]
        assert "@dataclass" in dataclass_section.code
        assert "TestWorkflowResult" in dataclass_section.code
        assert "success: bool" in dataclass_section.code
        assert "duration_seconds: float" in dataclass_section.code
        assert "cost: float" in dataclass_section.code
        assert "metadata: dict" in dataclass_section.code
        assert import_section.priority == 1

    def test_generate_code_sections_has_methods_section(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern and a basic context
        When calling generate_code_sections
        Then it should include a methods section with _create_result method
        """
        sections = pattern.generate_code_sections(basic_context)
        
        method_sections = [s for s in sections if s.location == "methods"]
        assert len(method_sections) == 1
        
        method_section = method_sections[0]
        assert "_create_result" in method_section.code
        assert "def _create_result" in method_section.code
        assert "success: bool" in method_section.code
        assert "duration: float" in method_section.code
        assert "cost: float" in method_section.code
        assert "TestWorkflowResult" in method_section.code

    def test_generate_code_sections_uses_workflow_name_from_context(
        self, pattern: ResultDataclassPattern
    ):
        """
        Given a ResultDataclassPattern and a context with workflow_name
        When calling generate_code_sections
        Then the generated code should reference the workflow name
        """
        context = {
            "workflow_name": "custom-workflow",
            "class_name": "CustomWorkflow",
        }
        sections = pattern.generate_code_sections(context)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        assert len(dataclass_sections) == 1
        assert "CustomWorkflowResult" in dataclass_sections[0].code
        assert "CustomWorkflow" in dataclass_sections[0].code

    def test_generate_code_sections_with_custom_fields(
        self, pattern: ResultDataclassPattern, context_with_custom_fields: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern and a context with custom result fields
        When calling generate_code_sections
        Then the generated dataclass should include the custom fields
        """
        sections = pattern.generate_code_sections(context_with_custom_fields)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        assert len(dataclass_sections) == 1
        
        dataclass_code = dataclass_sections[0].code
        assert "message: str" in dataclass_code
        assert "Status message" in dataclass_code
        assert "count: int" in dataclass_code
        assert "Item count" in dataclass_code

    def test_generate_code_sections_custom_fields_order(
        self, pattern: ResultDataclassPattern, context_with_custom_fields: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern with custom fields
        When calling generate_code_sections
        Then custom fields should appear before duration_seconds
        """
        sections = pattern.generate_code_sections(context_with_custom_fields)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        dataclass_code = dataclass_sections[0].code
        
        message_pos = dataclass_code.find("message: str")
        count_pos = dataclass_code.find("count: int")
        duration_pos = dataclass_code.find("duration_seconds: float")
        
        assert message_pos < duration_pos
        assert count_pos < duration_pos

    def test_generate_code_sections_without_custom_fields_has_comment(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern without custom fields
        When calling generate_code_sections
        Then the dataclass should include a comment for adding custom fields
        """
        sections = pattern.generate_code_sections(basic_context)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        dataclass_code = dataclass_sections[0].code
        
        assert "# Add custom fields here" in dataclass_code

    def test_generate_code_sections_with_empty_result_fields(
        self, pattern: ResultDataclassPattern
    ):
        """
        Given a ResultDataclassPattern with empty result_fields list
        When calling generate_code_sections
        Then it should generate code with the comment placeholder
        """
        context = {
            "workflow_name": "test-workflow",
            "class_name": "TestWorkflow",
            "result_fields": [],
        }
        sections = pattern.generate_code_sections(context)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        assert "# Add custom fields here" in dataclass_sections[0].code

    def test_generate_code_sections_with_single_custom_field(
        self, pattern: ResultDataclassPattern
    ):
        """
        Given a ResultDataclassPattern with a single custom field
        When calling generate_code_sections
        Then the dataclass should include exactly that field
        """
        context = {
            "workflow_name": "single-field-workflow",
            "class_name": "SingleFieldWorkflow",
            "result_fields": [
                {
                    "name": "status",
                    "type": "str",
                    "description": "Execution status",
                },
            ],
        }
        sections = pattern.generate_code_sections(context)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        dataclass_code = dataclass_sections[0].code
        
        assert "status: str" in dataclass_code
        assert "Execution status" in dataclass_code

    def test_generate_code_sections_defaults_workflow_name(
        self, pattern: ResultDataclassPattern
    ):
        """
        Given a ResultDataclassPattern with empty context
        When calling generate_code_sections
        Then it should use default workflow_name
        """
        context: dict[str, Any] = {}
        sections = pattern.generate_code_sections(context)
        
        # Should not raise an error and should generate sections
        assert len(sections) == 3

    def test_generate_code_sections_defaults_class_name(
        self, pattern: ResultDataclassPattern
    ):
        """
        Given a ResultDataclassPattern with context missing class_name
        When calling generate_code_sections
        Then it should use default class name
        """
        context = {"workflow_name": "test"}
        sections = pattern.generate_code_sections(context)
        
        dataclass_sections = [s for s in sections if s.location == "dataclasses"]
        assert "MyWorkflowResult" in dataclass_sections[0].code

    def test_generate_code_sections_method_has_docstring(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern
        When calling generate_code_sections
        Then the _create_result method should have a proper docstring
        """
        sections = pattern.generate_code_sections(basic_context)
        
        method_sections = [s for s in sections if s.location == "methods"]
        method_code = method_sections[0].code
        
        assert '"""Create structured result.' in method_code
        assert "Args:" in method_code
        assert "Returns:" in method_code

    def test_generate_code_sections_method_returns_correct_class(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern with class_name TestWorkflow
        When calling generate_code_sections
        Then the _create_result method should return TestWorkflowResult
        """
        sections = pattern.generate_code_sections(basic_context)
        
        method_sections = [s for s in sections if s.location == "methods"]
        method_code = method_sections[0].code
        
        assert "-> TestWorkflowResult:" in method_code
        assert "return TestWorkflowResult(" in method_code

    def test_generate_code_sections_includes_kwargs(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern
        When calling generate_code_sections
        Then the _create_result method should accept **kwargs
        """
        sections = pattern.generate_code_sections(basic_context)
        
        method_sections = [s for s in sections if s.location == "methods"]
        method_code = method_sections[0].code
        
        assert "**kwargs: Any" in method_code

    def test_generate_code_sections_all_priorities_set(
        self, pattern: ResultDataclassPattern, basic_context: dict[str, Any]
    ):
        """
        Given a ResultDataclassPattern
        When calling generate_code_sections