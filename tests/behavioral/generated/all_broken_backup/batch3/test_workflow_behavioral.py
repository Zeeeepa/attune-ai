"""Behavioral tests for workflow.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import json
from argparse import Namespace
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, Mock, call, mock_open, patch

import pytest

from empathy_os.cli.commands.workflow import (
    _extract_workflow_content,
    cmd_workflow,
)


class TestExtractWorkflowContent:
    """Behavioral tests for _extract_workflow_content function."""

    def test_given_none_input_when_extract_then_returns_none(self):
        """Given None as input, when extracting content, then returns None."""
        # Given
        final_output = None

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result is None

    def test_given_string_input_when_extract_then_returns_string(self):
        """Given a string input, when extracting content, then returns the string."""
        # Given
        final_output = "This is a test output"

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "This is a test output"

    def test_given_dict_with_formatted_report_when_extract_then_returns_report(self):
        """Given dict with formatted_report, when extracting, then returns report."""
        # Given
        final_output = {
            "formatted_report": "Security Audit Report",
            "answer": "Some answer",
            "other": "data"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "Security Audit Report"

    def test_given_dict_with_answer_when_extract_then_returns_answer(self):
        """Given dict with answer key, when extracting, then returns answer."""
        # Given
        final_output = {
            "answer": "This is the answer",
            "metadata": "some metadata"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "This is the answer"

    def test_given_dict_with_synthesis_when_extract_then_returns_synthesis(self):
        """Given dict with synthesis key, when extracting, then returns synthesis."""
        # Given
        final_output = {
            "synthesis": "Synthesized content",
            "raw": "raw data"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "Synthesized content"

    def test_given_dict_with_nested_dict_when_extract_then_recursively_extracts(self):
        """Given dict with nested dict, when extracting, then recursively extracts."""
        # Given
        final_output = {
            "result": {
                "answer": "Nested answer"
            }
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "Nested answer"

    def test_given_dict_with_long_string_value_when_extract_then_returns_value(self):
        """Given dict with long string value, when extracting, then returns that value."""
        # Given
        long_string = "x" * 150
        final_output = {
            "custom_key": long_string,
            "short": "y"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == long_string

    def test_given_dict_with_no_common_keys_when_extract_then_returns_json(self):
        """Given dict without common keys, when extracting, then returns JSON."""
        # Given
        final_output = {
            "unknown": "short",
            "data": 123
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert isinstance(result, str)
        assert "unknown" in result
        assert "data" in result

    def test_given_list_input_when_extract_then_returns_string_representation(self):
        """Given list input, when extracting, then returns string representation."""
        # Given
        final_output = ["item1", "item2", "item3"]

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == str(final_output)

    def test_given_dict_with_multiple_content_keys_when_extract_then_returns_first_priority(self):
        """Given dict with multiple content keys, when extracting, then returns highest priority."""
        # Given
        final_output = {
            "output": "output content",
            "formatted_report": "formatted report",
            "answer": "answer content"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "formatted report"

    def test_given_dict_with_report_key_when_extract_then_returns_report(self):
        """Given dict with report key, when extracting, then returns report."""
        # Given
        final_output = {
            "report": "Detailed report content"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "Detailed report content"

    def test_given_dict_with_recommendations_when_extract_then_returns_recommendations(self):
        """Given dict with recommendations, when extracting, then returns recommendations."""
        # Given
        final_output = {
            "recommendations": "Security recommendations"
        }

        # When
        result = _extract_workflow_content(final_output)

        # Then
        assert result == "Security recommendations"


class TestCmdWorkflow:
    """Behavioral tests for cmd_workflow command."""

    @pytest.fixture
    def mock_dependencies(self):
        """Fixture providing mocked dependencies."""
        with patch('empathy_os.cli.commands.workflow.get_workflow_list') as mock_list, \
             patch('empathy_os.cli.commands.workflow.get_workflow') as mock_get, \
             patch('empathy_os.cli.commands.workflow.WorkflowConfig') as mock_config, \
             patch('empathy_os.cli.commands.workflow.create_example_config') as mock_example, \
             patch('empathy_os.cli.commands.workflow._validate_file_path') as mock_validate, \
             patch('empathy_os.cli.commands.workflow.asyncio.run') as mock_asyncio_run, \
             patch('builtins.print') as mock_print:
            
            yield {
                'get_workflow_list': mock_list,
                'get_workflow': mock_get,
                'WorkflowConfig': mock_config,
                'create_example_config': mock_example,
                'validate_file_path': mock_validate,
                'asyncio_run': mock_asyncio_run,
                'print': mock_print,
            }

    def test_given_list_action_when_cmd_workflow_then_lists_workflows(self, mock_dependencies):
        """Given list action, when executing cmd_workflow, then lists all workflows."""
        # Given
        args = Namespace(action='list', json=False)
        mock_dependencies['get_workflow_list'].return_value = {
            'workflow1': {'description': 'Test workflow 1'},
            'workflow2': {'description': 'Test workflow 2'}
        }

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['get_workflow_list'].assert_called_once()
        assert mock_dependencies['print'].call_count >= 2

    def test_given_list_action_with_json_when_cmd_workflow_then_outputs_json(self, mock_dependencies):
        """Given list action with JSON flag, when executing, then outputs JSON."""
        # Given
        args = Namespace(action='list', json=True)
        workflows = {
            'workflow1': {'description': 'Test workflow 1'},
            'workflow2': {'description': 'Test workflow 2'}
        }
        mock_dependencies['get_workflow_list'].return_value = workflows

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['get_workflow_list'].assert_called_once()
        print_calls = [str(call) for call in mock_dependencies['print'].call_args_list]
        assert any('workflow1' in str(call) for call in print_calls)

    def test_given_describe_action_when_cmd_workflow_then_describes_workflow(self, mock_dependencies):
        """Given describe action, when executing cmd_workflow, then describes workflow."""
        # Given
        args = Namespace(action='describe', name='test-workflow', json=False)
        mock_workflow_class = MagicMock()
        mock_workflow_class.__doc__ = "Test workflow documentation"
        mock_workflow_class.get_description.return_value = {
            'name': 'test-workflow',
            'description': 'A test workflow',
            'tiers': ['fast', 'balanced']
        }
        mock_dependencies['get_workflow'].return_value = mock_workflow_class

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['get_workflow'].assert_called_once_with('test-workflow')
        mock_workflow_class.get_description.assert_called_once()
        assert mock_dependencies['print'].call_count >= 1

    def test_given_describe_action_with_json_when_cmd_workflow_then_outputs_json(self, mock_dependencies):
        """Given describe action with JSON, when executing, then outputs JSON."""
        # Given
        args = Namespace(action='describe', name='test-workflow', json=True)
        mock_workflow_class = MagicMock()
        description = {
            'name': 'test-workflow',
            'description': 'A test workflow'
        }
        mock_workflow_class.get_description.return_value = description
        mock_dependencies['get_workflow'].return_value = mock_workflow_class

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['get_workflow'].assert_called_once_with('test-workflow')
        print_calls = mock_dependencies['print'].call_args_list
        assert len(print_calls) > 0

    def test_given_describe_nonexistent_workflow_when_cmd_workflow_then_prints_error(self, mock_dependencies):
        """Given describe for nonexistent workflow, when executing, then prints error."""
        # Given
        args = Namespace(action='describe', name='nonexistent', json=False)
        mock_dependencies['get_workflow'].side_effect = ValueError("Workflow not found")

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['get_workflow'].assert_called_once_with('nonexistent')
        print_calls = [str(call) for call in mock_dependencies['print'].call_args_list]
        assert any('Error' in str(call) or 'not found' in str(call).lower() for call in print_calls)

    def test_given_run_action_with_input_string_when_cmd_workflow_then_executes(self, mock_dependencies):
        """Given run action with input string, when executing, then runs workflow."""
        # Given
        args = Namespace(
            action='run',
            name='test-workflow',
            input='{"query": "test"}',
            provider=None,
            json=False,
            use_recommended_tier=False,
            tier=None,
            config=None
        )
        
        mock_workflow_class = MagicMock()
        mock_workflow_instance = MagicMock()
        mock_workflow_class.return_value = mock_workflow_instance
        
        async def mock_run(**kwargs):
            return {"answer": "Test result"}
        
        mock_workflow_instance.run = mock_run
        mock_dependencies['get_workflow'].return_value = mock_workflow_class
        mock_dependencies['asyncio_run'].side_effect = lambda coro: asyncio.run(coro)

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['get_workflow'].assert_called_once_with('test-workflow')
        assert mock_dependencies['asyncio_run'].called

    def test_given_run_action_with_file_input_when_cmd_workflow_then_reads_file(self, mock_dependencies):
        """Given run action with file input, when executing, then reads from file."""
        # Given
        args = Namespace(
            action='run',
            name='test-workflow',
            input='@input.json',
            provider=None,
            json=False,
            use_recommended_tier=False,
            tier=None,
            config=None
        )
        
        mock_dependencies['validate_file_path'].return_value = Path('input.json')
        
        mock_workflow_class = MagicMock()
        mock_workflow_instance = MagicMock()
        mock_workflow_class.return_value = mock_workflow_instance
        
        async def mock_run(**kwargs):
            return {"answer": "Test result"}
        
        mock_workflow_instance.run = mock_run
        mock_dependencies['get_workflow'].return_value = mock_workflow_class
        
        file_content = '{"query": "test from file"}'
        
        with patch('builtins.open', mock_open(read_data=file_content)):
            mock_dependencies['asyncio_run'].side_effect = lambda coro: asyncio.run(coro)
            
            # When
            cmd_workflow(args)

        # Then
        mock_dependencies['validate_file_path'].assert_called_once()
        assert mock_dependencies['asyncio_run'].called

    def test_given_run_action_with_config_when_cmd_workflow_then_loads_config(self, mock_dependencies):
        """Given run action with config file, when executing, then loads config."""
        # Given
        args = Namespace(
            action='run',
            name='test-workflow',
            input='{"query": "test"}',
            provider=None,
            json=False,
            use_recommended_tier=False,
            tier=None,
            config='config.yaml'
        )
        
        mock_config_instance = MagicMock()
        mock_dependencies['WorkflowConfig'].from_file.return_value = mock_config_instance
        
        mock_workflow_class = MagicMock()
        mock_workflow_instance = MagicMock()
        mock_workflow_class.return_value = mock_workflow_instance
        
        async def mock_run(**kwargs):
            return {"answer": "Test result"}
        
        mock_workflow_instance.run = mock_run
        mock_dependencies['get_workflow'].return_value = mock_workflow_class
        mock_dependencies['asyncio_run'].side_effect = lambda coro: asyncio.run(coro)

        # When
        cmd_workflow(args)

        # Then
        mock_dependencies['WorkflowConfig'].from_file.assert_called_once_with('config.yaml')

    def test_given_run_action_with_provider_when_cmd_workflow_then_uses_provider(self, mock_dependencies):
        """Given run action with provider, when executing, then uses specified provider."""
        # Given
        args = Namespace(
            action='run',
            name='test-workflow',
            input='{"query": "test"}',
            provider='openai',
            json=False,
            use_recommended_tier=False,
            tier=None,
            config=None
        )
        
        mock_workflow_class = MagicMock()
        mock_workflow_instance = MagicMock()
        mock_workflow_class.return_value = mock_workflow_instance
        
        async def mock_run(**kwargs):
            return {"answer": "Test result"}
        
        mock