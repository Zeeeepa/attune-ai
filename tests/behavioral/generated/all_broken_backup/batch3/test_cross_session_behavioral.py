"""Behavioral tests for cross_session.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import time
from datetime import datetime, timedelta
from unittest.mock import MagicMock, Mock, patch, call

import pytest
import structlog

from empathy_os.memory.cross_session import (
    CHANNEL_SESSIONS,
    HEARTBEAT_INTERVAL_SECONDS,
    KEY_ACTIVE_AGENTS,
    KEY_SERVICE_HEARTBEAT,
    KEY_SERVICE_LOCK,
    SERVICE_LOCK_TTL_SECONDS,
    STALE_THRESHOLD_SECONDS,
    ConflictStrategy,
    SessionInfo,
    SessionType,
)
from empathy_os.memory.short_term import AccessTier, AgentCredentials


# === Fixtures ===


@pytest.fixture
def mock_redis():
    """Provide a mock Redis client."""
    redis = MagicMock()
    redis.ping.return_value = True
    redis.hgetall.return_value = {}
    redis.hset.return_value = 1
    redis.hdel.return_value = 1
    redis.publish.return_value = 1
    redis.set.return_value = True
    redis.get.return_value = None
    redis.delete.return_value = 1
    redis.setex.return_value = True
    return redis


@pytest.fixture
def mock_memory(mock_redis):
    """Provide a mock RedisShortTermMemory instance."""
    with patch("empathy_os.memory.cross_session.RedisShortTermMemory") as mock_class:
        memory = MagicMock()
        memory.redis = mock_redis
        memory.credentials = AgentCredentials(
            agent_id="test_agent",
            access_tier=AccessTier.DEVELOPER,
            capabilities=["read", "write"],
        )
        mock_class.return_value = memory
        yield memory


@pytest.fixture
def sample_session_info():
    """Provide a sample SessionInfo instance."""
    return SessionInfo(
        agent_id="agent_123",
        session_type=SessionType.CLAUDE,
        access_tier=AccessTier.DEVELOPER,
        capabilities=["read", "write", "delete"],
        started_at=datetime(2025, 1, 1, 12, 0, 0),
        last_heartbeat=datetime(2025, 1, 1, 12, 5, 0),
        metadata={"version": "1.0", "host": "localhost"},
    )


@pytest.fixture
def stale_session_info():
    """Provide a stale SessionInfo instance."""
    old_time = datetime.now() - timedelta(seconds=STALE_THRESHOLD_SECONDS + 10)
    return SessionInfo(
        agent_id="stale_agent",
        session_type=SessionType.WORKER,
        access_tier=AccessTier.USER,
        capabilities=["read"],
        started_at=old_time,
        last_heartbeat=old_time,
        metadata={},
    )


# === SessionType Tests ===


class TestSessionType:
    """Test SessionType enum."""

    def test_given_session_types_when_accessed_then_correct_values(self):
        """Given session type enum, when accessed, then returns correct values."""
        # Given/When/Then
        assert SessionType.CLAUDE.value == "claude"
        assert SessionType.SERVICE.value == "service"
        assert SessionType.WORKER.value == "worker"

    def test_given_string_value_when_converting_then_returns_enum(self):
        """Given string value, when converting to enum, then returns correct enum."""
        # Given
        value = "claude"

        # When
        session_type = SessionType(value)

        # Then
        assert session_type == SessionType.CLAUDE

    def test_given_invalid_value_when_converting_then_raises_error(self):
        """Given invalid value, when converting to enum, then raises ValueError."""
        # Given
        invalid_value = "invalid_type"

        # When/Then
        with pytest.raises(ValueError):
            SessionType(invalid_value)


# === ConflictStrategy Tests ===


class TestConflictStrategy:
    """Test ConflictStrategy enum."""

    def test_given_conflict_strategies_when_accessed_then_correct_values(self):
        """Given conflict strategy enum, when accessed, then returns correct values."""
        # Given/When/Then
        assert ConflictStrategy.PRIORITY_BASED.value == "priority"
        assert ConflictStrategy.FIRST_WRITE_WINS.value == "first_write"
        assert ConflictStrategy.LAST_WRITE_WINS.value == "last_write"

    def test_given_string_value_when_converting_then_returns_enum(self):
        """Given string value, when converting to enum, then returns correct enum."""
        # Given
        value = "priority"

        # When
        strategy = ConflictStrategy(value)

        # Then
        assert strategy == ConflictStrategy.PRIORITY_BASED


# === SessionInfo Tests ===


class TestSessionInfo:
    """Test SessionInfo dataclass."""

    def test_given_session_info_when_created_then_has_correct_attributes(
        self, sample_session_info
    ):
        """Given session info, when created, then has correct attributes."""
        # Given/When - fixture provides sample_session_info
        session = sample_session_info

        # Then
        assert session.agent_id == "agent_123"
        assert session.session_type == SessionType.CLAUDE
        assert session.access_tier == AccessTier.DEVELOPER
        assert session.capabilities == ["read", "write", "delete"]
        assert session.started_at == datetime(2025, 1, 1, 12, 0, 0)
        assert session.last_heartbeat == datetime(2025, 1, 1, 12, 5, 0)
        assert session.metadata == {"version": "1.0", "host": "localhost"}

    def test_given_session_info_when_converted_to_dict_then_correct_format(
        self, sample_session_info
    ):
        """Given session info, when converted to dict, then returns correct format."""
        # Given
        session = sample_session_info

        # When
        result = session.to_dict()

        # Then
        assert result["agent_id"] == "agent_123"
        assert result["session_type"] == "claude"
        assert result["access_tier"] == "developer"
        assert result["capabilities"] == ["read", "write", "delete"]
        assert result["started_at"] == "2025-01-01T12:00:00"
        assert result["last_heartbeat"] == "2025-01-01T12:05:00"
        assert result["metadata"] == {"version": "1.0", "host": "localhost"}

    def test_given_dict_when_creating_session_info_then_correct_object(self):
        """Given dictionary, when creating SessionInfo, then returns correct object."""
        # Given
        data = {
            "agent_id": "agent_456",
            "session_type": "service",
            "access_tier": "user",
            "capabilities": ["read"],
            "started_at": "2025-01-02T10:00:00",
            "last_heartbeat": "2025-01-02T10:30:00",
            "metadata": {"env": "production"},
        }

        # When
        session = SessionInfo.from_dict(data)

        # Then
        assert session.agent_id == "agent_456"
        assert session.session_type == SessionType.SERVICE
        assert session.access_tier == AccessTier.USER
        assert session.capabilities == ["read"]
        assert session.started_at == datetime(2025, 1, 2, 10, 0, 0)
        assert session.last_heartbeat == datetime(2025, 1, 2, 10, 30, 0)
        assert session.metadata == {"env": "production"}

    def test_given_dict_without_optional_fields_when_creating_then_uses_defaults(self):
        """Given dict without optional fields, when creating, then uses defaults."""
        # Given
        data = {
            "agent_id": "agent_789",
            "session_type": "worker",
            "access_tier": "admin",
            "started_at": "2025-01-03T08:00:00",
            "last_heartbeat": "2025-01-03T08:15:00",
        }

        # When
        session = SessionInfo.from_dict(data)

        # Then
        assert session.capabilities == []
        assert session.metadata == {}

    def test_given_fresh_session_when_checking_staleness_then_not_stale(
        self, sample_session_info
    ):
        """Given fresh session, when checking staleness, then returns False."""
        # Given
        session = sample_session_info
        session.last_heartbeat = datetime.now()

        # When
        is_stale = session.is_stale

        # Then
        assert not is_stale

    def test_given_old_session_when_checking_staleness_then_is_stale(
        self, stale_session_info
    ):
        """Given old session, when checking staleness, then returns True."""
        # Given
        session = stale_session_info

        # When
        is_stale = session.is_stale

        # Then
        assert is_stale

    def test_given_session_at_threshold_when_checking_staleness_then_not_stale(
        self, sample_session_info
    ):
        """Given session at threshold, when checking staleness, then returns False."""
        # Given
        session = sample_session_info
        session.last_heartbeat = datetime.now() - timedelta(
            seconds=STALE_THRESHOLD_SECONDS - 1
        )

        # When
        is_stale = session.is_stale

        # Then
        assert not is_stale

    def test_given_session_past_threshold_when_checking_staleness_then_is_stale(
        self, sample_session_info
    ):
        """Given session past threshold, when checking staleness, then returns True."""
        # Given
        session = sample_session_info
        session.last_heartbeat = datetime.now() - timedelta(
            seconds=STALE_THRESHOLD_SECONDS + 1
        )

        # When
        is_stale = session.is_stale

        # Then
        assert is_stale

    def test_given_session_info_when_roundtrip_conversion_then_preserves_data(
        self, sample_session_info
    ):
        """Given session info, when roundtrip conversion, then preserves data."""
        # Given
        original = sample_session_info

        # When
        data = original.to_dict()
        restored = SessionInfo.from_dict(data)

        # Then
        assert restored.agent_id == original.agent_id
        assert restored.session_type == original.session_type
        assert restored.access_tier == original.access_tier
        assert restored.capabilities == original.capabilities
        assert restored.started_at == original.started_at
        assert restored.last_heartbeat == original.last_heartbeat
        assert restored.metadata == original.metadata

    def test_given_empty_metadata_when_creating_session_then_defaults_empty_dict(self):
        """Given empty metadata, when creating session, then defaults to empty dict."""
        # Given/When
        session = SessionInfo(
            agent_id="test",
            session_type=SessionType.CLAUDE,
            access_tier=AccessTier.USER,
            capabilities=[],
            started_at=datetime.now(),
            last_heartbeat=datetime.now(),
        )

        # Then
        assert session.metadata == {}

    def test_given_session_with_extra_metadata_when_converted_then_preserves(self):
        """Given session with extra metadata, when converted, then preserves it."""
        # Given
        metadata = {
            "custom_field": "value",
            "nested": {"key": "val"},
            "number": 42,
        }
        session = SessionInfo(
            agent_id="test",
            session_type=SessionType.SERVICE,
            access_tier=AccessTier.ADMIN,
            capabilities=["admin"],
            started_at=datetime.now(),
            last_heartbeat=datetime.now(),
            metadata=metadata,
        )

        # When
        data = session.to_dict()
        restored = SessionInfo.from_dict(data)

        # Then
        assert restored.metadata == metadata


# === Constants Tests ===


class TestConstants:
    """Test module constants."""

    def test_given_constants_when_accessed_then_have_correct_values(self):
        """Given constants, when accessed, then have correct values."""
        # Given/When/Then
        assert CHANNEL_SESSIONS == "empathy:sessions"
        assert KEY_ACTIVE_AGENTS == "empathy:active_agents"
        assert KEY_SERVICE_LOCK == "empathy:service_lock"
        assert KEY_SERVICE_HEARTBEAT == "empathy:service_heartbeat"

    def test_given_timing_constants_when_accessed_then_have_correct_values(self):
        """Given timing constants, when accessed, then have correct values."""
        # Given/When/Then
        assert HEARTBEAT_INTERVAL_SECONDS == 30
        assert STALE_THRESHOLD_SECONDS == 90
        assert SERVICE_LOCK_TTL_SECONDS == 60

    def test_given_stale_threshold_when_compared_to_heartbeat_then_greater(self):
        """Given stale threshold, when compared to heartbeat, then is greater."""
        # Given/When/Then
        assert STALE_THRESHOLD_SECONDS > HEARTBEAT_INTERVAL_SECONDS


# === Integration Tests ===


class TestSessionInfoIntegration:
    """Integration tests for SessionInfo with various data types."""

    def test_given_all_session_types_when_converted_then_correct(self):
        """Given all session types, when converted, then handles correctly."""
        # Given
        for session_type in SessionType:
            session = SessionInfo(
                agent_id=f"agent_{session_type.value}",
                session_type=session_type,
                access_tier=AccessTier.USER,
                capabilities=[],
                started_at=datetime.now(),
                last_heartbeat=datetime.now(),
            )

            # When
            data = session.to_dict()
            restored = SessionInfo.from_dict(data)

            # Then
            assert restored.session_type == session_type

    def test_given_all_access_tiers_when_converted_then_correct(self):
        """Given all access tiers, when converted, then handles correctly."""
        # Given
        for access_tier in AccessTier:
            session = SessionInfo(
                agent_id=f"agent_{access_tier.value}",
                session_type=SessionType.CLAUDE,
                access_tier=access_tier,
                capabilities=[],
                started_at=datetime.now(),
                last_heartbeat=datetime.now(),
            )

            # When
            data = session.to_dict()
            restored = SessionInfo.from_dict(data)

            # Then
            assert restored.access_tier == access_tier

    def test_given_various_capability_lists_when_converted_then_preserves(self):
        """Given various capability lists, when converted, then preserves them."""
        # Given
        capability_sets = [
            [],
            ["read"],
            ["read", "write"],
            ["read", "write", "delete", "admin"],
        ]

        for capabilities in capability_sets:
            session = SessionInfo(
                agent_id="test",
                session_type=SessionType.WORKER,
                access_tier=AccessTier.USER,