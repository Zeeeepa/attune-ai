"""Behavioral tests for models.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from datetime import datetime, timedelta
from typing import Any

from empathy_os.project_index.models import (
    FileCategory,
    TestRequirement,
    FileRecord,
)


class TestFileCategory:
    """Behavioral tests for FileCategory enum."""

    def test_given_file_category_when_accessing_source_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing SOURCE category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.SOURCE

        # Then
        assert category == "source"
        assert category.value == "source"

    def test_given_file_category_when_accessing_test_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing TEST category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.TEST

        # Then
        assert category == "test"
        assert category.value == "test"

    def test_given_file_category_when_accessing_config_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing CONFIG category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.CONFIG

        # Then
        assert category == "config"
        assert category.value == "config"

    def test_given_file_category_when_accessing_docs_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing DOCS category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.DOCS

        # Then
        assert category == "docs"
        assert category.value == "docs"

    def test_given_file_category_when_accessing_asset_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing ASSET category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.ASSET

        # Then
        assert category == "asset"
        assert category.value == "asset"

    def test_given_file_category_when_accessing_generated_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing GENERATED category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.GENERATED

        # Then
        assert category == "generated"
        assert category.value == "generated"

    def test_given_file_category_when_accessing_build_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing BUILD category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.BUILD

        # Then
        assert category == "build"
        assert category.value == "build"

    def test_given_file_category_when_accessing_unknown_then_returns_correct_value(self):
        """
        Given a FileCategory enum
        When accessing UNKNOWN category
        Then it returns the correct string value
        """
        # Given/When
        category = FileCategory.UNKNOWN

        # Then
        assert category == "unknown"
        assert category.value == "unknown"

    def test_given_string_value_when_creating_category_then_creates_correct_enum(self):
        """
        Given a string value
        When creating a FileCategory from string
        Then it creates the correct enum instance
        """
        # Given
        value = "source"

        # When
        category = FileCategory(value)

        # Then
        assert category == FileCategory.SOURCE

    def test_given_all_categories_when_iterating_then_contains_all_values(self):
        """
        Given all FileCategory values
        When iterating through enum
        Then it contains all expected categories
        """
        # Given
        expected_categories = {
            "source", "test", "config", "docs", 
            "asset", "generated", "build", "unknown"
        }

        # When
        actual_categories = {cat.value for cat in FileCategory}

        # Then
        assert actual_categories == expected_categories


class TestTestRequirement:
    """Behavioral tests for TestRequirement enum."""

    def test_given_test_requirement_when_accessing_required_then_returns_correct_value(self):
        """
        Given a TestRequirement enum
        When accessing REQUIRED
        Then it returns the correct string value
        """
        # Given/When
        requirement = TestRequirement.REQUIRED

        # Then
        assert requirement == "required"
        assert requirement.value == "required"

    def test_given_test_requirement_when_accessing_optional_then_returns_correct_value(self):
        """
        Given a TestRequirement enum
        When accessing OPTIONAL
        Then it returns the correct string value
        """
        # Given/When
        requirement = TestRequirement.OPTIONAL

        # Then
        assert requirement == "optional"
        assert requirement.value == "optional"

    def test_given_test_requirement_when_accessing_not_applicable_then_returns_correct_value(self):
        """
        Given a TestRequirement enum
        When accessing NOT_APPLICABLE
        Then it returns the correct string value
        """
        # Given/When
        requirement = TestRequirement.NOT_APPLICABLE

        # Then
        assert requirement == "not_applicable"
        assert requirement.value == "not_applicable"

    def test_given_test_requirement_when_accessing_excluded_then_returns_correct_value(self):
        """
        Given a TestRequirement enum
        When accessing EXCLUDED
        Then it returns the correct string value
        """
        # Given/When
        requirement = TestRequirement.EXCLUDED

        # Then
        assert requirement == "excluded"
        assert requirement.value == "excluded"

    def test_given_string_value_when_creating_requirement_then_creates_correct_enum(self):
        """
        Given a string value
        When creating a TestRequirement from string
        Then it creates the correct enum instance
        """
        # Given
        value = "required"

        # When
        requirement = TestRequirement(value)

        # Then
        assert requirement == TestRequirement.REQUIRED

    def test_given_all_requirements_when_iterating_then_contains_all_values(self):
        """
        Given all TestRequirement values
        When iterating through enum
        Then it contains all expected requirements
        """
        # Given
        expected_requirements = {
            "required", "optional", "not_applicable", "excluded"
        }

        # When
        actual_requirements = {req.value for req in TestRequirement}

        # Then
        assert actual_requirements == expected_requirements


class TestFileRecord:
    """Behavioral tests for FileRecord dataclass."""

    @pytest.fixture
    def minimal_file_record(self) -> FileRecord:
        """Create a minimal FileRecord with required fields only."""
        return FileRecord(
            path="src/example.py",
            name="example.py"
        )

    @pytest.fixture
    def complete_file_record(self) -> FileRecord:
        """Create a complete FileRecord with all fields populated."""
        now = datetime.now()
        return FileRecord(
            path="src/module/feature.py",
            name="feature.py",
            category=FileCategory.SOURCE,
            language="python",
            test_requirement=TestRequirement.REQUIRED,
            test_file_path="tests/test_feature.py",
            tests_exist=True,
            test_count=15,
            coverage_percent=85.5,
            last_modified=now,
            tests_last_modified=now - timedelta(days=1),
            last_indexed=now,
            staleness_days=1,
            is_stale=True,
            lines_of_code=250,
            lines_of_test=350,
            complexity_score=12.5,
            has_docstrings=True,
            has_type_hints=True,
            lint_issues=2,
            imports=["os", "sys", "typing"],
            imported_by=["src/other.py", "src/another.py"],
            import_count=3,
            imported_by_count=2,
            impact_score=75.0,
            metadata={"custom_key": "custom_value"},
            needs_attention=True,
            attention_reasons=["Low coverage", "High complexity"]
        )

    def test_given_minimal_inputs_when_creating_file_record_then_uses_defaults(
        self, minimal_file_record: FileRecord
    ):
        """
        Given minimal required inputs
        When creating a FileRecord
        Then it uses appropriate default values
        """
        # Given/When (from fixture)
        record = minimal_file_record

        # Then
        assert record.path == "src/example.py"
        assert record.name == "example.py"
        assert record.category == FileCategory.UNKNOWN
        assert record.language == ""
        assert record.test_requirement == TestRequirement.REQUIRED
        assert record.test_file_path is None
        assert record.tests_exist is False
        assert record.test_count == 0
        assert record.coverage_percent == 0.0
        assert record.last_modified is None
        assert record.tests_last_modified is None
        assert record.last_indexed is None
        assert record.staleness_days == 0
        assert record.is_stale is False
        assert record.lines_of_code == 0
        assert record.lines_of_test == 0
        assert record.complexity_score == 0.0
        assert record.has_docstrings is False
        assert record.has_type_hints is False
        assert record.lint_issues == 0
        assert record.imports == []
        assert record.imported_by == []
        assert record.import_count == 0
        assert record.imported_by_count == 0
        assert record.impact_score == 0.0
        assert record.metadata == {}
        assert record.needs_attention is False
        assert record.attention_reasons == []

    def test_given_complete_inputs_when_creating_file_record_then_stores_all_values(
        self, complete_file_record: FileRecord
    ):
        """
        Given complete inputs with all fields
        When creating a FileRecord
        Then it stores all provided values correctly
        """
        # Given/When (from fixture)
        record = complete_file_record

        # Then
        assert record.path == "src/module/feature.py"
        assert record.name == "feature.py"
        assert record.category == FileCategory.SOURCE
        assert record.language == "python"
        assert record.test_requirement == TestRequirement.REQUIRED
        assert record.test_file_path == "tests/test_feature.py"
        assert record.tests_exist is True
        assert record.test_count == 15
        assert record.coverage_percent == 85.5
        assert record.staleness_days == 1
        assert record.is_stale is True
        assert record.lines_of_code == 250
        assert record.lines_of_test == 350
        assert record.complexity_score == 12.5
        assert record.has_docstrings is True
        assert record.has_type_hints is True
        assert record.lint_issues == 2
        assert record.imports == ["os", "sys", "typing"]
        assert record.imported_by == ["src/other.py", "src/another.py"]
        assert record.import_count == 3
        assert record.imported_by_count == 2
        assert record.impact_score == 75.0
        assert record.metadata == {"custom_key": "custom_value"}
        assert record.needs_attention is True
        assert record.attention_reasons == ["Low coverage", "High complexity"]

    def test_given_file_record_when_converting_to_dict_then_returns_serializable_dict(
        self, complete_file_record: FileRecord
    ):
        """
        Given a FileRecord with complete data
        When converting to dictionary
        Then it returns a properly formatted dictionary with all fields
        """
        # Given
        record = complete_file_record

        # When
        result = record.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["path"] == "src/module/feature.py"
        assert result["name"] == "feature.py"
        assert result["category"] == "source"
        assert result["language"] == "python"
        assert result["test_requirement"] == "required"
        assert result["test_file_path"] == "tests/test_feature.py"
        assert result["tests_exist"] is True
        assert result["test_count"] == 15
        assert result["coverage_percent"] == 85.5

    def test_given_minimal_record_when_converting_to_dict_then_handles_none_values(
        self, minimal_file_record: FileRecord
    ):
        """
        Given a minimal FileRecord with None values
        When converting to dictionary
        Then it properly handles None and default values
        """
        # Given
        record = minimal_file_record

        # When
        result = record.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["path"] == "src/example.py"
        assert result["name"] == "example.py"
        assert result["category"] == "unknown"
        assert result["test_requirement"] == "required"
        assert result["test_file_path"] is None
        assert result["tests_exist"] is False
        assert result["test_count"] == 0

    def test_given_enum_fields_when_converting_to_dict_then_converts_to_string_values(self):
        """
        Given a FileRecord with enum fields
        When converting to dictionary
        Then enum values are converted to their string representations
        """
        # Given
        record = FileRecord(
            path="test.py",
            name="test.py",
            category=FileCategory.TEST,
            test_requirement=TestRequirement.OPTIONAL
        )

        # When
        result = record.to_dict()

        # Then
        assert result["category"] == "test"
        assert result["test_requirement"] == "optional"
        assert isinstance(result["category"], str)
        assert isinstance(result["test_requirement"], str)

    def test_given_datetime_fields_when_converting_to_dict_then_preserves_datetime_objects(self):
        """
        Given a FileRecord with datetime fields
        When converting to dictionary
        Then datetime objects are preserved in the dictionary
        """
        # Given
        now = datetime.now()
        record = FileRecord(
            path="test.py",
            name="test.py",
            last_modified=now,
            last_indexed=now
        )

        # When
        result = record.to_dict()

        # Then
        assert isinstance(result["last_modified"], datetime)
        assert isinstance(result["last_indexed"], datetime)
        assert result["last_modified"] == now
        assert result["last_indexed"] == now

    def test_given_list_fields_when_converting_to_dict_then_preserves_lists(self):
        """
        Given a FileRecord with list fields
        When converting to dictionary
        Then lists are preserved correctly
        """
        # Given
        imports = ["module1", "module2", "module3"]
        imported_by = ["file1.py", "file2.py"]
        attention_reasons = ["reason1", "reason2"]
        
        record = FileRecord(
            path="test.py",
            name="test.py",
            imports=imports,
            imported_by=imported_by,
            attention_reasons=attention_reasons
        )

        # When
        result = record.to_dict()

        # Then
        assert result["imports"] == imports
        assert result["imported_by"] == imported_by
        assert result["attention_reasons"] == attention_reasons

    def test_given_metadata_field_when_converting_to_dict_then_preserves_nested_dict(self):