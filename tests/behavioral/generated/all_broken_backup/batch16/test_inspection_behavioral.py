"""Behavioral tests for inspection.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import subprocess
from pathlib import Path
from unittest.mock import MagicMock, Mock, call, patch

import pytest

from empathy_os.cli.commands.inspection import inspect_cmd, scan


class TestScanFunction:
    """Behavioral tests for the scan function."""

    @pytest.fixture
    def mock_console(self):
        """Fixture to mock the console object."""
        with patch("empathy_os.cli.commands.inspection.console") as mock:
            yield mock

    @pytest.fixture
    def mock_subprocess(self):
        """Fixture to mock subprocess.run."""
        with patch("empathy_os.cli.commands.inspection.subprocess.run") as mock:
            mock.return_value = Mock(returncode=0, stdout=b"", stderr=b"")
            yield mock

    def test_scan_with_default_parameters(self, mock_console, mock_subprocess):
        """
        Given: Default parameters for scan function
        When: scan() is called without arguments
        Then: Should run ruff and bandit with default settings
        """
        # When
        scan()

        # Then
        assert mock_console.print.call_count >= 4
        mock_console.print.assert_any_call(
            "[bold blue]Scanning .[/bold blue]\n"
        )
        mock_console.print.assert_any_call("[bold]Running ruff (linting)...[/bold]")
        mock_console.print.assert_any_call(
            "\n[bold]Running bandit (security)...[/bold]"
        )
        mock_console.print.assert_any_call("\n[bold green]Scan complete![/bold green]")

        assert mock_subprocess.call_count == 2
        mock_subprocess.assert_any_call(
            ["ruff", "check", "."], check=False
        )
        mock_subprocess.assert_any_call(
            ["bandit", "-r", ".", "-q"],
            check=False,
            capture_output=True,
        )

    def test_scan_with_custom_path(self, mock_console, mock_subprocess):
        """
        Given: A custom path to scan
        When: scan() is called with a specific path
        Then: Should run tools on the specified path
        """
        # Given
        custom_path = Path("/custom/path")

        # When
        scan(path=custom_path)

        # Then
        mock_console.print.assert_any_call(
            "[bold blue]Scanning /custom/path...[/bold blue]\n"
        )
        mock_subprocess.assert_any_call(
            ["ruff", "check", "/custom/path"], check=False
        )
        mock_subprocess.assert_any_call(
            ["bandit", "-r", "/custom/path", "-q"],
            check=False,
            capture_output=True,
        )

    def test_scan_with_fix_enabled(self, mock_console, mock_subprocess):
        """
        Given: fix parameter is set to True
        When: scan() is called with fix=True
        Then: Should add --fix flag to ruff command
        """
        # When
        scan(fix=True)

        # Then
        mock_subprocess.assert_any_call(
            ["ruff", "check", ".", "--fix"], check=False
        )

    def test_scan_with_json_format(self, mock_console, mock_subprocess):
        """
        Given: format_out parameter is set to 'json'
        When: scan() is called with format_out='json'
        Then: Should add json format flag to bandit command
        """
        # When
        scan(format_out="json")

        # Then
        mock_subprocess.assert_any_call(
            ["bandit", "-r", ".", "-q", "-f", "json"],
            check=False,
            capture_output=True,
        )

    def test_scan_with_text_format(self, mock_console, mock_subprocess):
        """
        Given: format_out parameter is set to 'text'
        When: scan() is called with format_out='text'
        Then: Should not add format flag to bandit command
        """
        # When
        scan(format_out="text")

        # Then
        mock_subprocess.assert_any_call(
            ["bandit", "-r", ".", "-q"],
            check=False,
            capture_output=True,
        )

    def test_scan_bandit_finds_no_issues(self, mock_console, mock_subprocess):
        """
        Given: Bandit scan returns no issues (returncode=0)
        When: scan() is called
        Then: Should display success message for security scan
        """
        # Given
        mock_subprocess.return_value = Mock(returncode=0, stdout=b"", stderr=b"")

        # When
        scan()

        # Then
        mock_console.print.assert_any_call(
            "[green]No security issues found[/green]"
        )

    def test_scan_bandit_finds_issues(self, mock_console, mock_subprocess):
        """
        Given: Bandit scan returns issues (returncode!=0) with output
        When: scan() is called
        Then: Should display bandit output
        """
        # Given
        bandit_output = b"[HIGH] SQL injection detected\n"
        mock_result = Mock(returncode=1, stdout=bandit_output, stderr=b"")
        
        def subprocess_side_effect(args, **kwargs):
            if "bandit" in args:
                return mock_result
            return Mock(returncode=0, stdout=b"", stderr=b"")
        
        mock_subprocess.side_effect = subprocess_side_effect

        # When
        scan()

        # Then
        mock_console.print.assert_any_call("[HIGH] SQL injection detected\n")

    def test_scan_bandit_no_output(self, mock_console, mock_subprocess):
        """
        Given: Bandit scan returns non-zero code but no stdout
        When: scan() is called
        Then: Should not print empty output
        """
        # Given
        mock_result = Mock(returncode=1, stdout=b"", stderr=b"")
        
        def subprocess_side_effect(args, **kwargs):
            if "bandit" in args:
                return mock_result
            return Mock(returncode=0, stdout=b"", stderr=b"")
        
        mock_subprocess.side_effect = subprocess_side_effect

        # When
        scan()

        # Then
        # Should not print empty string for bandit output
        calls = [str(call) for call in mock_console.print.call_args_list]
        assert not any("call('')" in c for c in calls if "bandit" in str(mock_console.print.call_args_list))

    def test_scan_with_all_parameters(self, mock_console, mock_subprocess):
        """
        Given: All parameters are provided
        When: scan() is called with path, format_out, fix, and staged
        Then: Should execute with all specified options
        """
        # Given
        path = Path("/test/path")

        # When
        scan(path=path, format_out="json", fix=True, staged=True)

        # Then
        mock_subprocess.assert_any_call(
            ["ruff", "check", "/test/path", "--fix"], check=False
        )
        mock_subprocess.assert_any_call(
            ["bandit", "-r", "/test/path", "-q", "-f", "json"],
            check=False,
            capture_output=True,
        )

    def test_scan_subprocess_with_check_false(self, mock_console, mock_subprocess):
        """
        Given: External tools may fail
        When: scan() is called
        Then: Should call subprocess with check=False to not raise on errors
        """
        # Given
        mock_subprocess.return_value = Mock(returncode=1, stdout=b"", stderr=b"")

        # When
        scan()

        # Then
        # Verify all subprocess calls have check=False
        for call_args in mock_subprocess.call_args_list:
            assert call_args.kwargs.get("check") is False


class TestInspectCmdFunction:
    """Behavioral tests for the inspect_cmd function."""

    @pytest.fixture
    def mock_console(self):
        """Fixture to mock the console object."""
        with patch("empathy_os.cli.commands.inspection.console") as mock:
            yield mock

    @pytest.fixture
    def mock_subprocess(self):
        """Fixture to mock subprocess.run."""
        with patch("empathy_os.cli.commands.inspection.subprocess.run") as mock:
            mock.return_value = Mock(returncode=0)
            yield mock

    def test_inspect_cmd_with_default_parameters(self, mock_console, mock_subprocess):
        """
        Given: Default parameters for inspect_cmd function
        When: inspect_cmd() is called without arguments
        Then: Should run empathy-inspect with default settings
        """
        # When
        inspect_cmd()

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-inspect", "."],
            check=False,
            capture_output=False,
        )

    def test_inspect_cmd_with_custom_path(self, mock_console, mock_subprocess):
        """
        Given: A custom path to inspect
        When: inspect_cmd() is called with a specific path
        Then: Should run empathy-inspect on the specified path
        """
        # Given
        custom_path = Path("/custom/inspect/path")

        # When
        inspect_cmd(path=custom_path)

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-inspect", "/custom/inspect/path"],
            check=False,
            capture_output=False,
        )

    def test_inspect_cmd_with_json_format(self, mock_console, mock_subprocess):
        """
        Given: format_out parameter is set to 'json'
        When: inspect_cmd() is called with format_out='json'
        Then: Should add format flag to command
        """
        # When
        inspect_cmd(format_out="json")

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-inspect", ".", "--format", "json"],
            check=False,
            capture_output=False,
        )

    def test_inspect_cmd_with_yaml_format(self, mock_console, mock_subprocess):
        """
        Given: format_out parameter is set to 'yaml'
        When: inspect_cmd() is called with format_out='yaml'
        Then: Should add yaml format flag to command
        """
        # When
        inspect_cmd(format_out="yaml")

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-inspect", ".", "--format", "yaml"],
            check=False,
            capture_output=False,
        )

    def test_inspect_cmd_with_text_format(self, mock_console, mock_subprocess):
        """
        Given: format_out parameter is set to 'text' (default)
        When: inspect_cmd() is called with format_out='text'
        Then: Should not add format flag to command
        """
        # When
        inspect_cmd(format_out="text")

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-inspect", "."],
            check=False,
            capture_output=False,
        )

    def test_inspect_cmd_tool_not_installed(self, mock_console, mock_subprocess):
        """
        Given: empathy-inspect tool is not installed
        When: inspect_cmd() is called and subprocess returns non-zero
        Then: Should display installation instructions
        """
        # Given
        mock_subprocess.return_value = Mock(returncode=127)  # Command not found

        # When
        inspect_cmd()

        # Then
        mock_console.print.assert_any_call(
            "[yellow]Note: empathy-inspect may not be installed[/yellow]"
        )
        mock_console.print.assert_any_call(
            "Install with: pip install empathy-framework[software]"
        )

    def test_inspect_cmd_tool_execution_error(self, mock_console, mock_subprocess):
        """
        Given: empathy-inspect tool fails during execution
        When: inspect_cmd() is called and subprocess returns error code
        Then: Should display installation note
        """
        # Given
        mock_subprocess.return_value = Mock(returncode=1)

        # When
        inspect_cmd()

        # Then
        mock_console.print.assert_any_call(
            "[yellow]Note: empathy-inspect may not be installed[/yellow]"
        )

    def test_inspect_cmd_successful_execution(self, mock_console, mock_subprocess):
        """
        Given: empathy-inspect tool executes successfully
        When: inspect_cmd() is called and subprocess returns 0
        Then: Should not display error messages
        """
        # Given
        mock_subprocess.return_value = Mock(returncode=0)

        # When
        inspect_cmd()

        # Then
        # Should not print warning messages
        warning_calls = [
            call for call in mock_console.print.call_args_list
            if "[yellow]" in str(call)
        ]
        assert len(warning_calls) == 0

    def test_inspect_cmd_with_all_parameters(self, mock_console, mock_subprocess):
        """
        Given: All parameters are provided
        When: inspect_cmd() is called with path and format_out
        Then: Should execute with all specified options
        """
        # Given
        path = Path("/full/test/path")

        # When
        inspect_cmd(path=path, format_out="json")

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-inspect", "/full/test/path", "--format", "json"],
            check=False,
            capture_output=False,
        )

    def test_inspect_cmd_subprocess_no_capture(self, mock_console, mock_subprocess):
        """
        Given: inspect_cmd needs to display output directly
        When: inspect_cmd() is called
        Then: Should call subprocess with capture_output=False
        """
        # When
        inspect_cmd()

        # Then
        call_args = mock_subprocess.call_args
        assert call_args.kwargs.get("capture_output") is False

    def test_inspect_cmd_subprocess_with_check_false(self, mock_console, mock_subprocess):
        """
        Given: External tool may not be installed
        When: inspect_cmd() is called
        Then: Should call subprocess with check=False to handle errors gracefully
        """
        # When
        inspect_cmd()

        # Then
        call_args = mock_subprocess.call_args
        assert call_args.kwargs.get("check") is False


class TestEdgeCases:
    """Edge case tests for inspection module."""

    @pytest.fixture
    def mock_console(self):
        """Fixture to mock the console object."""
        with patch("empathy_os.cli.commands.inspection.console") as mock:
            yield mock

    @pytest.fixture
    def mock_subprocess(self):
        """Fixture to mock subprocess.run."""
        with patch("empathy_os.cli.commands.inspection.subprocess.run") as mock:
            mock.return_value = Mock(returncode=0, stdout=b"", stderr=b"")
            yield mock

    def test_scan_with_relative_path(self, mock_console, mock_subprocess):
        """
        Given: A relative path with dots
        When: scan() is called with relative path
        Then: Should handle path correctly
        """
        # Given
        relative_path = Path("../relative/path")

        # When
        scan(path=relative_path)

        # Then