"""Behavioral tests for registry.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from dataclasses import FrozenInstanceError
from empathy_os.models.registry import (
    ModelTier,
    ModelProvider,
    ModelInfo,
)


class TestModelTier:
    """Test suite for ModelTier enum."""

    def test_model_tier_has_all_expected_values(self):
        """
        Given the ModelTier enum
        When checking available tier values
        Then all expected tiers should be present
        """
        # Given/When
        tiers = [tier.value for tier in ModelTier]

        # Then
        assert "cheap" in tiers
        assert "capable" in tiers
        assert "premium" in tiers
        assert len(tiers) == 3

    def test_model_tier_cheap_value(self):
        """
        Given the ModelTier enum
        When accessing the CHEAP tier
        Then it should have the correct string value
        """
        # Given/When
        tier = ModelTier.CHEAP

        # Then
        assert tier.value == "cheap"

    def test_model_tier_capable_value(self):
        """
        Given the ModelTier enum
        When accessing the CAPABLE tier
        Then it should have the correct string value
        """
        # Given/When
        tier = ModelTier.CAPABLE

        # Then
        assert tier.value == "capable"

    def test_model_tier_premium_value(self):
        """
        Given the ModelTier enum
        When accessing the PREMIUM tier
        Then it should have the correct string value
        """
        # Given/When
        tier = ModelTier.PREMIUM

        # Then
        assert tier.value == "premium"

    def test_model_tier_comparison(self):
        """
        Given two ModelTier instances
        When comparing them
        Then identical tiers should be equal
        """
        # Given
        tier1 = ModelTier.CHEAP
        tier2 = ModelTier.CHEAP
        tier3 = ModelTier.PREMIUM

        # Then
        assert tier1 == tier2
        assert tier1 != tier3


class TestModelProvider:
    """Test suite for ModelProvider enum."""

    def test_model_provider_has_anthropic(self):
        """
        Given the ModelProvider enum
        When checking available providers
        Then ANTHROPIC should be present
        """
        # Given/When
        providers = [provider.value for provider in ModelProvider]

        # Then
        assert "anthropic" in providers

    def test_model_provider_anthropic_value(self):
        """
        Given the ModelProvider enum
        When accessing the ANTHROPIC provider
        Then it should have the correct string value
        """
        # Given/When
        provider = ModelProvider.ANTHROPIC

        # Then
        assert provider.value == "anthropic"

    def test_model_provider_comparison(self):
        """
        Given two ModelProvider instances
        When comparing them
        Then identical providers should be equal
        """
        # Given
        provider1 = ModelProvider.ANTHROPIC
        provider2 = ModelProvider.ANTHROPIC

        # Then
        assert provider1 == provider2


class TestModelInfo:
    """Test suite for ModelInfo dataclass."""

    @pytest.fixture
    def basic_model_info(self):
        """Fixture providing a basic ModelInfo instance."""
        return ModelInfo(
            id="test-model-001",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )

    @pytest.fixture
    def full_model_info(self):
        """Fixture providing a fully configured ModelInfo instance."""
        return ModelInfo(
            id="claude-3-5-haiku-20241022",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=5.0,
            max_tokens=8192,
            supports_vision=True,
            supports_tools=True,
        )

    def test_create_model_info_with_required_fields(self):
        """
        Given required ModelInfo fields
        When creating a ModelInfo instance
        Then it should be created successfully with defaults
        """
        # When
        model = ModelInfo(
            id="test-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )

        # Then
        assert model.id == "test-model"
        assert model.provider == "anthropic"
        assert model.tier == "cheap"
        assert model.input_cost_per_million == 1.0
        assert model.output_cost_per_million == 2.0
        assert model.max_tokens == 4096  # default
        assert model.supports_vision is False  # default
        assert model.supports_tools is True  # default

    def test_create_model_info_with_all_fields(self, full_model_info):
        """
        Given all ModelInfo fields
        When creating a ModelInfo instance
        Then all fields should be set correctly
        """
        # Given/When (fixture)
        model = full_model_info

        # Then
        assert model.id == "claude-3-5-haiku-20241022"
        assert model.provider == "anthropic"
        assert model.tier == "cheap"
        assert model.input_cost_per_million == 1.0
        assert model.output_cost_per_million == 5.0
        assert model.max_tokens == 8192
        assert model.supports_vision is True
        assert model.supports_tools is True

    def test_model_info_is_frozen(self, basic_model_info):
        """
        Given a ModelInfo instance
        When attempting to modify a field
        Then it should raise FrozenInstanceError
        """
        # Given
        model = basic_model_info

        # When/Then
        with pytest.raises(FrozenInstanceError):
            model.id = "new-id"

    def test_model_id_property_returns_id(self, basic_model_info):
        """
        Given a ModelInfo instance
        When accessing the model_id property
        Then it should return the id field value
        """
        # Given
        model = basic_model_info

        # When
        model_id = model.model_id

        # Then
        assert model_id == model.id
        assert model_id == "test-model-001"

    def test_name_property_returns_id(self, basic_model_info):
        """
        Given a ModelInfo instance
        When accessing the name property
        Then it should return the id field value
        """
        # Given
        model = basic_model_info

        # When
        name = model.name

        # Then
        assert name == model.id
        assert name == "test-model-001"

    def test_cost_per_1k_input_calculation(self, basic_model_info):
        """
        Given a ModelInfo with input_cost_per_million = 1.0
        When accessing cost_per_1k_input property
        Then it should return 0.001 (1.0 / 1000)
        """
        # Given
        model = basic_model_info
        assert model.input_cost_per_million == 1.0

        # When
        cost_per_1k = model.cost_per_1k_input

        # Then
        assert cost_per_1k == 0.001

    def test_cost_per_1k_output_calculation(self, basic_model_info):
        """
        Given a ModelInfo with output_cost_per_million = 2.0
        When accessing cost_per_1k_output property
        Then it should return 0.002 (2.0 / 1000)
        """
        # Given
        model = basic_model_info
        assert model.output_cost_per_million == 2.0

        # When
        cost_per_1k = model.cost_per_1k_output

        # Then
        assert cost_per_1k == 0.002

    def test_cost_per_1k_input_with_large_value(self):
        """
        Given a ModelInfo with large input_cost_per_million
        When accessing cost_per_1k_input property
        Then it should calculate correctly
        """
        # Given
        model = ModelInfo(
            id="premium-model",
            provider="anthropic",
            tier="premium",
            input_cost_per_million=15000.0,
            output_cost_per_million=75000.0,
        )

        # When
        cost_per_1k = model.cost_per_1k_input

        # Then
        assert cost_per_1k == 15.0

    def test_cost_per_1k_output_with_large_value(self):
        """
        Given a ModelInfo with large output_cost_per_million
        When accessing cost_per_1k_output property
        Then it should calculate correctly
        """
        # Given
        model = ModelInfo(
            id="premium-model",
            provider="anthropic",
            tier="premium",
            input_cost_per_million=15000.0,
            output_cost_per_million=75000.0,
        )

        # When
        cost_per_1k = model.cost_per_1k_output

        # Then
        assert cost_per_1k == 75.0

    def test_cost_per_1k_input_with_zero(self):
        """
        Given a ModelInfo with zero input_cost_per_million
        When accessing cost_per_1k_input property
        Then it should return 0.0
        """
        # Given
        model = ModelInfo(
            id="free-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=0.0,
            output_cost_per_million=0.0,
        )

        # When
        cost_per_1k = model.cost_per_1k_input

        # Then
        assert cost_per_1k == 0.0

    def test_cost_per_1k_output_with_fractional_value(self):
        """
        Given a ModelInfo with fractional output_cost_per_million
        When accessing cost_per_1k_output property
        Then it should calculate with proper precision
        """
        # Given
        model = ModelInfo(
            id="fractional-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=0.5,
            output_cost_per_million=1.5,
        )

        # When
        cost_per_1k = model.cost_per_1k_output

        # Then
        assert cost_per_1k == pytest.approx(0.0015)

    def test_to_router_config_returns_dict(self, basic_model_info):
        """
        Given a ModelInfo instance
        When calling to_router_config
        Then it should return a dictionary
        """
        # Given
        model = basic_model_info

        # When
        config = model.to_router_config()

        # Then
        assert isinstance(config, dict)

    def test_to_router_config_contains_model_id(self, basic_model_info):
        """
        Given a ModelInfo instance
        When calling to_router_config
        Then the dict should contain model_id key
        """
        # Given
        model = basic_model_info

        # When
        config = model.to_router_config()

        # Then
        assert "model_id" in config
        assert config["model_id"] == "test-model-001"

    def test_to_router_config_contains_cost_per_1k_input(self, basic_model_info):
        """
        Given a ModelInfo instance
        When calling to_router_config
        Then the dict should contain cost_per_1k_input key
        """
        # Given
        model = basic_model_info

        # When
        config = model.to_router_config()

        # Then
        assert "cost_per_1k_input" in config
        assert config["cost_per_1k_input"] == 0.001

    def test_to_router_config_contains_cost_per_1k_output(self, basic_model_info):
        """
        Given a ModelInfo instance
        When calling to_router_config
        Then the dict should contain cost_per_1k_output key
        """
        # Given
        model = basic_model_info

        # When
        config = model.to_router_config()

        # Then
        assert "cost_per_1k_output" in config
        assert config["cost_per_1k_output"] == 0.002

    def test_to_router_config_with_full_model(self, full_model_info):
        """
        Given a fully configured ModelInfo instance
        When calling to_router_config
        Then all expected fields should be present with correct values
        """
        # Given
        model = full_model_info

        # When
        config = model.to_router_config()

        # Then
        assert config["model_id"] == "claude-3-5-haiku-20241022"
        assert config["cost_per_1k_input"] == 0.001
        assert config["cost_per_1k_output"] == 0.005

    def test_model_info_equality(self):
        """
        Given two ModelInfo instances with identical values
        When comparing them
        Then they should be equal
        """
        # Given
        model1 = ModelInfo(
            id="test-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )
        model2 = ModelInfo(
            id="test-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )

        # When/Then
        assert model1 == model2

    def test_model_info_inequality_different_id(self):
        """
        Given two ModelInfo instances with different ids
        When comparing them
        Then they should not be equal
        """
        # Given
        model1 = ModelInfo(
            id="test-model-1",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )
        model2 = ModelInfo(
            id="test-model-2",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )

        # When/Then
        assert model1 != model2

    def test_model_info_inequality_different_costs(self):
        """
        Given two ModelInfo instances with different costs
        When comparing them
        Then they should not be equal
        """
        # Given
        model1 = ModelInfo(
            id="test-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.0,
            output_cost_per_million=2.0,
        )
        model2 = ModelInfo(
            id="test-model",
            provider="anthropic",
            tier="cheap",
            input_cost_per_million=1.5,
            output_cost_per_million=2.0,
        )

        # When/Then
        assert model1 != model2

    def test_model_info_hashable(self, basic_model_info):
        """
        Given a ModelInfo instance (frozen dataclass)
        When using it in a set or as dict key
        Then it should be hashable
        """
        # Given