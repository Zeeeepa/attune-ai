"""Behavioral tests for websocket.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from empathy_os.hot_reload.websocket import ReloadNotificationManager


@pytest.fixture
def notification_manager():
    """Provide a fresh ReloadNotificationManager instance for each test.
    
    Given a new notification manager is needed
    When the fixture is requested
    Then return a clean ReloadNotificationManager instance
    """
    return ReloadNotificationManager()


@pytest.fixture
def mock_websocket():
    """Provide a mock WebSocket for testing.
    
    Given a WebSocket connection is needed for testing
    When the fixture is requested
    Then return a properly configured mock WebSocket
    """
    websocket = AsyncMock()
    websocket.accept = AsyncMock()
    websocket.send_json = AsyncMock()
    return websocket


@pytest.fixture
def multiple_mock_websockets():
    """Provide multiple mock WebSockets for testing broadcasts.
    
    Given multiple WebSocket connections are needed
    When the fixture is requested
    Then return a list of mock WebSocket instances
    """
    websockets = []
    for _ in range(3):
        ws = AsyncMock()
        ws.accept = AsyncMock()
        ws.send_json = AsyncMock()
        websockets.append(ws)
    return websockets


class TestReloadNotificationManagerInit:
    """Tests for ReloadNotificationManager initialization."""

    def test_initialization_creates_empty_connections_list(self):
        """Test that manager initializes with empty connections.
        
        Given a new ReloadNotificationManager is created
        When the instance is initialized
        Then it should have an empty connections list
        """
        manager = ReloadNotificationManager()
        
        assert manager._connections == []
        assert isinstance(manager._connections, list)

    def test_initialization_creates_asyncio_lock(self):
        """Test that manager initializes with an asyncio lock.
        
        Given a new ReloadNotificationManager is created
        When the instance is initialized
        Then it should have an asyncio.Lock instance
        """
        manager = ReloadNotificationManager()
        
        assert isinstance(manager._lock, asyncio.Lock)


class TestReloadNotificationManagerConnect:
    """Tests for WebSocket connection registration."""

    @pytest.mark.asyncio
    async def test_connect_accepts_websocket(self, notification_manager, mock_websocket):
        """Test that connect accepts the WebSocket connection.
        
        Given a notification manager with no connections
        When a WebSocket attempts to connect
        Then the WebSocket should be accepted
        """
        await notification_manager.connect(mock_websocket)
        
        mock_websocket.accept.assert_called_once()

    @pytest.mark.asyncio
    async def test_connect_adds_websocket_to_connections(
        self, notification_manager, mock_websocket
    ):
        """Test that connect adds WebSocket to connections list.
        
        Given a notification manager with no connections
        When a WebSocket connects
        Then the WebSocket should be added to the connections list
        """
        await notification_manager.connect(mock_websocket)
        
        assert mock_websocket in notification_manager._connections
        assert len(notification_manager._connections) == 1

    @pytest.mark.asyncio
    async def test_connect_sends_welcome_message(
        self, notification_manager, mock_websocket
    ):
        """Test that connect sends a welcome message to the client.
        
        Given a notification manager
        When a WebSocket connects
        Then a welcome message should be sent to the client
        """
        await notification_manager.connect(mock_websocket)
        
        mock_websocket.send_json.assert_called_once()
        call_args = mock_websocket.send_json.call_args[0][0]
        assert call_args["event"] == "connected"
        assert call_args["message"] == "Hot-reload notifications enabled"
        assert call_args["active_connections"] == 1

    @pytest.mark.asyncio
    async def test_connect_multiple_websockets(
        self, notification_manager, multiple_mock_websockets
    ):
        """Test connecting multiple WebSockets.
        
        Given a notification manager
        When multiple WebSockets connect
        Then all should be added to connections and receive welcome messages
        """
        for ws in multiple_mock_websockets:
            await notification_manager.connect(ws)
        
        assert len(notification_manager._connections) == 3
        for i, ws in enumerate(multiple_mock_websockets):
            ws.accept.assert_called_once()
            ws.send_json.assert_called_once()
            call_args = ws.send_json.call_args[0][0]
            assert call_args["active_connections"] == i + 1

    @pytest.mark.asyncio
    async def test_connect_thread_safety(self, notification_manager):
        """Test that connect is thread-safe with concurrent connections.
        
        Given a notification manager
        When multiple WebSockets connect concurrently
        Then all connections should be properly registered
        """
        websockets = [AsyncMock() for _ in range(10)]
        for ws in websockets:
            ws.accept = AsyncMock()
            ws.send_json = AsyncMock()
        
        tasks = [notification_manager.connect(ws) for ws in websockets]
        await asyncio.gather(*tasks)
        
        assert len(notification_manager._connections) == 10
        for ws in websockets:
            assert ws in notification_manager._connections


class TestReloadNotificationManagerDisconnect:
    """Tests for WebSocket disconnection."""

    @pytest.mark.asyncio
    async def test_disconnect_removes_websocket(
        self, notification_manager, mock_websocket
    ):
        """Test that disconnect removes WebSocket from connections.
        
        Given a notification manager with a connected WebSocket
        When the WebSocket disconnects
        Then it should be removed from the connections list
        """
        await notification_manager.connect(mock_websocket)
        assert len(notification_manager._connections) == 1
        
        await notification_manager.disconnect(mock_websocket)
        
        assert mock_websocket not in notification_manager._connections
        assert len(notification_manager._connections) == 0

    @pytest.mark.asyncio
    async def test_disconnect_nonexistent_websocket(
        self, notification_manager, mock_websocket
    ):
        """Test disconnecting a WebSocket that isn't connected.
        
        Given a notification manager with no connections
        When disconnect is called with a WebSocket
        Then it should complete without error
        """
        await notification_manager.disconnect(mock_websocket)
        
        assert len(notification_manager._connections) == 0

    @pytest.mark.asyncio
    async def test_disconnect_one_of_multiple_websockets(
        self, notification_manager, multiple_mock_websockets
    ):
        """Test disconnecting one WebSocket when multiple are connected.
        
        Given a notification manager with multiple connected WebSockets
        When one WebSocket disconnects
        Then only that WebSocket should be removed
        """
        for ws in multiple_mock_websockets:
            await notification_manager.connect(ws)
        
        await notification_manager.disconnect(multiple_mock_websockets[1])
        
        assert len(notification_manager._connections) == 2
        assert multiple_mock_websockets[1] not in notification_manager._connections
        assert multiple_mock_websockets[0] in notification_manager._connections
        assert multiple_mock_websockets[2] in notification_manager._connections

    @pytest.mark.asyncio
    async def test_disconnect_thread_safety(self, notification_manager):
        """Test that disconnect is thread-safe with concurrent disconnections.
        
        Given a notification manager with multiple connected WebSockets
        When multiple WebSockets disconnect concurrently
        Then all should be properly removed
        """
        websockets = [AsyncMock() for _ in range(10)]
        for ws in websockets:
            ws.accept = AsyncMock()
            ws.send_json = AsyncMock()
            await notification_manager.connect(ws)
        
        tasks = [notification_manager.disconnect(ws) for ws in websockets[:5]]
        await asyncio.gather(*tasks)
        
        assert len(notification_manager._connections) == 5
        for ws in websockets[:5]:
            assert ws not in notification_manager._connections
        for ws in websockets[5:]:
            assert ws in notification_manager._connections


class TestReloadNotificationManagerBroadcast:
    """Tests for broadcasting messages to all connections."""

    @pytest.mark.asyncio
    async def test_broadcast_to_single_connection(
        self, notification_manager, mock_websocket
    ):
        """Test broadcasting a message to a single connection.
        
        Given a notification manager with one connected WebSocket
        When a message is broadcast
        Then the WebSocket should receive the message
        """
        await notification_manager.connect(mock_websocket)
        mock_websocket.send_json.reset_mock()
        
        message = {"event": "reload", "data": "test"}
        await notification_manager.broadcast(message)
        
        assert mock_websocket.send_json.call_count == 1
        mock_websocket.send_json.assert_called_with(message)

    @pytest.mark.asyncio
    async def test_broadcast_to_multiple_connections(
        self, notification_manager, multiple_mock_websockets
    ):
        """Test broadcasting a message to multiple connections.
        
        Given a notification manager with multiple connected WebSockets
        When a message is broadcast
        Then all WebSockets should receive the message
        """
        for ws in multiple_mock_websockets:
            await notification_manager.connect(ws)
            ws.send_json.reset_mock()
        
        message = {"event": "reload", "data": "test"}
        await notification_manager.broadcast(message)
        
        for ws in multiple_mock_websockets:
            assert ws.send_json.call_count == 1
            ws.send_json.assert_called_with(message)

    @pytest.mark.asyncio
    async def test_broadcast_with_no_connections(self, notification_manager):
        """Test broadcasting when no connections exist.
        
        Given a notification manager with no connections
        When a message is broadcast
        Then the operation should complete without error
        """
        message = {"event": "reload", "data": "test"}
        
        await notification_manager.broadcast(message)
        
        assert len(notification_manager._connections) == 0

    @pytest.mark.asyncio
    async def test_broadcast_removes_failed_connections(
        self, notification_manager, multiple_mock_websockets
    ):
        """Test that broadcast removes connections that fail.
        
        Given a notification manager with multiple connected WebSockets
        When one WebSocket fails during broadcast
        Then the failed WebSocket should be removed from connections
        """
        for ws in multiple_mock_websockets:
            await notification_manager.connect(ws)
            ws.send_json.reset_mock()
        
        # Make the second WebSocket fail
        multiple_mock_websockets[1].send_json.side_effect = Exception("Connection error")
        
        message = {"event": "reload", "data": "test"}
        await notification_manager.broadcast(message)
        
        assert len(notification_manager._connections) == 2
        assert multiple_mock_websockets[1] not in notification_manager._connections
        assert multiple_mock_websockets[0] in notification_manager._connections
        assert multiple_mock_websockets[2] in notification_manager._connections

    @pytest.mark.asyncio
    async def test_broadcast_handles_multiple_failures(
        self, notification_manager, multiple_mock_websockets
    ):
        """Test that broadcast handles multiple connection failures.
        
        Given a notification manager with multiple connected WebSockets
        When multiple WebSockets fail during broadcast
        Then all failed WebSockets should be removed
        """
        for ws in multiple_mock_websockets:
            await notification_manager.connect(ws)
            ws.send_json.reset_mock()
        
        # Make first and last WebSocket fail
        multiple_mock_websockets[0].send_json.side_effect = Exception("Error 1")
        multiple_mock_websockets[2].send_json.side_effect = Exception("Error 2")
        
        message = {"event": "reload", "data": "test"}
        await notification_manager.broadcast(message)
        
        assert len(notification_manager._connections) == 1
        assert multiple_mock_websockets[1] in notification_manager._connections
        assert multiple_mock_websockets[0] not in notification_manager._connections
        assert multiple_mock_websockets[2] not in notification_manager._connections

    @pytest.mark.asyncio
    async def test_broadcast_with_complex_message(
        self, notification_manager, mock_websocket
    ):
        """Test broadcasting a complex message structure.
        
        Given a notification manager with a connected WebSocket
        When a complex message is broadcast
        Then the WebSocket should receive the complete message
        """
        await notification_manager.connect(mock_websocket)
        mock_websocket.send_json.reset_mock()
        
        message = {
            "event": "workflow_reloaded",
            "workflow_id": "test_workflow",
            "timestamp": 1234567890,
            "changes": ["file1.py", "file2.py"],
            "metadata": {"version": "1.0", "status": "success"},
        }
        await notification_manager.broadcast(message)
        
        mock_websocket.send_json.assert_called_once_with(message)


class TestReloadNotificationManagerSendToClient:
    """Tests for sending messages to individual clients."""

    @pytest.mark.asyncio
    async def test_send_to_client_success(self, notification_manager, mock_websocket):
        """Test successfully sending a message to a client.
        
        Given a notification manager and a WebSocket
        When _send_to_client is called
        Then the message should be sent via send_json
        """
        message = {"event": "test", "data": "value"}
        
        await notification_manager._send_to_client(mock_websocket, message)
        
        mock_websocket.send_json.assert_called_once_with(message)

    @pytest.mark.asyncio
    async def test_send_to_client_with_empty_message(
        self, notification_manager, mock_websocket
    ):
        """Test sending an empty message to a client.
        
        Given a notification manager and a WebSocket
        When _send_to_client is called with an empty message
        Then the empty message should be sent
        """
        message = {}
        
        await notification_manager._send_to_client(mock_websocket, message)
        
        mock_websocket.send_json.assert_called_once_with(message)

    @pytest.mark.asyncio
    async def test_send_to_client_propagates_exception(
        self, notification_manager, mock_websocket
    ):
        """Test that _send_to_client propagates exceptions.
        
        Given a notification manager and a WebSocket that fails
        When _send_to_client is called
        Then the exception should be propagated
        """
        mock_websocket.send_json.side_effect = Exception("Send failed")
        message = {"event": "test"}
        
        with pytest.raises(Exception, match="Send failed"):
            await notification_manager._send_to_client(mock_websocket, message)


class TestReloadNotificationManagerConcurrency:
    """Tests for concurrent operations and thread safety."""

    @pytest.mark.asyncio
    async def test_concurrent_connect_and_broadcast(self, notification_manager):
        """Test concurrent connections and broadcasts.
        
        Given a notification manager
        When connections and broadcasts happen concurrently
        Then all operations should complete successfully
        """
        websockets = [AsyncMock() for _ in range(5)]
        for ws in websockets: