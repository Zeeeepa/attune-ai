"""Behavioral tests for document_manager.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import logging
from pathlib import Path
from typing import Any
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import pytest

from empathy_os.workflows.base import ModelTier
from empathy_os.workflows.document_manager import DocumentManagerWorkflow


@pytest.fixture
def mock_logger():
    """Mock logger for testing."""
    with patch("empathy_os.workflows.document_manager.logger") as mock_log:
        yield mock_log


@pytest.fixture
def workflow():
    """Create a DocumentManagerWorkflow instance for testing."""
    return DocumentManagerWorkflow()


@pytest.fixture
def sample_input_data():
    """Sample input data with path."""
    return {"path": "/test/project"}


@pytest.fixture
def sample_input_data_no_path():
    """Sample input data without path."""
    return {"other_key": "value"}


@pytest.fixture
def mock_codebase_context():
    """Mock codebase context data."""
    return """
    Module: empathy_os.workflows.base
    Classes: BaseWorkflow, ModelTier
    Functions: execute, run_stage
    """


class TestDocumentManagerWorkflowInitialization:
    """Test DocumentManagerWorkflow initialization."""

    def test_given_no_arguments_when_initialized_then_creates_instance(self):
        """
        Given: No arguments provided
        When: DocumentManagerWorkflow is initialized
        Then: Instance is created with correct attributes
        """
        # Given / When
        workflow = DocumentManagerWorkflow()

        # Then
        assert workflow is not None
        assert workflow.name == "document-manager"
        assert workflow.description.startswith("You are an expert")
        assert workflow.stages == ["process"]
        assert workflow.tier_map == {"process": ModelTier.CAPABLE}

    def test_given_kwargs_when_initialized_then_passes_to_base(self):
        """
        Given: Additional kwargs provided
        When: DocumentManagerWorkflow is initialized
        Then: Kwargs are passed to BaseWorkflow
        """
        # Given
        kwargs = {"custom_param": "value"}

        # When
        with patch("empathy_os.workflows.document_manager.BaseWorkflow.__init__") as mock_init:
            mock_init.return_value = None
            workflow = DocumentManagerWorkflow(**kwargs)

        # Then
        mock_init.assert_called_once_with(**kwargs)


class TestDocumentManagerWorkflowRunStage:
    """Test run_stage method."""

    @pytest.mark.asyncio
    async def test_given_process_stage_when_run_stage_then_calls_process(self, workflow, sample_input_data):
        """
        Given: A 'process' stage name
        When: run_stage is called
        Then: _process method is invoked with correct parameters
        """
        # Given
        stage_name = "process"
        tier = ModelTier.CAPABLE
        expected_result = ("result", 100, 50)

        with patch.object(workflow, "_process", new_callable=AsyncMock) as mock_process:
            mock_process.return_value = expected_result

            # When
            result = await workflow.run_stage(stage_name, tier, sample_input_data)

            # Then
            assert result == expected_result
            mock_process.assert_called_once_with(sample_input_data, tier)

    @pytest.mark.asyncio
    async def test_given_unknown_stage_when_run_stage_then_raises_value_error(self, workflow, sample_input_data):
        """
        Given: An unknown stage name
        When: run_stage is called
        Then: ValueError is raised
        """
        # Given
        stage_name = "unknown_stage"
        tier = ModelTier.CAPABLE

        # When / Then
        with pytest.raises(ValueError, match="Unknown stage: unknown_stage"):
            await workflow.run_stage(stage_name, tier, sample_input_data)


class TestDocumentManagerWorkflowProcess:
    """Test _process method."""

    @pytest.mark.asyncio
    async def test_given_dict_with_path_when_process_then_extracts_path(self, workflow, sample_input_data):
        """
        Given: Input data as dict with 'path' key
        When: _process is called
        Then: Path is extracted and resolved
        """
        # Given
        tier = ModelTier.CAPABLE

        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = "mocked_context"
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = ("doc_result", 100, 50)

                # When
                result = await workflow._process(sample_input_data, tier)

                # Then
                mock_scan.assert_called_once()
                call_path = mock_scan.call_args[0][0]
                assert isinstance(call_path, Path)
                assert str(call_path).endswith("test/project")

    @pytest.mark.asyncio
    async def test_given_dict_without_path_when_process_then_uses_default_path(self, workflow, sample_input_data_no_path):
        """
        Given: Input data as dict without 'path' key
        When: _process is called
        Then: Default path '.' is used
        """
        # Given
        tier = ModelTier.CAPABLE

        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = "mocked_context"
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = ("doc_result", 100, 50)

                # When
                result = await workflow._process(sample_input_data_no_path, tier)

                # Then
                mock_scan.assert_called_once()
                call_path = mock_scan.call_args[0][0]
                assert isinstance(call_path, Path)

    @pytest.mark.asyncio
    async def test_given_non_dict_input_when_process_then_uses_default_path(self, workflow):
        """
        Given: Input data is not a dict
        When: _process is called
        Then: Default path '.' is used
        """
        # Given
        input_data = "string_input"
        tier = ModelTier.CAPABLE

        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = "mocked_context"
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = ("doc_result", 100, 50)

                # When
                result = await workflow._process(input_data, tier)

                # Then
                mock_scan.assert_called_once()
                call_path = mock_scan.call_args[0][0]
                assert isinstance(call_path, Path)

    @pytest.mark.asyncio
    async def test_given_valid_input_when_process_then_scans_codebase(self, workflow, sample_input_data):
        """
        Given: Valid input data
        When: _process is called
        Then: Codebase is scanned
        """
        # Given
        tier = ModelTier.CAPABLE

        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = "mocked_context"
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = ("doc_result", 100, 50)

                # When
                result = await workflow._process(sample_input_data, tier)

                # Then
                mock_scan.assert_called_once()
                assert result == ("doc_result", 100, 50)

    @pytest.mark.asyncio
    async def test_given_valid_input_when_process_then_calls_model_with_prompts(self, workflow, sample_input_data, mock_codebase_context):
        """
        Given: Valid input data and mocked codebase context
        When: _process is called
        Then: Model is called with system and user prompts
        """
        # Given
        tier = ModelTier.CAPABLE

        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = mock_codebase_context
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = ("doc_result", 100, 50)

                # When
                result = await workflow._process(sample_input_data, tier)

                # Then
                mock_call.assert_called_once()
                call_args = mock_call.call_args
                
                # Verify system prompt
                system_prompt = call_args[0][0]
                assert "expert technical writer" in system_prompt
                assert "DO NOT ask questions" in system_prompt
                
                # Verify user prompt
                user_prompt = call_args[0][1]
                assert "Create comprehensive API documentation" in user_prompt
                assert mock_codebase_context in user_prompt
                
                # Verify tier
                assert call_args[0][2] == tier

    @pytest.mark.asyncio
    async def test_given_valid_input_when_process_then_returns_tuple(self, workflow, sample_input_data):
        """
        Given: Valid input data
        When: _process is called
        Then: Returns tuple of (result, input_tokens, output_tokens)
        """
        # Given
        tier = ModelTier.CAPABLE
        expected_result = ("documentation", 150, 75)

        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = "mocked_context"
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = expected_result

                # When
                result = await workflow._process(sample_input_data, tier)

                # Then
                assert isinstance(result, tuple)
                assert len(result) == 3
                assert result[0] == "documentation"
                assert result[1] == 150
                assert result[2] == 75


class TestDocumentManagerWorkflowScanCodebase:
    """Test _scan_codebase method."""

    def test_given_directory_path_when_scan_codebase_then_returns_context(self, workflow):
        """
        Given: A valid directory path
        When: _scan_codebase is called
        Then: Returns codebase context string
        """
        # Given
        test_path = Path("/test/path")

        with patch.object(Path, "exists") as mock_exists:
            mock_exists.return_value = True
            with patch.object(Path, "is_dir") as mock_is_dir:
                mock_is_dir.return_value = True
                with patch.object(Path, "rglob") as mock_rglob:
                    mock_rglob.return_value = []

                    # When
                    result = workflow._scan_codebase(test_path)

                    # Then
                    assert isinstance(result, str)
                    assert len(result) > 0

    def test_given_directory_with_python_files_when_scan_codebase_then_includes_files(self, workflow):
        """
        Given: A directory with Python files
        When: _scan_codebase is called
        Then: Context includes file information
        """
        # Given
        test_path = Path("/test/path")
        mock_file1 = MagicMock(spec=Path)
        mock_file1.name = "module1.py"
        mock_file1.suffix = ".py"
        mock_file1.is_file.return_value = True
        mock_file1.stat.return_value.st_size = 1000

        with patch.object(Path, "exists") as mock_exists:
            mock_exists.return_value = True
            with patch.object(Path, "is_dir") as mock_is_dir:
                mock_is_dir.return_value = True
                with patch.object(Path, "rglob") as mock_rglob:
                    mock_rglob.return_value = [mock_file1]

                    # When
                    result = workflow._scan_codebase(test_path)

                    # Then
                    assert "module1.py" in result

    def test_given_nonexistent_path_when_scan_codebase_then_returns_error_context(self, workflow):
        """
        Given: A nonexistent path
        When: _scan_codebase is called
        Then: Returns context indicating path not found
        """
        # Given
        test_path = Path("/nonexistent/path")

        with patch.object(Path, "exists") as mock_exists:
            mock_exists.return_value = False

            # When
            result = workflow._scan_codebase(test_path)

            # Then
            assert isinstance(result, str)
            assert "not found" in result.lower() or "does not exist" in result.lower() or len(result) == 0

    def test_given_file_instead_of_directory_when_scan_codebase_then_handles_gracefully(self, workflow):
        """
        Given: A file path instead of directory
        When: _scan_codebase is called
        Then: Handles gracefully and returns context
        """
        # Given
        test_path = Path("/test/file.py")

        with patch.object(Path, "exists") as mock_exists:
            mock_exists.return_value = True
            with patch.object(Path, "is_dir") as mock_is_dir:
                mock_is_dir.return_value = False

                # When
                result = workflow._scan_codebase(test_path)

                # Then
                assert isinstance(result, str)

    def test_given_empty_directory_when_scan_codebase_then_returns_empty_context(self, workflow):
        """
        Given: An empty directory
        When: _scan_codebase is called
        Then: Returns context with no files
        """
        # Given
        test_path = Path("/empty/dir")

        with patch.object(Path, "exists") as mock_exists:
            mock_exists.return_value = True
            with patch.object(Path, "is_dir") as mock_is_dir:
                mock_is_dir.return_value = True
                with patch.object(Path, "rglob") as mock_rglob:
                    mock_rglob.return_value = []

                    # When
                    result = workflow._scan_codebase(test_path)

                    # Then
                    assert isinstance(result, str)


class TestDocumentManagerWorkflowIntegration:
    """Integration tests for DocumentManagerWorkflow."""

    @pytest.mark.asyncio
    async def test_given_complete_workflow_when_execute_then_processes_successfully(self, workflow, sample_input_data):
        """
        Given: Complete workflow setup
        When: execute method is called (inherited from BaseWorkflow)
        Then: Workflow processes successfully through all stages
        """
        # Given
        with patch.object(workflow, "_scan_codebase") as mock_scan:
            mock_scan.return_value = "context"
            with patch.object(workflow, "_call_model", new_callable=AsyncMock) as mock_call:
                mock_call.return_value = ("documentation", 100, 50)
                with patch.object(workflow, "run_stage", new_callable=AsyncM