"""Behavioral tests for generator.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import logging
from datetime import datetime
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, patch, mock_open

import pytest
from jinja2 import Environment, TemplateNotFound

from empathy_os.test_generator.generator import (
    TestGenerator,
    _get_default_template_dir,
)


# Fixtures


@pytest.fixture
def temp_template_dir(tmp_path):
    """Create temporary template directory with test templates.
    
    Given a temporary directory
    When test templates are created
    Then they are available for template rendering
    """
    template_dir = tmp_path / "templates"
    template_dir.mkdir()
    
    # Create basic test templates
    (template_dir / "unit_tests.py.j2").write_text(
        "# Unit tests for {{ workflow_id }}\n"
        "def test_{{ workflow_id }}():\n"
        "    pass\n"
    )
    (template_dir / "integration_tests.py.j2").write_text(
        "# Integration tests for {{ workflow_id }}\n"
        "def test_integration_{{ workflow_id }}():\n"
        "    pass\n"
    )
    (template_dir / "e2e_tests.py.j2").write_text(
        "# E2E tests for {{ workflow_id }}\n"
        "def test_e2e_{{ workflow_id }}():\n"
        "    pass\n"
    )
    
    return template_dir


@pytest.fixture
def mock_risk_analyzer():
    """Create mock risk analyzer.
    
    Given a mocked RiskAnalyzer
    When risk analysis is performed
    Then it returns predefined risk assessments
    """
    with patch("empathy_os.test_generator.generator.RiskAnalyzer") as mock:
        analyzer = Mock()
        analyzer.analyze_workflow.return_value = {
            "overall_risk": "medium",
            "risk_score": 5,
            "risk_factors": ["complexity", "external_dependencies"],
            "recommendations": ["Add integration tests", "Mock external APIs"],
        }
        mock.return_value = analyzer
        yield analyzer


@pytest.fixture
def mock_pattern_registry():
    """Create mock pattern registry.
    
    Given a mocked pattern registry
    When patterns are retrieved
    Then they return predefined pattern data
    """
    with patch("empathy_os.test_generator.generator.get_pattern_registry") as mock:
        registry = Mock()
        
        # Mock LinearFlowPattern
        linear_pattern = Mock()
        linear_pattern.pattern_id = "linear_flow"
        linear_pattern.name = "Linear Flow"
        linear_pattern.description = "Sequential execution pattern"
        
        # Mock PhasedProcessingPattern
        phased_pattern = Mock()
        phased_pattern.pattern_id = "phased_processing"
        phased_pattern.name = "Phased Processing"
        phased_pattern.description = "Multi-phase processing pattern"
        
        registry.get_pattern.side_effect = lambda pid: {
            "linear_flow": linear_pattern,
            "phased_processing": phased_pattern,
        }.get(pid)
        
        mock.return_value = registry
        yield registry


@pytest.fixture
def test_generator(temp_template_dir, mock_risk_analyzer, mock_pattern_registry):
    """Create TestGenerator instance with mocked dependencies.
    
    Given mocked dependencies
    When TestGenerator is initialized
    Then it's ready for testing
    """
    return TestGenerator(template_dir=temp_template_dir)


# Tests for _get_default_template_dir


class TestGetDefaultTemplateDir:
    """Tests for _get_default_template_dir function."""
    
    def test_returns_path_object(self):
        """Given the default template directory function is called
        When it executes successfully
        Then it returns a Path object
        """
        result = _get_default_template_dir()
        assert isinstance(result, Path)
    
    def test_path_ends_with_templates(self):
        """Given the default template directory function is called
        When it returns a path
        Then the path ends with 'templates'
        """
        result = _get_default_template_dir()
        assert result.name == "templates"
    
    @patch("empathy_os.test_generator.generator.Path")
    def test_fallback_when_file_unavailable(self, mock_path):
        """Given __file__ is not available (pytest environment)
        When the function is called
        Then it uses fallback strategies
        """
        # Make Path(__file__) raise AttributeError
        mock_path.side_effect = AttributeError("__file__ not available")
        
        with patch("importlib.util.find_spec") as mock_spec:
            spec_mock = Mock()
            spec_mock.origin = "/fake/path/module.py"
            mock_spec.return_value = spec_mock
            
            # Call function - should not raise
            result = _get_default_template_dir()
            assert result is not None
    
    @patch("empathy_os.test_generator.generator.Path")
    @patch("importlib.util.find_spec")
    def test_fallback_to_cwd(self, mock_spec, mock_path_class):
        """Given all fallback strategies fail
        When the function is called
        Then it uses current working directory
        """
        # Make Path(__file__) raise
        mock_path_class.side_effect = [
            AttributeError("__file__ not available"),
            Mock(spec=Path),  # For Path.cwd() call
        ]
        
        # Make importlib.util.find_spec return None
        mock_spec.return_value = None
        
        with patch("sys.modules", {}):
            result = _get_default_template_dir()
            # Should attempt to construct path from cwd
            assert mock_path_class.called


# Tests for TestGenerator.__init__


class TestTestGeneratorInit:
    """Tests for TestGenerator initialization."""
    
    def test_initializes_with_default_template_dir(self, mock_risk_analyzer, mock_pattern_registry):
        """Given no template directory is provided
        When TestGenerator is initialized
        Then it uses the default template directory
        """
        with patch("empathy_os.test_generator.generator._get_default_template_dir") as mock_get_dir:
            mock_get_dir.return_value = Path("/fake/templates")
            
            generator = TestGenerator()
            
            assert generator.template_dir == Path("/fake/templates")
            mock_get_dir.assert_called_once()
    
    def test_initializes_with_custom_template_dir(self, temp_template_dir, mock_risk_analyzer, mock_pattern_registry):
        """Given a custom template directory is provided
        When TestGenerator is initialized
        Then it uses the provided directory
        """
        generator = TestGenerator(template_dir=temp_template_dir)
        
        assert generator.template_dir == temp_template_dir
    
    def test_creates_jinja2_environment(self, test_generator):
        """Given TestGenerator is initialized
        When checking the environment
        Then a Jinja2 Environment is created with correct settings
        """
        assert isinstance(test_generator.env, Environment)
        assert test_generator.env.trim_blocks is True
        assert test_generator.env.lstrip_blocks is True
        assert test_generator.env.autoescape is True
    
    def test_creates_risk_analyzer(self, test_generator, mock_risk_analyzer):
        """Given TestGenerator is initialized
        When checking the risk analyzer
        Then a RiskAnalyzer instance is created
        """
        assert test_generator.risk_analyzer is not None
    
    def test_creates_pattern_registry(self, test_generator, mock_pattern_registry):
        """Given TestGenerator is initialized
        When checking the registry
        Then a pattern registry is created
        """
        assert test_generator.registry is not None


# Tests for TestGenerator.generate_tests


class TestGenerateTests:
    """Tests for TestGenerator.generate_tests method."""
    
    def test_generates_all_test_types_successfully(self, test_generator):
        """Given a valid workflow ID and pattern IDs
        When generate_tests is called
        Then all test types are generated successfully
        """
        result = test_generator.generate_tests(
            workflow_id="test_workflow",
            pattern_ids=["linear_flow"],
            workflow_module="test.module",
            workflow_class="TestWorkflow",
        )
        
        assert "unit_tests" in result
        assert "integration_tests" in result
        assert "e2e_tests" in result
        assert result["unit_tests"] is not None
        assert "test_workflow" in result["unit_tests"]
    
    def test_calls_risk_analyzer(self, test_generator, mock_risk_analyzer):
        """Given a workflow to generate tests for
        When generate_tests is called
        Then the risk analyzer is invoked
        """
        test_generator.generate_tests(
            workflow_id="risky_workflow",
            pattern_ids=["linear_flow"],
        )
        
        mock_risk_analyzer.analyze_workflow.assert_called_once()
        call_args = mock_risk_analyzer.analyze_workflow.call_args
        assert call_args[1]["workflow_id"] == "risky_workflow"
    
    def test_retrieves_patterns_from_registry(self, test_generator, mock_pattern_registry):
        """Given pattern IDs are provided
        When generate_tests is called
        Then patterns are retrieved from the registry
        """
        test_generator.generate_tests(
            workflow_id="test_workflow",
            pattern_ids=["linear_flow", "phased_processing"],
        )
        
        assert mock_pattern_registry.get_pattern.call_count == 2
        mock_pattern_registry.get_pattern.assert_any_call("linear_flow")
        mock_pattern_registry.get_pattern.assert_any_call("phased_processing")
    
    def test_handles_missing_template(self, test_generator, temp_template_dir):
        """Given a template file is missing
        When generate_tests is called
        Then it handles the error gracefully
        """
        # Remove one template
        (temp_template_dir / "unit_tests.py.j2").unlink()
        
        result = test_generator.generate_tests(
            workflow_id="test_workflow",
            pattern_ids=["linear_flow"],
        )
        
        # Should have None for missing template
        assert result["unit_tests"] is None
        # Others should still be generated
        assert result["integration_tests"] is not None
    
    def test_includes_workflow_metadata(self, test_generator):
        """Given workflow metadata is provided
        When generate_tests is called
        Then the metadata is included in the generated tests
        """
        result = test_generator.generate_tests(
            workflow_id="metadata_workflow",
            pattern_ids=["linear_flow"],
            workflow_module="my.custom.module",
            workflow_class="CustomWorkflow",
        )
        
        # All test types should be generated
        assert result["unit_tests"] is not None
        assert "metadata_workflow" in result["unit_tests"]
    
    def test_handles_empty_pattern_ids(self, test_generator):
        """Given an empty list of pattern IDs
        When generate_tests is called
        Then it generates tests without pattern-specific content
        """
        result = test_generator.generate_tests(
            workflow_id="no_pattern_workflow",
            pattern_ids=[],
        )
        
        assert "unit_tests" in result
        assert "integration_tests" in result
        assert "e2e_tests" in result
    
    def test_handles_unknown_pattern_id(self, test_generator, mock_pattern_registry):
        """Given an unknown pattern ID
        When generate_tests is called
        Then it handles the missing pattern gracefully
        """
        mock_pattern_registry.get_pattern.return_value = None
        
        result = test_generator.generate_tests(
            workflow_id="test_workflow",
            pattern_ids=["unknown_pattern"],
        )
        
        # Should still generate tests
        assert result is not None
        assert isinstance(result, dict)
    
    def test_passes_risk_analysis_to_templates(self, test_generator, mock_risk_analyzer):
        """Given risk analysis is performed
        When templates are rendered
        Then risk analysis results are available in template context
        """
        mock_risk_analyzer.analyze_workflow.return_value = {
            "overall_risk": "high",
            "risk_score": 8,
            "risk_factors": ["critical_path", "data_integrity"],
        }
        
        result = test_generator.generate_tests(
            workflow_id="high_risk_workflow",
            pattern_ids=["linear_flow"],
        )
        
        # Tests should be generated with risk context
        assert result is not None
        mock_risk_analyzer.analyze_workflow.assert_called_once()
    
    def test_generates_with_multiple_patterns(self, test_generator, mock_pattern_registry):
        """Given multiple pattern IDs
        When generate_tests is called
        Then tests are generated incorporating all patterns
        """
        result = test_generator.generate_tests(
            workflow_id="multi_pattern_workflow",
            pattern_ids=["linear_flow", "phased_processing"],
        )
        
        assert result["unit_tests"] is not None
        assert result["integration_tests"] is not None
        assert result["e2e_tests"] is not None
        assert mock_pattern_registry.get_pattern.call_count == 2
    
    def test_returns_dict_with_expected_keys(self, test_generator):
        """Given generate_tests is called
        When it completes successfully
        Then it returns a dict with all expected test type keys
        """
        result = test_generator.generate_tests(
            workflow_id="test_workflow",
            pattern_ids=["linear_flow"],
        )
        
        assert isinstance(result, dict)
        assert "unit_tests" in result
        assert "integration_tests" in result
        assert "e2e_tests" in result
    
    def test_handles_template_rendering_error(self, test_generator, temp_template_dir):
        """Given a template with invalid syntax
        When generate_tests is called
        Then it handles the rendering error gracefully
        """
        # Create template with invalid Jinja2 syntax
        (temp_template_dir / "unit_tests.py.j2").write_text(
            "{% invalid syntax %}"
        )
        
        result = test_generator.generate_tests(
            workflow_id="test_workflow",
            pattern_ids=["linear_flow"],
        )
        
        # Should handle error - unit_tests might be None or empty
        assert "unit_tests" in result
    
    def test_generates_tests_without_optional_params(self, test_generator):
        """Given only required parameters
        When generate_tests is called
        Then tests are generated successfully
        """
        result = test_generator.generate_tests(
            workflow_id="minimal_workflow",
            pattern_ids=["linear_flow"],
        )
        
        assert result is not None
        assert "unit_tests" in result
        assert result["unit_tests"] is not None


# Integration tests


class TestTestGeneratorIntegration:
    """Integration tests for TestGenerator."""
    
    def test_end_to_end_test_generation(self, temp_template_dir, mock_risk_analyzer, mock_pattern_registry):
        """Given a complete test generation scenario
        When all components work together
        Then comprehensive tests are generated
        """
        generator = TestGenerator(template_dir=temp_template_dir)
        
        result = generator.generate_tests(
            workflow_