"""Behavioral tests for registry.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import Mock, MagicMock, patch

from empathy_os.workflow_patterns.registry import WorkflowPatternRegistry
from empathy_os.workflow_patterns.core import PatternCategory, WorkflowComplexity, WorkflowPattern


class MockPattern(WorkflowPattern):
    """Mock pattern for testing."""

    def __init__(
        self,
        pattern_id: str = "mock_pattern",
        name: str = "Mock Pattern",
        description: str = "A mock pattern for testing",
        category: PatternCategory = PatternCategory.STRUCTURAL,
        complexity: WorkflowComplexity = WorkflowComplexity.SIMPLE,
        tags: list[str] | None = None,
    ):
        self.id = pattern_id
        self.name = name
        self.description = description
        self.category = category
        self.complexity = complexity
        self.tags = tags or []

    def execute(self, context: dict) -> dict:
        """Mock execute method."""
        return {"status": "success"}

    def validate(self, context: dict) -> bool:
        """Mock validate method."""
        return True


@pytest.fixture
def registry():
    """Fixture providing a fresh registry instance.

    Given: A clean workflow pattern registry
    When: Tests need a registry instance
    Then: A new registry with default patterns is provided
    """
    with patch("empathy_os.workflow_patterns.registry.SingleStagePattern") as mock_single, \
         patch("empathy_os.workflow_patterns.registry.MultiStagePattern") as mock_multi, \
         patch("empathy_os.workflow_patterns.registry.CrewBasedPattern") as mock_crew, \
         patch("empathy_os.workflow_patterns.registry.ConditionalTierPattern") as mock_conditional, \
         patch("empathy_os.workflow_patterns.registry.ConfigDrivenPattern") as mock_config, \
         patch("empathy_os.workflow_patterns.registry.CodeScannerPattern") as mock_scanner, \
         patch("empathy_os.workflow_patterns.registry.ResultDataclassPattern") as mock_result:
        
        # Configure mocks to return pattern instances with unique IDs
        mock_single.return_value = MockPattern("single_stage", "Single Stage", category=PatternCategory.STRUCTURAL)
        mock_multi.return_value = MockPattern("multi_stage", "Multi Stage", category=PatternCategory.STRUCTURAL)
        mock_crew.return_value = MockPattern("crew_based", "Crew Based", category=PatternCategory.STRUCTURAL)
        mock_conditional.return_value = MockPattern("conditional_tier", "Conditional", category=PatternCategory.BEHAVIORAL)
        mock_config.return_value = MockPattern("config_driven", "Config", category=PatternCategory.BEHAVIORAL)
        mock_scanner.return_value = MockPattern("code_scanner", "Scanner", category=PatternCategory.BEHAVIORAL)
        mock_result.return_value = MockPattern("result_dataclass", "Result", category=PatternCategory.OUTPUT)
        
        return WorkflowPatternRegistry()


@pytest.fixture
def empty_registry():
    """Fixture providing an empty registry without default patterns.

    Given: A registry without default patterns
    When: Tests need to control registry contents
    Then: An empty registry is provided
    """
    with patch.object(WorkflowPatternRegistry, "_register_default_patterns"):
        return WorkflowPatternRegistry()


@pytest.fixture
def custom_pattern():
    """Fixture providing a custom pattern for testing.

    Given: A custom workflow pattern
    When: Tests need a pattern instance
    Then: A configured mock pattern is provided
    """
    return MockPattern(
        pattern_id="custom_pattern",
        name="Custom Test Pattern",
        description="A custom pattern for testing",
        category=PatternCategory.STRUCTURAL,
        complexity=WorkflowComplexity.MODERATE,
        tags=["test", "custom"],
    )


class TestWorkflowPatternRegistryInitialization:
    """Tests for WorkflowPatternRegistry initialization."""

    def test_registry_initialization_registers_default_patterns(self, registry):
        """Test that registry initializes with default patterns.

        Given: A new WorkflowPatternRegistry instance
        When: The registry is initialized
        Then: Default patterns are registered
        """
        # Then
        patterns = registry.list_all()
        assert len(patterns) == 7
        pattern_ids = {p.id for p in patterns}
        assert "single_stage" in pattern_ids
        assert "multi_stage" in pattern_ids
        assert "crew_based" in pattern_ids
        assert "conditional_tier" in pattern_ids
        assert "config_driven" in pattern_ids
        assert "code_scanner" in pattern_ids
        assert "result_dataclass" in pattern_ids

    def test_registry_initializes_empty_patterns_dict(self, empty_registry):
        """Test that registry initializes with empty patterns dict.

        Given: A registry without default patterns
        When: The registry is initialized
        Then: The patterns dictionary exists but is empty
        """
        # Then
        assert hasattr(empty_registry, "_patterns")
        assert isinstance(empty_registry._patterns, dict)

    def test_registry_calls_register_default_patterns(self):
        """Test that initialization calls _register_default_patterns.

        Given: The WorkflowPatternRegistry class
        When: A new instance is created
        Then: _register_default_patterns is called
        """
        # When/Then
        with patch.object(WorkflowPatternRegistry, "_register_default_patterns") as mock_register:
            registry = WorkflowPatternRegistry()
            mock_register.assert_called_once()


class TestWorkflowPatternRegistryRegister:
    """Tests for registering patterns."""

    def test_register_adds_new_pattern(self, empty_registry, custom_pattern):
        """Test registering a new pattern.

        Given: An empty registry and a custom pattern
        When: The pattern is registered
        Then: The pattern is added to the registry
        """
        # When
        empty_registry.register(custom_pattern)

        # Then
        assert custom_pattern.id in empty_registry._patterns
        assert empty_registry._patterns[custom_pattern.id] == custom_pattern

    def test_register_overwrites_existing_pattern(self, empty_registry):
        """Test that registering overwrites existing pattern with same ID.

        Given: A registry with an existing pattern
        When: A new pattern with the same ID is registered
        Then: The old pattern is replaced
        """
        # Given
        old_pattern = MockPattern("test_id", "Old Pattern")
        empty_registry.register(old_pattern)

        # When
        new_pattern = MockPattern("test_id", "New Pattern")
        empty_registry.register(new_pattern)

        # Then
        assert empty_registry._patterns["test_id"] == new_pattern
        assert empty_registry._patterns["test_id"].name == "New Pattern"

    def test_register_multiple_patterns(self, empty_registry):
        """Test registering multiple patterns.

        Given: An empty registry and multiple patterns
        When: Multiple patterns are registered
        Then: All patterns are available in the registry
        """
        # Given
        pattern1 = MockPattern("pattern1", "Pattern 1")
        pattern2 = MockPattern("pattern2", "Pattern 2")
        pattern3 = MockPattern("pattern3", "Pattern 3")

        # When
        empty_registry.register(pattern1)
        empty_registry.register(pattern2)
        empty_registry.register(pattern3)

        # Then
        assert len(empty_registry._patterns) == 3
        assert empty_registry.get("pattern1") == pattern1
        assert empty_registry.get("pattern2") == pattern2
        assert empty_registry.get("pattern3") == pattern3


class TestWorkflowPatternRegistryGet:
    """Tests for getting patterns by ID."""

    def test_get_existing_pattern(self, empty_registry, custom_pattern):
        """Test retrieving an existing pattern by ID.

        Given: A registry with a registered pattern
        When: get() is called with the pattern's ID
        Then: The pattern is returned
        """
        # Given
        empty_registry.register(custom_pattern)

        # When
        result = empty_registry.get("custom_pattern")

        # Then
        assert result is not None
        assert result == custom_pattern
        assert result.id == "custom_pattern"

    def test_get_nonexistent_pattern_returns_none(self, empty_registry):
        """Test getting a non-existent pattern returns None.

        Given: An empty registry
        When: get() is called with a non-existent ID
        Then: None is returned
        """
        # When
        result = empty_registry.get("nonexistent")

        # Then
        assert result is None

    def test_get_with_empty_string(self, empty_registry):
        """Test getting with empty string ID.

        Given: A registry
        When: get() is called with empty string
        Then: None is returned
        """
        # When
        result = empty_registry.get("")

        # Then
        assert result is None

    def test_get_returns_correct_pattern_among_many(self, empty_registry):
        """Test getting specific pattern from multiple registered patterns.

        Given: A registry with multiple patterns
        When: get() is called with a specific ID
        Then: The correct pattern is returned
        """
        # Given
        pattern1 = MockPattern("pattern1", "Pattern 1")
        pattern2 = MockPattern("pattern2", "Pattern 2")
        pattern3 = MockPattern("pattern3", "Pattern 3")
        empty_registry.register(pattern1)
        empty_registry.register(pattern2)
        empty_registry.register(pattern3)

        # When
        result = empty_registry.get("pattern2")

        # Then
        assert result == pattern2
        assert result.name == "Pattern 2"


class TestWorkflowPatternRegistryListAll:
    """Tests for listing all patterns."""

    def test_list_all_returns_all_patterns(self, registry):
        """Test that list_all returns all registered patterns.

        Given: A registry with default patterns
        When: list_all() is called
        Then: All patterns are returned
        """
        # When
        patterns = registry.list_all()

        # Then
        assert len(patterns) == 7
        assert all(isinstance(p, WorkflowPattern) for p in patterns)

    def test_list_all_returns_empty_list_for_empty_registry(self, empty_registry):
        """Test that list_all returns empty list for empty registry.

        Given: An empty registry
        When: list_all() is called
        Then: An empty list is returned
        """
        # When
        patterns = empty_registry.list_all()

        # Then
        assert patterns == []
        assert isinstance(patterns, list)

    def test_list_all_returns_copy_of_patterns(self, empty_registry, custom_pattern):
        """Test that list_all returns a new list (not internal dict values).

        Given: A registry with patterns
        When: list_all() is called multiple times
        Then: Each call returns a new list
        """
        # Given
        empty_registry.register(custom_pattern)

        # When
        list1 = empty_registry.list_all()
        list2 = empty_registry.list_all()

        # Then
        assert list1 is not list2
        assert list1 == list2

    def test_list_all_reflects_newly_registered_patterns(self, empty_registry):
        """Test that list_all reflects patterns registered after initial call.

        Given: A registry
        When: Patterns are registered after calling list_all
        Then: Subsequent calls include new patterns
        """
        # Given
        pattern1 = MockPattern("pattern1", "Pattern 1")
        empty_registry.register(pattern1)
        initial_list = empty_registry.list_all()

        # When
        pattern2 = MockPattern("pattern2", "Pattern 2")
        empty_registry.register(pattern2)
        updated_list = empty_registry.list_all()

        # Then
        assert len(initial_list) == 1
        assert len(updated_list) == 2


class TestWorkflowPatternRegistryListByCategory:
    """Tests for listing patterns by category."""

    def test_list_by_category_structural(self, registry):
        """Test listing patterns by structural category.

        Given: A registry with patterns in different categories
        When: list_by_category() is called with STRUCTURAL
        Then: Only structural patterns are returned
        """
        # When
        patterns = registry.list_by_category(PatternCategory.STRUCTURAL)

        # Then
        assert len(patterns) == 3
        assert all(p.category == PatternCategory.STRUCTURAL for p in patterns)

    def test_list_by_category_behavioral(self, registry):
        """Test listing patterns by behavioral category.

        Given: A registry with patterns in different categories
        When: list_by_category() is called with BEHAVIORAL
        Then: Only behavioral patterns are returned
        """
        # When
        patterns = registry.list_by_category(PatternCategory.BEHAVIORAL)

        # Then
        assert len(patterns) == 3
        assert all(p.category == PatternCategory.BEHAVIORAL for p in patterns)

    def test_list_by_category_output(self, registry):
        """Test listing patterns by output category.

        Given: A registry with patterns in different categories
        When: list_by_category() is called with OUTPUT
        Then: Only output patterns are returned
        """
        # When
        patterns = registry.list_by_category(PatternCategory.OUTPUT)

        # Then
        assert len(patterns) == 1
        assert all(p.category == PatternCategory.OUTPUT for p in patterns)

    def test_list_by_category_returns_empty_for_no_matches(self, empty_registry):
        """Test that list_by_category returns empty list when no matches.

        Given: An empty registry
        When: list_by_category() is called
        Then: An empty list is returned
        """
        # When
        patterns = empty_registry.list_by_category(PatternCategory.STRUCTURAL)

        # Then
        assert patterns == []

    def test_list_by_category_filters_correctly(self, empty_registry):
        """Test that list_by_category filters patterns correctly.

        Given: A registry with mixed category patterns
        When: list_by_category() is called with specific category
        Then: Only patterns matching that category are returned
        """
        # Given
        structural = MockPattern("s1", "S1", category=PatternCategory.STRUCTURAL)
        behavioral = MockPattern("b1", "B1", category=PatternCategory.BEHAVIORAL)
        output = MockPattern("o1", "O1", category=PatternCategory.OUTPUT)
        empty_registry.register(structural)
        empty_registry.register(behavioral)
        empty_registry.register(output)

        # When
        behavioral_patterns = empty_registry.list_by_category(PatternCategory.BEHAVIORAL)

        # Then
        assert len(behavioral_patterns) == 1
        assert behavioral_patterns[0] == behavioral


class TestWorkflowPatternRegistryListByComplexity:
    """Tests for listing patterns by complexity."""

    def test_list_by_complexity_simple(self, empty_registry):
        """Test listing patterns by simple complexity.

        Given: A registry with patterns of different complexities
        When: list_by_complexity() is called with SIMPLE
        Then: Only simple patterns are returned
        """
        # Given
        simple = MockPattern("s1", "Simple", complexity=WorkflowComplexity.SIMPLE)
        moderate = MockPattern("m1", "Moderate", complexity=WorkflowComplexity.MODERATE)
        empty_registry.register(simple)
        empty_registry.register(moderate)

        # When
        patterns = empty_registry.list_by_complexity(WorkflowComplexity.SIMPLE)