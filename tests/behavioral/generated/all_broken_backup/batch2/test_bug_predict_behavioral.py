"""Behavioral tests for bug_predict.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import logging
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest
import yaml

from empathy_os.workflows.bug_predict import (
    BugPredictWorkflow,
    _load_bug_predict_config,
    _should_exclude_file,
)
from empathy_os.workflows.base import ModelTier


class TestLoadBugPredictConfig:
    """Behavioral tests for _load_bug_predict_config function."""

    def test_given_no_config_file_when_loading_then_returns_defaults(self, tmp_path):
        """
        Given: No empathy configuration files exist
        When: Loading bug_predict configuration
        Then: Default configuration values are returned
        """
        with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
            mock_path.return_value.exists.return_value = False

            result = _load_bug_predict_config()

            assert result["risk_threshold"] == 0.7
            assert result["exclude_files"] == []
            assert result["acceptable_exception_contexts"] == [
                "version",
                "config",
                "cleanup",
                "optional",
            ]

    def test_given_empathy_config_yml_exists_when_loading_then_returns_config(
        self, tmp_path
    ):
        """
        Given: empathy.config.yml exists with bug_predict settings
        When: Loading bug_predict configuration
        Then: Configuration from file is returned
        """
        config_content = {
            "bug_predict": {
                "risk_threshold": 0.85,
                "exclude_files": ["**/test_*.py", "**/conftest.py"],
                "acceptable_exception_contexts": ["custom", "context"],
            }
        }

        with patch("builtins.open", mock_open(read_data=yaml.dump(config_content))):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [True, False, False, False]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.85
                assert result["exclude_files"] == ["**/test_*.py", "**/conftest.py"]
                assert result["acceptable_exception_contexts"] == ["custom", "context"]

    def test_given_partial_config_when_loading_then_returns_merged_with_defaults(self):
        """
        Given: Configuration file exists with partial bug_predict settings
        When: Loading bug_predict configuration
        Then: Partial config is merged with defaults
        """
        config_content = {"bug_predict": {"risk_threshold": 0.9}}

        with patch("builtins.open", mock_open(read_data=yaml.dump(config_content))):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [True, False, False, False]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.9
                assert result["exclude_files"] == []
                assert result["acceptable_exception_contexts"] == [
                    "version",
                    "config",
                    "cleanup",
                    "optional",
                ]

    def test_given_invalid_yaml_when_loading_then_returns_defaults(self):
        """
        Given: Configuration file exists but contains invalid YAML
        When: Loading bug_predict configuration
        Then: Default configuration is returned
        """
        with patch("builtins.open", mock_open(read_data="invalid: yaml: content: [")):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [True, False, False, False]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.7
                assert result["exclude_files"] == []

    def test_given_empty_config_when_loading_then_returns_defaults(self):
        """
        Given: Configuration file exists but is empty
        When: Loading bug_predict configuration
        Then: Default configuration is returned
        """
        with patch("builtins.open", mock_open(read_data="")):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [True, False, False, False]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.7

    def test_given_config_without_bug_predict_when_loading_then_returns_defaults(self):
        """
        Given: Configuration file exists but has no bug_predict section
        When: Loading bug_predict configuration
        Then: Default configuration is returned
        """
        config_content = {"other_workflow": {"some_setting": "value"}}

        with patch("builtins.open", mock_open(read_data=yaml.dump(config_content))):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [True, False, False, False]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.7

    def test_given_file_read_error_when_loading_then_returns_defaults(self):
        """
        Given: Configuration file exists but cannot be read (OSError)
        When: Loading bug_predict configuration
        Then: Default configuration is returned
        """
        with patch("builtins.open", side_effect=OSError("Permission denied")):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [True, False, False, False]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.7

    def test_given_multiple_config_files_when_loading_then_uses_first_found(self):
        """
        Given: Multiple configuration file paths exist
        When: Loading bug_predict configuration
        Then: First existing configuration file is used
        """
        config_content = {"bug_predict": {"risk_threshold": 0.95}}

        with patch("builtins.open", mock_open(read_data=yaml.dump(config_content))):
            with patch("empathy_os.workflows.bug_predict.Path") as mock_path:
                mock_path.return_value.exists.side_effect = [
                    False,
                    True,
                    False,
                    False,
                ]

                result = _load_bug_predict_config()

                assert result["risk_threshold"] == 0.95


class TestShouldExcludeFile:
    """Behavioral tests for _should_exclude_file function."""

    def test_given_no_patterns_when_checking_then_returns_false(self):
        """
        Given: No exclusion patterns provided
        When: Checking if file should be excluded
        Then: False is returned
        """
        result = _should_exclude_file("src/main.py", [])

        assert result is False

    def test_given_simple_pattern_match_when_checking_then_returns_true(self):
        """
        Given: File matches a simple exclusion pattern
        When: Checking if file should be excluded
        Then: True is returned
        """
        result = _should_exclude_file("test_main.py", ["test_*.py"])

        assert result is True

    def test_given_simple_pattern_no_match_when_checking_then_returns_false(self):
        """
        Given: File does not match simple exclusion pattern
        When: Checking if file should be excluded
        Then: False is returned
        """
        result = _should_exclude_file("main.py", ["test_*.py"])

        assert result is False

    def test_given_recursive_pattern_with_match_when_checking_then_returns_true(self):
        """
        Given: File matches a recursive ** pattern
        When: Checking if file should be excluded
        Then: True is returned
        """
        result = _should_exclude_file("src/tests/test_main.py", ["**/test_*.py"])

        assert result is True

    def test_given_recursive_pattern_no_match_when_checking_then_returns_false(self):
        """
        Given: File does not match recursive ** pattern
        When: Checking if file should be excluded
        Then: False is returned
        """
        result = _should_exclude_file("src/main.py", ["**/test_*.py"])

        assert result is False

    def test_given_prefix_pattern_with_match_when_checking_then_returns_true(self):
        """
        Given: File matches ** prefix pattern
        When: Checking if file should be excluded
        Then: True is returned
        """
        result = _should_exclude_file("deep/nested/file.txt", ["**/file.txt"])

        assert result is True

    def test_given_suffix_pattern_with_match_when_checking_then_returns_true(self):
        """
        Given: File matches ** suffix pattern
        When: Checking if file should be excluded
        Then: True is returned
        """
        result = _should_exclude_file("src/tests/conftest.py", ["src/**"])

        assert result is True

    def test_given_multiple_patterns_with_one_match_when_checking_then_returns_true(
        self,
    ):
        """
        Given: Multiple exclusion patterns with one matching
        When: Checking if file should be excluded
        Then: True is returned
        """
        patterns = ["*.md", "**/test_*.py", "*.txt"]
        result = _should_exclude_file("src/test_main.py", patterns)

        assert result is True

    def test_given_complex_recursive_pattern_when_checking_then_handles_correctly(self):
        """
        Given: Complex recursive pattern with multiple ** segments
        When: Checking if file should be excluded
        Then: Only first ** is processed, rest treated as literal
        """
        result = _should_exclude_file(
            "src/nested/test.py", ["src/**/nested/**/test.py"]
        )

        # Pattern splits on first **, so becomes: "src/" prefix and "nested/**/test.py" suffix
        assert result is True

    def test_given_windows_path_when_checking_then_handles_correctly(self):
        """
        Given: Windows-style path separators
        When: Checking if file should be excluded
        Then: Pattern matching works correctly
        """
        result = _should_exclude_file("src\\tests\\test_main.py", ["**/test_*.py"])

        # Should handle both / and \ in paths
        assert result is True


class TestBugPredictWorkflow:
    """Behavioral tests for BugPredictWorkflow class."""

    @pytest.fixture
    def mock_workflow_context(self):
        """Provide a mock workflow context."""
        context = Mock()
        context.current_tier = ModelTier.CHEAP
        context.llm_client = Mock()
        context.memory_client = Mock()
        return context

    @pytest.fixture
    def workflow(self, mock_workflow_context):
        """Provide a BugPredictWorkflow instance."""
        with patch(
            "empathy_os.workflows.bug_predict._load_bug_predict_config"
        ) as mock_config:
            mock_config.return_value = {
                "risk_threshold": 0.7,
                "exclude_files": [],
                "acceptable_exception_contexts": [
                    "version",
                    "config",
                    "cleanup",
                    "optional",
                ],
            }
            return BugPredictWorkflow(context=mock_workflow_context)

    def test_given_workflow_instance_when_created_then_has_correct_attributes(
        self, workflow
    ):
        """
        Given: BugPredictWorkflow instance is created
        When: Checking instance attributes
        Then: Workflow has correct name and steps configuration
        """
        assert workflow.name == "bug_predict"
        assert hasattr(workflow, "steps")
        assert len(workflow.steps) > 0

    def test_given_workflow_when_checking_steps_then_has_four_stages(self, workflow):
        """
        Given: BugPredictWorkflow instance
        When: Checking workflow steps
        Then: Has scan, correlate, predict, and recommend steps
        """
        step_names = [step.name for step in workflow.steps]

        assert "scan" in step_names
        assert "correlate" in step_names
        assert "predict" in step_names
        assert "recommend" in step_names

    def test_given_workflow_when_checking_tiers_then_correct_tiers_assigned(
        self, workflow
    ):
        """
        Given: BugPredictWorkflow instance
        When: Checking step tiers
        Then: Steps have correct ModelTier assignments
        """
        step_tiers = {step.name: step.tier for step in workflow.steps}

        assert step_tiers["scan"] == ModelTier.CHEAP
        assert step_tiers["correlate"] == ModelTier.CAPABLE
        assert step_tiers["predict"] == ModelTier.CAPABLE
        assert step_tiers["recommend"] == ModelTier.PREMIUM

    @patch("empathy_os.workflows.bug_predict.Path")
    def test_given_codebase_path_when_running_scan_then_scans_files(
        self, mock_path, workflow, mock_workflow_context
    ):
        """
        Given: A codebase path is provided
        When: Running the scan step
        Then: Files are scanned and patterns extracted
        """
        mock_workflow_context.llm_client.generate.return_value = json.dumps(
            {
                "files_scanned": 5,
                "patterns": [
                    {"type": "exception", "location": "file.py:10"}
                ],
            }
        )

        # Mock Path.glob to return mock files
        mock_file = Mock()
        mock_file.suffix = ".py"
        mock_file.is_file.return_value = True
        mock_file.read_text.return_value = "def test():\n    pass"
        mock_file.__str__.return_value = "src/test.py"

        mock_path_instance = Mock()
        mock_path_instance.glob.return_value = [mock_file]
        mock_path.return_value = mock_path_instance

        result = workflow.run(codebase_path="src/")

        assert "scan" in result
        mock_workflow_context.llm_client.generate.assert_called()

    @patch("empathy_os.workflows.bug_predict.Path")
    def test_given_excluded_files_when_scanning_then_files_are_skipped(
        self, mock_path, mock_workflow_context
    ):
        """
        Given: Exclusion patterns are configured
        When: Scanning codebase
        Then: Matching files are skipped
        """
        with patch(
            "empathy_os.workflows.bug_predict._load_bug_predict_config"
        ) as mock_config:
            mock_config.return_value = {
                "risk_threshold": 0.7,
                "exclude_files": ["**/test_*.py"],
                "acceptable_exception_contexts": [],
            }
            workflow = BugPredictWorkflow(context=mock_workflow_context)

        mock_workflow_context.llm_client.generate.return_value = json.dumps(
            {"files_scanned": 0, "patterns": []}
        )