"""Behavioral tests for unified.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import os
import tempfile
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, call, mock_open, patch

import pytest

from empathy_os.memory.unified import (
    CLAUDE_COMPACT_STATE_TEMPLATE,
    AccessTier,
    AgentCredentials,
    Classification,
    Environment,
    MemoryConfig,
    MemoryStatistics,
    PatternPromotionRecord,
    StagedPattern,
    StorageBackend,
    TTLStrategy,
    UnifiedMemory,
    _validate_pattern_metadata,
    _validate_state_data,
)


class TestEnvironmentEnum:
    """Tests for Environment enum."""

    def test_given_environment_enum_when_accessed_then_has_expected_values(self):
        """Given environment enum, when accessed, then has expected values."""
        # Given/When/Then
        assert Environment.DEVELOPMENT.value == "development"
        assert Environment.STAGING.value == "staging"
        assert Environment.PRODUCTION.value == "production"


class TestMemoryConfig:
    """Tests for MemoryConfig dataclass."""

    def test_given_no_args_when_created_then_has_defaults(self):
        """Given no arguments, when MemoryConfig created, then has default values."""
        # Given/When
        config = MemoryConfig()

        # Then
        assert config.environment == Environment.DEVELOPMENT
        assert config.file_session_enabled is True
        assert config.file_session_dir == ".empathy"
        assert config.redis_url is None
        assert config.redis_host == "localhost"
        assert config.redis_port == 6379
        assert config.redis_mock is False
        assert config.redis_auto_start is False
        assert config.redis_required is False
        assert config.default_ttl_seconds == 3600
        assert config.storage_dir == "./memdocs_storage"
        assert config.encryption_enabled is True
        assert config.claude_memory_enabled is True
        assert config.load_enterprise_memory is True
        assert config.load_project_memory is True
        assert config.load_user_memory is True
        assert config.auto_promote_threshold == 0.8
        assert config.auto_generate_compact_state is True

    def test_given_custom_values_when_created_then_uses_custom_values(self):
        """Given custom values, when MemoryConfig created, then uses custom values."""
        # Given/When
        config = MemoryConfig(
            environment=Environment.PRODUCTION,
            redis_host="redis.example.com",
            redis_port=6380,
            storage_dir="/custom/storage",
            auto_promote_threshold=0.9,
        )

        # Then
        assert config.environment == Environment.PRODUCTION
        assert config.redis_host == "redis.example.com"
        assert config.redis_port == 6380
        assert config.storage_dir == "/custom/storage"
        assert config.auto_promote_threshold == 0.9


class TestMemoryStatistics:
    """Tests for MemoryStatistics dataclass."""

    def test_given_no_args_when_created_then_has_zero_defaults(self):
        """Given no arguments, when MemoryStatistics created, then has zero defaults."""
        # Given/When
        stats = MemoryStatistics()

        # Then
        assert stats.short_term_keys == 0
        assert stats.staged_patterns == 0
        assert stats.long_term_patterns == 0
        assert stats.auto_promoted == 0
        assert stats.manual_promoted == 0
        assert stats.redis_available is False
        assert stats.file_session_available is False
        assert stats.active_backend == StorageBackend.NONE


class TestPatternPromotionRecord:
    """Tests for PatternPromotionRecord dataclass."""

    def test_given_required_args_when_created_then_initializes_correctly(self):
        """Given required arguments, when PatternPromotionRecord created, then initializes correctly."""
        # Given
        pattern_id = "test-pattern-123"
        promoted_id = "promoted-456"
        timestamp = datetime.now()

        # When
        record = PatternPromotionRecord(
            staged_pattern_id=pattern_id,
            promoted_pattern_id=promoted_id,
            promotion_timestamp=timestamp,
            confidence_score=0.95,
            promotion_reason="High usage frequency",
        )

        # Then
        assert record.staged_pattern_id == pattern_id
        assert record.promoted_pattern_id == promoted_id
        assert record.promotion_timestamp == timestamp
        assert record.confidence_score == 0.95
        assert record.promotion_reason == "High usage frequency"


class TestStorageBackend:
    """Tests for StorageBackend enum."""

    def test_given_storage_backend_enum_when_accessed_then_has_expected_values(self):
        """Given StorageBackend enum, when accessed, then has expected values."""
        # Given/When/Then
        assert StorageBackend.NONE.value == "none"
        assert StorageBackend.FILE_SESSION.value == "file_session"
        assert StorageBackend.REDIS.value == "redis"


class TestValidatePatternMetadata:
    """Tests for _validate_pattern_metadata function."""

    def test_given_valid_metadata_when_validated_then_returns_true(self):
        """Given valid metadata dictionary, when validated, then returns True."""
        # Given
        metadata = {
            "pattern_type": "algorithm",
            "confidence": 0.85,
            "tags": ["test", "example"],
        }

        # When
        result = _validate_pattern_metadata(metadata)

        # Then
        assert result is True

    def test_given_none_when_validated_then_returns_false(self):
        """Given None, when validated, then returns False."""
        # Given/When
        result = _validate_pattern_metadata(None)

        # Then
        assert result is False

    def test_given_non_dict_when_validated_then_returns_false(self):
        """Given non-dictionary type, when validated, then returns False."""
        # Given/When
        result = _validate_pattern_metadata("not a dict")

        # Then
        assert result is False

    def test_given_empty_dict_when_validated_then_returns_true(self):
        """Given empty dictionary, when validated, then returns True."""
        # Given/When
        result = _validate_pattern_metadata({})

        # Then
        assert result is True


class TestValidateStateData:
    """Tests for _validate_state_data function."""

    def test_given_valid_state_data_when_validated_then_returns_true(self):
        """Given valid state data dictionary, when validated, then returns True."""
        # Given
        state_data = {
            "session_id": "test-session",
            "timestamp": "2025-01-01T00:00:00",
            "data": {"key": "value"},
        }

        # When
        result = _validate_state_data(state_data)

        # Then
        assert result is True

    def test_given_none_when_validated_then_returns_false(self):
        """Given None, when validated, then returns False."""
        # Given/When
        result = _validate_state_data(None)

        # Then
        assert result is False

    def test_given_non_dict_when_validated_then_returns_false(self):
        """Given non-dictionary type, when validated, then returns False."""
        # Given/When
        result = _validate_state_data([1, 2, 3])

        # Then
        assert result is False

    def test_given_empty_dict_when_validated_then_returns_true(self):
        """Given empty dictionary, when validated, then returns True."""
        # Given/When
        result = _validate_state_data({})

        # Then
        assert result is True


class TestUnifiedMemoryInitialization:
    """Tests for UnifiedMemory initialization."""

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_user_id_when_initialized_then_creates_file_session(
        self, mock_path, mock_file_session
    ):
        """Given user_id, when UnifiedMemory initialized, then creates file session."""
        # Given
        user_id = "test@example.com"
        mock_path.return_value.mkdir = Mock()

        # When
        memory = UnifiedMemory(user_id=user_id)

        # Then
        assert memory.user_id == user_id
        assert memory._active_backend == StorageBackend.FILE_SESSION
        mock_file_session.assert_called_once()

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.ensure_redis")
    @patch("empathy_os.memory.unified.RedisShortTermMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_redis_auto_start_when_initialized_then_starts_redis(
        self, mock_path, mock_redis_stm, mock_ensure_redis, mock_file_session
    ):
        """Given redis_auto_start=True, when initialized, then starts Redis."""
        # Given
        mock_path.return_value.mkdir = Mock()
        mock_redis_status = Mock()
        mock_redis_status.is_running = True
        mock_redis_status.connection_url = "redis://localhost:6379"
        mock_ensure_redis.return_value = mock_redis_status

        config = MemoryConfig(redis_auto_start=True)

        # When
        memory = UnifiedMemory(user_id="test@example.com", config=config)

        # Then
        mock_ensure_redis.assert_called_once()
        assert memory._active_backend == StorageBackend.REDIS

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_custom_config_when_initialized_then_uses_config(
        self, mock_path, mock_file_session
    ):
        """Given custom config, when initialized, then uses config settings."""
        # Given
        mock_path.return_value.mkdir = Mock()
        config = MemoryConfig(
            environment=Environment.PRODUCTION,
            file_session_dir="/custom/dir",
            default_ttl_seconds=7200,
        )

        # When
        memory = UnifiedMemory(user_id="test@example.com", config=config)

        # Then
        assert memory.config.environment == Environment.PRODUCTION
        assert memory.config.default_ttl_seconds == 7200

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.ensure_redis")
    @patch("empathy_os.memory.unified.Path")
    def test_given_redis_required_and_unavailable_when_initialized_then_raises_error(
        self, mock_path, mock_ensure_redis, mock_file_session
    ):
        """Given redis_required=True and Redis unavailable, when initialized, then raises error."""
        # Given
        mock_path.return_value.mkdir = Mock()
        mock_redis_status = Mock()
        mock_redis_status.is_running = False
        mock_ensure_redis.return_value = mock_redis_status

        config = MemoryConfig(redis_required=True, redis_auto_start=True)

        # When/Then
        with pytest.raises(RuntimeError, match="Redis is required"):
            UnifiedMemory(user_id="test@example.com", config=config)

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_file_session_disabled_when_initialized_then_no_file_session(
        self, mock_path, mock_file_session
    ):
        """Given file_session_enabled=False, when initialized, then no file session created."""
        # Given
        mock_path.return_value.mkdir = Mock()
        config = MemoryConfig(file_session_enabled=False)

        # When
        memory = UnifiedMemory(user_id="test@example.com", config=config)

        # Then
        assert memory._file_session is None
        assert memory._active_backend == StorageBackend.NONE


class TestUnifiedMemoryStash:
    """Tests for UnifiedMemory.stash method."""

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_file_session_backend_when_stash_called_then_stores_in_file(
        self, mock_path, mock_file_session
    ):
        """Given file session backend, when stash called, then stores in file session."""
        # Given
        mock_path.return_value.mkdir = Mock()
        mock_file_instance = Mock()
        mock_file_session.return_value = mock_file_instance
        memory = UnifiedMemory(user_id="test@example.com")

        # When
        memory.stash("test_key", {"data": "value"})

        # Then
        mock_file_instance.store_item.assert_called_once_with(
            "test_key", {"data": "value"}, ttl_seconds=3600
        )

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.ensure_redis")
    @patch("empathy_os.memory.unified.RedisShortTermMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_redis_backend_when_stash_called_then_stores_in_redis(
        self, mock_path, mock_redis_stm, mock_ensure_redis, mock_file_session
    ):
        """Given Redis backend, when stash called, then stores in Redis."""
        # Given
        mock_path.return_value.mkdir = Mock()
        mock_redis_status = Mock()
        mock_redis_status.is_running = True
        mock_redis_status.connection_url = "redis://localhost:6379"
        mock_ensure_redis.return_value = mock_redis_status

        mock_redis_instance = Mock()
        mock_redis_stm.return_value = mock_redis_instance

        config = MemoryConfig(redis_auto_start=True)
        memory = UnifiedMemory(user_id="test@example.com", config=config)

        # When
        memory.stash("test_key", {"data": "value"}, ttl_seconds=1800)

        # Then
        mock_redis_instance.store.assert_called_once_with(
            "test_key", {"data": "value"}, ttl_seconds=1800, tier=AccessTier.HOT
        )

    @patch("empathy_os.memory.unified.FileSessionMemory")
    @patch("empathy_os.memory.unified.Path")
    def test_given_custom_ttl_when_stash_called_then_uses_custom_ttl(
        self, mock_path, mock_file_session
    ):
        """Given custom TTL, when stash called, then uses custom TTL value."""
        # Given
        mock_path.return_value.mkdir = Mock()
        mock_file_instance = Mock()
        mock_file_session.return_value = mock_file_instance
        memory = UnifiedMemory(user_id="test@example.com")

        # When
        memory.stash("test