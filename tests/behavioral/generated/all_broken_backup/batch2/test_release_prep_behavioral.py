"""Behavioral tests for release_prep.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, patch, call

import pytest

from empathy_os.workflows.release_prep import (
    RELEASE_PREP_STEPS,
    ReleasePreparationWorkflow,
)
from empathy_os.workflows.base import ModelTier


@pytest.fixture
def mock_subprocess():
    """Mock subprocess for command execution."""
    with patch("empathy_os.workflows.release_prep.subprocess") as mock:
        yield mock


@pytest.fixture
def mock_datetime():
    """Mock datetime for consistent timestamps."""
    with patch("empathy_os.workflows.release_prep.datetime") as mock:
        mock.now.return_value = datetime(2025, 1, 15, 12, 0, 0)
        yield mock


@pytest.fixture
def base_workflow_instance():
    """Create a basic workflow instance without security crew."""
    return ReleasePreparationWorkflow(skip_approve_if_clean=True)


@pytest.fixture
def workflow_with_security_crew():
    """Create workflow instance with security crew enabled."""
    return ReleasePreparationWorkflow(
        skip_approve_if_clean=False,
        use_security_crew=True,
        crew_config={"max_iterations": 5}
    )


class TestReleasePreparationWorkflowInitialization:
    """Tests for ReleasePreparationWorkflow initialization."""

    def test_given_default_params_when_initialized_then_sets_correct_attributes(self):
        """Given default parameters
        When workflow is initialized
        Then it sets correct default attributes.
        """
        # Given / When
        workflow = ReleasePreparationWorkflow()

        # Then
        assert workflow.name == "release-prep"
        assert workflow.description == "Pre-release quality gate with health, security, and changelog"
        assert workflow.skip_approve_if_clean is True
        assert workflow.use_security_crew is False
        assert workflow.crew_config == {}
        assert workflow._has_blockers is False

    def test_given_skip_approve_false_when_initialized_then_sets_attribute(self):
        """Given skip_approve_if_clean=False
        When workflow is initialized
        Then it sets the attribute correctly.
        """
        # Given / When
        workflow = ReleasePreparationWorkflow(skip_approve_if_clean=False)

        # Then
        assert workflow.skip_approve_if_clean is False

    def test_given_security_crew_disabled_when_initialized_then_sets_standard_stages(self):
        """Given use_security_crew=False
        When workflow is initialized
        Then it sets standard stages without crew_security.
        """
        # Given / When
        workflow = ReleasePreparationWorkflow(use_security_crew=False)

        # Then
        assert workflow.stages == ["health", "security", "changelog", "approve"]
        assert "crew_security" not in workflow.tier_map
        assert workflow.tier_map["health"] == ModelTier.CHEAP
        assert workflow.tier_map["security"] == ModelTier.CAPABLE
        assert workflow.tier_map["changelog"] == ModelTier.CAPABLE
        assert workflow.tier_map["approve"] == ModelTier.PREMIUM

    def test_given_security_crew_enabled_when_initialized_then_adds_crew_security_stage(self):
        """Given use_security_crew=True
        When workflow is initialized
        Then it adds crew_security stage with correct tier.
        """
        # Given / When
        workflow = ReleasePreparationWorkflow(use_security_crew=True)

        # Then
        assert workflow.stages == ["health", "security", "crew_security", "changelog", "approve"]
        assert workflow.tier_map["crew_security"] == ModelTier.PREMIUM
        assert workflow.use_security_crew is True

    def test_given_crew_config_when_initialized_then_stores_config(self):
        """Given crew_config dictionary
        When workflow is initialized
        Then it stores the configuration.
        """
        # Given
        config = {"max_iterations": 10, "verbose": True}

        # When
        workflow = ReleasePreparationWorkflow(crew_config=config)

        # Then
        assert workflow.crew_config == config

    def test_given_kwargs_when_initialized_then_passes_to_base(self):
        """Given additional kwargs
        When workflow is initialized
        Then it passes them to BaseWorkflow.
        """
        # Given / When
        with patch("empathy_os.workflows.release_prep.BaseWorkflow.__init__") as mock_base:
            workflow = ReleasePreparationWorkflow(
                custom_param="value",
                another_param=123
            )

        # Then
        mock_base.assert_called_once()
        call_kwargs = mock_base.call_args[1]
        assert "custom_param" in call_kwargs
        assert call_kwargs["custom_param"] == "value"


class TestReleasePreparationWorkflowRunHealthStage:
    """Tests for _run_health_stage method."""

    def test_given_clean_health_check_when_run_then_returns_success(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given all health checks pass
        When _run_health_stage is called
        Then it returns success status.
        """
        # Given
        mock_subprocess.run.return_value = Mock(
            returncode=0,
            stdout="All checks passed",
            stderr=""
        )

        # When
        result = base_workflow_instance._run_health_stage()

        # Then
        assert result["status"] == "success"
        assert "Health checks passed" in result["output"]
        assert base_workflow_instance._has_blockers is False

    def test_given_failing_health_check_when_run_then_returns_failure(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given health checks fail
        When _run_health_stage is called
        Then it returns failure status and sets blockers.
        """
        # Given
        mock_subprocess.run.return_value = Mock(
            returncode=1,
            stdout="",
            stderr="Lint errors found"
        )

        # When
        result = base_workflow_instance._run_health_stage()

        # Then
        assert result["status"] == "failure"
        assert "Health checks failed" in result["output"]
        assert base_workflow_instance._has_blockers is True

    def test_given_subprocess_exception_when_run_then_handles_error(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given subprocess raises exception
        When _run_health_stage is called
        Then it handles the error gracefully.
        """
        # Given
        mock_subprocess.run.side_effect = subprocess.SubprocessError("Command failed")

        # When
        result = base_workflow_instance._run_health_stage()

        # Then
        assert result["status"] == "error"
        assert "Command failed" in result["output"]
        assert base_workflow_instance._has_blockers is True

    def test_given_health_stage_when_run_then_executes_correct_commands(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given health stage
        When _run_health_stage is called
        Then it executes the correct health check commands.
        """
        # Given
        mock_subprocess.run.return_value = Mock(returncode=0, stdout="", stderr="")

        # When
        base_workflow_instance._run_health_stage()

        # Then
        # Verify subprocess.run was called with appropriate commands
        assert mock_subprocess.run.called


class TestReleasePreparationWorkflowRunSecurityStage:
    """Tests for _run_security_stage method."""

    def test_given_no_security_issues_when_run_then_returns_success(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given no security issues found
        When _run_security_stage is called
        Then it returns success status.
        """
        # Given
        mock_subprocess.run.return_value = Mock(
            returncode=0,
            stdout="No security issues found",
            stderr=""
        )

        # When
        result = base_workflow_instance._run_security_stage()

        # Then
        assert result["status"] == "success"
        assert "No security issues" in result["output"]
        assert base_workflow_instance._has_blockers is False

    def test_given_security_issues_found_when_run_then_returns_warning(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given security issues are found
        When _run_security_stage is called
        Then it returns warning status and sets blockers.
        """
        # Given
        mock_subprocess.run.return_value = Mock(
            returncode=1,
            stdout="",
            stderr="3 vulnerabilities found"
        )

        # When
        result = base_workflow_instance._run_security_stage()

        # Then
        assert result["status"] in ["warning", "failure"]
        assert base_workflow_instance._has_blockers is True

    def test_given_security_scan_error_when_run_then_handles_error(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given security scan raises exception
        When _run_security_stage is called
        Then it handles the error gracefully.
        """
        # Given
        mock_subprocess.run.side_effect = Exception("Scanner not found")

        # When
        result = base_workflow_instance._run_security_stage()

        # Then
        assert result["status"] == "error"
        assert "Scanner not found" in result["output"]


class TestReleasePreparationWorkflowRunCrewSecurityStage:
    """Tests for _run_crew_security_stage method."""

    def test_given_crew_disabled_when_run_then_skips_stage(
        self, base_workflow_instance
    ):
        """Given security crew is disabled
        When _run_crew_security_stage is called
        Then it skips the stage.
        """
        # Given / When
        result = base_workflow_instance._run_crew_security_stage()

        # Then
        assert result["status"] == "skipped"
        assert "not enabled" in result["output"]

    def test_given_crew_enabled_when_run_then_executes_crew(
        self, workflow_with_security_crew
    ):
        """Given security crew is enabled
        When _run_crew_security_stage is called
        Then it executes the security crew.
        """
        # Given
        with patch("empathy_os.workflows.release_prep.SecurityAuditCrew") as mock_crew:
            mock_instance = Mock()
            mock_instance.kickoff.return_value = {
                "status": "success",
                "findings": []
            }
            mock_crew.return_value = mock_instance

            # When
            result = workflow_with_security_crew._run_crew_security_stage()

            # Then
            assert result["status"] == "success"
            mock_crew.assert_called_once()

    def test_given_crew_finds_issues_when_run_then_sets_blockers(
        self, workflow_with_security_crew
    ):
        """Given security crew finds critical issues
        When _run_crew_security_stage is called
        Then it sets blockers flag.
        """
        # Given
        with patch("empathy_os.workflows.release_prep.SecurityAuditCrew") as mock_crew:
            mock_instance = Mock()
            mock_instance.kickoff.return_value = {
                "status": "critical",
                "findings": ["SQL injection vulnerability"]
            }
            mock_crew.return_value = mock_instance

            # When
            result = workflow_with_security_crew._run_crew_security_stage()

            # Then
            assert workflow_with_security_crew._has_blockers is True

    def test_given_crew_raises_exception_when_run_then_handles_error(
        self, workflow_with_security_crew
    ):
        """Given security crew raises exception
        When _run_crew_security_stage is called
        Then it handles the error gracefully.
        """
        # Given
        with patch("empathy_os.workflows.release_prep.SecurityAuditCrew") as mock_crew:
            mock_crew.side_effect = Exception("Crew initialization failed")

            # When
            result = workflow_with_security_crew._run_crew_security_stage()

            # Then
            assert result["status"] == "error"
            assert "Crew initialization failed" in result["output"]


class TestReleasePreparationWorkflowRunChangelogStage:
    """Tests for _run_changelog_stage method."""

    def test_given_git_commits_when_run_then_generates_changelog(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given git commits exist
        When _run_changelog_stage is called
        Then it generates a changelog.
        """
        # Given
        mock_subprocess.run.return_value = Mock(
            returncode=0,
            stdout="commit1\ncommit2\ncommit3",
            stderr=""
        )

        # When
        result = base_workflow_instance._run_changelog_stage()

        # Then
        assert result["status"] == "success"
        assert "changelog" in result["output"].lower()

    def test_given_no_commits_when_run_then_returns_empty_changelog(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given no new commits
        When _run_changelog_stage is called
        Then it returns an empty changelog.
        """
        # Given
        mock_subprocess.run.return_value = Mock(
            returncode=0,
            stdout="",
            stderr=""
        )

        # When
        result = base_workflow_instance._run_changelog_stage()

        # Then
        assert result["status"] == "success"
        assert "no changes" in result["output"].lower() or "empty" in result["output"].lower()

    def test_given_git_error_when_run_then_handles_error(
        self, base_workflow_instance, mock_subprocess
    ):
        """Given git command fails
        When _run_changelog_stage is called
        Then it handles the error gracefully.
        """
        # Given
        mock_subprocess.run.side_effect = subprocess.CalledProcessError(
            1, "git", stderr="Not a git repository"
        )

        # When
        result = base_workflow_instance._run_changelog_stage()

        # Then
        assert result["status"] == "error"


class TestReleasePreparationWorkflowRunApproveStage:
    """Tests for _run_approve_stage method."""

    def test_given_skip_approve_and_no_blockers_when_run_then_skips(
        self, base_workflow_instance
    ):
        """Given skip_approve_if_clean=True and no blockers
        When _run_approve_stage is called
        Then it skips the approval stage.
        """
        # Given
        base_workflow_instance._has_blockers = False
        base_workflow_instance.skip_approve_if_clean = True

        # When
        result = base_workflow_instance._run_approve_stage({})

        # Then
        assert result["status"] == "skipped"
        assert "Auto-approved" in result["output"]

    def test_given_skip_approve_false_when_run_then_performs_approval(
        self, base_workflow_instance
    ):
        """Given skip_approve_if_clean=False
        When _run_approve_stage is called
        Then it performs the approval check.
        """
        # Given
        base_