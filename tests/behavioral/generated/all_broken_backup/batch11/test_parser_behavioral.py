"""Behavioral tests for parser.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import pytest
import xml.etree.ElementTree as ET

from empathy_os.prompts.parser import Finding, ParsedResponse, parse_xml_response


class TestFinding:
    """Behavioral tests for Finding dataclass."""

    def test_finding_creation_with_all_fields(self):
        """Given all fields, when creating Finding, then all fields are set."""
        # Given
        severity = "critical"
        title = "SQL Injection Vulnerability"
        location = "user_auth.py:45"
        details = "User input not sanitized"
        fix = "Use parameterized queries"

        # When
        finding = Finding(
            severity=severity,
            title=title,
            location=location,
            details=details,
            fix=fix,
        )

        # Then
        assert finding.severity == severity
        assert finding.title == title
        assert finding.location == location
        assert finding.details == details
        assert finding.fix == fix

    def test_finding_creation_with_minimal_fields(self):
        """Given only required fields, when creating Finding, then defaults are used."""
        # Given
        severity = "medium"
        title = "Code smell detected"

        # When
        finding = Finding(severity=severity, title=title)

        # Then
        assert finding.severity == severity
        assert finding.title == title
        assert finding.location is None
        assert finding.details == ""
        assert finding.fix == ""

    def test_finding_to_dict_converts_all_fields(self):
        """Given a Finding, when converting to dict, then all fields are included."""
        # Given
        finding = Finding(
            severity="high",
            title="Memory leak",
            location="memory.py:100",
            details="Buffer not freed",
            fix="Add cleanup code",
        )

        # When
        result = finding.to_dict()

        # Then
        assert result == {
            "severity": "high",
            "title": "Memory leak",
            "location": "memory.py:100",
            "details": "Buffer not freed",
            "fix": "Add cleanup code",
        }

    def test_finding_to_dict_with_none_location(self):
        """Given a Finding with None location, when converting to dict, then None is preserved."""
        # Given
        finding = Finding(severity="low", title="Minor issue")

        # When
        result = finding.to_dict()

        # Then
        assert result["location"] is None

    def test_finding_from_dict_with_all_fields(self):
        """Given a complete dict, when creating Finding from dict, then all fields are set."""
        # Given
        data = {
            "severity": "critical",
            "title": "XSS vulnerability",
            "location": "template.html:23",
            "details": "Unescaped output",
            "fix": "Use template escaping",
        }

        # When
        finding = Finding.from_dict(data)

        # Then
        assert finding.severity == "critical"
        assert finding.title == "XSS vulnerability"
        assert finding.location == "template.html:23"
        assert finding.details == "Unescaped output"
        assert finding.fix == "Use template escaping"

    def test_finding_from_dict_with_missing_fields(self):
        """Given a dict with missing fields, when creating Finding, then defaults are used."""
        # Given
        data = {"title": "Issue"}

        # When
        finding = Finding.from_dict(data)

        # Then
        assert finding.severity == "medium"
        assert finding.title == "Issue"
        assert finding.location is None
        assert finding.details == ""
        assert finding.fix == ""

    def test_finding_from_dict_with_empty_strings(self):
        """Given a dict with empty strings, when creating Finding, then empty strings are preserved."""
        # Given
        data = {
            "severity": "",
            "title": "",
            "location": "",
            "details": "",
            "fix": "",
        }

        # When
        finding = Finding.from_dict(data)

        # Then
        assert finding.severity == ""
        assert finding.title == ""
        assert finding.location == ""
        assert finding.details == ""
        assert finding.fix == ""

    def test_finding_roundtrip_serialization(self):
        """Given a Finding, when converting to dict and back, then object is preserved."""
        # Given
        original = Finding(
            severity="high",
            title="Security issue",
            location="auth.py:50",
            details="Weak encryption",
            fix="Use stronger algorithm",
        )

        # When
        as_dict = original.to_dict()
        restored = Finding.from_dict(as_dict)

        # Then
        assert restored.severity == original.severity
        assert restored.title == original.title
        assert restored.location == original.location
        assert restored.details == original.details
        assert restored.fix == original.fix


class TestParsedResponse:
    """Behavioral tests for ParsedResponse dataclass."""

    def test_parsed_response_creation_with_all_fields(self):
        """Given all fields, when creating ParsedResponse, then all fields are set."""
        # Given
        finding = Finding(severity="high", title="Issue")
        
        # When
        response = ParsedResponse(
            success=True,
            raw="<root>test</root>",
            summary="Test summary",
            findings=[finding],
            checklist=["item1", "item2"],
            errors=["error1"],
            extra={"key": "value"},
        )

        # Then
        assert response.success is True
        assert response.raw == "<root>test</root>"
        assert response.summary == "Test summary"
        assert len(response.findings) == 1
        assert response.findings[0] == finding
        assert response.checklist == ["item1", "item2"]
        assert response.errors == ["error1"]
        assert response.extra == {"key": "value"}

    def test_parsed_response_creation_with_minimal_fields(self):
        """Given only required fields, when creating ParsedResponse, then defaults are used."""
        # Given/When
        response = ParsedResponse(success=False, raw="raw text")

        # Then
        assert response.success is False
        assert response.raw == "raw text"
        assert response.summary is None
        assert response.findings == []
        assert response.checklist == []
        assert response.errors == []
        assert response.extra == {}

    def test_parsed_response_to_dict_converts_all_fields(self):
        """Given a ParsedResponse, when converting to dict, then all fields are included."""
        # Given
        finding = Finding(severity="low", title="Minor")
        response = ParsedResponse(
            success=True,
            raw="<xml/>",
            summary="Summary",
            findings=[finding],
            checklist=["check1"],
            errors=["err1"],
            extra={"data": 123},
        )

        # When
        result = response.to_dict()

        # Then
        assert result["success"] is True
        assert result["raw"] == "<xml/>"
        assert result["summary"] == "Summary"
        assert len(result["findings"]) == 1
        assert result["findings"][0]["severity"] == "low"
        assert result["checklist"] == ["check1"]
        assert result["errors"] == ["err1"]
        assert result["extra"] == {"data": 123}

    def test_parsed_response_to_dict_with_multiple_findings(self):
        """Given a ParsedResponse with multiple findings, when converting to dict, then all findings are included."""
        # Given
        findings = [
            Finding(severity="high", title="Issue 1"),
            Finding(severity="medium", title="Issue 2"),
            Finding(severity="low", title="Issue 3"),
        ]
        response = ParsedResponse(success=True, raw="", findings=findings)

        # When
        result = response.to_dict()

        # Then
        assert len(result["findings"]) == 3
        assert result["findings"][0]["title"] == "Issue 1"
        assert result["findings"][1]["title"] == "Issue 2"
        assert result["findings"][2]["title"] == "Issue 3"

    def test_parsed_response_from_dict_with_all_fields(self):
        """Given a complete dict, when creating ParsedResponse from dict, then all fields are set."""
        # Given
        data = {
            "success": True,
            "raw": "<test/>",
            "summary": "Test",
            "findings": [
                {"severity": "high", "title": "Finding 1"},
                {"severity": "low", "title": "Finding 2"},
            ],
            "checklist": ["a", "b"],
            "errors": ["e1"],
            "extra": {"x": 1},
        }

        # When
        response = ParsedResponse.from_dict(data)

        # Then
        assert response.success is True
        assert response.raw == "<test/>"
        assert response.summary == "Test"
        assert len(response.findings) == 2
        assert response.findings[0].title == "Finding 1"
        assert response.findings[1].title == "Finding 2"
        assert response.checklist == ["a", "b"]
        assert response.errors == ["e1"]
        assert response.extra == {"x": 1}

    def test_parsed_response_from_dict_with_missing_fields(self):
        """Given a dict with missing fields, when creating ParsedResponse, then defaults are used."""
        # Given
        data = {}

        # When
        response = ParsedResponse.from_dict(data)

        # Then
        assert response.success is False
        assert response.raw == ""
        assert response.summary is None
        assert response.findings == []
        assert response.checklist == []
        assert response.errors == []
        assert response.extra == {}

    def test_parsed_response_from_dict_with_empty_findings(self):
        """Given a dict with empty findings list, when creating ParsedResponse, then findings is empty."""
        # Given
        data = {"success": True, "raw": "test", "findings": []}

        # When
        response = ParsedResponse.from_dict(data)

        # Then
        assert response.findings == []

    def test_parsed_response_roundtrip_serialization(self):
        """Given a ParsedResponse, when converting to dict and back, then object is preserved."""
        # Given
        original = ParsedResponse(
            success=True,
            raw="<root>content</root>",
            summary="Summary text",
            findings=[Finding(severity="medium", title="Test finding")],
            checklist=["item"],
            errors=["error"],
            extra={"custom": "data"},
        )

        # When
        as_dict = original.to_dict()
        restored = ParsedResponse.from_dict(as_dict)

        # Then
        assert restored.success == original.success
        assert restored.raw == original.raw
        assert restored.summary == original.summary
        assert len(restored.findings) == len(original.findings)
        assert restored.findings[0].title == original.findings[0].title
        assert restored.checklist == original.checklist
        assert restored.errors == original.errors
        assert restored.extra == original.extra

    def test_parsed_response_from_raw_creates_failed_response(self):
        """Given raw text, when creating ParsedResponse from raw, then failed response is created."""
        # Given
        raw_text = "This is unparsed text"

        # When
        response = ParsedResponse.from_raw(raw_text)

        # Then
        assert response.success is False
        assert response.raw == raw_text
        assert response.summary is None
        assert response.findings == []
        assert response.checklist == []
        assert response.errors == []
        assert response.extra == {}

    def test_parsed_response_from_raw_with_errors(self):
        """Given raw text and errors, when creating ParsedResponse from raw, then errors are included."""
        # Given
        raw_text = "Unparsed content"
        errors = ["Parse error 1", "Parse error 2"]

        # When
        response = ParsedResponse.from_raw(raw_text, errors=errors)

        # Then
        assert response.success is False
        assert response.raw == raw_text
        assert response.errors == errors

    def test_parsed_response_from_raw_with_none_errors(self):
        """Given raw text and None errors, when creating ParsedResponse from raw, then errors is empty."""
        # Given
        raw_text = "Content"

        # When
        response = ParsedResponse.from_raw(raw_text, errors=None)

        # Then
        assert response.errors == []

    def test_parsed_response_from_raw_with_empty_errors(self):
        """Given raw text and empty errors list, when creating ParsedResponse from raw, then errors is empty."""
        # Given
        raw_text = "Content"

        # When
        response = ParsedResponse.from_raw(raw_text, errors=[])

        # Then
        assert response.errors == []


class TestParseXmlResponse:
    """Behavioral tests for parse_xml_response function."""

    def test_parse_valid_xml_with_summary(self):
        """Given valid XML with summary, when parsing, then summary is extracted."""
        # Given
        xml_response = """
        <response>
            <summary>This is a test summary</summary>
        </response>
        """

        # When
        result = parse_xml_response(xml_response)

        # Then
        assert result.success is True
        assert result.summary == "This is a test summary"
        assert len(result.findings) == 0
        assert len(result.errors) == 0

    def test_parse_valid_xml_with_single_finding(self):
        """Given valid XML with one finding, when parsing, then finding is extracted."""
        # Given
        xml_response = """
        <response>
            <findings>
                <finding>
                    <severity>high</severity>
                    <title>Security Issue</title>
                    <location>file.py:10</location>
                    <details>Detailed description</details>
                    <fix>How to fix it</fix>
                </finding>
            </findings>
        </response>
        """

        # When
        result = parse_xml_response(xml_response)

        # Then
        assert result.success is True
        assert len(result.findings) == 1
        assert result.findings[0].severity == "high"
        assert result.findings[0].title == "Security Issue"
        assert result.findings[0].location == "file.py:10"
        assert result.findings[0].details == "Detailed description"
        assert result.findings[0].fix == "How to fix it"

    def test_parse_valid_xml_with_multiple_findings(self):
        """Given valid XML with multiple findings, when parsing, then all findings are extracted."""
        # Given
        xml_response = """
        <response>
            <findings>
                <finding>
                    <severity>critical</severity>
                    <title>Issue 1</title>
                </finding>
                <finding>
                    <severity>medium</severity>
                    <title>Issue 2</title>
                </finding>
                <finding>
                    <severity>low</severity>
                    <title>Issue 3</title>
                </finding>
            </findings>
        </response>
        """

        # When
        result = parse_xml_response(xml_response)

        # Then
        assert result.success is True
        assert len(result.findings) == 3
        assert result.findings[0].severity == "critical"
        assert result.findings[1].severity == "medium"
        assert result.findings[2].severity == "low"

    def test_parse_valid_xml_with_checklist(self):