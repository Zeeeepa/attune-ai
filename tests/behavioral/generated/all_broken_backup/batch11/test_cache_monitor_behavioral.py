"""Behavioral tests for cache_monitor.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from datetime import datetime
from unittest.mock import patch

import pytest

from empathy_os.cache_monitor import CacheMonitor, CacheStats


# Fixtures
@pytest.fixture
def cache_stats():
    """Given a fresh CacheStats instance."""
    return CacheStats(name="test_cache", max_size=100)


@pytest.fixture
def populated_cache_stats():
    """Given a CacheStats instance with recorded data."""
    stats = CacheStats(name="populated_cache", max_size=100)
    stats.hits = 80
    stats.misses = 20
    stats.evictions = 5
    stats.size = 75
    return stats


@pytest.fixture
def cache_monitor():
    """Given a fresh CacheMonitor instance."""
    # Reset singleton state
    CacheMonitor._instance = None
    return CacheMonitor.get_instance()


@pytest.fixture
def fixed_datetime():
    """Given a fixed datetime for testing."""
    return datetime(2025, 1, 15, 12, 0, 0)


# CacheStats Tests
class TestCacheStatsInitialization:
    """Tests for CacheStats initialization."""

    def test_given_name_when_created_then_initializes_with_defaults(self):
        """Given a cache name, when CacheStats is created, then it initializes with default values."""
        # When
        stats = CacheStats(name="my_cache")

        # Then
        assert stats.name == "my_cache"
        assert stats.hits == 0
        assert stats.misses == 0
        assert stats.evictions == 0
        assert stats.size == 0
        assert stats.max_size == 0
        assert isinstance(stats.created_at, datetime)
        assert isinstance(stats.last_updated, datetime)

    def test_given_custom_values_when_created_then_uses_provided_values(self):
        """Given custom values, when CacheStats is created, then it uses provided values."""
        # Given
        created = datetime(2025, 1, 1, 0, 0, 0)

        # When
        stats = CacheStats(
            name="custom_cache",
            hits=10,
            misses=5,
            evictions=2,
            size=50,
            max_size=100,
            created_at=created,
        )

        # Then
        assert stats.name == "custom_cache"
        assert stats.hits == 10
        assert stats.misses == 5
        assert stats.evictions == 2
        assert stats.size == 50
        assert stats.max_size == 100
        assert stats.created_at == created


class TestCacheStatsProperties:
    """Tests for CacheStats computed properties."""

    def test_given_no_requests_when_total_requests_then_returns_zero(
        self, cache_stats
    ):
        """Given no cache requests, when total_requests is accessed, then returns 0."""
        # Then
        assert cache_stats.total_requests == 0

    def test_given_hits_and_misses_when_total_requests_then_returns_sum(
        self, cache_stats
    ):
        """Given hits and misses, when total_requests is accessed, then returns sum."""
        # Given
        cache_stats.hits = 80
        cache_stats.misses = 20

        # Then
        assert cache_stats.total_requests == 100

    def test_given_no_requests_when_hit_rate_then_returns_zero(self, cache_stats):
        """Given no requests, when hit_rate is accessed, then returns 0.0."""
        # Then
        assert cache_stats.hit_rate == 0.0

    def test_given_all_hits_when_hit_rate_then_returns_one(self, cache_stats):
        """Given all hits, when hit_rate is accessed, then returns 1.0."""
        # Given
        cache_stats.hits = 100

        # Then
        assert cache_stats.hit_rate == 1.0

    def test_given_mixed_requests_when_hit_rate_then_calculates_correctly(
        self, populated_cache_stats
    ):
        """Given mixed hits and misses, when hit_rate is accessed, then calculates correctly."""
        # Then
        assert populated_cache_stats.hit_rate == 0.8

    def test_given_no_requests_when_miss_rate_then_returns_one(self, cache_stats):
        """Given no requests, when miss_rate is accessed, then returns 1.0."""
        # Then
        assert cache_stats.miss_rate == 1.0

    def test_given_all_hits_when_miss_rate_then_returns_zero(self, cache_stats):
        """Given all hits, when miss_rate is accessed, then returns 0.0."""
        # Given
        cache_stats.hits = 100

        # Then
        assert cache_stats.miss_rate == 0.0

    def test_given_mixed_requests_when_miss_rate_then_calculates_correctly(
        self, populated_cache_stats
    ):
        """Given mixed hits and misses, when miss_rate is accessed, then calculates correctly."""
        # Then
        assert populated_cache_stats.miss_rate == 0.2

    def test_given_no_max_size_when_utilization_then_returns_zero(self, cache_stats):
        """Given no max_size, when utilization is accessed, then returns 0.0."""
        # Given
        cache_stats.size = 50

        # Then
        assert cache_stats.utilization == 0.0

    def test_given_size_and_max_size_when_utilization_then_calculates_correctly(
        self, populated_cache_stats
    ):
        """Given size and max_size, when utilization is accessed, then calculates correctly."""
        # Then
        assert populated_cache_stats.utilization == 0.75

    def test_given_full_cache_when_utilization_then_returns_one(self, cache_stats):
        """Given full cache, when utilization is accessed, then returns 1.0."""
        # Given
        cache_stats.size = 100
        cache_stats.max_size = 100

        # Then
        assert cache_stats.utilization == 1.0


class TestCacheStatsRecordMethods:
    """Tests for CacheStats recording methods."""

    @patch("empathy_os.cache_monitor.datetime")
    def test_given_cache_stats_when_record_hit_then_increments_hits(
        self, mock_datetime, cache_stats, fixed_datetime
    ):
        """Given cache stats, when record_hit is called, then increments hits and updates timestamp."""
        # Given
        mock_datetime.now.return_value = fixed_datetime
        initial_hits = cache_stats.hits

        # When
        cache_stats.record_hit()

        # Then
        assert cache_stats.hits == initial_hits + 1
        assert cache_stats.last_updated == fixed_datetime

    @patch("empathy_os.cache_monitor.datetime")
    def test_given_cache_stats_when_record_miss_then_increments_misses(
        self, mock_datetime, cache_stats, fixed_datetime
    ):
        """Given cache stats, when record_miss is called, then increments misses and updates timestamp."""
        # Given
        mock_datetime.now.return_value = fixed_datetime
        initial_misses = cache_stats.misses

        # When
        cache_stats.record_miss()

        # Then
        assert cache_stats.misses == initial_misses + 1
        assert cache_stats.last_updated == fixed_datetime

    @patch("empathy_os.cache_monitor.datetime")
    def test_given_cache_stats_when_record_eviction_then_increments_evictions(
        self, mock_datetime, cache_stats, fixed_datetime
    ):
        """Given cache stats, when record_eviction is called, then increments evictions and updates timestamp."""
        # Given
        mock_datetime.now.return_value = fixed_datetime
        initial_evictions = cache_stats.evictions

        # When
        cache_stats.record_eviction()

        # Then
        assert cache_stats.evictions == initial_evictions + 1
        assert cache_stats.last_updated == fixed_datetime

    @patch("empathy_os.cache_monitor.datetime")
    def test_given_cache_stats_when_update_size_then_updates_size(
        self, mock_datetime, cache_stats, fixed_datetime
    ):
        """Given cache stats, when update_size is called, then updates size and timestamp."""
        # Given
        mock_datetime.now.return_value = fixed_datetime

        # When
        cache_stats.update_size(75)

        # Then
        assert cache_stats.size == 75
        assert cache_stats.last_updated == fixed_datetime

    @patch("empathy_os.cache_monitor.datetime")
    def test_given_cache_stats_when_update_size_with_max_then_updates_both(
        self, mock_datetime, cache_stats, fixed_datetime
    ):
        """Given cache stats, when update_size with max_size is called, then updates both."""
        # Given
        mock_datetime.now.return_value = fixed_datetime

        # When
        cache_stats.update_size(75, max_size=200)

        # Then
        assert cache_stats.size == 75
        assert cache_stats.max_size == 200
        assert cache_stats.last_updated == fixed_datetime

    @patch("empathy_os.cache_monitor.datetime")
    def test_given_cache_stats_when_update_size_without_max_then_preserves_max(
        self, mock_datetime, cache_stats, fixed_datetime
    ):
        """Given cache stats with existing max_size, when update_size without max_size is called, then preserves max_size."""
        # Given
        mock_datetime.now.return_value = fixed_datetime
        cache_stats.max_size = 150

        # When
        cache_stats.update_size(80)

        # Then
        assert cache_stats.size == 80
        assert cache_stats.max_size == 150


class TestCacheStatsToDict:
    """Tests for CacheStats to_dict export."""

    def test_given_fresh_stats_when_to_dict_then_exports_all_fields(self, cache_stats):
        """Given fresh cache stats, when to_dict is called, then exports all fields."""
        # When
        result = cache_stats.to_dict()

        # Then
        assert result["name"] == "test_cache"
        assert result["hits"] == 0
        assert result["misses"] == 0
        assert result["evictions"] == 0
        assert result["total_requests"] == 0
        assert result["hit_rate"] == 0.0
        assert result["miss_rate"] == 1.0
        assert result["size"] == 0
        assert result["max_size"] == 100
        assert result["utilization"] == 0.0
        assert isinstance(result["created_at"], str)
        assert isinstance(result["last_updated"], str)

    def test_given_populated_stats_when_to_dict_then_exports_correct_values(
        self, populated_cache_stats
    ):
        """Given populated cache stats, when to_dict is called, then exports correct calculated values."""
        # When
        result = populated_cache_stats.to_dict()

        # Then
        assert result["name"] == "populated_cache"
        assert result["hits"] == 80
        assert result["misses"] == 20
        assert result["evictions"] == 5
        assert result["total_requests"] == 100
        assert result["hit_rate"] == 0.8
        assert result["miss_rate"] == 0.2
        assert result["size"] == 75
        assert result["max_size"] == 100
        assert result["utilization"] == 0.75

    def test_given_stats_when_to_dict_then_rounds_floats_to_four_decimals(
        self, cache_stats
    ):
        """Given cache stats with fractional values, when to_dict is called, then rounds floats to 4 decimals."""
        # Given
        cache_stats.hits = 2
        cache_stats.misses = 3
        cache_stats.size = 33
        cache_stats.max_size = 100

        # When
        result = cache_stats.to_dict()

        # Then
        assert result["hit_rate"] == 0.4
        assert result["miss_rate"] == 0.6
        assert result["utilization"] == 0.33


class TestCacheMonitorSingleton:
    """Tests for CacheMonitor singleton pattern."""

    def test_given_no_instance_when_get_instance_then_creates_instance(self):
        """Given no existing instance, when get_instance is called, then creates new instance."""
        # Given
        CacheMonitor._instance = None

        # When
        monitor = CacheMonitor.get_instance()

        # Then
        assert isinstance(monitor, CacheMonitor)
        assert CacheMonitor._instance is monitor

    def test_given_existing_instance_when_get_instance_then_returns_same_instance(
        self, cache_monitor
    ):
        """Given existing instance, when get_instance is called, then returns same instance."""
        # Given
        first_monitor = cache_monitor

        # When
        second_monitor = CacheMonitor.get_instance()

        # Then
        assert first_monitor is second_monitor


class TestCacheMonitorRegistration:
    """Tests for cache registration."""

    def test_given_monitor_when_register_cache_then_creates_stats(
        self, cache_monitor
    ):
        """Given cache monitor, when register_cache is called, then creates cache stats."""
        # When
        cache_monitor.register_cache("new_cache", max_size=200)

        # Then
        assert "new_cache" in cache_monitor._caches
        stats = cache_monitor._caches["new_cache"]
        assert stats.name == "new_cache"
        assert stats.max_size == 200

    def test_given_monitor_when_register_cache_without_max_size_then_defaults_zero(
        self, cache_monitor
    ):
        """Given cache monitor, when register_cache without max_size is called, then defaults to 0."""
        # When
        cache_monitor.register_cache("unlimited_cache")

        # Then
        stats = cache_monitor._caches["unlimited_cache"]
        assert stats.max_size == 0

    def test_given_existing_cache_when_register_again_then_replaces_stats(
        self, cache_monitor
    ):
        """Given existing cache, when register_cache is called again, then replaces stats."""
        # Given
        cache_monitor.register_cache("cache1", max_size=100)
        cache_monitor._caches["cache1"].hits = 50

        # When
        cache_monitor.register_cache("cache1", max_size=200)

        # Then
        stats = cache_monitor._caches["cache1"]
        assert stats.max_size == 200
        assert stats.hits == 0  # Fresh stats


class TestCacheMonitorGetStats:
    """Tests for getting cache statistics."""

    def test_given_registered_cache_when_get_stats_then_returns_stats(
        self, cache_monitor
    ):
        """Given registered cache, when get_stats is called, then returns cache stats."""
        # Given
        cache_monitor.register_cache("test_cache", max_size=100)

        # When
        stats = cache_monitor.get_stats("test_cache")

        # Then
        assert stats is not None
        assert stats.name == "test_cache"

    def test_given_unregistered_cache_when_get_stats_