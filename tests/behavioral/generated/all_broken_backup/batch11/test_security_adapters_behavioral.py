"""Behavioral tests for security_adapters.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
from typing import Any
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from empathy_os.workflows.security_adapters import (
    _check_crew_available,
    _get_crew_audit,
    crew_report_to_workflow_format,
)


@pytest.fixture
def mock_security_report():
    """Create a mock SecurityReport object."""
    mock_report = MagicMock()
    
    # Create mock findings
    mock_finding1 = MagicMock()
    mock_finding1.category = MagicMock(value="authentication")
    mock_finding1.title = "Weak Password Policy"
    mock_finding1.description = "Password requirements are insufficient"
    mock_finding1.severity = MagicMock(value="high")
    mock_finding1.file_path = "/path/to/auth.py"
    mock_finding1.line_number = 42
    mock_finding1.code_snippet = "def validate_password(pwd): return len(pwd) > 3"
    mock_finding1.remediation = "Implement stronger password requirements"
    
    mock_finding2 = MagicMock()
    mock_finding2.category = None
    mock_finding2.title = "SQL Injection Risk"
    mock_finding2.description = "Unparameterized SQL query"
    mock_finding2.severity = None
    mock_finding2.file_path = "/path/to/db.py"
    mock_finding2.line_number = 15
    mock_finding2.code_snippet = None
    mock_finding2.remediation = "Use parameterized queries"
    
    mock_report.findings = [mock_finding1, mock_finding2]
    mock_report.summary = "Found 2 security issues"
    mock_report.risk_score = 7.5
    mock_report.recommendations = ["Fix auth issues", "Review SQL queries"]
    mock_report.metadata = {"scan_duration": 45.2, "files_scanned": 100}
    
    return mock_report


@pytest.fixture
def expected_workflow_format():
    """Expected workflow format for the mock report."""
    return {
        "findings": [
            {
                "type": "authentication",
                "title": "Weak Password Policy",
                "description": "Password requirements are insufficient",
                "severity": "high",
                "file": "/path/to/auth.py",
                "line": 42,
                "match": "def validate_password(pwd): return len(pwd) > 3",
                "remediation": "Implement stronger password requirements",
            },
            {
                "type": "other",
                "title": "SQL Injection Risk",
                "description": "Unparameterized SQL query",
                "severity": "medium",
                "file": "/path/to/db.py",
                "line": 15,
                "match": None,
                "remediation": "Use parameterized queries",
            },
        ],
        "assessment": {
            "summary": "Found 2 security issues",
            "risk_score": 7.5,
            "recommendations": ["Fix auth issues", "Review SQL queries"],
        },
        "metadata": {"scan_duration": 45.2, "files_scanned": 100},
    }


class TestCheckCrewAvailable:
    """Behavioral tests for _check_crew_available function."""

    def test_given_crew_module_exists_when_checking_then_returns_true(self):
        """Given the SecurityAuditCrew module is available,
        When checking crew availability,
        Then it should return True.
        """
        # Given
        with patch("empathy_os.workflows.security_adapters.importlib") as mock_importlib:
            mock_module = MagicMock()
            
            # When
            with patch.dict("sys.modules", {"empathy_llm_toolkit.agent_factory.crews": mock_module}):
                result = _check_crew_available()
        
        # Then
        assert result is True

    def test_given_crew_module_missing_when_checking_then_returns_false(self):
        """Given the SecurityAuditCrew module is not available,
        When checking crew availability,
        Then it should return False.
        """
        # Given / When
        with patch("empathy_os.workflows.security_adapters.__import__", side_effect=ImportError):
            # Force the import to fail by manipulating the import mechanism
            import sys
            original_modules = sys.modules.copy()
            if "empathy_llm_toolkit.agent_factory.crews" in sys.modules:
                del sys.modules["empathy_llm_toolkit.agent_factory.crews"]
            
            try:
                result = _check_crew_available()
            finally:
                sys.modules.update(original_modules)
        
        # Then
        assert result is False


class TestGetCrewAudit:
    """Behavioral tests for _get_crew_audit function."""

    @pytest.mark.asyncio
    async def test_given_crew_unavailable_when_getting_audit_then_returns_none(self):
        """Given SecurityAuditCrew is not available,
        When attempting to get audit results,
        Then it should return None without attempting audit.
        """
        # Given
        with patch("empathy_os.workflows.security_adapters._check_crew_available", return_value=False):
            # When
            result = await _get_crew_audit(target="/path/to/code")
        
        # Then
        assert result is None

    @pytest.mark.asyncio
    async def test_given_crew_available_when_getting_audit_then_returns_report(self, mock_security_report):
        """Given SecurityAuditCrew is available,
        When getting audit results successfully,
        Then it should return the SecurityReport.
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.audit = AsyncMock(return_value=mock_security_report)
        
        with patch("empathy_os.workflows.security_adapters._check_crew_available", return_value=True):
            with patch("empathy_os.workflows.security_adapters.SecurityAuditCrew", return_value=mock_crew):
                with patch("empathy_os.workflows.security_adapters.SecurityAuditConfig") as mock_config:
                    # When
                    result = await _get_crew_audit(target="/path/to/code")
        
        # Then
        assert result == mock_security_report
        mock_crew.audit.assert_called_once_with("/path/to/code")

    @pytest.mark.asyncio
    async def test_given_custom_config_when_getting_audit_then_uses_config(self, mock_security_report):
        """Given custom configuration is provided,
        When getting audit results,
        Then it should use the provided config.
        """
        # Given
        custom_config = {"max_depth": 5, "exclude_patterns": ["*.test.py"]}
        mock_crew = MagicMock()
        mock_crew.audit = AsyncMock(return_value=mock_security_report)
        
        with patch("empathy_os.workflows.security_adapters._check_crew_available", return_value=True):
            with patch("empathy_os.workflows.security_adapters.SecurityAuditCrew", return_value=mock_crew):
                with patch("empathy_os.workflows.security_adapters.SecurityAuditConfig") as mock_config_class:
                    # When
                    result = await _get_crew_audit(target="/path/to/code", config=custom_config)
        
        # Then
        mock_config_class.assert_called_once_with(**custom_config)
        assert result == mock_security_report

    @pytest.mark.asyncio
    async def test_given_timeout_when_audit_exceeds_timeout_then_returns_none(self):
        """Given a timeout is set,
        When the audit exceeds the timeout,
        Then it should return None and log warning.
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.audit = AsyncMock(side_effect=asyncio.TimeoutError())
        
        with patch("empathy_os.workflows.security_adapters._check_crew_available", return_value=True):
            with patch("empathy_os.workflows.security_adapters.SecurityAuditCrew", return_value=mock_crew):
                with patch("empathy_os.workflows.security_adapters.SecurityAuditConfig"):
                    with patch("empathy_os.workflows.security_adapters.logger") as mock_logger:
                        # When
                        result = await _get_crew_audit(target="/path/to/code", timeout=1.0)
        
        # Then
        assert result is None
        mock_logger.warning.assert_called_once()
        assert "timed out" in mock_logger.warning.call_args[0][0]

    @pytest.mark.asyncio
    async def test_given_audit_raises_exception_when_getting_audit_then_returns_none(self):
        """Given the audit process raises an exception,
        When getting audit results,
        Then it should return None and log warning.
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.audit = AsyncMock(side_effect=ValueError("Audit failed"))
        
        with patch("empathy_os.workflows.security_adapters._check_crew_available", return_value=True):
            with patch("empathy_os.workflows.security_adapters.SecurityAuditCrew", return_value=mock_crew):
                with patch("empathy_os.workflows.security_adapters.SecurityAuditConfig"):
                    with patch("empathy_os.workflows.security_adapters.logger") as mock_logger:
                        # When
                        result = await _get_crew_audit(target="/path/to/code")
        
        # Then
        assert result is None
        mock_logger.warning.assert_called_once()
        assert "audit failed" in mock_logger.warning.call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_given_no_config_when_getting_audit_then_uses_default_config(self, mock_security_report):
        """Given no custom configuration is provided,
        When getting audit results,
        Then it should use default empty config.
        """
        # Given
        mock_crew = MagicMock()
        mock_crew.audit = AsyncMock(return_value=mock_security_report)
        
        with patch("empathy_os.workflows.security_adapters._check_crew_available", return_value=True):
            with patch("empathy_os.workflows.security_adapters.SecurityAuditCrew", return_value=mock_crew):
                with patch("empathy_os.workflows.security_adapters.SecurityAuditConfig") as mock_config_class:
                    # When
                    result = await _get_crew_audit(target="/path/to/code")
        
        # Then
        mock_config_class.assert_called_once_with()
        assert result == mock_security_report


class TestCrewReportToWorkflowFormat:
    """Behavioral tests for crew_report_to_workflow_format function."""

    def test_given_valid_report_when_converting_then_returns_workflow_format(
        self, mock_security_report, expected_workflow_format
    ):
        """Given a valid SecurityReport,
        When converting to workflow format,
        Then it should return properly formatted dict.
        """
        # Given / When
        result = crew_report_to_workflow_format(mock_security_report)
        
        # Then
        assert result == expected_workflow_format

    def test_given_report_with_no_findings_when_converting_then_returns_empty_findings(self):
        """Given a SecurityReport with no findings,
        When converting to workflow format,
        Then it should return empty findings list.
        """
        # Given
        mock_report = MagicMock()
        mock_report.findings = []
        mock_report.summary = "No issues found"
        mock_report.risk_score = 0.0
        mock_report.recommendations = []
        mock_report.metadata = {}
        
        # When
        result = crew_report_to_workflow_format(mock_report)
        
        # Then
        assert result["findings"] == []
        assert result["assessment"]["summary"] == "No issues found"
        assert result["assessment"]["risk_score"] == 0.0

    def test_given_finding_with_long_snippet_when_converting_then_truncates_snippet(self):
        """Given a finding with code snippet longer than 100 characters,
        When converting to workflow format,
        Then it should truncate the snippet to 100 characters.
        """
        # Given
        mock_finding = MagicMock()
        mock_finding.category = MagicMock(value="test")
        mock_finding.title = "Test Finding"
        mock_finding.description = "Test description"
        mock_finding.severity = MagicMock(value="low")
        mock_finding.file_path = "/test.py"
        mock_finding.line_number = 1
        mock_finding.code_snippet = "x" * 200  # 200 character snippet
        mock_finding.remediation = "Fix it"
        
        mock_report = MagicMock()
        mock_report.findings = [mock_finding]
        mock_report.summary = "Test"
        mock_report.risk_score = 1.0
        mock_report.recommendations = []
        mock_report.metadata = {}
        
        # When
        result = crew_report_to_workflow_format(mock_report)
        
        # Then
        assert len(result["findings"][0]["match"]) == 100
        assert result["findings"][0]["match"] == "x" * 100

    def test_given_finding_with_none_values_when_converting_then_uses_defaults(self):
        """Given a finding with None category and severity,
        When converting to workflow format,
        Then it should use default values (other, medium).
        """
        # Given
        mock_finding = MagicMock()
        mock_finding.category = None
        mock_finding.title = "Test Finding"
        mock_finding.description = "Test description"
        mock_finding.severity = None
        mock_finding.file_path = "/test.py"
        mock_finding.line_number = 1
        mock_finding.code_snippet = None
        mock_finding.remediation = "Fix it"
        
        mock_report = MagicMock()
        mock_report.findings = [mock_finding]
        mock_report.summary = "Test"
        mock_report.risk_score = 1.0
        mock_report.recommendations = []
        mock_report.metadata = {}
        
        # When
        result = crew_report_to_workflow_format(mock_report)
        
        # Then
        assert result["findings"][0]["type"] == "other"
        assert result["findings"][0]["severity"] == "medium"
        assert result["findings"][0]["match"] is None

    def test_given_report_with_multiple_findings_when_converting_then_converts_all(self):
        """Given a SecurityReport with multiple findings,
        When converting to workflow format,
        Then it should convert all findings correctly.
        """
        # Given
        findings = []
        for i in range(5):
            mock_finding = MagicMock()
            mock_finding.category = MagicMock(value=f"category_{i}")
            mock_finding.title = f"Finding {i}"
            mock_finding.description = f"Description {i}"
            mock_finding.severity = MagicMock(