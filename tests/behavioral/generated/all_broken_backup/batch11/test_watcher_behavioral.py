"""Behavioral tests for watcher.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import logging
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch, call

import pytest
from watchdog.events import FileModifiedEvent
from watchdog.observers import Observer

from empathy_os.hot_reload.watcher import (
    WorkflowFileHandler,
    WorkflowFileWatcher,
)


@pytest.fixture
def mock_reload_callback():
    """Provide a mock reload callback function."""
    return Mock()


@pytest.fixture
def workflow_handler(mock_reload_callback):
    """Provide a WorkflowFileHandler instance."""
    return WorkflowFileHandler(reload_callback=mock_reload_callback)


@pytest.fixture
def mock_observer():
    """Provide a mock Observer instance."""
    with patch("empathy_os.hot_reload.watcher.Observer") as mock_obs:
        observer_instance = Mock(spec=Observer)
        mock_obs.return_value = observer_instance
        yield observer_instance


@pytest.fixture
def workflow_dirs(tmp_path):
    """Provide temporary workflow directories."""
    dir1 = tmp_path / "workflows1"
    dir2 = tmp_path / "workflows2"
    dir1.mkdir()
    dir2.mkdir()
    return [dir1, dir2]


class TestWorkflowFileHandler:
    """Behavioral tests for WorkflowFileHandler class."""

    def test_init_sets_callback_and_empty_processing_set(self, mock_reload_callback):
        """
        Given: A reload callback function
        When: WorkflowFileHandler is initialized
        Then: The callback is stored and processing set is empty
        """
        handler = WorkflowFileHandler(reload_callback=mock_reload_callback)
        
        assert handler.reload_callback == mock_reload_callback
        assert handler._processing == set()

    def test_on_modified_ignores_directory_events(self, workflow_handler, mock_reload_callback):
        """
        Given: A directory modification event
        When: on_modified is called
        Then: The callback is not invoked
        """
        event = FileModifiedEvent("/some/directory")
        event.is_directory = True
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_not_called()

    def test_on_modified_ignores_non_python_files(self, workflow_handler, mock_reload_callback):
        """
        Given: A non-Python file modification event
        When: on_modified is called
        Then: The callback is not invoked
        """
        event = FileModifiedEvent("/path/to/file.txt")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_not_called()

    def test_on_modified_ignores_pycache_files(self, workflow_handler, mock_reload_callback):
        """
        Given: A Python file in __pycache__ directory
        When: on_modified is called
        Then: The callback is not invoked
        """
        event = FileModifiedEvent("/path/__pycache__/module.py")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_not_called()

    def test_on_modified_ignores_test_files(self, workflow_handler, mock_reload_callback):
        """
        Given: A test file modification event
        When: on_modified is called
        Then: The callback is not invoked
        """
        event = FileModifiedEvent("/path/to/test_workflow.py")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_not_called()

    def test_on_modified_processes_valid_workflow_file(self, workflow_handler, mock_reload_callback):
        """
        Given: A valid workflow Python file modification event
        When: on_modified is called
        Then: The callback is invoked with workflow ID and file path
        """
        event = FileModifiedEvent("/path/to/my_workflow.py")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_called_once_with("my", "/path/to/my_workflow.py")

    def test_on_modified_handles_bytes_file_path(self, workflow_handler, mock_reload_callback):
        """
        Given: A file modification event with bytes path
        When: on_modified is called
        Then: The path is decoded and processed correctly
        """
        event = FileModifiedEvent(b"/path/to/workflow.py")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_called_once_with("workflow", "/path/to/workflow.py")

    def test_on_modified_prevents_duplicate_processing(self, workflow_handler, mock_reload_callback):
        """
        Given: Multiple events for the same file in quick succession
        When: on_modified is called multiple times
        Then: Only the first event is processed
        """
        event = FileModifiedEvent("/path/to/workflow.py")
        event.is_directory = False
        
        # Add file to processing set manually
        workflow_handler._processing.add("/path/to/workflow.py")
        
        workflow_handler.on_modified(event)
        
        mock_reload_callback.assert_not_called()

    def test_on_modified_removes_from_processing_after_completion(self, workflow_handler):
        """
        Given: A valid workflow file modification event
        When: on_modified completes processing
        Then: The file path is removed from processing set
        """
        event = FileModifiedEvent("/path/to/workflow.py")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        assert "/path/to/workflow.py" not in workflow_handler._processing

    def test_on_modified_removes_from_processing_on_error(self, workflow_handler, mock_reload_callback):
        """
        Given: A callback that raises an exception
        When: on_modified is called
        Then: The file path is still removed from processing set
        """
        mock_reload_callback.side_effect = RuntimeError("Callback error")
        event = FileModifiedEvent("/path/to/workflow.py")
        event.is_directory = False
        
        workflow_handler.on_modified(event)
        
        assert "/path/to/workflow.py" not in workflow_handler._processing

    def test_on_modified_logs_error_on_callback_exception(self, workflow_handler, mock_reload_callback, caplog):
        """
        Given: A callback that raises an exception
        When: on_modified is called
        Then: The error is logged
        """
        mock_reload_callback.side_effect = ValueError("Test error")
        event = FileModifiedEvent("/path/to/workflow.py")
        event.is_directory = False
        
        with caplog.at_level(logging.ERROR):
            workflow_handler.on_modified(event)
        
        assert "Error processing file change" in caplog.text
        assert "Test error" in caplog.text

    def test_on_modified_logs_info_on_successful_detection(self, workflow_handler, caplog):
        """
        Given: A valid workflow file modification event
        When: on_modified is called
        Then: An info message is logged
        """
        event = FileModifiedEvent("/path/to/workflow.py")
        event.is_directory = False
        
        with caplog.at_level(logging.INFO):
            workflow_handler.on_modified(event)
        
        assert "Detected change in workflow" in caplog.text

    def test_extract_workflow_id_with_workflow_suffix(self, workflow_handler):
        """
        Given: A file path with _workflow suffix
        When: _extract_workflow_id is called
        Then: The workflow ID without suffix is returned
        """
        workflow_id = workflow_handler._extract_workflow_id("/path/to/my_workflow.py")
        
        assert workflow_id == "my"

    def test_extract_workflow_id_with_workflow_prefix(self, workflow_handler):
        """
        Given: A file path with workflow_ prefix
        When: _extract_workflow_id is called
        Then: The workflow ID without prefix is returned
        """
        workflow_id = workflow_handler._extract_workflow_id("/path/to/workflow_my.py")
        
        assert workflow_id == "my"

    def test_extract_workflow_id_with_plain_name(self, workflow_handler):
        """
        Given: A file path without workflow prefix/suffix
        When: _extract_workflow_id is called
        Then: The filename stem is returned as workflow ID
        """
        workflow_id = workflow_handler._extract_workflow_id("/path/to/myworkflow.py")
        
        assert workflow_id == "myworkflow"

    def test_extract_workflow_id_converts_to_lowercase(self, workflow_handler):
        """
        Given: A file path with uppercase characters
        When: _extract_workflow_id is called
        Then: The workflow ID is returned in lowercase
        """
        workflow_id = workflow_handler._extract_workflow_id("/path/to/MyWorkflow.py")
        
        assert workflow_id == "myworkflow"

    def test_extract_workflow_id_handles_complex_path(self, workflow_handler):
        """
        Given: A complex file path with multiple components
        When: _extract_workflow_id is called
        Then: Only the filename is used for workflow ID extraction
        """
        workflow_id = workflow_handler._extract_workflow_id(
            "/home/user/workflows/subdir/email_workflow.py"
        )
        
        assert workflow_id == "email"

    def test_extract_workflow_id_empty_filename_returns_none(self, workflow_handler):
        """
        Given: A file path that results in empty workflow ID
        When: _extract_workflow_id is called
        Then: None is returned
        """
        # This case is theoretical, as Path.stem would typically not be empty
        # but we test the logic that checks for empty workflow_id
        with patch.object(Path, "stem", ""):
            workflow_id = workflow_handler._extract_workflow_id("/path/to/.py")
        
        assert workflow_id is None or workflow_id == ""


class TestWorkflowFileWatcher:
    """Behavioral tests for WorkflowFileWatcher class."""

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_init_creates_observer_and_handler(self, mock_observer_class, workflow_dirs, mock_reload_callback):
        """
        Given: Workflow directories and a reload callback
        When: WorkflowFileWatcher is initialized
        Then: An observer and handler are created
        """
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        
        assert watcher.observer is not None
        assert isinstance(watcher.handler, WorkflowFileHandler)
        assert watcher.workflow_dirs == workflow_dirs

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_start_schedules_all_directories(self, mock_observer_class, workflow_dirs, mock_reload_callback):
        """
        Given: A WorkflowFileWatcher with multiple directories
        When: start() is called
        Then: All directories are scheduled for watching
        """
        mock_observer_instance = Mock()
        mock_observer_class.return_value = mock_observer_instance
        
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        watcher.start()
        
        assert mock_observer_instance.schedule.call_count == len(workflow_dirs)
        for directory in workflow_dirs:
            mock_observer_instance.schedule.assert_any_call(
                watcher.handler,
                str(directory),
                recursive=True
            )

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_start_starts_observer(self, mock_observer_class, workflow_dirs, mock_reload_callback):
        """
        Given: A WorkflowFileWatcher
        When: start() is called
        Then: The observer is started
        """
        mock_observer_instance = Mock()
        mock_observer_class.return_value = mock_observer_instance
        
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        watcher.start()
        
        mock_observer_instance.start.assert_called_once()

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_start_logs_info_message(self, mock_observer_class, workflow_dirs, mock_reload_callback, caplog):
        """
        Given: A WorkflowFileWatcher
        When: start() is called
        Then: An info message is logged
        """
        mock_observer_instance = Mock()
        mock_observer_class.return_value = mock_observer_instance
        
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        
        with caplog.at_level(logging.INFO):
            watcher.start()
        
        assert "Started watching" in caplog.text
        for directory in workflow_dirs:
            assert str(directory) in caplog.text

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_stop_stops_observer(self, mock_observer_class, workflow_dirs, mock_reload_callback):
        """
        Given: A started WorkflowFileWatcher
        When: stop() is called
        Then: The observer is stopped
        """
        mock_observer_instance = Mock()
        mock_observer_class.return_value = mock_observer_instance
        
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        watcher.start()
        watcher.stop()
        
        mock_observer_instance.stop.assert_called_once()

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_stop_joins_observer(self, mock_observer_class, workflow_dirs, mock_reload_callback):
        """
        Given: A started WorkflowFileWatcher
        When: stop() is called
        Then: The observer is joined
        """
        mock_observer_instance = Mock()
        mock_observer_class.return_value = mock_observer_instance
        
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        watcher.start()
        watcher.stop()
        
        mock_observer_instance.join.assert_called_once()

    @patch("empathy_os.hot_reload.watcher.Observer")
    def test_stop_logs_info_message(self, mock_observer_class, workflow_dirs, mock_reload_callback, caplog):
        """
        Given: A started WorkflowFileWatcher
        When: stop() is called
        Then: An info message is logged
        """
        mock_observer_instance = Mock()
        mock_observer_class.return_value = mock_observer_instance
        
        watcher = WorkflowFileWatcher(
            workflow_dirs=workflow_dirs,
            reload_callback=mock_reload_callback
        )
        watcher.start()
        
        with caplog.at_level(logging.INFO):
            watcher.stop()
        
        assert "Stopped watching workflow directories"