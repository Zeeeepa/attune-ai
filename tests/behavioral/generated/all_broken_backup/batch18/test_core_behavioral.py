"""Behavioral tests for core.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from unittest.mock import MagicMock, patch

import pytest
import typer
from rich.console import Console

from empathy_os.cli.core import console, get_empathy_version, version_callback


class TestConsoleInstance:
    """Test the shared console instance."""

    def test_console_is_rich_console_instance(self):
        """
        Given the cli.core module is imported
        When accessing the console instance
        Then it should be a Rich Console object
        """
        # Given/When: console is already imported
        # Then
        assert isinstance(console, Console)

    def test_console_is_singleton(self):
        """
        Given the cli.core module is imported multiple times
        When accessing the console instance
        Then it should be the same instance
        """
        # Given
        from empathy_os.cli.core import console as console1
        from empathy_os.cli.core import console as console2

        # When/Then
        assert console1 is console2


class TestGetEmpathyVersion:
    """Test the get_empathy_version function."""

    def test_returns_version_when_package_installed(self):
        """
        Given the empathy-framework package is installed
        When calling get_empathy_version
        Then it should return the package version string
        """
        # Given
        mock_version = "1.2.3"
        
        # When
        with patch("empathy_os.cli.core.get_version", return_value=mock_version):
            result = get_empathy_version()
        
        # Then
        assert result == mock_version
        assert isinstance(result, str)

    def test_returns_dev_when_package_not_found(self):
        """
        Given the empathy-framework package is not found
        When calling get_empathy_version
        Then it should return 'dev' as fallback
        """
        # Given
        from importlib.metadata import PackageNotFoundError
        
        # When
        with patch("empathy_os.cli.core.get_version", side_effect=PackageNotFoundError):
            result = get_empathy_version()
        
        # Then
        assert result == "dev"

    def test_returns_dev_when_generic_exception_occurs(self):
        """
        Given an unexpected exception occurs during version lookup
        When calling get_empathy_version
        Then it should return 'dev' as fallback
        """
        # Given/When
        with patch("empathy_os.cli.core.get_version", side_effect=RuntimeError("Unexpected error")):
            result = get_empathy_version()
        
        # Then
        assert result == "dev"

    def test_calls_get_version_with_correct_package_name(self):
        """
        Given the get_version function is available
        When calling get_empathy_version
        Then it should query for 'empathy-framework' package
        """
        # Given
        with patch("empathy_os.cli.core.get_version") as mock_get_version:
            mock_get_version.return_value = "1.0.0"
            
            # When
            get_empathy_version()
            
            # Then
            mock_get_version.assert_called_once_with("empathy-framework")

    def test_handles_empty_version_string(self):
        """
        Given get_version returns an empty string
        When calling get_empathy_version
        Then it should return the empty string without error
        """
        # Given/When
        with patch("empathy_os.cli.core.get_version", return_value=""):
            result = get_empathy_version()
        
        # Then
        assert result == ""

    def test_handles_version_with_special_characters(self):
        """
        Given get_version returns a version with special characters
        When calling get_empathy_version
        Then it should return the version string as-is
        """
        # Given
        special_version = "1.2.3-alpha+build.123"
        
        # When
        with patch("empathy_os.cli.core.get_version", return_value=special_version):
            result = get_empathy_version()
        
        # Then
        assert result == special_version


class TestVersionCallback:
    """Test the version_callback function."""

    def test_prints_version_and_exits_when_value_is_true(self):
        """
        Given value is True
        When calling version_callback
        Then it should print the version and raise typer.Exit
        """
        # Given
        value = True
        mock_console = MagicMock(spec=Console)
        
        # When/Then
        with patch("empathy_os.cli.core.console", mock_console):
            with patch("empathy_os.cli.core.get_empathy_version", return_value="1.2.3"):
                with pytest.raises(typer.Exit):
                    version_callback(value)
        
        # Then
        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0][0]
        assert "Empathy Framework" in call_args
        assert "1.2.3" in call_args

    def test_does_nothing_when_value_is_false(self):
        """
        Given value is False
        When calling version_callback
        Then it should not print anything or raise an exception
        """
        # Given
        value = False
        mock_console = MagicMock(spec=Console)
        
        # When
        with patch("empathy_os.cli.core.console", mock_console):
            result = version_callback(value)
        
        # Then
        assert result is None
        mock_console.print.assert_not_called()

    def test_prints_with_rich_formatting(self):
        """
        Given value is True
        When calling version_callback
        Then it should use Rich markup for formatted output
        """
        # Given
        value = True
        mock_console = MagicMock(spec=Console)
        
        # When
        with patch("empathy_os.cli.core.console", mock_console):
            with patch("empathy_os.cli.core.get_empathy_version", return_value="2.0.0"):
                with pytest.raises(typer.Exit):
                    version_callback(value)
        
        # Then
        call_args = mock_console.print.call_args[0][0]
        assert "[bold blue]" in call_args
        assert "[/bold blue]" in call_args

    def test_uses_get_empathy_version_for_version_info(self):
        """
        Given value is True
        When calling version_callback
        Then it should call get_empathy_version to get the version
        """
        # Given
        value = True
        
        # When
        with patch("empathy_os.cli.core.get_empathy_version") as mock_get_version:
            mock_get_version.return_value = "3.1.4"
            with patch("empathy_os.cli.core.console"):
                with pytest.raises(typer.Exit):
                    version_callback(value)
        
        # Then
        mock_get_version.assert_called_once()

    def test_prints_dev_version_when_package_not_installed(self):
        """
        Given the package version cannot be determined
        When calling version_callback with True
        Then it should print 'dev' as the version
        """
        # Given
        value = True
        mock_console = MagicMock(spec=Console)
        
        # When
        with patch("empathy_os.cli.core.console", mock_console):
            with patch("empathy_os.cli.core.get_empathy_version", return_value="dev"):
                with pytest.raises(typer.Exit):
                    version_callback(value)
        
        # Then
        call_args = mock_console.print.call_args[0][0]
        assert "dev" in call_args

    def test_exits_without_code_when_value_is_true(self):
        """
        Given value is True
        When calling version_callback
        Then it should raise typer.Exit with default exit code
        """
        # Given
        value = True
        
        # When/Then
        with patch("empathy_os.cli.core.console"):
            with patch("empathy_os.cli.core.get_empathy_version", return_value="1.0.0"):
                with pytest.raises(typer.Exit) as exc_info:
                    version_callback(value)
        
        # Then
        assert exc_info.value.exit_code == 0

    @pytest.mark.parametrize("version_string", [
        "1.0.0",
        "2.5.3-beta",
        "dev",
        "0.0.1",
        "10.20.30",
    ])
    def test_prints_various_version_formats(self, version_string):
        """
        Given various version string formats
        When calling version_callback with True
        Then it should correctly include the version in the output
        """
        # Given
        value = True
        mock_console = MagicMock(spec=Console)
        
        # When
        with patch("empathy_os.cli.core.console", mock_console):
            with patch("empathy_os.cli.core.get_empathy_version", return_value=version_string):
                with pytest.raises(typer.Exit):
                    version_callback(value)
        
        # Then
        call_args = mock_console.print.call_args[0][0]
        assert version_string in call_args


class TestIntegration:
    """Integration tests for core module components."""

    def test_version_callback_integrates_with_get_empathy_version(self):
        """
        Given the full module is operational
        When version_callback is called with True
        Then it should successfully retrieve and display version
        """
        # Given
        value = True
        mock_console = MagicMock(spec=Console)
        
        # When
        with patch("empathy_os.cli.core.console", mock_console):
            with pytest.raises(typer.Exit):
                version_callback(value)
        
        # Then
        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0][0]
        assert "Empathy Framework" in call_args
        assert "v" in call_args

    def test_console_can_be_used_for_output(self):
        """
        Given the console instance exists
        When using it to print output
        Then it should work without errors
        """
        # Given/When
        try:
            console.print("Test message")
            success = True
        except Exception:
            success = False
        
        # Then
        assert success