"""Behavioral tests for context.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import pytest

from empathy_os.prompts.context import PromptContext


class TestPromptContextInitialization:
    """Tests for PromptContext initialization and validation."""

    def test_given_valid_role_and_goal_when_creating_context_then_succeeds(self) -> None:
        """Given valid role and goal, when creating context, then it succeeds."""
        # Given
        role = "test engineer"
        goal = "validate code quality"

        # When
        context = PromptContext(role=role, goal=goal)

        # Then
        assert context.role == role
        assert context.goal == goal
        assert context.instructions == []
        assert context.constraints == []
        assert context.input_type == "code"
        assert context.input_payload == ""
        assert context.extra == {}

    def test_given_missing_role_when_creating_context_then_raises_value_error(self) -> None:
        """Given missing role, when creating context, then raises ValueError."""
        # Given
        role = ""
        goal = "validate code quality"

        # When / Then
        with pytest.raises(ValueError, match="role is required"):
            PromptContext(role=role, goal=goal)

    def test_given_missing_goal_when_creating_context_then_raises_value_error(self) -> None:
        """Given missing goal, when creating context, then raises ValueError."""
        # Given
        role = "test engineer"
        goal = ""

        # When / Then
        with pytest.raises(ValueError, match="goal is required"):
            PromptContext(role=role, goal=goal)

    def test_given_whitespace_role_when_creating_context_then_raises_value_error(self) -> None:
        """Given whitespace-only role, when creating context, then raises ValueError."""
        # Given
        role = "   "
        goal = "validate code quality"

        # When / Then
        with pytest.raises(ValueError, match="role is required"):
            PromptContext(role=role, goal=goal)

    def test_given_whitespace_goal_when_creating_context_then_raises_value_error(self) -> None:
        """Given whitespace-only goal, when creating context, then raises ValueError."""
        # Given
        role = "test engineer"
        goal = "   "

        # When / Then
        with pytest.raises(ValueError, match="goal is required"):
            PromptContext(role=role, goal=goal)

    def test_given_full_parameters_when_creating_context_then_all_fields_set(self) -> None:
        """Given all parameters, when creating context, then all fields are set correctly."""
        # Given
        role = "code reviewer"
        goal = "ensure code quality"
        instructions = ["Check syntax", "Verify logic"]
        constraints = ["Be concise", "Focus on errors"]
        input_type = "diff"
        input_payload = "diff content here"
        extra = {"project": "test-project", "reviewer": "alice"}

        # When
        context = PromptContext(
            role=role,
            goal=goal,
            instructions=instructions,
            constraints=constraints,
            input_type=input_type,
            input_payload=input_payload,
            extra=extra,
        )

        # Then
        assert context.role == role
        assert context.goal == goal
        assert context.instructions == instructions
        assert context.constraints == constraints
        assert context.input_type == input_type
        assert context.input_payload == input_payload
        assert context.extra == extra

    def test_given_none_lists_when_creating_context_then_uses_default_factories(self) -> None:
        """Given None for list fields, when creating context, then uses default empty lists."""
        # Given
        role = "analyzer"
        goal = "analyze data"

        # When
        context = PromptContext(role=role, goal=goal)

        # Then
        assert context.instructions == []
        assert context.constraints == []
        assert context.extra == {}

    def test_given_multiple_contexts_when_using_default_factories_then_each_has_own_lists(self) -> None:
        """Given multiple contexts, when using default factories, then each has independent lists."""
        # Given
        role = "analyzer"
        goal = "analyze data"

        # When
        context1 = PromptContext(role=role, goal=goal)
        context2 = PromptContext(role=role, goal=goal)
        context1.instructions.append("instruction1")
        context1.extra["key"] = "value"

        # Then
        assert len(context1.instructions) == 1
        assert len(context2.instructions) == 0
        assert "key" in context1.extra
        assert "key" not in context2.extra


class TestPromptContextForSecurityAudit:
    """Tests for for_security_audit class method."""

    def test_given_code_when_creating_security_audit_context_then_has_correct_structure(self) -> None:
        """Given code, when creating security audit context, then has correct structure."""
        # Given
        code = "def vulnerable_function():\n    eval(user_input)"

        # When
        context = PromptContext.for_security_audit(code=code)

        # Then
        assert context.role == "application security engineer"
        assert "security vulnerabilities" in context.goal.lower()
        assert len(context.instructions) > 0
        assert any("OWASP" in instr for instr in context.instructions)
        assert any("severity" in instr.lower() for instr in context.instructions)
        assert len(context.constraints) > 0
        assert context.input_type == "code"
        assert context.input_payload == code

    def test_given_code_and_findings_when_creating_security_audit_then_extra_populated(self) -> None:
        """Given code and findings, when creating security audit, then extra data populated."""
        # Given
        code = "vulnerable code"
        findings_summary = "3 critical issues found"
        risk_level = "high"

        # When
        context = PromptContext.for_security_audit(
            code=code,
            findings_summary=findings_summary,
            risk_level=risk_level,
        )

        # Then
        assert context.extra["findings_summary"] == findings_summary
        assert context.extra["risk_level"] == risk_level

    def test_given_extra_kwargs_when_creating_security_audit_then_merged_into_extra(self) -> None:
        """Given extra kwargs, when creating security audit, then merged into extra dict."""
        # Given
        code = "test code"
        custom_field = "custom value"
        another_field = 42

        # When
        context = PromptContext.for_security_audit(
            code=code,
            custom_field=custom_field,
            another_field=another_field,
        )

        # Then
        assert context.extra["custom_field"] == custom_field
        assert context.extra["another_field"] == another_field

    def test_given_empty_code_when_creating_security_audit_then_accepts_empty_payload(self) -> None:
        """Given empty code, when creating security audit, then accepts empty payload."""
        # Given
        code = ""

        # When
        context = PromptContext.for_security_audit(code=code)

        # Then
        assert context.input_payload == ""
        assert context.role  # Should still have role
        assert context.goal  # Should still have goal

    def test_given_multiline_code_when_creating_security_audit_then_preserves_formatting(self) -> None:
        """Given multiline code, when creating security audit, then preserves formatting."""
        # Given
        code = """def function():
    if True:
        return None"""

        # When
        context = PromptContext.for_security_audit(code=code)

        # Then
        assert context.input_payload == code
        assert "\n" in context.input_payload

    def test_given_security_audit_when_checking_instructions_then_has_owasp_focus(self) -> None:
        """Given security audit context, when checking instructions, then has OWASP focus."""
        # Given / When
        context = PromptContext.for_security_audit(code="test")

        # Then
        assert any("OWASP" in instr for instr in context.instructions)
        assert any("severity" in instr.lower() for instr in context.instructions)
        assert any("remediation" in instr.lower() for instr in context.instructions)

    def test_given_security_audit_when_checking_constraints_then_has_quality_requirements(self) -> None:
        """Given security audit context, when checking constraints, then has quality requirements."""
        # Given / When
        context = PromptContext.for_security_audit(code="test")

        # Then
        assert any("specific" in cons.lower() for cons in context.constraints)
        assert any("severity" in cons.lower() or "prioritize" in cons.lower() for cons in context.constraints)


class TestPromptContextForCodeReview:
    """Tests for for_code_review class method."""

    def test_given_diff_when_creating_code_review_context_then_has_correct_structure(self) -> None:
        """Given diff, when creating code review context, then has correct structure."""
        # Given
        diff = "+def new_function():\n-def old_function():"
        input_type = "diff"

        # When
        context = PromptContext.for_code_review(code_or_diff=diff, input_type=input_type)

        # Then
        assert context.role == "senior software engineer"
        assert "code review" in context.goal.lower()
        assert len(context.instructions) > 0
        assert len(context.constraints) > 0
        assert context.input_type == input_type
        assert context.input_payload == diff

    def test_given_code_when_creating_code_review_context_then_defaults_to_code_type(self) -> None:
        """Given code, when creating code review context, then defaults to code type."""
        # Given
        code = "def function(): pass"

        # When
        context = PromptContext.for_code_review(code_or_diff=code)

        # Then
        assert context.input_type == "code"
        assert context.input_payload == code

    def test_given_focus_areas_when_creating_code_review_then_added_to_extra(self) -> None:
        """Given focus areas, when creating code review, then added to extra."""
        # Given
        code = "test code"
        focus_areas = ["performance", "security"]

        # When
        context = PromptContext.for_code_review(code_or_diff=code, focus_areas=focus_areas)

        # Then
        assert context.extra["focus_areas"] == focus_areas

    def test_given_extra_kwargs_when_creating_code_review_then_merged_into_extra(self) -> None:
        """Given extra kwargs, when creating code review, then merged into extra dict."""
        # Given
        code = "test code"
        author = "john_doe"
        branch = "feature/new-thing"

        # When
        context = PromptContext.for_code_review(
            code_or_diff=code,
            author=author,
            branch=branch,
        )

        # Then
        assert context.extra["author"] == author
        assert context.extra["branch"] == branch

    def test_given_code_review_when_checking_instructions_then_has_best_practices(self) -> None:
        """Given code review context, when checking instructions, then has best practices."""
        # Given / When
        context = PromptContext.for_code_review(code_or_diff="test")

        # Then
        assert any("readability" in instr.lower() or "best practices" in instr.lower() for instr in context.instructions)

    def test_given_code_review_when_checking_constraints_then_has_constructive_tone(self) -> None:
        """Given code review context, when checking constraints, then has constructive tone."""
        # Given / When
        context = PromptContext.for_code_review(code_or_diff="test")

        # Then
        assert any("constructive" in cons.lower() or "respectful" in cons.lower() for cons in context.constraints)

    def test_given_empty_diff_when_creating_code_review_then_accepts_empty_payload(self) -> None:
        """Given empty diff, when creating code review, then accepts empty payload."""
        # Given
        diff = ""

        # When
        context = PromptContext.for_code_review(code_or_diff=diff)

        # Then
        assert context.input_payload == ""
        assert context.role
        assert context.goal


class TestPromptContextForDocumentAnalysis:
    """Tests for for_document_analysis class method."""

    def test_given_document_when_creating_analysis_context_then_has_correct_structure(self) -> None:
        """Given document, when creating analysis context, then has correct structure."""
        # Given
        document = "This is a document to analyze."
        analysis_type = "summary"

        # When
        context = PromptContext.for_document_analysis(
            document=document,
            analysis_type=analysis_type,
        )

        # Then
        assert context.role == "document analyst"
        assert "analyze" in context.goal.lower()
        assert len(context.instructions) > 0
        assert context.input_type == "document"
        assert context.input_payload == document

    def test_given_analysis_type_when_creating_document_analysis_then_added_to_extra(self) -> None:
        """Given analysis type, when creating document analysis, then added to extra."""
        # Given
        document = "test document"
        analysis_type = "extract_entities"

        # When
        context = PromptContext.for_document_analysis(
            document=document,
            analysis_type=analysis_type,
        )

        # Then
        assert context.extra["analysis_type"] == analysis_type

    def test_given_extra_kwargs_when_creating_document_analysis_then_merged_into_extra(self) -> None:
        """Given extra kwargs, when creating document analysis, then merged into extra dict."""
        # Given
        document = "test doc"
        language = "en"
        format_type = "markdown"

        # When
        context = PromptContext.for_document_analysis(
            document=document,
            analysis_type="summary",
            language=language,
            format_type=format_type,
        )

        # Then
        assert context.extra["language"] == language
        assert context.extra["format_type"] == format_type

    def test_given_empty_document_when_creating_analysis_then_accepts_empty_payload(self) -> None:
        """Given empty document, when creating analysis, then accepts empty payload."""
        # Given
        document = ""
        analysis_type = "summary"

        # When
        context = PromptContext.for_document_analysis(
            document=document,
            analysis_type=analysis_type,
        )

        # Then
        assert context.input_payload == ""
        assert context.role
        assert context.goal

    def test_given_document_analysis_when_checking_instructions_then_has_analysis_guidance(self) -> None:
        """Given document analysis context, when checking instructions, then has analysis guidance."""
        # Given / When
        context = PromptContext.for_document_analysis(
            document="test",
            analysis_type="summary",
        )

        # Then
        assert len(context.instructions) > 0
        assert any(isinstance(instr, str) for instr in context.instructions)


class TestPromptContextForQuestionAnswering