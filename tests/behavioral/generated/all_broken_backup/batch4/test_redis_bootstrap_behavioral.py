"""Behavioral tests for redis_bootstrap.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import subprocess
import time
from unittest.mock import MagicMock, Mock, patch, call

import pytest

from empathy_os.memory.redis_bootstrap import (
    IS_LINUX,
    IS_MACOS,
    IS_WINDOWS,
    RedisStartMethod,
    RedisStatus,
    _check_redis_running,
    _find_command,
    _run_silent,
    _start_via_homebrew,
    _start_via_systemd,
    _start_via_windows_service,
    _start_via_chocolatey,
    _start_via_scoop,
    _start_via_wsl,
    _start_via_docker,
    _start_via_direct,
    ensure_redis,
)


# Fixtures


@pytest.fixture
def mock_redis_client():
    """Provide a mock Redis client."""
    with patch("empathy_os.memory.redis_bootstrap.redis") as mock_redis:
        yield mock_redis


@pytest.fixture
def mock_subprocess_run():
    """Provide a mock subprocess.run."""
    with patch("empathy_os.memory.redis_bootstrap.subprocess.run") as mock_run:
        yield mock_run


@pytest.fixture
def mock_shutil_which():
    """Provide a mock shutil.which."""
    with patch("empathy_os.memory.redis_bootstrap.shutil.which") as mock_which:
        yield mock_which


@pytest.fixture
def mock_time_sleep():
    """Provide a mock time.sleep."""
    with patch("empathy_os.memory.redis_bootstrap.time.sleep") as mock_sleep:
        yield mock_sleep


@pytest.fixture
def mock_logger():
    """Provide a mock logger."""
    with patch("empathy_os.memory.redis_bootstrap.logger") as mock_log:
        yield mock_log


# Tests for RedisStatus dataclass


class TestRedisStatus:
    """Tests for RedisStatus dataclass."""

    def test_given_redis_status_when_created_with_defaults_then_has_expected_fields(self):
        """Test RedisStatus creation with default values."""
        # Given / When
        status = RedisStatus(
            available=True,
            method=RedisStartMethod.ALREADY_RUNNING,
        )

        # Then
        assert status.available is True
        assert status.method == RedisStartMethod.ALREADY_RUNNING
        assert status.host == "localhost"
        assert status.port == 6379
        assert status.message == ""
        assert status.pid is None

    def test_given_redis_status_when_created_with_custom_values_then_has_custom_fields(self):
        """Test RedisStatus creation with custom values."""
        # Given / When
        status = RedisStatus(
            available=False,
            method=RedisStartMethod.DOCKER,
            host="redis-server",
            port=6380,
            message="Connection failed",
            pid=12345,
        )

        # Then
        assert status.available is False
        assert status.method == RedisStartMethod.DOCKER
        assert status.host == "redis-server"
        assert status.port == 6380
        assert status.message == "Connection failed"
        assert status.pid == 12345


# Tests for _check_redis_running


class TestCheckRedisRunning:
    """Tests for _check_redis_running function."""

    def test_given_redis_is_running_when_check_then_returns_true(
        self, mock_redis_client
    ):
        """Test checking Redis when it's running successfully."""
        # Given
        mock_client = Mock()
        mock_client.ping.return_value = True
        mock_redis_client.Redis.return_value = mock_client

        # When
        result = _check_redis_running()

        # Then
        assert result is True
        mock_redis_client.Redis.assert_called_once_with(
            host="localhost", port=6379, socket_connect_timeout=1
        )
        mock_client.ping.assert_called_once()

    def test_given_redis_is_not_running_when_check_then_returns_false(
        self, mock_redis_client
    ):
        """Test checking Redis when it's not running."""
        # Given
        mock_client = Mock()
        mock_client.ping.side_effect = Exception("Connection refused")
        mock_redis_client.Redis.return_value = mock_client

        # When
        result = _check_redis_running()

        # Then
        assert result is False

    def test_given_custom_host_and_port_when_check_then_uses_custom_values(
        self, mock_redis_client
    ):
        """Test checking Redis with custom host and port."""
        # Given
        mock_client = Mock()
        mock_client.ping.return_value = True
        mock_redis_client.Redis.return_value = mock_client

        # When
        result = _check_redis_running(host="redis-server", port=6380)

        # Then
        assert result is True
        mock_redis_client.Redis.assert_called_once_with(
            host="redis-server", port=6380, socket_connect_timeout=1
        )

    def test_given_redis_import_error_when_check_then_returns_false(self):
        """Test checking Redis when redis module is not available."""
        # Given
        with patch("empathy_os.memory.redis_bootstrap.redis", side_effect=ImportError):
            # When
            result = _check_redis_running()

            # Then
            assert result is False


# Tests for _find_command


class TestFindCommand:
    """Tests for _find_command function."""

    def test_given_command_exists_when_find_then_returns_path(self, mock_shutil_which):
        """Test finding a command that exists."""
        # Given
        mock_shutil_which.return_value = "/usr/bin/redis-server"

        # When
        result = _find_command("redis-server")

        # Then
        assert result == "/usr/bin/redis-server"
        mock_shutil_which.assert_called_once_with("redis-server")

    def test_given_command_does_not_exist_when_find_then_returns_none(
        self, mock_shutil_which
    ):
        """Test finding a command that doesn't exist."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _find_command("nonexistent-command")

        # Then
        assert result is None


# Tests for _run_silent


class TestRunSilent:
    """Tests for _run_silent function."""

    def test_given_successful_command_when_run_then_returns_success_and_output(
        self, mock_subprocess_run
    ):
        """Test running a successful command."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "Success output\n"
        mock_result.stderr = ""
        mock_subprocess_run.return_value = mock_result

        # When
        success, output = _run_silent(["echo", "test"])

        # Then
        assert success is True
        assert output == "Success output\n"
        mock_subprocess_run.assert_called_once_with(
            ["echo", "test"],
            check=False,
            capture_output=True,
            text=True,
            timeout=5,
        )

    def test_given_failed_command_when_run_then_returns_failure_and_output(
        self, mock_subprocess_run
    ):
        """Test running a failed command."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 1
        mock_result.stdout = ""
        mock_result.stderr = "Error message\n"
        mock_subprocess_run.return_value = mock_result

        # When
        success, output = _run_silent(["false"])

        # Then
        assert success is False
        assert output == "Error message\n"

    def test_given_timeout_when_run_then_returns_failure_and_timeout(
        self, mock_subprocess_run
    ):
        """Test running a command that times out."""
        # Given
        mock_subprocess_run.side_effect = subprocess.TimeoutExpired(
            cmd=["sleep", "10"], timeout=5
        )

        # When
        success, output = _run_silent(["sleep", "10"])

        # Then
        assert success is False
        assert output == "timeout"

    def test_given_exception_when_run_then_returns_failure_and_error_message(
        self, mock_subprocess_run
    ):
        """Test running a command that raises an exception."""
        # Given
        mock_subprocess_run.side_effect = OSError("File not found")

        # When
        success, output = _run_silent(["nonexistent"])

        # Then
        assert success is False
        assert output == "File not found"

    def test_given_custom_timeout_when_run_then_uses_custom_timeout(
        self, mock_subprocess_run
    ):
        """Test running a command with custom timeout."""
        # Given
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = ""
        mock_result.stderr = ""
        mock_subprocess_run.return_value = mock_result

        # When
        _run_silent(["test"], timeout=10)

        # Then
        mock_subprocess_run.assert_called_once_with(
            ["test"],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )


# Tests for _start_via_homebrew


class TestStartViaHomebrew:
    """Tests for _start_via_homebrew function."""

    def test_given_homebrew_not_installed_when_start_then_returns_false(
        self, mock_shutil_which, mock_logger
    ):
        """Test starting via Homebrew when brew is not installed."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _start_via_homebrew()

        # Then
        assert result is False

    def test_given_redis_not_installed_via_homebrew_when_start_then_returns_false(
        self, mock_shutil_which, mock_subprocess_run, mock_logger
    ):
        """Test starting via Homebrew when Redis is not installed."""
        # Given
        mock_shutil_which.return_value = "/usr/local/bin/brew"
        mock_result = Mock()
        mock_result.returncode = 1
        mock_result.stdout = ""
        mock_result.stderr = "Error: No such formula: redis"
        mock_subprocess_run.return_value = mock_result

        # When
        result = _start_via_homebrew()

        # Then
        assert result is False
        mock_logger.debug.assert_called_with("redis_not_installed_via_homebrew")

    def test_given_redis_installed_when_start_successfully_then_returns_true(
        self, mock_shutil_which, mock_subprocess_run, mock_time_sleep, mock_logger
    ):
        """Test starting Redis successfully via Homebrew."""
        # Given
        mock_shutil_which.return_value = "/usr/local/bin/brew"

        # Mock both brew list and brew services start
        mock_result_list = Mock()
        mock_result_list.returncode = 0
        mock_result_list.stdout = "redis"
        mock_result_list.stderr = ""

        mock_result_start = Mock()
        mock_result_start.returncode = 0
        mock_result_start.stdout = "Successfully started redis"
        mock_result_start.stderr = ""

        mock_subprocess_run.side_effect = [mock_result_list, mock_result_start]

        # When
        result = _start_via_homebrew()

        # Then
        assert result is True
        mock_time_sleep.assert_called_once_with(1)
        mock_logger.info.assert_called_once_with("redis_started_via_homebrew")

    def test_given_redis_installed_when_start_fails_then_returns_false(
        self, mock_shutil_which, mock_subprocess_run, mock_logger
    ):
        """Test starting Redis via Homebrew when start command fails."""
        # Given
        mock_shutil_which.return_value = "/usr/local/bin/brew"

        mock_result_list = Mock()
        mock_result_list.returncode = 0
        mock_result_list.stdout = "redis"
        mock_result_list.stderr = ""

        mock_result_start = Mock()
        mock_result_start.returncode = 1
        mock_result_start.stdout = ""
        mock_result_start.stderr = "Failed to start redis"

        mock_subprocess_run.side_effect = [mock_result_list, mock_result_start]

        # When
        result = _start_via_homebrew()

        # Then
        assert result is False
        mock_logger.debug.assert_called()


# Tests for _start_via_systemd


class TestStartViaSystemd:
    """Tests for _start_via_systemd function."""

    def test_given_systemctl_not_found_when_start_then_returns_false(
        self, mock_shutil_which
    ):
        """Test starting via systemd when systemctl is not found."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _start_via_systemd()

        # Then
        assert result is False

    def test_given_systemctl_found_when_start_successfully_then_returns_true(
        self, mock_shutil_which, mock_subprocess_run, mock_time_sleep, mock_logger
    ):
        """Test starting Redis successfully via systemd."""
        # Given
        mock_shutil_which.return_value = "/usr/bin/systemctl"
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = ""
        mock_result.stderr = ""
        mock_subprocess_run.return_value = mock_result

        # When
        result = _start_via_systemd()

        # Then
        assert result is True
        mock_time_sleep.assert_called_once_with(1)
        mock_logger.info.assert_called_once_with("redis_started_via_systemd")

    def test_given_systemctl_found_when_start_fails_then_returns_false(
        self, mock_shutil_which, mock_subprocess_run, mock_logger
    ):
        """Test starting via systemd when start command fails."""
        # Given
        mock_shutil_which.return_value = "/usr/bin/systemctl"
        mock_result = Mock()
        mock_result.returncode = 1
        mock_result.stdout = ""
        mock_result.stderr = "Failed to start redis"
        mock_subprocess_run.return_value = mock_result

        # When
        result = _start_via_systemd()

        # Then
        assert result is False
        mock_logger.debug.assert_called()


# Tests for _start_via_windows_service


class TestStartViaWindowsService:
    """Tests for _start_via_windows_service function."""

    def test_given_net_not_found_when_start_then_returns_false(
        self, mock_shutil_which
    ):
        """Test starting via Windows service when net is not found."""
        # Given
        mock_shutil_which.return_value = None

        # When
        result = _start_via_windows_service()

        # Then
        assert result is False

    def test_given_net_found_when_