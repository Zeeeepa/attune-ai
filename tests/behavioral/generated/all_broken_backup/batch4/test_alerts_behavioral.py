"""Behavioral tests for alerts.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import smtplib
import sqlite3
import tempfile
import time
import urllib.error
import urllib.request
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, patch, call

import pytest

from empathy_os.monitoring.alerts import (
    _validate_webhook_url,
    AlertChannel,
    AlertRule,
    AlertManager,
    MetricType,
)


class TestValidateWebhookUrl:
    """Test suite for _validate_webhook_url function."""

    def test_given_valid_http_url_when_validated_then_returns_unchanged(self):
        """Test that valid HTTP URL is accepted."""
        # Given
        url = "http://example.com/webhook"
        
        # When
        result = _validate_webhook_url(url)
        
        # Then
        assert result == url

    def test_given_valid_https_url_when_validated_then_returns_unchanged(self):
        """Test that valid HTTPS URL is accepted."""
        # Given
        url = "https://api.example.com/webhook"
        
        # When
        result = _validate_webhook_url(url)
        
        # Then
        assert result == url

    def test_given_empty_string_when_validated_then_raises_value_error(self):
        """Test that empty string raises ValueError."""
        # Given
        url = ""
        
        # When/Then
        with pytest.raises(ValueError, match="webhook_url must be a non-empty string"):
            _validate_webhook_url(url)

    def test_given_none_when_validated_then_raises_value_error(self):
        """Test that None raises ValueError."""
        # Given
        url = None
        
        # When/Then
        with pytest.raises(ValueError, match="webhook_url must be a non-empty string"):
            _validate_webhook_url(url)

    def test_given_non_string_when_validated_then_raises_value_error(self):
        """Test that non-string type raises ValueError."""
        # Given
        url = 12345
        
        # When/Then
        with pytest.raises(ValueError, match="webhook_url must be a non-empty string"):
            _validate_webhook_url(url)

    def test_given_invalid_scheme_when_validated_then_raises_value_error(self):
        """Test that non-HTTP(S) schemes are rejected."""
        # Given
        invalid_urls = [
            "ftp://example.com",
            "file:///etc/passwd",
            "gopher://example.com",
            "javascript:alert(1)",
        ]
        
        # When/Then
        for url in invalid_urls:
            with pytest.raises(ValueError, match="Only http and https allowed"):
                _validate_webhook_url(url)

    def test_given_localhost_when_validated_then_raises_value_error(self):
        """Test that localhost URLs are rejected."""
        # Given
        localhost_urls = [
            "http://localhost/webhook",
            "http://127.0.0.1/webhook",
            "http://[::1]/webhook",
            "http://0.0.0.0/webhook",
        ]
        
        # When/Then
        for url in localhost_urls:
            with pytest.raises(ValueError, match="cannot target local or metadata address"):
                _validate_webhook_url(url)

    def test_given_metadata_service_url_when_validated_then_raises_value_error(self):
        """Test that cloud metadata service URLs are rejected."""
        # Given
        metadata_urls = [
            "http://169.254.169.254/latest/meta-data",
            "http://metadata.google.internal/",
        ]
        
        # When/Then
        for url in metadata_urls:
            with pytest.raises(ValueError, match="cannot target local or metadata address"):
                _validate_webhook_url(url)

    def test_given_private_ip_when_validated_then_raises_value_error(self):
        """Test that private IP addresses are rejected."""
        # Given
        private_ips = [
            "http://10.0.0.1/webhook",
            "http://172.16.0.1/webhook",
            "http://192.168.1.1/webhook",
        ]
        
        # When/Then
        for url in private_ips:
            with pytest.raises(ValueError, match="Webhook URL targets private IP"):
                _validate_webhook_url(url)

    def test_given_url_without_hostname_when_validated_then_raises_value_error(self):
        """Test that URL without hostname is rejected."""
        # Given
        url = "http:///webhook"
        
        # When/Then
        with pytest.raises(ValueError, match="must contain a valid hostname"):
            _validate_webhook_url(url)

    def test_given_dangerous_port_when_validated_then_raises_value_error(self):
        """Test that dangerous internal ports are rejected."""
        # Given
        dangerous_urls = [
            "http://example.com:6379/webhook",  # Redis
            "http://example.com:5432/webhook",  # PostgreSQL
            "http://example.com:27017/webhook",  # MongoDB
        ]
        
        # When/Then
        for url in dangerous_urls:
            with pytest.raises(ValueError, match="targets dangerous internal port"):
                _validate_webhook_url(url)

    def test_given_malformed_url_when_validated_then_raises_value_error(self):
        """Test that malformed URL raises ValueError."""
        # Given
        url = "ht!tp://not-a-url"
        
        # When/Then
        with pytest.raises(ValueError, match="Invalid URL format"):
            _validate_webhook_url(url)


class TestAlertChannel:
    """Test suite for AlertChannel enum."""

    def test_given_webhook_channel_when_accessed_then_has_correct_value(self):
        """Test that WEBHOOK enum has correct value."""
        # Given/When
        channel = AlertChannel.WEBHOOK
        
        # Then
        assert channel.value == "webhook"

    def test_given_email_channel_when_accessed_then_has_correct_value(self):
        """Test that EMAIL enum has correct value."""
        # Given/When
        channel = AlertChannel.EMAIL
        
        # Then
        assert channel.value == "email"

    def test_given_stdout_channel_when_accessed_then_has_correct_value(self):
        """Test that STDOUT enum has correct value."""
        # Given/When
        channel = AlertChannel.STDOUT
        
        # Then
        assert channel.value == "stdout"


class TestMetricType:
    """Test suite for MetricType enum."""

    def test_given_daily_cost_metric_when_accessed_then_has_correct_value(self):
        """Test that DAILY_COST enum has correct value."""
        # Given/When
        metric = MetricType.DAILY_COST
        
        # Then
        assert metric.value == "daily_cost"

    def test_given_error_rate_metric_when_accessed_then_has_correct_value(self):
        """Test that ERROR_RATE enum has correct value."""
        # Given/When
        metric = MetricType.ERROR_RATE
        
        # Then
        assert metric.value == "error_rate"

    def test_given_avg_latency_metric_when_accessed_then_has_correct_value(self):
        """Test that AVG_LATENCY enum has correct value."""
        # Given/When
        metric = MetricType.AVG_LATENCY
        
        # Then
        assert metric.value == "avg_latency"

    def test_given_token_usage_metric_when_accessed_then_has_correct_value(self):
        """Test that TOKEN_USAGE enum has correct value."""
        # Given/When
        metric = MetricType.TOKEN_USAGE
        
        # Then
        assert metric.value == "token_usage"


class TestAlertRule:
    """Test suite for AlertRule dataclass."""

    def test_given_valid_parameters_when_created_then_alert_rule_initialized(self):
        """Test that AlertRule can be created with valid parameters."""
        # Given
        rule_id = "test-rule"
        metric = MetricType.DAILY_COST
        threshold = 100.0
        channel = AlertChannel.WEBHOOK
        config = {"url": "http://example.com"}
        
        # When
        rule = AlertRule(
            rule_id=rule_id,
            metric=metric,
            threshold=threshold,
            channel=channel,
            config=config,
        )
        
        # Then
        assert rule.rule_id == rule_id
        assert rule.metric == metric
        assert rule.threshold == threshold
        assert rule.channel == channel
        assert rule.config == config
        assert rule.enabled is True
        assert rule.cooldown_seconds == 3600

    def test_given_custom_cooldown_when_created_then_uses_custom_value(self):
        """Test that custom cooldown is respected."""
        # Given
        cooldown = 7200
        
        # When
        rule = AlertRule(
            rule_id="test",
            metric=MetricType.ERROR_RATE,
            threshold=5.0,
            channel=AlertChannel.STDOUT,
            config={},
            cooldown_seconds=cooldown,
        )
        
        # Then
        assert rule.cooldown_seconds == cooldown

    def test_given_disabled_flag_when_created_then_rule_disabled(self):
        """Test that rule can be created in disabled state."""
        # Given/When
        rule = AlertRule(
            rule_id="test",
            metric=MetricType.TOKEN_USAGE,
            threshold=1000000,
            channel=AlertChannel.EMAIL,
            config={},
            enabled=False,
        )
        
        # Then
        assert rule.enabled is False


class TestAlertManager:
    """Test suite for AlertManager class."""

    @pytest.fixture
    def temp_db_path(self):
        """Create temporary database path."""
        with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as f:
            db_path = Path(f.name)
        yield db_path
        if db_path.exists():
            db_path.unlink()

    @pytest.fixture
    def alert_manager(self, temp_db_path):
        """Create AlertManager instance with temporary database."""
        manager = AlertManager(db_path=temp_db_path)
        yield manager
        manager.close()

    def test_given_valid_db_path_when_initialized_then_creates_tables(self, temp_db_path):
        """Test that AlertManager creates necessary database tables."""
        # Given/When
        manager = AlertManager(db_path=temp_db_path)
        
        # Then
        conn = sqlite3.connect(temp_db_path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='alert_rules'"
        )
        assert cursor.fetchone() is not None
        cursor.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='alert_history'"
        )
        assert cursor.fetchone() is not None
        conn.close()
        manager.close()

    def test_given_new_rule_when_added_then_stored_in_database(self, alert_manager):
        """Test that new alert rule is stored in database."""
        # Given
        rule = AlertRule(
            rule_id="cost-alert",
            metric=MetricType.DAILY_COST,
            threshold=50.0,
            channel=AlertChannel.WEBHOOK,
            config={"url": "https://hooks.example.com/alert"},
        )
        
        # When
        alert_manager.add_rule(rule)
        
        # Then
        rules = alert_manager.get_rules()
        assert len(rules) == 1
        assert rules[0].rule_id == "cost-alert"
        assert rules[0].threshold == 50.0

    def test_given_duplicate_rule_id_when_added_then_raises_value_error(self, alert_manager):
        """Test that duplicate rule IDs are rejected."""
        # Given
        rule1 = AlertRule(
            rule_id="duplicate",
            metric=MetricType.ERROR_RATE,
            threshold=10.0,
            channel=AlertChannel.STDOUT,
            config={},
        )
        rule2 = AlertRule(
            rule_id="duplicate",
            metric=MetricType.AVG_LATENCY,
            threshold=1000.0,
            channel=AlertChannel.EMAIL,
            config={},
        )
        alert_manager.add_rule(rule1)
        
        # When/Then
        with pytest.raises(ValueError, match="already exists"):
            alert_manager.add_rule(rule2)

    def test_given_existing_rule_when_removed_then_deleted_from_database(self, alert_manager):
        """Test that rule can be removed from database."""
        # Given
        rule = AlertRule(
            rule_id="temp-rule",
            metric=MetricType.TOKEN_USAGE,
            threshold=500000,
            channel=AlertChannel.STDOUT,
            config={},
        )
        alert_manager.add_rule(rule)
        
        # When
        alert_manager.remove_rule("temp-rule")
        
        # Then
        rules = alert_manager.get_rules()
        assert len(rules) == 0

    def test_given_nonexistent_rule_when_removed_then_raises_value_error(self, alert_manager):
        """Test that removing nonexistent rule raises error."""
        # Given/When/Then
        with pytest.raises(ValueError, match="not found"):
            alert_manager.remove_rule("nonexistent")

    def test_given_rule_when_enabled_then_updates_database(self, alert_manager):
        """Test that rule can be enabled."""
        # Given
        rule = AlertRule(
            rule_id="test-rule",
            metric=MetricType.DAILY_COST,
            threshold=100.0,
            channel=AlertChannel.STDOUT,
            config={},
            enabled=False,
        )
        alert_manager.add_rule(rule)
        
        # When
        alert_manager.set_rule_enabled("test-rule", True)
        
        # Then
        rules = alert_manager.get_rules()
        assert rules[0].enabled is True

    def test_given_rule_when_disabled_then_updates_database(self, alert_manager):
        """Test that rule can be disabled."""
        # Given
        rule = AlertRule(
            rule_id="test-rule",
            metric=MetricType.ERROR_RATE,
            threshold=5.0,
            channel=AlertChannel.STDOUT,
            config={},
            enabled=True,
        )
        alert_manager.add_rule(rule)
        
        # When
        alert_manager.set_rule_enabled("test-rule", False)
        
        # Then
        rules = alert_manager.get_rules()
        assert rules[0].enabled is False

    @patch("empathy_os.monitoring.alerts.urllib.request.urlopen")
    def test_given_webhook_channel_when_alert_triggered_then_sends_http_request(
        self, mock_urlopen, alert_manager
    ):
        """Test that webhook alert sends HTTP POST request."""
        # Given
        mock_response = Mock()
        mock_response.status = 200
        mock_urlopen.return_value.__enter__.return_value = mock_response
        
        rule = AlertRule(
            rule_id="webhook-test",
            metric=MetricType.DAILY_