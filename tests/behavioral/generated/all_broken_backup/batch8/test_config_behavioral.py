"""Behavioral tests for config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import os
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, mock_open, patch

import pytest

from empathy_os.config import (
    YAML_AVAILABLE,
    EmpathyConfig,
    _validate_file_path,
)


class TestValidateFilePath:
    """Behavioral tests for _validate_file_path function."""

    def test_given_valid_path_when_validated_then_returns_resolved_path(self):
        """GIVEN a valid file path
        WHEN _validate_file_path is called
        THEN it returns a resolved Path object
        """
        # Given
        path = "test_file.txt"

        # When
        result = _validate_file_path(path)

        # Then
        assert isinstance(result, Path)
        assert result.is_absolute()

    def test_given_empty_path_when_validated_then_raises_value_error(self):
        """GIVEN an empty path string
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = ""

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_none_path_when_validated_then_raises_value_error(self):
        """GIVEN None as path
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = None

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_non_string_path_when_validated_then_raises_value_error(self):
        """GIVEN a non-string path
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = 123

        # When/Then
        with pytest.raises(ValueError, match="path must be a non-empty string"):
            _validate_file_path(path)

    def test_given_path_with_null_bytes_when_validated_then_raises_value_error(self):
        """GIVEN a path containing null bytes
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = "test\x00file.txt"

        # When/Then
        with pytest.raises(ValueError, match="path contains null bytes"):
            _validate_file_path(path)

    def test_given_path_outside_allowed_dir_when_validated_then_raises_value_error(self):
        """GIVEN a path outside allowed directory
        WHEN _validate_file_path is called with allowed_dir
        THEN it raises ValueError
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            path = "/tmp/outside.txt"
            allowed_dir = tmpdir

            # When/Then
            with pytest.raises(ValueError, match="path must be within"):
                _validate_file_path(path, allowed_dir=allowed_dir)

    def test_given_path_inside_allowed_dir_when_validated_then_returns_path(self):
        """GIVEN a path inside allowed directory
        WHEN _validate_file_path is called with allowed_dir
        THEN it returns the resolved path
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            path = os.path.join(tmpdir, "inside.txt")
            allowed_dir = tmpdir

            # When
            result = _validate_file_path(path, allowed_dir=allowed_dir)

            # Then
            assert isinstance(result, Path)
            assert str(result).startswith(tmpdir)

    def test_given_etc_path_when_validated_then_raises_value_error(self):
        """GIVEN a path in /etc directory
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = "/etc/passwd"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_sys_path_when_validated_then_raises_value_error(self):
        """GIVEN a path in /sys directory
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = "/sys/kernel"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_proc_path_when_validated_then_raises_value_error(self):
        """GIVEN a path in /proc directory
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = "/proc/cpuinfo"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    def test_given_dev_path_when_validated_then_raises_value_error(self):
        """GIVEN a path in /dev directory
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        path = "/dev/null"

        # When/Then
        with pytest.raises(ValueError, match="Cannot write to system directory"):
            _validate_file_path(path)

    @patch("empathy_os.config.Path")
    def test_given_invalid_path_when_resolved_then_raises_value_error(self, mock_path_class):
        """GIVEN an invalid path that cannot be resolved
        WHEN _validate_file_path is called
        THEN it raises ValueError
        """
        # Given
        mock_path = MagicMock()
        mock_path.resolve.side_effect = OSError("Invalid path")
        mock_path_class.return_value = mock_path
        path = "invalid_path"

        # When/Then
        with pytest.raises(ValueError, match="Invalid path"):
            _validate_file_path(path)

    def test_given_path_with_traversal_when_validated_with_allowed_dir_then_raises_error(self):
        """GIVEN a path with directory traversal
        WHEN _validate_file_path is called with allowed_dir
        THEN it raises ValueError
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            path = os.path.join(tmpdir, "..", "..", "etc", "passwd")
            allowed_dir = tmpdir

            # When/Then
            with pytest.raises(ValueError, match="path must be within"):
                _validate_file_path(path, allowed_dir=allowed_dir)


class TestEmpathyConfig:
    """Behavioral tests for EmpathyConfig class."""

    def test_given_no_args_when_config_created_then_uses_defaults(self):
        """GIVEN no arguments
        WHEN EmpathyConfig is instantiated
        THEN it uses default values
        """
        # Given/When
        config = EmpathyConfig()

        # Then
        assert config.user_id == "default_user"
        assert config.target_level == 3
        assert config.confidence_threshold == 0.75
        assert config.trust_building_rate == 0.05
        assert config.trust_erosion_rate == 0.10
        assert config.persistence_enabled is True
        assert config.persistence_backend == "sqlite"
        assert config.persistence_path == "./empathy_data"
        assert config.state_persistence is True
        assert config.state_path == "./empathy_state"
        assert config.metrics_enabled is True
        assert config.metrics_path == "./metrics.db"
        assert config.log_level == "INFO"
        assert config.log_file is None
        assert config.structured_logging is True
        assert config.pattern_library_enabled is True
        assert config.pattern_sharing is True
        assert config.pattern_confidence_threshold == 0.3

    def test_given_custom_values_when_config_created_then_uses_custom_values(self):
        """GIVEN custom configuration values
        WHEN EmpathyConfig is instantiated
        THEN it uses provided values
        """
        # Given
        custom_user = "custom_user"
        custom_level = 5
        custom_threshold = 0.9

        # When
        config = EmpathyConfig(
            user_id=custom_user,
            target_level=custom_level,
            confidence_threshold=custom_threshold,
        )

        # Then
        assert config.user_id == custom_user
        assert config.target_level == custom_level
        assert config.confidence_threshold == custom_threshold

    def test_given_config_when_converted_to_dict_then_returns_dict(self):
        """GIVEN an EmpathyConfig instance
        WHEN converted to dict using asdict
        THEN it returns a dictionary with all fields
        """
        # Given
        config = EmpathyConfig(user_id="test_user", target_level=4)

        # When
        config_dict = config.to_dict()

        # Then
        assert isinstance(config_dict, dict)
        assert config_dict["user_id"] == "test_user"
        assert config_dict["target_level"] == 4
        assert "confidence_threshold" in config_dict

    def test_given_yaml_file_when_loaded_then_returns_config(self):
        """GIVEN a YAML configuration file
        WHEN load_from_yaml is called
        THEN it returns EmpathyConfig with loaded values
        """
        if not YAML_AVAILABLE:
            pytest.skip("YAML not available")

        # Given
        yaml_content = """
user_id: yaml_user
target_level: 5
confidence_threshold: 0.85
"""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".yml", delete=False) as f:
            f.write(yaml_content)
            yaml_path = f.name

        try:
            # When
            config = EmpathyConfig.load_from_yaml(yaml_path)

            # Then
            assert config.user_id == "yaml_user"
            assert config.target_level == 5
            assert config.confidence_threshold == 0.85
        finally:
            os.unlink(yaml_path)

    def test_given_nonexistent_yaml_file_when_loaded_then_raises_file_not_found(self):
        """GIVEN a non-existent YAML file path
        WHEN load_from_yaml is called
        THEN it raises FileNotFoundError
        """
        if not YAML_AVAILABLE:
            pytest.skip("YAML not available")

        # Given
        nonexistent_path = "/nonexistent/path/config.yml"

        # When/Then
        with pytest.raises(FileNotFoundError):
            EmpathyConfig.load_from_yaml(nonexistent_path)

    def test_given_invalid_yaml_when_loaded_then_raises_value_error(self):
        """GIVEN an invalid YAML file
        WHEN load_from_yaml is called
        THEN it raises ValueError
        """
        if not YAML_AVAILABLE:
            pytest.skip("YAML not available")

        # Given
        invalid_yaml = "{ invalid yaml content ["
        with tempfile.NamedTemporaryFile(mode="w", suffix=".yml", delete=False) as f:
            f.write(invalid_yaml)
            yaml_path = f.name

        try:
            # When/Then
            with pytest.raises(ValueError):
                EmpathyConfig.load_from_yaml(yaml_path)
        finally:
            os.unlink(yaml_path)

    def test_given_json_file_when_loaded_then_returns_config(self):
        """GIVEN a JSON configuration file
        WHEN load_from_json is called
        THEN it returns EmpathyConfig with loaded values
        """
        # Given
        json_content = {
            "user_id": "json_user",
            "target_level": 4,
            "confidence_threshold": 0.8,
        }
        with tempfile.NamedTemporaryFile(
            mode="w", suffix=".json", delete=False
        ) as f:
            json.dump(json_content, f)
            json_path = f.name

        try:
            # When
            config = EmpathyConfig.load_from_json(json_path)

            # Then
            assert config.user_id == "json_user"
            assert config.target_level == 4
            assert config.confidence_threshold == 0.8
        finally:
            os.unlink(json_path)

    def test_given_nonexistent_json_file_when_loaded_then_raises_file_not_found(self):
        """GIVEN a non-existent JSON file path
        WHEN load_from_json is called
        THEN it raises FileNotFoundError
        """
        # Given
        nonexistent_path = "/nonexistent/path/config.json"

        # When/Then
        with pytest.raises(FileNotFoundError):
            EmpathyConfig.load_from_json(nonexistent_path)

    def test_given_invalid_json_when_loaded_then_raises_value_error(self):
        """GIVEN an invalid JSON file
        WHEN load_from_json is called
        THEN it raises ValueError
        """
        # Given
        invalid_json = "{ invalid json content"
        with tempfile.NamedTemporaryFile(
            mode="w", suffix=".json", delete=False
        ) as f:
            f.write(invalid_json)
            json_path = f.name

        try:
            # When/Then
            with pytest.raises(ValueError):
                EmpathyConfig.load_from_json(json_path)
        finally:
            os.unlink(json_path)

    def test_given_env_vars_when_loaded_then_returns_config(self):
        """GIVEN environment variables
        WHEN load_from_env is called
        THEN it returns EmpathyConfig with values from environment
        """
        # Given
        env_vars = {
            "EMPATHY_USER_ID": "env_user",
            "EMPATHY_TARGET_LEVEL": "6",
            "EMPATHY_CONFIDENCE_THRESHOLD": "0.95",
            "EMPATHY_PERSISTENCE_ENABLED": "false",
            "EMPATHY_METRICS_ENABLED": "true",
        }

        with patch.dict(os.environ, env_vars):
            # When
            config = EmpathyConfig.load_from_env()

            # Then
            assert config.user_id == "env_user"
            assert config.target_level == 6
            assert config.confidence_threshold == 0.95
            assert config.persistence_enabled is False
            assert config.metrics_enabled is True

    def test_given_no_env_vars_when_loaded_then_uses_defaults(self):
        """GIVEN no environment variables
        WHEN load_from_env is called
        THEN it returns EmpathyConfig with default values
        """
        # Given
        with patch.dict(os.environ, {}, clear=True):
            # When
            config = EmpathyConfig.load_from_env()

            # Then
            assert config.user_id == "default_user"
            assert config.target_level == 3
            assert config.confidence_threshold == 0.75

    def test_given_invalid_int_env_var_when_loaded_then_uses_default(self):
        """GIVEN invalid integer environment variable
        WHEN load_from_env is called
        THEN it uses default value for that field
        """
        #