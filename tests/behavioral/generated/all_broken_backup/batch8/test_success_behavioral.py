"""Behavioral tests for success.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from datetime import datetime
from typing import Any
from unittest.mock import Mock

import pytest

from empathy_os.socratic.success import (
    MetricDirection,
    MetricType,
    SuccessMetric,
)


class TestMetricType:
    """Tests for MetricType enum."""

    def test_given_metric_type_when_accessing_values_then_returns_correct_strings(self):
        """Given: MetricType enum
        When: Accessing enum values
        Then: Returns correct string values
        """
        # Given/When/Then
        assert MetricType.COUNT.value == "count"
        assert MetricType.PERCENTAGE.value == "percentage"
        assert MetricType.RATIO.value == "ratio"
        assert MetricType.DURATION.value == "duration"
        assert MetricType.BOOLEAN.value == "boolean"
        assert MetricType.IMPROVEMENT.value == "improvement"
        assert MetricType.THRESHOLD.value == "threshold"
        assert MetricType.SCORE.value == "score"
        assert MetricType.RATING.value == "rating"

    def test_given_metric_type_string_when_creating_from_value_then_creates_enum(self):
        """Given: String value
        When: Creating MetricType from string
        Then: Returns correct enum member
        """
        # Given
        value = "count"

        # When
        metric_type = MetricType(value)

        # Then
        assert metric_type == MetricType.COUNT

    def test_given_all_metric_types_when_checking_count_then_has_nine_types(self):
        """Given: MetricType enum
        When: Counting all types
        Then: Has exactly 9 metric types
        """
        # Given/When
        all_types = list(MetricType)

        # Then
        assert len(all_types) == 9


class TestMetricDirection:
    """Tests for MetricDirection enum."""

    def test_given_metric_direction_when_accessing_values_then_returns_correct_strings(self):
        """Given: MetricDirection enum
        When: Accessing enum values
        Then: Returns correct string values
        """
        # Given/When/Then
        assert MetricDirection.HIGHER_IS_BETTER.value == "higher"
        assert MetricDirection.LOWER_IS_BETTER.value == "lower"
        assert MetricDirection.TARGET_VALUE.value == "target"
        assert MetricDirection.RANGE.value == "range"

    def test_given_direction_string_when_creating_from_value_then_creates_enum(self):
        """Given: String value
        When: Creating MetricDirection from string
        Then: Returns correct enum member
        """
        # Given
        value = "higher"

        # When
        direction = MetricDirection(value)

        # Then
        assert direction == MetricDirection.HIGHER_IS_BETTER

    def test_given_all_directions_when_checking_count_then_has_four_directions(self):
        """Given: MetricDirection enum
        When: Counting all directions
        Then: Has exactly 4 directions
        """
        # Given/When
        all_directions = list(MetricDirection)

        # Then
        assert len(all_directions) == 4


class TestSuccessMetric:
    """Tests for SuccessMetric dataclass."""

    @pytest.fixture
    def basic_metric(self) -> SuccessMetric:
        """Fixture providing a basic success metric."""
        return SuccessMetric(
            id="test_metric",
            name="Test Metric",
            description="A test metric",
            metric_type=MetricType.COUNT,
        )

    @pytest.fixture
    def count_metric(self) -> SuccessMetric:
        """Fixture providing a count-based metric."""
        return SuccessMetric(
            id="security_issues_found",
            name="Security Issues Detected",
            description="Number of security vulnerabilities identified",
            metric_type=MetricType.COUNT,
            direction=MetricDirection.HIGHER_IS_BETTER,
            minimum_value=0,
            unit="issues",
        )

    @pytest.fixture
    def percentage_metric(self) -> SuccessMetric:
        """Fixture providing a percentage-based metric."""
        return SuccessMetric(
            id="code_coverage",
            name="Code Coverage",
            description="Percentage of code covered by tests",
            metric_type=MetricType.PERCENTAGE,
            direction=MetricDirection.HIGHER_IS_BETTER,
            target_value=80.0,
            minimum_value=0.0,
            maximum_value=100.0,
            unit="%",
        )

    @pytest.fixture
    def duration_metric(self) -> SuccessMetric:
        """Fixture providing a duration-based metric."""
        return SuccessMetric(
            id="execution_time",
            name="Execution Time",
            description="Time taken to complete workflow",
            metric_type=MetricType.DURATION,
            direction=MetricDirection.LOWER_IS_BETTER,
            maximum_value=300.0,
            unit="seconds",
        )

    @pytest.fixture
    def target_metric(self) -> SuccessMetric:
        """Fixture providing a target value metric."""
        return SuccessMetric(
            id="optimal_temperature",
            name="Optimal Temperature",
            description="Target temperature for process",
            metric_type=MetricType.SCORE,
            direction=MetricDirection.TARGET_VALUE,
            target_value=75.0,
            unit="Â°F",
        )

    @pytest.fixture
    def range_metric(self) -> SuccessMetric:
        """Fixture providing a range-based metric."""
        return SuccessMetric(
            id="response_time",
            name="Response Time",
            description="Time to respond within acceptable range",
            metric_type=MetricType.DURATION,
            direction=MetricDirection.RANGE,
            minimum_value=100.0,
            maximum_value=500.0,
            unit="ms",
        )

    @pytest.fixture
    def boolean_metric(self) -> SuccessMetric:
        """Fixture providing a boolean metric."""
        return SuccessMetric(
            id="tests_pass",
            name="Tests Pass",
            description="Whether all tests pass",
            metric_type=MetricType.BOOLEAN,
            direction=MetricDirection.HIGHER_IS_BETTER,
        )

    @pytest.fixture
    def weighted_metric(self) -> SuccessMetric:
        """Fixture providing a weighted metric."""
        return SuccessMetric(
            id="performance_score",
            name="Performance Score",
            description="Overall performance rating",
            metric_type=MetricType.SCORE,
            direction=MetricDirection.HIGHER_IS_BETTER,
            weight=0.8,
            is_primary=True,
        )

    @pytest.fixture
    def custom_extractor_metric(self) -> SuccessMetric:
        """Fixture providing a metric with custom extractor."""
        return SuccessMetric(
            id="custom_metric",
            name="Custom Metric",
            description="Metric with custom extraction",
            metric_type=MetricType.COUNT,
            extractor=lambda data: len(data.get("items", [])),
        )

    def test_given_minimal_params_when_creating_metric_then_creates_with_defaults(self):
        """Given: Minimal required parameters
        When: Creating SuccessMetric
        Then: Creates metric with default values
        """
        # Given
        metric_id = "test_id"
        name = "Test Name"
        description = "Test Description"
        metric_type = MetricType.COUNT

        # When
        metric = SuccessMetric(
            id=metric_id,
            name=name,
            description=description,
            metric_type=metric_type,
        )

        # Then
        assert metric.id == metric_id
        assert metric.name == name
        assert metric.description == description
        assert metric.metric_type == metric_type
        assert metric.direction == MetricDirection.HIGHER_IS_BETTER
        assert metric.target_value is None
        assert metric.minimum_value is None
        assert metric.maximum_value is None
        assert metric.unit == ""
        assert metric.weight == 1.0
        assert metric.is_primary is False
        assert metric.extraction_path == ""
        assert metric.extractor is None

    def test_given_all_params_when_creating_metric_then_creates_with_all_values(self):
        """Given: All parameters provided
        When: Creating SuccessMetric
        Then: Creates metric with all specified values
        """
        # Given
        extractor = lambda x: x

        # When
        metric = SuccessMetric(
            id="full_metric",
            name="Full Metric",
            description="Complete metric definition",
            metric_type=MetricType.PERCENTAGE,
            direction=MetricDirection.TARGET_VALUE,
            target_value=85.0,
            minimum_value=50.0,
            maximum_value=100.0,
            unit="%",
            weight=0.75,
            is_primary=True,
            extraction_path="$.data.score",
            extractor=extractor,
        )

        # Then
        assert metric.id == "full_metric"
        assert metric.name == "Full Metric"
        assert metric.description == "Complete metric definition"
        assert metric.metric_type == MetricType.PERCENTAGE
        assert metric.direction == MetricDirection.TARGET_VALUE
        assert metric.target_value == 85.0
        assert metric.minimum_value == 50.0
        assert metric.maximum_value == 100.0
        assert metric.unit == "%"
        assert metric.weight == 0.75
        assert metric.is_primary is True
        assert metric.extraction_path == "$.data.score"
        assert metric.extractor == extractor

    def test_given_count_metric_when_evaluating_higher_value_then_returns_success(
        self, count_metric
    ):
        """Given: Count metric with HIGHER_IS_BETTER direction
        When: Evaluating with higher value
        Then: Returns success result
        """
        # Given
        value = 10.0
        baseline = 5.0

        # When
        result = count_metric.evaluate(value, baseline)

        # Then - this will test the evaluate method when implemented
        # For now, we just test that the method exists
        assert hasattr(count_metric, "evaluate")

    def test_given_percentage_metric_when_checking_attributes_then_has_correct_values(
        self, percentage_metric
    ):
        """Given: Percentage metric
        When: Checking attributes
        Then: Has correct values for percentage type
        """
        # Given/When/Then
        assert percentage_metric.id == "code_coverage"
        assert percentage_metric.metric_type == MetricType.PERCENTAGE
        assert percentage_metric.target_value == 80.0
        assert percentage_metric.minimum_value == 0.0
        assert percentage_metric.maximum_value == 100.0
        assert percentage_metric.unit == "%"

    def test_given_duration_metric_when_checking_direction_then_is_lower_better(
        self, duration_metric
    ):
        """Given: Duration metric
        When: Checking direction
        Then: Direction is LOWER_IS_BETTER
        """
        # Given/When/Then
        assert duration_metric.metric_type == MetricType.DURATION
        assert duration_metric.direction == MetricDirection.LOWER_IS_BETTER
        assert duration_metric.maximum_value == 300.0

    def test_given_target_metric_when_checking_direction_then_is_target_value(
        self, target_metric
    ):
        """Given: Target value metric
        When: Checking direction
        Then: Direction is TARGET_VALUE
        """
        # Given/When/Then
        assert target_metric.direction == MetricDirection.TARGET_VALUE
        assert target_metric.target_value == 75.0

    def test_given_range_metric_when_checking_bounds_then_has_min_and_max(
        self, range_metric
    ):
        """Given: Range metric
        When: Checking bounds
        Then: Has both minimum and maximum values
        """
        # Given/When/Then
        assert range_metric.direction == MetricDirection.RANGE
        assert range_metric.minimum_value == 100.0
        assert range_metric.maximum_value == 500.0

    def test_given_boolean_metric_when_checking_type_then_is_boolean(
        self, boolean_metric
    ):
        """Given: Boolean metric
        When: Checking type
        Then: Type is BOOLEAN
        """
        # Given/When/Then
        assert boolean_metric.metric_type == MetricType.BOOLEAN
        assert boolean_metric.minimum_value is None
        assert boolean_metric.maximum_value is None

    def test_given_weighted_metric_when_checking_weight_then_has_custom_weight(
        self, weighted_metric
    ):
        """Given: Weighted metric
        When: Checking weight
        Then: Has custom weight value
        """
        # Given/When/Then
        assert weighted_metric.weight == 0.8
        assert weighted_metric.is_primary is True

    def test_given_custom_extractor_when_checking_extractor_then_is_callable(
        self, custom_extractor_metric
    ):
        """Given: Metric with custom extractor
        When: Checking extractor
        Then: Extractor is callable
        """
        # Given/When/Then
        assert custom_extractor_metric.extractor is not None
        assert callable(custom_extractor_metric.extractor)

    def test_given_custom_extractor_when_calling_with_data_then_extracts_value(
        self, custom_extractor_metric
    ):
        """Given: Metric with custom extractor
        When: Calling extractor with data
        Then: Extracts correct value
        """
        # Given
        data = {"items": [1, 2, 3, 4, 5]}

        # When
        result = custom_extractor_metric.extractor(data)

        # Then
        assert result == 5

    def test_given_custom_extractor_when_calling_with_empty_data_then_returns_zero(
        self, custom_extractor_metric
    ):
        """Given: Metric with custom extractor
        When: Calling extractor with empty data
        Then: Returns zero
        """
        # Given
        data = {}

        # When
        result = custom_extractor_metric.extractor(data)

        # Then
        assert result == 0

    def test_given_metric_when_comparing_equality_then_compares_by_id(self):
        """Given: Two metrics with same id
        When: Comparing equality
        Then: Considers them equal based on id
        """
        # Given
        metric1 = SuccessMetric(
            id="same_id",
            name="Name 1",
            description="Desc 1",
            metric_type=MetricType.COUNT,
        )
        metric2 = SuccessMetric(
            id="same_id",
            name="Name 2",
            description="Desc 2",
            metric_type=MetricType.PERCENTAGE,
        )

        # When/Then
        # Note: dataclasses compare by all fields by default
        # This test documents current behavior
        assert metric1.id == metric2.id
        assert metric1 != metric2  # Different other fields

    def test_given_metric_when_converting_to_string_then_returns_representation(
        self, basic_metric
    ):
        """Given: Success metric
        When: Converting to