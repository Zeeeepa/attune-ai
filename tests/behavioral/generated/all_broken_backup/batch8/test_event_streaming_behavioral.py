"""Behavioral tests for event_streaming.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import time
from datetime import datetime
from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest
from redis.exceptions import ConnectionError, RedisError, ResponseError

from empathy_os.telemetry.event_streaming import EventStreamer, StreamEvent


@pytest.fixture
def mock_redis():
    """Fixture providing a mocked Redis client."""
    with patch("empathy_os.telemetry.event_streaming.redis.Redis") as mock:
        redis_instance = MagicMock()
        mock.return_value = redis_instance
        yield redis_instance


@pytest.fixture
def event_streamer(mock_redis):
    """Fixture providing an EventStreamer instance with mocked Redis."""
    return EventStreamer()


@pytest.fixture
def sample_event_data():
    """Fixture providing sample event data."""
    return {
        "agent_id": "worker-1",
        "status": "running",
        "progress": 0.5,
        "metadata": {"task": "processing", "priority": "high"},
    }


@pytest.fixture
def sample_stream_event():
    """Fixture providing a sample StreamEvent."""
    return StreamEvent(
        event_id="1706356800000-0",
        event_type="agent_heartbeat",
        timestamp=datetime(2025, 1, 27, 12, 0, 0),
        data={"agent_id": "worker-1", "status": "running"},
        source="empathy_os",
    )


class TestStreamEvent:
    """Behavioral tests for StreamEvent dataclass."""

    def test_to_dict_with_datetime_timestamp(self):
        """
        GIVEN a StreamEvent with a datetime timestamp
        WHEN to_dict is called
        THEN it returns a properly formatted dictionary with ISO timestamp
        """
        # Given
        event = StreamEvent(
            event_id="12345-0",
            event_type="agent_heartbeat",
            timestamp=datetime(2025, 1, 27, 12, 30, 45),
            data={"agent_id": "test-agent"},
            source="test_source",
        )

        # When
        result = event.to_dict()

        # Then
        assert result["event_id"] == "12345-0"
        assert result["event_type"] == "agent_heartbeat"
        assert result["timestamp"] == "2025-01-27T12:30:45"
        assert result["data"] == {"agent_id": "test-agent"}
        assert result["source"] == "test_source"

    def test_to_dict_with_string_timestamp(self):
        """
        GIVEN a StreamEvent with a string timestamp
        WHEN to_dict is called
        THEN it returns the timestamp as-is
        """
        # Given
        event = StreamEvent(
            event_id="12345-0",
            event_type="workflow_progress",
            timestamp="2025-01-27T12:30:45",
            data={},
            source="empathy_os",
        )

        # When
        result = event.to_dict()

        # Then
        assert result["timestamp"] == "2025-01-27T12:30:45"

    def test_to_dict_with_complex_data(self):
        """
        GIVEN a StreamEvent with nested data structures
        WHEN to_dict is called
        THEN it preserves the complex data structure
        """
        # Given
        complex_data = {
            "agent_id": "worker-1",
            "metrics": {"cpu": 0.75, "memory": 0.60},
            "tags": ["production", "critical"],
            "nested": {"level1": {"level2": "value"}},
        }
        event = StreamEvent(
            event_id="12345-0",
            event_type="agent_heartbeat",
            timestamp=datetime(2025, 1, 27, 12, 0, 0),
            data=complex_data,
        )

        # When
        result = event.to_dict()

        # Then
        assert result["data"] == complex_data
        assert result["data"]["metrics"]["cpu"] == 0.75
        assert result["data"]["tags"] == ["production", "critical"]

    def test_from_redis_entry_with_valid_data(self):
        """
        GIVEN valid Redis stream entry data
        WHEN from_redis_entry is called
        THEN it creates a properly initialized StreamEvent
        """
        # Given
        event_id = "1706356800000-0"
        entry_data = {
            b"event_type": b"agent_heartbeat",
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b'{"agent_id": "worker-1", "status": "running"}',
            b"source": b"empathy_os",
        }

        # When
        event = StreamEvent.from_redis_entry(event_id, entry_data)

        # Then
        assert event.event_id == event_id
        assert event.event_type == "agent_heartbeat"
        assert event.timestamp == datetime(2025, 1, 27, 12, 0, 0)
        assert event.data == {"agent_id": "worker-1", "status": "running"}
        assert event.source == "empathy_os"

    def test_from_redis_entry_with_invalid_timestamp(self):
        """
        GIVEN Redis entry with invalid timestamp
        WHEN from_redis_entry is called
        THEN it defaults to current UTC time
        """
        # Given
        entry_data = {
            b"event_type": b"agent_error",
            b"timestamp": b"invalid-timestamp",
            b"data": b"{}",
        }

        # When
        with patch("empathy_os.telemetry.event_streaming.datetime") as mock_datetime:
            mock_datetime.fromisoformat.side_effect = ValueError
            mock_datetime.utcnow.return_value = datetime(2025, 1, 27, 15, 0, 0)
            event = StreamEvent.from_redis_entry("12345-0", entry_data)

        # Then
        assert event.timestamp == datetime(2025, 1, 27, 15, 0, 0)

    def test_from_redis_entry_with_invalid_json(self):
        """
        GIVEN Redis entry with invalid JSON data
        WHEN from_redis_entry is called
        THEN it defaults to empty dict for data
        """
        # Given
        entry_data = {
            b"event_type": b"coordination_signal",
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b"invalid-json{",
        }

        # When
        event = StreamEvent.from_redis_entry("12345-0", entry_data)

        # Then
        assert event.data == {}
        assert event.event_type == "coordination_signal"

    def test_from_redis_entry_with_missing_fields(self):
        """
        GIVEN Redis entry with missing fields
        WHEN from_redis_entry is called
        THEN it uses default values
        """
        # Given
        entry_data = {}

        # When
        event = StreamEvent.from_redis_entry("12345-0", entry_data)

        # Then
        assert event.event_type == "unknown"
        assert event.data == {}
        assert event.source == "empathy_os"
        assert isinstance(event.timestamp, datetime)

    def test_from_redis_entry_with_empty_data_field(self):
        """
        GIVEN Redis entry with empty data field
        WHEN from_redis_entry is called
        THEN it creates event with empty dict
        """
        # Given
        entry_data = {
            b"event_type": b"workflow_progress",
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b"",
        }

        # When
        event = StreamEvent.from_redis_entry("12345-0", entry_data)

        # Then
        assert event.data == {}


class TestEventStreamerInit:
    """Behavioral tests for EventStreamer initialization."""

    def test_init_with_default_parameters(self, mock_redis):
        """
        GIVEN default parameters
        WHEN EventStreamer is initialized
        THEN it creates instance with default stream name and Redis connection
        """
        # When
        streamer = EventStreamer()

        # Then
        assert streamer.stream_name == "empathy_os:events"
        assert streamer.redis_client is not None

    def test_init_with_custom_stream_name(self, mock_redis):
        """
        GIVEN custom stream name
        WHEN EventStreamer is initialized
        THEN it uses the custom stream name
        """
        # When
        streamer = EventStreamer(stream_name="custom:stream")

        # Then
        assert streamer.stream_name == "custom:stream"

    @patch("empathy_os.telemetry.event_streaming.redis.Redis")
    def test_init_with_custom_redis_config(self, mock_redis_class):
        """
        GIVEN custom Redis configuration
        WHEN EventStreamer is initialized
        THEN it creates Redis client with custom config
        """
        # When
        streamer = EventStreamer(
            redis_host="custom-host", redis_port=6380, redis_db=2
        )

        # Then
        mock_redis_class.assert_called_once_with(
            host="custom-host",
            port=6380,
            db=2,
            decode_responses=False,
        )


class TestEventStreamerPublish:
    """Behavioral tests for publishing events."""

    def test_publish_event_success(self, event_streamer, mock_redis, sample_event_data):
        """
        GIVEN valid event data
        WHEN publish_event is called
        THEN it publishes to Redis stream and returns event ID
        """
        # Given
        mock_redis.xadd.return_value = b"1706356800000-0"

        # When
        event_id = event_streamer.publish_event(
            event_type="agent_heartbeat", data=sample_event_data
        )

        # Then
        assert event_id == "1706356800000-0"
        mock_redis.xadd.assert_called_once()
        call_args = mock_redis.xadd.call_args
        assert call_args[0][0] == "empathy_os:events"
        assert call_args[1]["maxlen"] == 10000
        assert "event_type" in call_args[0][1]
        assert "timestamp" in call_args[0][1]
        assert "data" in call_args[0][1]

    def test_publish_event_with_custom_source(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """
        GIVEN custom source parameter
        WHEN publish_event is called
        THEN it includes the custom source in the event
        """
        # Given
        mock_redis.xadd.return_value = b"1706356800000-0"

        # When
        event_streamer.publish_event(
            event_type="coordination_signal",
            data=sample_event_data,
            source="custom_source",
        )

        # Then
        call_args = mock_redis.xadd.call_args[0][1]
        assert call_args["source"] == "custom_source"

    def test_publish_event_serializes_data_to_json(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """
        GIVEN event data with complex types
        WHEN publish_event is called
        THEN it serializes data to JSON string
        """
        # Given
        mock_redis.xadd.return_value = b"1706356800000-0"

        # When
        event_streamer.publish_event(
            event_type="workflow_progress", data=sample_event_data
        )

        # Then
        call_args = mock_redis.xadd.call_args[0][1]
        assert isinstance(call_args["data"], str)
        parsed = json.loads(call_args["data"])
        assert parsed == sample_event_data

    def test_publish_event_with_redis_error(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """
        GIVEN Redis connection error
        WHEN publish_event is called
        THEN it raises RedisError
        """
        # Given
        mock_redis.xadd.side_effect = ConnectionError("Connection failed")

        # When/Then
        with pytest.raises(ConnectionError):
            event_streamer.publish_event(
                event_type="agent_error", data=sample_event_data
            )

    def test_publish_event_with_empty_data(self, event_streamer, mock_redis):
        """
        GIVEN empty data dictionary
        WHEN publish_event is called
        THEN it publishes event with empty JSON object
        """
        # Given
        mock_redis.xadd.return_value = b"1706356800000-0"

        # When
        event_id = event_streamer.publish_event(event_type="agent_heartbeat", data={})

        # Then
        assert event_id == "1706356800000-0"
        call_args = mock_redis.xadd.call_args[0][1]
        assert call_args["data"] == "{}"

    def test_publish_event_timestamp_format(self, event_streamer, mock_redis):
        """
        GIVEN event publication
        WHEN publish_event is called
        THEN it includes properly formatted ISO timestamp
        """
        # Given
        mock_redis.xadd.return_value = b"1706356800000-0"

        # When
        with patch("empathy_os.telemetry.event_streaming.datetime") as mock_datetime:
            mock_datetime.utcnow.return_value = datetime(2025, 1, 27, 12, 30, 45)
            event_streamer.publish_event(event_type="test", data={})

        # Then
        call_args = mock_redis.xadd.call_args[0][1]
        assert call_args["timestamp"] == "2025-01-27T12:30:45"


class TestEventStreamerConsume:
    """Behavioral tests for consuming events."""

    def test_consume_events_single_type(self, event_streamer, mock_redis):
        """
        GIVEN single event type filter
        WHEN consume_events is called
        THEN it yields events of that type
        """
        # Given
        mock_redis.xread.return_value = [
            [
                b"empathy_os:events",
                [
                    (
                        b"1706356800000-0",
                        {
                            b"event_type": b"agent_heartbeat",
                            b"timestamp": b"2025-01-27T12:00:00",
                            b"data": b'{"agent_id": "worker-1"}',
                            b"source": b"empathy_os",
                        },
                    )
                ],
            ]
        ]

        # When
        events = []
        consumer = event_streamer.consume_events(event_types=["agent_heartbeat"])
        for i, event in enumerate(consumer):
            events.append(event)
            if i >= 0:  # Get one event and break
                break

        # Then
        assert len(events) == 1
        assert events[0].event_type == "agent_heartbeat"
        assert events[0].data == {"agent_id": "worker-1"}

    def