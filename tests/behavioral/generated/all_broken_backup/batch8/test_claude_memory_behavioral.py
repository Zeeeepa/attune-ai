"""Behavioral tests for claude_memory.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import os
from pathlib import Path
from unittest.mock import Mock, PropertyMock, mock_open, patch

import pytest

from empathy_os.memory.claude_memory import (
    ClaudeMemoryConfig,
    ClaudeMemoryLoader,
    MemoryFile,
)


@pytest.fixture
def temp_project_root(tmp_path):
    """Given a temporary project root directory."""
    return tmp_path


@pytest.fixture
def basic_config():
    """Given a basic Claude memory configuration."""
    return ClaudeMemoryConfig(enabled=True)


@pytest.fixture
def disabled_config():
    """Given a disabled Claude memory configuration."""
    return ClaudeMemoryConfig(enabled=False)


@pytest.fixture
def selective_config():
    """Given a selective Claude memory configuration."""
    return ClaudeMemoryConfig(
        enabled=True,
        load_enterprise=False,
        load_user=True,
        load_project=True,
    )


@pytest.fixture
def mock_memory_files():
    """Given mock memory file contents."""
    return {
        "enterprise": "# Enterprise Memory\nOrg-wide guidelines",
        "user": "# User Memory\nPersonal preferences",
        "project": "# Project Memory\nProject-specific context",
    }


class TestClaudeMemoryConfig:
    """Behavioral tests for ClaudeMemoryConfig dataclass."""

    def test_default_configuration(self):
        """Given default initialization
        When creating a ClaudeMemoryConfig
        Then it should have sensible defaults."""
        # When
        config = ClaudeMemoryConfig()

        # Then
        assert config.enabled is False
        assert config.load_enterprise is True
        assert config.load_user is True
        assert config.load_project is True
        assert config.enterprise_memory_path is None
        assert config.project_root is None
        assert config.max_import_depth == 5
        assert config.max_file_size_bytes == 1_000_000
        assert config.validate_files is True

    def test_custom_configuration(self):
        """Given custom configuration values
        When creating a ClaudeMemoryConfig
        Then it should use the provided values."""
        # When
        config = ClaudeMemoryConfig(
            enabled=True,
            load_enterprise=False,
            enterprise_memory_path="/custom/path",
            max_import_depth=10,
            max_file_size_bytes=500_000,
        )

        # Then
        assert config.enabled is True
        assert config.load_enterprise is False
        assert config.enterprise_memory_path == "/custom/path"
        assert config.max_import_depth == 10
        assert config.max_file_size_bytes == 500_000


class TestMemoryFile:
    """Behavioral tests for MemoryFile dataclass."""

    def test_memory_file_creation(self):
        """Given memory file attributes
        When creating a MemoryFile
        Then it should store all attributes correctly."""
        # When
        memory = MemoryFile(
            level="user",
            path="/home/user/.claude/CLAUDE.md",
            content="# User Memory Content",
            imports=["@import common.md"],
            load_order=1,
        )

        # Then
        assert memory.level == "user"
        assert memory.path == "/home/user/.claude/CLAUDE.md"
        assert memory.content == "# User Memory Content"
        assert memory.imports == ["@import common.md"]
        assert memory.load_order == 1

    def test_memory_file_defaults(self):
        """Given minimal memory file attributes
        When creating a MemoryFile
        Then it should use default values for optional fields."""
        # When
        memory = MemoryFile(
            level="project",
            path="./CLAUDE.md",
            content="# Project Memory",
        )

        # Then
        assert memory.imports == []
        assert memory.load_order == 0


class TestClaudeMemoryLoaderInitialization:
    """Behavioral tests for ClaudeMemoryLoader initialization."""

    def test_loader_with_default_config(self):
        """Given no configuration
        When creating a ClaudeMemoryLoader
        Then it should use default configuration."""
        # When
        loader = ClaudeMemoryLoader()

        # Then
        assert loader.config is not None
        assert loader.config.enabled is False
        assert loader._memory_cache == {}
        assert loader._import_stack == []

    def test_loader_with_custom_config(self, basic_config):
        """Given a custom configuration
        When creating a ClaudeMemoryLoader
        Then it should use the provided configuration."""
        # When
        loader = ClaudeMemoryLoader(config=basic_config)

        # Then
        assert loader.config == basic_config
        assert loader.config.enabled is True


class TestClaudeMemoryLoaderDisabled:
    """Behavioral tests for disabled Claude memory loader."""

    def test_load_all_memory_when_disabled(self, disabled_config):
        """Given a disabled configuration
        When loading all memory
        Then it should return empty string without loading files."""
        # Given
        loader = ClaudeMemoryLoader(config=disabled_config)

        # When
        with patch("empathy_os.memory.claude_memory.logger") as mock_logger:
            result = loader.load_all_memory()

        # Then
        assert result == ""
        mock_logger.debug.assert_called_once_with("claude_memory_disabled")


class TestClaudeMemoryLoaderPathResolution:
    """Behavioral tests for memory file path resolution."""

    @patch("empathy_os.memory.claude_memory.Path.exists")
    @patch("empathy_os.memory.claude_memory.Path.is_file")
    def test_find_enterprise_memory_from_env(self, mock_is_file, mock_exists):
        """Given an environment variable for enterprise memory
        When finding enterprise memory path
        Then it should use the environment variable path."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        mock_exists.return_value = True
        mock_is_file.return_value = True

        # When
        with patch.dict(os.environ, {"CLAUDE_ENTERPRISE_MEMORY": "/custom/enterprise.md"}):
            path = loader._find_enterprise_memory()

        # Then
        assert path == Path("/custom/enterprise.md")

    @patch("empathy_os.memory.claude_memory.Path.exists")
    @patch("empathy_os.memory.claude_memory.Path.is_file")
    def test_find_enterprise_memory_from_config(self, mock_is_file, mock_exists):
        """Given enterprise memory path in config
        When finding enterprise memory path
        Then it should use the config path."""
        # Given
        config = ClaudeMemoryConfig(
            enabled=True,
            enterprise_memory_path="/config/enterprise.md"
        )
        loader = ClaudeMemoryLoader(config=config)
        mock_exists.return_value = True
        mock_is_file.return_value = True

        # When
        path = loader._find_enterprise_memory()

        # Then
        assert path == Path("/config/enterprise.md")

    @patch("empathy_os.memory.claude_memory.Path.exists")
    def test_find_enterprise_memory_default_location(self, mock_exists):
        """Given no explicit enterprise memory path
        When finding enterprise memory path
        Then it should check default location."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        mock_exists.side_effect = lambda: self == Path("/etc/claude/CLAUDE.md")

        # When
        path = loader._find_enterprise_memory()

        # Then
        assert path is None or path == Path("/etc/claude/CLAUDE.md")

    @patch("empathy_os.memory.claude_memory.Path.home")
    @patch("empathy_os.memory.claude_memory.Path.exists")
    @patch("empathy_os.memory.claude_memory.Path.is_file")
    def test_find_user_memory(self, mock_is_file, mock_exists, mock_home, tmp_path):
        """Given a user home directory
        When finding user memory path
        Then it should check ~/.claude/CLAUDE.md."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        mock_home.return_value = tmp_path
        user_claude_dir = tmp_path / ".claude"
        user_claude_dir.mkdir()
        user_memory = user_claude_dir / "CLAUDE.md"
        user_memory.write_text("# User Memory")
        mock_exists.return_value = True
        mock_is_file.return_value = True

        # When
        path = loader._find_user_memory()

        # Then
        assert path == user_memory

    def test_find_project_memory_in_claude_dir(self, temp_project_root):
        """Given a project with .claude/CLAUDE.md
        When finding project memory path
        Then it should return the .claude/CLAUDE.md path."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        claude_dir = temp_project_root / ".claude"
        claude_dir.mkdir()
        memory_file = claude_dir / "CLAUDE.md"
        memory_file.write_text("# Project Memory")

        # When
        path = loader._find_project_memory(str(temp_project_root))

        # Then
        assert path == memory_file

    def test_find_project_memory_in_root(self, temp_project_root):
        """Given a project with CLAUDE.md in root
        When finding project memory path
        Then it should return the root CLAUDE.md path."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        memory_file = temp_project_root / "CLAUDE.md"
        memory_file.write_text("# Project Memory")

        # When
        path = loader._find_project_memory(str(temp_project_root))

        # Then
        assert path == memory_file

    def test_find_project_memory_none_found(self, temp_project_root):
        """Given a project without CLAUDE.md
        When finding project memory path
        Then it should return None."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())

        # When
        path = loader._find_project_memory(str(temp_project_root))

        # Then
        assert path is None


class TestClaudeMemoryLoaderFileReading:
    """Behavioral tests for reading memory files."""

    def test_read_memory_file_success(self, temp_project_root):
        """Given a valid memory file
        When reading the memory file
        Then it should return the content."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        memory_file = temp_project_root / "CLAUDE.md"
        content = "# Test Memory\nSome content"
        memory_file.write_text(content)

        # When
        result = loader._read_memory_file(memory_file)

        # Then
        assert result == content

    def test_read_memory_file_not_found(self):
        """Given a non-existent memory file
        When reading the memory file
        Then it should return empty string and log error."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())

        # When
        with patch("empathy_os.memory.claude_memory.logger") as mock_logger:
            result = loader._read_memory_file(Path("/nonexistent/file.md"))

        # Then
        assert result == ""
        mock_logger.error.assert_called()

    def test_read_memory_file_exceeds_size_limit(self, temp_project_root):
        """Given a memory file exceeding size limit
        When reading the memory file
        Then it should return empty string and log error."""
        # Given
        config = ClaudeMemoryConfig(enabled=True, max_file_size_bytes=10)
        loader = ClaudeMemoryLoader(config=config)
        memory_file = temp_project_root / "CLAUDE.md"
        memory_file.write_text("This content is too long for the limit")

        # When
        with patch("empathy_os.memory.claude_memory.logger") as mock_logger:
            result = loader._read_memory_file(memory_file)

        # Then
        assert result == ""
        mock_logger.error.assert_called()

    @patch("empathy_os.memory.claude_memory._validate_file_path")
    def test_read_memory_file_validation_failure(self, mock_validate, temp_project_root):
        """Given a memory file that fails validation
        When reading the memory file
        Then it should return empty string and log error."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        memory_file = temp_project_root / "CLAUDE.md"
        memory_file.write_text("# Memory")
        mock_validate.side_effect = ValueError("Invalid path")

        # When
        with patch("empathy_os.memory.claude_memory.logger") as mock_logger:
            result = loader._read_memory_file(memory_file)

        # Then
        assert result == ""
        mock_logger.error.assert_called()


class TestClaudeMemoryLoaderImportParsing:
    """Behavioral tests for parsing @import directives."""

    def test_parse_imports_single(self):
        """Given content with a single @import directive
        When parsing imports
        Then it should extract the import path."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        content = "# Memory\n@import common.md\nMore content"

        # When
        imports = loader._parse_imports(content)

        # Then
        assert imports == ["common.md"]

    def test_parse_imports_multiple(self):
        """Given content with multiple @import directives
        When parsing imports
        Then it should extract all import paths."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        content = """# Memory
@import common.md
Some text
@import shared/utils.md
@import ../parent.md
"""

        # When
        imports = loader._parse_imports(content)

        # Then
        assert imports == ["common.md", "shared/utils.md", "../parent.md"]

    def test_parse_imports_none(self):
        """Given content without @import directives
        When parsing imports
        Then it should return empty list."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        content = "# Memory\nNo imports here"

        # When
        imports = loader._parse_imports(content)

        # Then
        assert imports == []

    def test_parse_imports_with_whitespace(self):
        """Given content with @import directives with various whitespace
        When parsing imports
        Then it should handle whitespace correctly."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        content = "@import   file1.md  \n@import\tfile2.md\n@import file3.md"

        # When
        imports = loader._parse_imports(content)

        # Then
        assert "file1.md" in imports
        assert "file2.md" in imports
        assert "file3.md" in imports


class TestClaudeMemoryLoaderImportResolution:
    """Behavioral tests for resolving imported files."""

    def test_resolve_import_relative_path(self, temp_project_root):
        """Given a relative import path
        When resolving the import
        Then it should resolve relative to the parent file."""
        # Given
        loader = ClaudeMemoryLoader(basic_config())
        parent_file = temp_project_root / "CLAUDE.md"
        imported_