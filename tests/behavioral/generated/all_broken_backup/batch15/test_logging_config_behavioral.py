"""Behavioral tests for logging_config.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import logging
import logging.handlers
import sys
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch, mock_open

import pytest

from empathy_os.logging_config import StructuredFormatter, create_logger


class TestStructuredFormatter:
    """Behavioral tests for StructuredFormatter class."""

    def test_initialization_with_defaults(self):
        """Given: No arguments provided
        When: StructuredFormatter is initialized
        Then: Default values are set correctly
        """
        # When
        formatter = StructuredFormatter()

        # Then
        assert formatter.include_context is False
        assert isinstance(formatter.use_color, bool)

    def test_initialization_with_color_disabled(self):
        """Given: use_color set to False
        When: StructuredFormatter is initialized
        Then: Color output is disabled
        """
        # When
        formatter = StructuredFormatter(use_color=False)

        # Then
        assert formatter.use_color is False

    def test_initialization_with_context_enabled(self):
        """Given: include_context set to True
        When: StructuredFormatter is initialized
        Then: Context inclusion is enabled
        """
        # When
        formatter = StructuredFormatter(include_context=True)

        # Then
        assert formatter.include_context is True

    @patch('sys.stderr.isatty', return_value=True)
    def test_initialization_with_tty_terminal(self, mock_isatty):
        """Given: Terminal is a TTY
        When: StructuredFormatter is initialized with use_color=True
        Then: Color is enabled
        """
        # When
        formatter = StructuredFormatter(use_color=True)

        # Then
        assert formatter.use_color is True
        mock_isatty.assert_called_once()

    @patch('sys.stderr.isatty', return_value=False)
    def test_initialization_without_tty_terminal(self, mock_isatty):
        """Given: Terminal is not a TTY
        When: StructuredFormatter is initialized with use_color=True
        Then: Color is disabled automatically
        """
        # When
        formatter = StructuredFormatter(use_color=True)

        # Then
        assert formatter.use_color is False
        mock_isatty.assert_called_once()

    def test_format_basic_log_record_without_color(self):
        """Given: A basic log record without color
        When: Format is called
        Then: Correctly formatted message is returned
        """
        # Given
        formatter = StructuredFormatter(use_color=False)
        record = logging.LogRecord(
            name="test_module",
            level=logging.INFO,
            pathname="test.py",
            lineno=10,
            msg="Test message",
            args=(),
            exc_info=None,
            func="test_function"
        )

        # When
        result = formatter.format(record)

        # Then
        assert "INFO" in result
        assert "test_module" in result
        assert "test_function" in result
        assert "Test message" in result
        assert "\033[" not in result  # No ANSI codes

    @patch('sys.stderr.isatty', return_value=True)
    def test_format_basic_log_record_with_color(self, mock_isatty):
        """Given: A basic log record with color enabled
        When: Format is called
        Then: Correctly formatted message with ANSI codes is returned
        """
        # Given
        formatter = StructuredFormatter(use_color=True)
        record = logging.LogRecord(
            name="test_module",
            level=logging.INFO,
            pathname="test.py",
            lineno=10,
            msg="Test message",
            args=(),
            exc_info=None,
            func="test_function"
        )

        # When
        result = formatter.format(record)

        # Then
        assert "INFO" in result
        assert "test_module" in result
        assert "test_function" in result
        assert "Test message" in result
        assert "\033[" in result  # ANSI codes present

    def test_format_log_record_with_context(self):
        """Given: A log record with context information
        When: Format is called with include_context=True
        Then: Context is included in formatted message
        """
        # Given
        formatter = StructuredFormatter(use_color=False, include_context=True)
        record = logging.LogRecord(
            name="test_module",
            level=logging.INFO,
            pathname="test.py",
            lineno=10,
            msg="Test message",
            args=(),
            exc_info=None,
            func="test_function"
        )
        record.context = {"user_id": "123", "request_id": "abc"}

        # When
        result = formatter.format(record)

        # Then
        assert "user_id=123" in result
        assert "request_id=abc" in result

    def test_format_log_record_without_context_attribute(self):
        """Given: A log record without context attribute
        When: Format is called with include_context=True
        Then: No context is added to message
        """
        # Given
        formatter = StructuredFormatter(use_color=False, include_context=True)
        record = logging.LogRecord(
            name="test_module",
            level=logging.INFO,
            pathname="test.py",
            lineno=10,
            msg="Test message",
            args=(),
            exc_info=None,
            func="test_function"
        )

        # When
        result = formatter.format(record)

        # Then
        assert "Test message" in result
        assert "[" not in result.split("Test message")[1]  # No context brackets after message

    def test_format_log_record_with_exception(self):
        """Given: A log record with exception information
        When: Format is called
        Then: Exception traceback is included
        """
        # Given
        formatter = StructuredFormatter(use_color=False)
        try:
            raise ValueError("Test exception")
        except ValueError:
            exc_info = sys.exc_info()

        record = logging.LogRecord(
            name="test_module",
            level=logging.ERROR,
            pathname="test.py",
            lineno=10,
            msg="Error occurred",
            args=(),
            exc_info=exc_info,
            func="test_function"
        )

        # When
        result = formatter.format(record)

        # Then
        assert "Error occurred" in result
        assert "Traceback" in result
        assert "ValueError" in result
        assert "Test exception" in result

    @pytest.mark.parametrize("level,expected_color", [
        (logging.DEBUG, "\033[36m"),
        (logging.INFO, "\033[32m"),
        (logging.WARNING, "\033[33m"),
        (logging.ERROR, "\033[31m"),
        (logging.CRITICAL, "\033[35m"),
    ])
    @patch('sys.stderr.isatty', return_value=True)
    def test_format_different_log_levels(self, mock_isatty, level, expected_color):
        """Given: Different log levels
        When: Format is called with color enabled
        Then: Appropriate color code is used
        """
        # Given
        formatter = StructuredFormatter(use_color=True)
        record = logging.LogRecord(
            name="test_module",
            level=level,
            pathname="test.py",
            lineno=10,
            msg="Test message",
            args=(),
            exc_info=None,
            func="test_function"
        )

        # When
        result = formatter.format(record)

        # Then
        assert expected_color in result

    def test_format_timestamp_format(self):
        """Given: A log record
        When: Format is called
        Then: Timestamp is formatted correctly
        """
        # Given
        formatter = StructuredFormatter(use_color=False)
        record = logging.LogRecord(
            name="test_module",
            level=logging.INFO,
            pathname="test.py",
            lineno=10,
            msg="Test message",
            args=(),
            exc_info=None,
            func="test_function"
        )

        # When
        result = formatter.format(record)

        # Then
        # Check that timestamp format matches [YYYY-MM-DD HH:MM:SS]
        import re
        timestamp_pattern = r'\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]'
        assert re.search(timestamp_pattern, result) is not None


class TestCreateLogger:
    """Behavioral tests for create_logger function."""

    def test_create_logger_with_defaults(self):
        """Given: Only logger name provided
        When: create_logger is called
        Then: Logger is created with default settings
        """
        # When
        logger = create_logger("test_logger")

        # Then
        assert logger.name == "test_logger"
        assert logger.level == logging.INFO
        assert len(logger.handlers) > 0

    def test_create_logger_with_custom_level(self):
        """Given: Custom log level provided
        When: create_logger is called
        Then: Logger uses specified level
        """
        # When
        logger = create_logger("test_logger", level=logging.DEBUG)

        # Then
        assert logger.level == logging.DEBUG

    @patch('logging.handlers.RotatingFileHandler')
    @patch('pathlib.Path.mkdir')
    def test_create_logger_with_log_file(self, mock_mkdir, mock_handler):
        """Given: Log file path provided
        When: create_logger is called
        Then: File handler is added
        """
        # Given
        mock_file_handler = MagicMock()
        mock_handler.return_value = mock_file_handler

        # When
        logger = create_logger("test_logger", log_file="/tmp/test.log")

        # Then
        mock_handler.assert_called_once()
        assert any(h == mock_file_handler for h in logger.handlers)

    @patch('logging.handlers.RotatingFileHandler')
    @patch('pathlib.Path.mkdir')
    def test_create_logger_with_log_dir(self, mock_mkdir, mock_handler):
        """Given: Log directory provided
        When: create_logger is called
        Then: File handler is created in specified directory
        """
        # Given
        mock_file_handler = MagicMock()
        mock_handler.return_value = mock_file_handler

        # When
        logger = create_logger("test_logger", log_dir="/tmp/logs")

        # Then
        mock_mkdir.assert_called_once_with(parents=True, exist_ok=True)
        mock_handler.assert_called_once()

    @patch('logging.handlers.RotatingFileHandler')
    @patch('pathlib.Path.mkdir')
    def test_create_logger_with_custom_rotation_settings(self, mock_mkdir, mock_handler):
        """Given: Custom max_bytes and backup_count
        When: create_logger is called
        Then: RotatingFileHandler uses specified settings
        """
        # Given
        mock_file_handler = MagicMock()
        mock_handler.return_value = mock_file_handler
        max_bytes = 5 * 1024 * 1024
        backup_count = 10

        # When
        logger = create_logger(
            "test_logger",
            log_file="/tmp/test.log",
            max_bytes=max_bytes,
            backup_count=backup_count
        )

        # Then
        call_args = mock_handler.call_args
        assert call_args[1]['maxBytes'] == max_bytes
        assert call_args[1]['backupCount'] == backup_count

    def test_create_logger_console_handler_added(self):
        """Given: No file logging specified
        When: create_logger is called
        Then: Console handler is added
        """
        # When
        logger = create_logger("test_logger")

        # Then
        console_handlers = [h for h in logger.handlers if isinstance(h, logging.StreamHandler)]
        assert len(console_handlers) > 0

    def test_create_logger_uses_structured_formatter(self):
        """Given: Logger is created
        When: Checking handler formatters
        Then: StructuredFormatter is used
        """
        # When
        logger = create_logger("test_logger")

        # Then
        for handler in logger.handlers:
            assert isinstance(handler.formatter, StructuredFormatter)

    def test_create_logger_with_color_disabled(self):
        """Given: use_color set to False
        When: create_logger is called
        Then: Formatter has color disabled
        """
        # When
        logger = create_logger("test_logger", use_color=False)

        # Then
        for handler in logger.handlers:
            assert handler.formatter.use_color is False

    def test_create_logger_with_context_enabled(self):
        """Given: include_context set to True
        When: create_logger is called
        Then: Formatter includes context
        """
        # When
        logger = create_logger("test_logger", include_context=True)

        # Then
        for handler in logger.handlers:
            assert handler.formatter.include_context is True

    @patch('logging.handlers.RotatingFileHandler')
    @patch('pathlib.Path.mkdir', side_effect=PermissionError("Permission denied"))
    def test_create_logger_handles_directory_creation_error(self, mock_mkdir, mock_handler):
        """Given: Directory creation fails with PermissionError
        When: create_logger is called with log_dir
        Then: Error is raised appropriately
        """
        # When/Then
        with pytest.raises(PermissionError):
            create_logger("test_logger", log_dir="/root/forbidden")

    def test_create_logger_propagation_disabled(self):
        """Given: Logger is created
        When: Checking propagate attribute
        Then: Propagation is disabled to prevent duplicate logs
        """
        # When
        logger = create_logger("test_logger")

        # Then
        assert logger.propagate is False

    @patch('logging.handlers.RotatingFileHandler')
    @patch('pathlib.Path.mkdir')
    def test_create_logger_file_handler_level_matches_logger(self, mock_mkdir, mock_handler):
        """Given: Logger created with specific level
        When: File handler is added
        Then: Handler level matches logger level
        """
        # Given
        mock_file_handler = MagicMock()
        mock_handler.return_value = mock_file_handler

        # When
        logger = create_logger("test_logger", level=logging.DEBUG, log_file="/tmp/test.log")

        # Then
        mock_file_handler.setLevel.assert_called_once_with(logging.DEBUG)

    def test_create_logger_multiple_calls_same_name(self):
        """Given: Multiple calls with same logger name
        When: create_logger is called multiple times
        Then: Same logger instance is returned (logging behavior)
        """
        # When
        logger1 = create_logger("duplicate_logger")
        logger2 = create_logger("duplicate_logger")

        # Then
        assert logger1.name == logger2.name

    @patch('logging.handlers.RotatingFileHandler')
    @patch('pathlib.Path.mkdir')
    def test_create_logger_both_file_and_dir_specified(self, mock_mkdir, mock_handler):
        """Given: Both log_file and log_dir specified
        When: create_logger is called
        Then: log_file takes precedence
        """
        #