"""Behavioral tests for parsers.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from pathlib import Path
from typing import Any

import pytest
import yaml

from empathy_os.workflows.keyboard_shortcuts.parsers import (
    FeatureParser,
    VSCodeCommandParser,
)
from empathy_os.workflows.keyboard_shortcuts.schema import (
    Category,
    Feature,
    FrequencyTier,
)


# Fixtures


@pytest.fixture
def temp_file(tmp_path: Path) -> Path:
    """Create a temporary file path."""
    return tmp_path / "test_file.json"


@pytest.fixture
def vscode_parser() -> VSCodeCommandParser:
    """Create a VSCode command parser instance."""
    return VSCodeCommandParser()


@pytest.fixture
def valid_package_json() -> dict[str, Any]:
    """Create a valid package.json structure."""
    return {
        "name": "empathy-os",
        "version": "1.0.0",
        "contributes": {
            "commands": [
                {
                    "command": "empathy.quick.morning",
                    "title": "Empathy: Quick → Morning",
                    "icon": "$(sunrise)",
                },
                {
                    "command": "empathy.focus.deep",
                    "title": "Empathy: Focus → Deep Work",
                    "icon": "$(target)",
                },
                {
                    "command": "empathy.general.settings",
                    "title": "Empathy: Settings",
                    "icon": "$(gear)",
                },
            ]
        },
    }


@pytest.fixture
def package_json_with_edge_cases() -> dict[str, Any]:
    """Create package.json with edge cases."""
    return {
        "contributes": {
            "commands": [
                {
                    "command": "_empathy.internal.command",
                    "title": "Internal Command",
                },
                {
                    "command": "empathy.no.title",
                    "title": "",
                },
                {
                    "command": "empathy.minimal",
                },
                {
                    "command": "empathy.complex.nested.command",
                    "title": "Multi → Level → Nested",
                    "icon": "$(puzzle)",
                },
                {
                    "command": "empathy.simple",
                    "title": "Simple Title",
                },
            ]
        }
    }


@pytest.fixture
def empty_package_json() -> dict[str, Any]:
    """Create an empty package.json structure."""
    return {}


# Tests for FeatureParser base class


class TestFeatureParser:
    """Tests for the FeatureParser abstract base class."""

    def test_given_abstract_parser_when_instantiate_then_raises_error(self):
        """Given: FeatureParser is an abstract class
        When: Attempting to instantiate directly
        Then: TypeError is raised
        """
        with pytest.raises(TypeError):
            FeatureParser()

    def test_given_concrete_parser_when_missing_parse_then_raises_error(self):
        """Given: A concrete parser without parse method
        When: Attempting to instantiate
        Then: TypeError is raised
        """

        class IncompleteParser(FeatureParser):
            def can_parse(self, path: Path) -> bool:
                return True

        with pytest.raises(TypeError):
            IncompleteParser()

    def test_given_concrete_parser_when_missing_can_parse_then_raises_error(self):
        """Given: A concrete parser without can_parse method
        When: Attempting to instantiate
        Then: TypeError is raised
        """

        class IncompleteParser(FeatureParser):
            def parse(self, path: Path) -> list[Feature]:
                return []

        with pytest.raises(TypeError):
            IncompleteParser()

    def test_given_complete_concrete_parser_when_instantiate_then_succeeds(self):
        """Given: A concrete parser with all required methods
        When: Attempting to instantiate
        Then: Instance is created successfully
        """

        class CompleteParser(FeatureParser):
            def parse(self, path: Path) -> list[Feature]:
                return []

            def can_parse(self, path: Path) -> bool:
                return True

        parser = CompleteParser()
        assert isinstance(parser, FeatureParser)


# Tests for VSCodeCommandParser.can_parse


class TestVSCodeCommandParserCanParse:
    """Tests for VSCodeCommandParser.can_parse method."""

    def test_given_package_json_when_can_parse_then_returns_true(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A file named package.json that exists
        When: Checking if parser can parse
        Then: Returns True
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text("{}")

        # When
        result = vscode_parser.can_parse(package_json_path)

        # Then
        assert result is True

    def test_given_non_package_json_when_can_parse_then_returns_false(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A file not named package.json
        When: Checking if parser can parse
        Then: Returns False
        """
        # Given
        other_file = tmp_path / "other.json"
        other_file.write_text("{}")

        # When
        result = vscode_parser.can_parse(other_file)

        # Then
        assert result is False

    def test_given_nonexistent_package_json_when_can_parse_then_returns_false(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A path to package.json that doesn't exist
        When: Checking if parser can parse
        Then: Returns False
        """
        # Given
        nonexistent_path = tmp_path / "package.json"

        # When
        result = vscode_parser.can_parse(nonexistent_path)

        # Then
        assert result is False

    def test_given_directory_named_package_json_when_can_parse_then_returns_false(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A directory named package.json
        When: Checking if parser can parse
        Then: Returns False
        """
        # Given
        dir_path = tmp_path / "package.json"
        dir_path.mkdir()

        # When
        result = vscode_parser.can_parse(dir_path)

        # Then
        assert result is False


# Tests for VSCodeCommandParser.parse


class TestVSCodeCommandParserParse:
    """Tests for VSCodeCommandParser.parse method."""

    def test_given_valid_package_json_when_parse_then_extracts_features(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path, valid_package_json: dict
    ):
        """Given: A valid package.json with commands
        When: Parsing the file
        Then: Features are extracted correctly
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text(json.dumps(valid_package_json))

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        assert len(features) == 3
        assert all(isinstance(f, Feature) for f in features)
        assert features[0].id == "morning"
        assert features[0].name == "Morning"
        assert features[0].command == "empathy.quick.morning"
        assert features[0].icon == "$(sunrise)"

    def test_given_invalid_json_when_parse_then_returns_empty_list(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A file with invalid JSON
        When: Parsing the file
        Then: Returns empty list
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text("invalid json{")

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        assert features == []

    def test_given_nonexistent_file_when_parse_then_returns_empty_list(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A nonexistent file path
        When: Parsing the file
        Then: Returns empty list
        """
        # Given
        nonexistent_path = tmp_path / "package.json"

        # When
        features = vscode_parser.parse(nonexistent_path)

        # Then
        assert features == []

    def test_given_empty_package_json_when_parse_then_returns_empty_list(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path, empty_package_json: dict
    ):
        """Given: An empty package.json
        When: Parsing the file
        Then: Returns empty list
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text(json.dumps(empty_package_json))

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        assert features == []

    def test_given_package_json_with_hidden_commands_when_parse_then_skips_hidden(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path, package_json_with_edge_cases: dict
    ):
        """Given: package.json with hidden/internal commands
        When: Parsing the file
        Then: Hidden commands are skipped
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text(json.dumps(package_json_with_edge_cases))

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        # Should skip: _internal.command, no.title, and minimal (no title)
        assert len(features) == 2
        command_ids = [f.command for f in features]
        assert "empathy.complex.nested.command" in command_ids
        assert "empathy.simple" in command_ids
        assert "_empathy.internal.command" not in command_ids

    def test_given_package_json_without_contributes_when_parse_then_returns_empty_list(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: package.json without contributes section
        When: Parsing the file
        Then: Returns empty list
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text(json.dumps({"name": "test"}))

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        assert features == []

    def test_given_package_json_without_commands_when_parse_then_returns_empty_list(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: package.json with contributes but no commands
        When: Parsing the file
        Then: Returns empty list
        """
        # Given
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text(json.dumps({"contributes": {}}))

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        assert features == []

    def test_given_command_without_icon_when_parse_then_uses_default_icon(
        self, vscode_parser: VSCodeCommandParser, tmp_path: Path
    ):
        """Given: A command without an icon specified
        When: Parsing the file
        Then: Uses default icon
        """
        # Given
        package_json = {
            "contributes": {
                "commands": [
                    {
                        "command": "empathy.test",
                        "title": "Test Command",
                    }
                ]
            }
        }
        package_json_path = tmp_path / "package.json"
        package_json_path.write_text(json.dumps(package_json))

        # When
        features = vscode_parser.parse(package_json_path)

        # Then
        assert len(features) == 1
        assert features[0].icon == "$(symbol-misc)"


# Tests for VSCodeCommandParser._extract_category


class TestVSCodeCommandParserExtractCategory:
    """Tests for VSCodeCommandParser._extract_category method."""

    def test_given_title_with_arrow_when_extract_category_then_returns_prefix(
        self, vscode_parser: VSCodeCommandParser
    ):
        """Given: Title with arrow separator
        When: Extracting category
        Then: Returns the prefix before arrow
        """
        # Given
        title = "Empathy: Quick → Morning"

        # When
        category = vscode_parser._extract_category(title)

        # Then
        assert category == "Quick"

    def test_given_title_with_colon_no_arrow_when_extract_category_then_returns_prefix(
        self, vscode_parser: VSCodeCommandParser
    ):
        """Given: Title with colon but no arrow
        When: Extracting category
        Then: Returns the prefix before colon
        """
        # Given
        title = "Empathy: Settings"

        # When
        category = vscode_parser._extract_category(title)

        # Then
        assert category == "Empathy"

    def test_given_simple_title_when_extract_category_then_returns_general(
        self, vscode_parser: VSCodeCommandParser
    ):
        """Given: Simple title without separators
        When: Extracting category
        Then: Returns 'General'
        """
        # Given
        title = "Simple Command"

        # When
        category = vscode_parser._extract_category(title)

        # Then
        assert category == "General"

    def test_given_title_with_multiple_arrows_when_extract_category_then_returns_first_prefix(
        self, vscode_parser: VSCodeCommandParser
    ):
        """Given: Title with multiple arrow separators
        When: Extracting category
        Then: Returns the first prefix
        """
        # Given
        title = "Empathy: Multi → Level → Nested"

        # When
        category = vscode_parser._extract_category(title)

        # Then
        assert category == "Multi"

    def test_given_empty_title_when_extract_category_then_returns_general(
        self, vscode_parser: VSCodeCommandParser
    ):
        """Given: Empty title
        When: Extracting category
        Then: Returns 'General'
        """
        # Given
        title = ""

        # When
        category = vscode_parser._extract_category(title)

        # Then
        assert category == "General"


# Tests for VSCodeCommandParser._extract_name


class TestVSCodeCommandParserExtractName:
    """Tests for VSCodeCommandParser._extract_name method."""

    def test_given_title_with_arrow_when_extract_name_then_returns_suffix(
        self, vscode_parser: VSCodeCommandParser
    ):
        """Given: Title with arrow separator
        When: Extracting name
        Then: Returns the suffix after arrow
        """
        # Given
        title = "Empathy: Quick → Morning"

        # When
        name = vscode_parser._extract_name(title)

        # Then
        assert name == "Morning"

    def test_given