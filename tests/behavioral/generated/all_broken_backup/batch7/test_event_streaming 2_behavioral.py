"""Behavioral tests for event_streaming 2.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
import time
from datetime import datetime
from typing import Any
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.telemetry.event_streaming_2 import (
    EventStreamer,
    StreamEvent,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def mock_redis():
    """Provide a mocked Redis client."""
    with patch("empathy_os.telemetry.event_streaming_2.redis") as mock_redis_module:
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        yield mock_client


@pytest.fixture
def event_streamer(mock_redis):
    """Provide an EventStreamer instance with mocked Redis."""
    return EventStreamer()


@pytest.fixture
def sample_event_data():
    """Provide sample event data."""
    return {
        "agent_id": "worker-1",
        "status": "running",
        "progress": 0.5,
        "message": "Processing task",
    }


@pytest.fixture
def sample_stream_event():
    """Provide a sample StreamEvent instance."""
    return StreamEvent(
        event_id="1706356800000-0",
        event_type="agent_heartbeat",
        timestamp=datetime(2025, 1, 27, 12, 0, 0),
        data={"agent_id": "worker-1", "status": "running"},
        source="empathy_os",
    )


# ============================================================================
# StreamEvent Tests
# ============================================================================


class TestStreamEventToDict:
    """Tests for StreamEvent.to_dict method."""

    def test_given_stream_event_when_to_dict_then_returns_dict_with_all_fields(
        self, sample_stream_event
    ):
        """Given a StreamEvent, when to_dict is called, then return dict with all fields."""
        # When
        result = sample_stream_event.to_dict()

        # Then
        assert result["event_id"] == "1706356800000-0"
        assert result["event_type"] == "agent_heartbeat"
        assert result["timestamp"] == "2025-01-27T12:00:00"
        assert result["data"] == {"agent_id": "worker-1", "status": "running"}
        assert result["source"] == "empathy_os"

    def test_given_stream_event_with_string_timestamp_when_to_dict_then_returns_string_timestamp(
        self,
    ):
        """Given a StreamEvent with string timestamp, when to_dict is called, then return string timestamp."""
        # Given
        event = StreamEvent(
            event_id="123-0",
            event_type="test",
            timestamp="2025-01-27T12:00:00",
            data={},
        )

        # When
        result = event.to_dict()

        # Then
        assert result["timestamp"] == "2025-01-27T12:00:00"

    def test_given_stream_event_with_nested_data_when_to_dict_then_preserves_nested_structure(
        self,
    ):
        """Given a StreamEvent with nested data, when to_dict is called, then preserve nested structure."""
        # Given
        nested_data = {
            "agent": {"id": "worker-1", "type": "processor"},
            "metrics": {"cpu": 0.75, "memory": 0.5},
        }
        event = StreamEvent(
            event_id="123-0",
            event_type="test",
            timestamp=datetime.utcnow(),
            data=nested_data,
        )

        # When
        result = event.to_dict()

        # Then
        assert result["data"] == nested_data
        assert result["data"]["agent"]["id"] == "worker-1"
        assert result["data"]["metrics"]["cpu"] == 0.75


class TestStreamEventFromRedisEntry:
    """Tests for StreamEvent.from_redis_entry class method."""

    def test_given_valid_redis_entry_when_from_redis_entry_then_creates_stream_event(
        self,
    ):
        """Given a valid Redis entry, when from_redis_entry is called, then create StreamEvent."""
        # Given
        event_id = "1706356800000-0"
        entry_data = {
            b"event_type": b"agent_heartbeat",
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b'{"agent_id": "worker-1", "status": "running"}',
            b"source": b"empathy_os",
        }

        # When
        event = StreamEvent.from_redis_entry(event_id, entry_data)

        # Then
        assert event.event_id == event_id
        assert event.event_type == "agent_heartbeat"
        assert event.timestamp == datetime(2025, 1, 27, 12, 0, 0)
        assert event.data == {"agent_id": "worker-1", "status": "running"}
        assert event.source == "empathy_os"

    def test_given_entry_with_invalid_timestamp_when_from_redis_entry_then_uses_current_time(
        self,
    ):
        """Given an entry with invalid timestamp, when from_redis_entry is called, then use current time."""
        # Given
        event_id = "123-0"
        entry_data = {
            b"event_type": b"test",
            b"timestamp": b"invalid-timestamp",
            b"data": b"{}",
        }

        # When
        before = datetime.utcnow()
        event = StreamEvent.from_redis_entry(event_id, entry_data)
        after = datetime.utcnow()

        # Then
        assert before <= event.timestamp <= after

    def test_given_entry_with_missing_timestamp_when_from_redis_entry_then_uses_current_time(
        self,
    ):
        """Given an entry with missing timestamp, when from_redis_entry is called, then use current time."""
        # Given
        event_id = "123-0"
        entry_data = {
            b"event_type": b"test",
            b"data": b"{}",
        }

        # When
        before = datetime.utcnow()
        event = StreamEvent.from_redis_entry(event_id, entry_data)
        after = datetime.utcnow()

        # Then
        assert before <= event.timestamp <= after

    def test_given_entry_with_invalid_json_data_when_from_redis_entry_then_uses_empty_dict(
        self,
    ):
        """Given an entry with invalid JSON data, when from_redis_entry is called, then use empty dict."""
        # Given
        event_id = "123-0"
        entry_data = {
            b"event_type": b"test",
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b"invalid-json{",
        }

        # When
        event = StreamEvent.from_redis_entry(event_id, entry_data)

        # Then
        assert event.data == {}

    def test_given_entry_with_missing_data_when_from_redis_entry_then_uses_empty_dict(
        self,
    ):
        """Given an entry with missing data, when from_redis_entry is called, then use empty dict."""
        # Given
        event_id = "123-0"
        entry_data = {
            b"event_type": b"test",
            b"timestamp": b"2025-01-27T12:00:00",
        }

        # When
        event = StreamEvent.from_redis_entry(event_id, entry_data)

        # Then
        assert event.data == {}

    def test_given_entry_with_missing_event_type_when_from_redis_entry_then_uses_unknown(
        self,
    ):
        """Given an entry with missing event_type, when from_redis_entry is called, then use 'unknown'."""
        # Given
        event_id = "123-0"
        entry_data = {
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b"{}",
        }

        # When
        event = StreamEvent.from_redis_entry(event_id, entry_data)

        # Then
        assert event.event_type == "unknown"

    def test_given_entry_with_missing_source_when_from_redis_entry_then_uses_default_source(
        self,
    ):
        """Given an entry with missing source, when from_redis_entry is called, then use default source."""
        # Given
        event_id = "123-0"
        entry_data = {
            b"event_type": b"test",
            b"timestamp": b"2025-01-27T12:00:00",
            b"data": b"{}",
        }

        # When
        event = StreamEvent.from_redis_entry(event_id, entry_data)

        # Then
        assert event.source == "empathy_os"


# ============================================================================
# EventStreamer Initialization Tests
# ============================================================================


class TestEventStreamerInit:
    """Tests for EventStreamer initialization."""

    def test_given_default_params_when_init_then_creates_redis_connection(
        self, mock_redis
    ):
        """Given default params, when EventStreamer is initialized, then create Redis connection."""
        # When
        streamer = EventStreamer()

        # Then
        assert streamer.redis_client is not None

    def test_given_custom_redis_url_when_init_then_uses_custom_url(self):
        """Given custom Redis URL, when EventStreamer is initialized, then use custom URL."""
        # Given
        custom_url = "redis://custom-host:6380/2"

        # When
        with patch("empathy_os.telemetry.event_streaming_2.redis") as mock_redis_module:
            streamer = EventStreamer(redis_url=custom_url)

            # Then
            mock_redis_module.Redis.from_url.assert_called_once_with(
                custom_url, decode_responses=False
            )

    def test_given_custom_stream_prefix_when_init_then_uses_custom_prefix(
        self, event_streamer
    ):
        """Given custom stream prefix, when EventStreamer is initialized, then use custom prefix."""
        # When
        streamer = EventStreamer(stream_prefix="custom_prefix")

        # Then
        assert streamer.stream_prefix == "custom_prefix"

    def test_given_custom_max_stream_length_when_init_then_uses_custom_length(
        self, event_streamer
    ):
        """Given custom max stream length, when EventStreamer is initialized, then use custom length."""
        # When
        streamer = EventStreamer(max_stream_length=5000)

        # Then
        assert streamer.max_stream_length == 5000


# ============================================================================
# EventStreamer.publish_event Tests
# ============================================================================


class TestEventStreamerPublishEvent:
    """Tests for EventStreamer.publish_event method."""

    def test_given_valid_event_when_publish_event_then_adds_to_redis_stream(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """Given valid event, when publish_event is called, then add to Redis stream."""
        # Given
        mock_redis.xadd.return_value = b"1706356800000-0"

        # When
        result = event_streamer.publish_event("agent_heartbeat", sample_event_data)

        # Then
        assert result == "1706356800000-0"
        mock_redis.xadd.assert_called_once()
        call_args = mock_redis.xadd.call_args
        assert call_args[0][0] == "empathy_events:agent_heartbeat"
        assert call_args[1]["maxlen"] == 10000
        assert call_args[1]["approximate"] is True

    def test_given_event_with_custom_source_when_publish_event_then_includes_custom_source(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """Given event with custom source, when publish_event is called, then include custom source."""
        # Given
        mock_redis.xadd.return_value = b"123-0"

        # When
        event_streamer.publish_event(
            "agent_heartbeat", sample_event_data, source="custom_source"
        )

        # Then
        call_args = mock_redis.xadd.call_args
        fields = call_args[0][1]
        assert fields["source"] == "custom_source"

    def test_given_event_when_publish_event_then_includes_timestamp(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """Given event, when publish_event is called, then include timestamp."""
        # Given
        mock_redis.xadd.return_value = b"123-0"

        # When
        before = datetime.utcnow()
        event_streamer.publish_event("agent_heartbeat", sample_event_data)
        after = datetime.utcnow()

        # Then
        call_args = mock_redis.xadd.call_args
        fields = call_args[0][1]
        timestamp = datetime.fromisoformat(fields["timestamp"])
        assert before <= timestamp <= after

    def test_given_event_when_publish_event_then_serializes_data_to_json(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """Given event, when publish_event is called, then serialize data to JSON."""
        # Given
        mock_redis.xadd.return_value = b"123-0"

        # When
        event_streamer.publish_event("agent_heartbeat", sample_event_data)

        # Then
        call_args = mock_redis.xadd.call_args
        fields = call_args[0][1]
        data = json.loads(fields["data"])
        assert data == sample_event_data

    def test_given_redis_error_when_publish_event_then_logs_error_and_returns_none(
        self, event_streamer, mock_redis, sample_event_data
    ):
        """Given Redis error, when publish_event is called, then log error and return None."""
        # Given
        mock_redis.xadd.side_effect = Exception("Redis connection error")

        # When
        with patch("empathy_os.telemetry.event_streaming_2.logger") as mock_logger:
            result = event_streamer.publish_event("agent_heartbeat", sample_event_data)

            # Then
            assert result is None
            mock_logger.error.assert_called_once()

    def test_given_multiple_events_when_publish_event_then_publishes_all_events(
        self, event_streamer, mock_redis
    ):
        """Given multiple events, when publish_event is called, then publish all events."""
        # Given
        mock_redis.xadd.side_effect = [b"1-0", b"2-0", b"3-0"]
        events = [
            {"agent_id": "worker-1"},
            {"agent_id": "worker-2"},
            {"agent_id": "worker-3"},
        ]

        # When
        results = [event_streamer.publish_event("test", data) for data in events]

        # Then
        assert results == ["1-0", "2-0", "3-0"]