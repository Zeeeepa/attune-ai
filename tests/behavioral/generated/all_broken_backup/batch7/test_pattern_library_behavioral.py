"""Behavioral tests for pattern_library.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from datetime import datetime, timedelta
from unittest.mock import Mock, patch, MagicMock
from empathy_os.pattern_library import Pattern, PatternMatch, PatternLibrary


class TestPattern:
    """Behavioral tests for Pattern dataclass."""

    def test_pattern_creation_with_defaults(self):
        """
        Given: A pattern with minimal required fields
        When: Creating the pattern
        Then: Default values are properly initialized
        """
        # Given/When
        pattern = Pattern(
            id="pattern-1",
            agent_id="agent-1",
            pattern_type="sequential",
            name="Test Pattern",
            description="A test pattern"
        )

        # Then
        assert pattern.id == "pattern-1"
        assert pattern.agent_id == "agent-1"
        assert pattern.pattern_type == "sequential"
        assert pattern.name == "Test Pattern"
        assert pattern.description == "A test pattern"
        assert pattern.context == {}
        assert pattern.code is None
        assert pattern.confidence == 0.5
        assert pattern.usage_count == 0
        assert pattern.success_count == 0
        assert pattern.failure_count == 0
        assert isinstance(pattern.discovered_at, datetime)
        assert pattern.last_used is None
        assert pattern.tags == []

    def test_pattern_creation_with_all_fields(self):
        """
        Given: A pattern with all fields specified
        When: Creating the pattern
        Then: All values are properly set
        """
        # Given
        now = datetime.now()
        context = {"domain": "test"}
        code = "def example(): pass"
        tags = ["tag1", "tag2"]

        # When
        pattern = Pattern(
            id="pattern-2",
            agent_id="agent-2",
            pattern_type="temporal",
            name="Full Pattern",
            description="A complete pattern",
            context=context,
            code=code,
            confidence=0.8,
            usage_count=10,
            success_count=8,
            failure_count=2,
            discovered_at=now,
            last_used=now,
            tags=tags
        )

        # Then
        assert pattern.context == context
        assert pattern.code == code
        assert pattern.confidence == 0.8
        assert pattern.usage_count == 10
        assert pattern.success_count == 8
        assert pattern.failure_count == 2
        assert pattern.discovered_at == now
        assert pattern.last_used == now
        assert pattern.tags == tags

    def test_success_rate_with_no_usage(self):
        """
        Given: A pattern with no usage history
        When: Calculating success rate
        Then: Returns 0.0
        """
        # Given
        pattern = Pattern(
            id="pattern-3",
            agent_id="agent-3",
            pattern_type="behavioral",
            name="Unused Pattern",
            description="No usage yet"
        )

        # When
        success_rate = pattern.success_rate

        # Then
        assert success_rate == 0.0

    def test_success_rate_with_all_successes(self):
        """
        Given: A pattern with only successful uses
        When: Calculating success rate
        Then: Returns 1.0
        """
        # Given
        pattern = Pattern(
            id="pattern-4",
            agent_id="agent-4",
            pattern_type="conditional",
            name="Perfect Pattern",
            description="Always works",
            success_count=10,
            failure_count=0
        )

        # When
        success_rate = pattern.success_rate

        # Then
        assert success_rate == 1.0

    def test_success_rate_with_mixed_results(self):
        """
        Given: A pattern with both successes and failures
        When: Calculating success rate
        Then: Returns correct ratio
        """
        # Given
        pattern = Pattern(
            id="pattern-5",
            agent_id="agent-5",
            pattern_type="sequential",
            name="Mixed Pattern",
            description="Sometimes works",
            success_count=7,
            failure_count=3
        )

        # When
        success_rate = pattern.success_rate

        # Then
        assert success_rate == 0.7

    def test_success_rate_with_all_failures(self):
        """
        Given: A pattern with only failures
        When: Calculating success rate
        Then: Returns 0.0
        """
        # Given
        pattern = Pattern(
            id="pattern-6",
            agent_id="agent-6",
            pattern_type="temporal",
            name="Failed Pattern",
            description="Never works",
            success_count=0,
            failure_count=5
        )

        # When
        success_rate = pattern.success_rate

        # Then
        assert success_rate == 0.0

    @patch('empathy_os.pattern_library.datetime')
    def test_record_usage_success(self, mock_datetime):
        """
        Given: A pattern and a successful usage
        When: Recording the usage
        Then: Success counters increment and last_used updates
        """
        # Given
        now = datetime(2025, 1, 15, 10, 30)
        mock_datetime.now.return_value = now
        pattern = Pattern(
            id="pattern-7",
            agent_id="agent-7",
            pattern_type="sequential",
            name="Success Pattern",
            description="Test success recording",
            usage_count=0,
            success_count=0,
            failure_count=0
        )

        # When
        pattern.record_usage(success=True)

        # Then
        assert pattern.usage_count == 1
        assert pattern.success_count == 1
        assert pattern.failure_count == 0
        assert pattern.last_used == now

    @patch('empathy_os.pattern_library.datetime')
    def test_record_usage_failure(self, mock_datetime):
        """
        Given: A pattern and a failed usage
        When: Recording the usage
        Then: Failure counters increment and last_used updates
        """
        # Given
        now = datetime(2025, 1, 15, 11, 0)
        mock_datetime.now.return_value = now
        pattern = Pattern(
            id="pattern-8",
            agent_id="agent-8",
            pattern_type="conditional",
            name="Failure Pattern",
            description="Test failure recording",
            usage_count=0,
            success_count=0,
            failure_count=0
        )

        # When
        pattern.record_usage(success=False)

        # Then
        assert pattern.usage_count == 1
        assert pattern.success_count == 0
        assert pattern.failure_count == 1
        assert pattern.last_used == now

    @patch('empathy_os.pattern_library.datetime')
    def test_record_usage_updates_confidence_after_threshold(self, mock_datetime):
        """
        Given: A pattern with 4 uses
        When: Recording the 5th usage
        Then: Confidence is updated to match success rate
        """
        # Given
        now = datetime(2025, 1, 15, 12, 0)
        mock_datetime.now.return_value = now
        pattern = Pattern(
            id="pattern-9",
            agent_id="agent-9",
            pattern_type="behavioral",
            name="Confidence Pattern",
            description="Test confidence update",
            usage_count=4,
            success_count=3,
            failure_count=1,
            confidence=0.5
        )

        # When
        pattern.record_usage(success=True)

        # Then
        assert pattern.usage_count == 5
        assert pattern.success_count == 4
        assert pattern.failure_count == 1
        assert pattern.confidence == 0.8  # 4/5

    @patch('empathy_os.pattern_library.datetime')
    def test_record_usage_does_not_update_confidence_before_threshold(self, mock_datetime):
        """
        Given: A pattern with fewer than 5 uses
        When: Recording usage
        Then: Confidence remains unchanged
        """
        # Given
        now = datetime(2025, 1, 15, 13, 0)
        mock_datetime.now.return_value = now
        pattern = Pattern(
            id="pattern-10",
            agent_id="agent-10",
            pattern_type="sequential",
            name="Low Usage Pattern",
            description="Test confidence threshold",
            usage_count=2,
            success_count=1,
            failure_count=1,
            confidence=0.5
        )

        # When
        pattern.record_usage(success=True)

        # Then
        assert pattern.usage_count == 3
        assert pattern.confidence == 0.5  # Unchanged

    @patch('empathy_os.pattern_library.datetime')
    def test_record_multiple_usages(self, mock_datetime):
        """
        Given: A pattern
        When: Recording multiple usages
        Then: All counters update correctly
        """
        # Given
        times = [datetime(2025, 1, 15, i, 0) for i in range(14, 20)]
        mock_datetime.now.side_effect = times
        pattern = Pattern(
            id="pattern-11",
            agent_id="agent-11",
            pattern_type="temporal",
            name="Multi Usage Pattern",
            description="Test multiple recordings"
        )

        # When
        pattern.record_usage(success=True)
        pattern.record_usage(success=True)
        pattern.record_usage(success=False)
        pattern.record_usage(success=True)
        pattern.record_usage(success=True)

        # Then
        assert pattern.usage_count == 5
        assert pattern.success_count == 4
        assert pattern.failure_count == 1
        assert pattern.success_rate == 0.8
        assert pattern.confidence == 0.8
        assert pattern.last_used == times[4]


class TestPatternMatch:
    """Behavioral tests for PatternMatch dataclass."""

    def test_pattern_match_creation(self):
        """
        Given: A pattern and match details
        When: Creating a PatternMatch
        Then: All fields are properly set
        """
        # Given
        pattern = Pattern(
            id="pattern-12",
            agent_id="agent-12",
            pattern_type="sequential",
            name="Matched Pattern",
            description="Pattern to match"
        )
        relevance = 0.85
        factors = ["context_match", "tag_overlap"]

        # When
        match = PatternMatch(
            pattern=pattern,
            relevance_score=relevance,
            matching_factors=factors
        )

        # Then
        assert match.pattern == pattern
        assert match.relevance_score == 0.85
        assert match.matching_factors == factors

    def test_pattern_match_with_zero_relevance(self):
        """
        Given: A pattern with zero relevance
        When: Creating a PatternMatch
        Then: Relevance score is 0.0
        """
        # Given
        pattern = Pattern(
            id="pattern-13",
            agent_id="agent-13",
            pattern_type="conditional",
            name="Irrelevant Pattern",
            description="Not relevant"
        )

        # When
        match = PatternMatch(
            pattern=pattern,
            relevance_score=0.0,
            matching_factors=[]
        )

        # Then
        assert match.relevance_score == 0.0
        assert match.matching_factors == []

    def test_pattern_match_with_perfect_relevance(self):
        """
        Given: A pattern with perfect relevance
        When: Creating a PatternMatch
        Then: Relevance score is 1.0
        """
        # Given
        pattern = Pattern(
            id="pattern-14",
            agent_id="agent-14",
            pattern_type="behavioral",
            name="Perfect Pattern",
            description="Perfectly relevant"
        )
        factors = ["exact_context", "all_tags", "high_confidence"]

        # When
        match = PatternMatch(
            pattern=pattern,
            relevance_score=1.0,
            matching_factors=factors
        )

        # Then
        assert match.relevance_score == 1.0
        assert len(match.matching_factors) == 3


class TestPatternLibrary:
    """Behavioral tests for PatternLibrary class."""

    @pytest.fixture
    def library(self):
        """Fixture providing a fresh PatternLibrary instance."""
        return PatternLibrary()

    @pytest.fixture
    def sample_pattern(self):
        """Fixture providing a sample pattern."""
        return Pattern(
            id="pattern-sample",
            agent_id="agent-sample",
            pattern_type="sequential",
            name="Sample Pattern",
            description="A sample pattern for testing",
            tags=["test", "sample"]
        )

    def test_pattern_library_initialization(self, library):
        """
        Given: PatternLibrary class
        When: Creating a new instance
        Then: Library is empty
        """
        # Given/When (via fixture)
        # Then
        assert isinstance(library, PatternLibrary)
        assert hasattr(library, 'patterns')

    def test_add_pattern_to_empty_library(self, library, sample_pattern):
        """
        Given: An empty pattern library and a pattern
        When: Adding the pattern
        Then: Pattern is stored in library
        """
        # Given (via fixtures)
        # When
        library.add_pattern(sample_pattern)

        # Then
        assert sample_pattern.id in library.patterns
        assert library.patterns[sample_pattern.id] == sample_pattern

    def test_add_multiple_patterns(self, library):
        """
        Given: An empty pattern library
        When: Adding multiple patterns
        Then: All patterns are stored
        """
        # Given
        pattern1 = Pattern(
            id="pattern-multi-1",
            agent_id="agent-1",
            pattern_type="sequential",
            name="Pattern 1",
            description="First pattern"
        )
        pattern2 = Pattern(
            id="pattern-multi-2",
            agent_id="agent-2",
            pattern_type="temporal",
            name="Pattern 2",
            description="Second pattern"
        )
        pattern3 = Pattern(
            id="pattern-multi-3",
            agent_id="agent-3",
            pattern_type="conditional",
            name="Pattern 3",
            description="Third pattern"
        )

        # When
        library.add_pattern(pattern1)
        library.add_pattern(pattern2)
        library.add_pattern(pattern3)

        # Then
        assert len(library.patterns) == 3
        assert pattern1.id in library.patterns
        assert pattern2.id in library.patterns
        assert pattern3.id in library.patterns

    def test_add_pattern_with_duplicate_id_replaces(self, library):
        """
        Given: A library with an existing pattern
        When: Adding a pattern with the same id
        Then: Pattern is replaced
        """
        # Given
        original = Pattern(
            id="pattern-dup",
            agent_id="agent-1",
            pattern_type="sequential",
            name="Original",
            description="Original pattern"
        )
        library.add_pattern(original)

        replacement = Pattern(
            id="pattern-dup",
            agent_id="agent-2",
            pattern_type="temporal",
            name="Replacement",
            description="Replacement pattern"
        )

        # When
        library.add_pattern(replacement)

        # Then
        assert len(library.patterns) == 1
        assert library.patterns["pattern-dup"].name == "Replacement"
        assert library.patterns