"""Behavioral tests for pattern_learner.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, mock_open, patch

import pytest

from empathy_os.orchestration.pattern_learner import (
    ExecutionRecord,
    PatternLearner,
    PatternStats,
)


# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def sample_execution_record():
    """Given a sample execution record."""
    return ExecutionRecord(
        pattern="test_pattern",
        success=True,
        duration_seconds=1.5,
        cost=0.05,
        confidence=0.9,
        context_features={"feature1": "value1", "feature2": 42},
        timestamp="2026-01-01T12:00:00",
    )


@pytest.fixture
def sample_pattern_stats():
    """Given sample pattern statistics."""
    return PatternStats(
        pattern="test_pattern",
        total_executions=10,
        success_count=8,
        total_duration=15.0,
        total_cost=0.5,
        avg_confidence=0.85,
    )


@pytest.fixture
def temp_storage_path(tmp_path):
    """Given a temporary storage path."""
    return tmp_path / "pattern_learner.json"


@pytest.fixture
def pattern_learner(temp_storage_path):
    """Given a pattern learner instance."""
    return PatternLearner(storage_path=temp_storage_path)


@pytest.fixture
def populated_pattern_learner(pattern_learner):
    """Given a pattern learner with some execution records."""
    pattern_learner.record_execution(
        pattern="pattern_a",
        success=True,
        duration_seconds=1.0,
        cost=0.01,
        confidence=0.9,
        context_features={"type": "simple", "complexity": "low"},
    )
    pattern_learner.record_execution(
        pattern="pattern_a",
        success=True,
        duration_seconds=1.2,
        cost=0.012,
        confidence=0.88,
        context_features={"type": "simple", "complexity": "low"},
    )
    pattern_learner.record_execution(
        pattern="pattern_b",
        success=False,
        duration_seconds=2.5,
        cost=0.03,
        confidence=0.5,
        context_features={"type": "complex", "complexity": "high"},
    )
    pattern_learner.record_execution(
        pattern="pattern_c",
        success=True,
        duration_seconds=0.8,
        cost=0.008,
        confidence=0.95,
        context_features={"type": "simple", "complexity": "medium"},
    )
    return pattern_learner


# =============================================================================
# ExecutionRecord Tests
# =============================================================================


class TestExecutionRecord:
    """Behavioral tests for ExecutionRecord dataclass."""

    def test_execution_record_creation_with_defaults(self):
        """Given minimal parameters, when creating an execution record,
        then it should have default values for optional fields."""
        # When
        record = ExecutionRecord(
            pattern="test_pattern", success=True, duration_seconds=1.0
        )

        # Then
        assert record.pattern == "test_pattern"
        assert record.success is True
        assert record.duration_seconds == 1.0
        assert record.cost == 0.0
        assert record.confidence == 0.0
        assert record.context_features == {}
        assert isinstance(record.timestamp, str)

    def test_execution_record_creation_with_all_fields(self, sample_execution_record):
        """Given all parameters, when creating an execution record,
        then it should contain all provided values."""
        # Then
        assert sample_execution_record.pattern == "test_pattern"
        assert sample_execution_record.success is True
        assert sample_execution_record.duration_seconds == 1.5
        assert sample_execution_record.cost == 0.05
        assert sample_execution_record.confidence == 0.9
        assert sample_execution_record.context_features == {
            "feature1": "value1",
            "feature2": 42,
        }
        assert sample_execution_record.timestamp == "2026-01-01T12:00:00"

    def test_execution_record_to_dict(self, sample_execution_record):
        """Given an execution record, when converting to dict,
        then it should contain all fields."""
        # When
        result = sample_execution_record.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["pattern"] == "test_pattern"
        assert result["success"] is True
        assert result["duration_seconds"] == 1.5
        assert result["cost"] == 0.05
        assert result["confidence"] == 0.9
        assert result["context_features"] == {"feature1": "value1", "feature2": 42}
        assert result["timestamp"] == "2026-01-01T12:00:00"

    def test_execution_record_from_dict(self):
        """Given a dictionary, when creating an execution record from it,
        then it should match the original values."""
        # Given
        data = {
            "pattern": "test_pattern",
            "success": False,
            "duration_seconds": 2.0,
            "cost": 0.1,
            "confidence": 0.7,
            "context_features": {"key": "value"},
            "timestamp": "2026-01-02T10:00:00",
        }

        # When
        record = ExecutionRecord.from_dict(data)

        # Then
        assert record.pattern == "test_pattern"
        assert record.success is False
        assert record.duration_seconds == 2.0
        assert record.cost == 0.1
        assert record.confidence == 0.7
        assert record.context_features == {"key": "value"}
        assert record.timestamp == "2026-01-02T10:00:00"

    def test_execution_record_round_trip_conversion(self, sample_execution_record):
        """Given an execution record, when converting to dict and back,
        then it should match the original."""
        # When
        data = sample_execution_record.to_dict()
        reconstructed = ExecutionRecord.from_dict(data)

        # Then
        assert reconstructed.pattern == sample_execution_record.pattern
        assert reconstructed.success == sample_execution_record.success
        assert reconstructed.duration_seconds == sample_execution_record.duration_seconds
        assert reconstructed.cost == sample_execution_record.cost
        assert reconstructed.confidence == sample_execution_record.confidence
        assert reconstructed.context_features == sample_execution_record.context_features
        assert reconstructed.timestamp == sample_execution_record.timestamp


# =============================================================================
# PatternStats Tests
# =============================================================================


class TestPatternStats:
    """Behavioral tests for PatternStats dataclass."""

    def test_pattern_stats_creation_with_defaults(self):
        """Given minimal parameters, when creating pattern stats,
        then it should have default values for optional fields."""
        # When
        stats = PatternStats(pattern="test_pattern")

        # Then
        assert stats.pattern == "test_pattern"
        assert stats.total_executions == 0
        assert stats.success_count == 0
        assert stats.total_duration == 0.0
        assert stats.total_cost == 0.0
        assert stats.avg_confidence == 0.0

    def test_pattern_stats_success_rate_calculation(self, sample_pattern_stats):
        """Given pattern stats with executions, when calculating success rate,
        then it should return correct percentage."""
        # When
        success_rate = sample_pattern_stats.success_rate

        # Then
        assert success_rate == 0.8  # 8 out of 10

    def test_pattern_stats_success_rate_with_zero_executions(self):
        """Given pattern stats with no executions, when calculating success rate,
        then it should return 0.0."""
        # Given
        stats = PatternStats(pattern="test_pattern")

        # When
        success_rate = stats.success_rate

        # Then
        assert success_rate == 0.0

    def test_pattern_stats_avg_duration_calculation(self, sample_pattern_stats):
        """Given pattern stats with executions, when calculating avg duration,
        then it should return correct average."""
        # When
        avg_duration = sample_pattern_stats.avg_duration

        # Then
        assert avg_duration == 1.5  # 15.0 / 10

    def test_pattern_stats_avg_duration_with_zero_executions(self):
        """Given pattern stats with no executions, when calculating avg duration,
        then it should return 0.0."""
        # Given
        stats = PatternStats(pattern="test_pattern")

        # When
        avg_duration = stats.avg_duration

        # Then
        assert avg_duration == 0.0

    def test_pattern_stats_avg_cost_calculation(self, sample_pattern_stats):
        """Given pattern stats with executions, when calculating avg cost,
        then it should return correct average."""
        # When
        avg_cost = sample_pattern_stats.avg_cost

        # Then
        assert avg_cost == 0.05  # 0.5 / 10

    def test_pattern_stats_avg_cost_with_zero_executions(self):
        """Given pattern stats with no executions, when calculating avg cost,
        then it should return 0.0."""
        # Given
        stats = PatternStats(pattern="test_pattern")

        # When
        avg_cost = stats.avg_cost

        # Then
        assert avg_cost == 0.0


# =============================================================================
# PatternLearner Initialization Tests
# =============================================================================


class TestPatternLearnerInitialization:
    """Behavioral tests for PatternLearner initialization."""

    def test_pattern_learner_initialization_default_path(self):
        """Given no storage path, when creating pattern learner,
        then it should use default path."""
        # When
        learner = PatternLearner()

        # Then
        assert learner.storage_path == Path("data/pattern_learner.json")
        assert learner.stats == {}
        assert learner.execution_history == []

    def test_pattern_learner_initialization_custom_path(self, temp_storage_path):
        """Given a custom storage path, when creating pattern learner,
        then it should use that path."""
        # When
        learner = PatternLearner(storage_path=temp_storage_path)

        # Then
        assert learner.storage_path == temp_storage_path

    @patch("empathy_os.orchestration.pattern_learner.Path.exists")
    @patch("empathy_os.orchestration.pattern_learner.Path.open")
    def test_pattern_learner_loads_existing_data_on_init(
        self, mock_open_file, mock_exists, temp_storage_path
    ):
        """Given existing storage file, when creating pattern learner,
        then it should load the data."""
        # Given
        mock_exists.return_value = True
        existing_data = {
            "stats": {
                "pattern_a": {
                    "pattern": "pattern_a",
                    "total_executions": 5,
                    "success_count": 4,
                    "total_duration": 10.0,
                    "total_cost": 0.5,
                    "avg_confidence": 0.8,
                }
            },
            "history": [
                {
                    "pattern": "pattern_a",
                    "success": True,
                    "duration_seconds": 2.0,
                    "cost": 0.1,
                    "confidence": 0.8,
                    "context_features": {},
                    "timestamp": "2026-01-01T12:00:00",
                }
            ],
        }
        mock_open_file.return_value = mock_open(
            read_data=json.dumps(existing_data)
        ).return_value

        # When
        learner = PatternLearner(storage_path=temp_storage_path)

        # Then
        assert "pattern_a" in learner.stats
        assert learner.stats["pattern_a"].total_executions == 5
        assert len(learner.execution_history) == 1

    @patch("empathy_os.orchestration.pattern_learner.Path.exists")
    def test_pattern_learner_handles_missing_file(self, mock_exists, temp_storage_path):
        """Given no existing storage file, when creating pattern learner,
        then it should start with empty data."""
        # Given
        mock_exists.return_value = False

        # When
        learner = PatternLearner(storage_path=temp_storage_path)

        # Then
        assert learner.stats == {}
        assert learner.execution_history == []

    @patch("empathy_os.orchestration.pattern_learner.Path.exists")
    @patch("empathy_os.orchestration.pattern_learner.Path.open")
    def test_pattern_learner_handles_corrupted_file(
        self, mock_open_file, mock_exists, temp_storage_path, caplog
    ):
        """Given a corrupted storage file, when creating pattern learner,
        then it should log error and start with empty data."""
        # Given
        mock_exists.return_value = True
        mock_open_file.return_value = mock_open(read_data="invalid json").return_value

        # When
        with caplog.at_level(logging.ERROR):
            learner = PatternLearner(storage_path=temp_storage_path)

        # Then
        assert learner.stats == {}
        assert learner.execution_history == []
        assert "Failed to load" in caplog.text


# =============================================================================
# PatternLearner Recording Tests
# =============================================================================


class TestPatternLearnerRecording:
    """Behavioral tests for recording executions."""

    def test_record_execution_creates_new_stats(self, pattern_learner):
        """Given a new pattern, when recording execution,
        then it should create new stats entry."""
        # When
        pattern_learner.record_execution(
            pattern="new_pattern",
            success=True,
            duration_seconds=1.0,
            cost=0.01,
            confidence=0.9,
        )

        # Then
        assert "new_pattern" in pattern_learner.stats
        assert pattern_learner.stats["new_pattern"].total_executions == 1
        assert pattern_learner.stats["new_pattern"].success_count == 1

    def test_record_execution_updates_existing_stats(self, pattern_learner):
        """Given an existing pattern, when recording multiple executions,
        then it should update stats correctly."""
        # When
        pattern_learner.record_execution(
            pattern="test_pattern", success=True, duration_seconds=1.0, cost=0.01
        )
        pattern_learner.record_execution(
            pattern="test_pattern", success=False, duration_seconds=2.0, cost=0.02
        )

        # Then
        stats = pattern_learner.stats["test_pattern"]
        assert stats.total_executions == 2
        assert stats.success_count == 1
        assert stats.total_duration == 3.0
        assert stats.total_cost == 0.03

    def test_record_execution_adds_to_history(self, pattern_learner):
        """Given an execution record, when recording,
        then it should be added to history."""
        # When
        pattern_learner.record_execution(
            pattern="test_pattern",
            success=True,