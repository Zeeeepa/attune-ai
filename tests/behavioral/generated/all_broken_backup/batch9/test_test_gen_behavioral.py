"""Behavioral tests for test_gen.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import ast
import logging
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, PropertyMock, call, mock_open, patch

import pytest

from empathy_os.workflows.progressive.core import (
    EscalationConfig,
    FailureAnalysis,
    ProgressiveWorkflowResult,
    Tier,
    TierResult,
)
from empathy_os.workflows.progressive.test_gen import ProgressiveTestGenWorkflow


class TestProgressiveTestGenWorkflowInitialization:
    """Test suite for ProgressiveTestGenWorkflow initialization."""

    def test_init_with_no_config_creates_default_config(self):
        """
        Given: No configuration provided
        When: Workflow is initialized
        Then: Default configuration is created and target_file is None
        """
        # When
        workflow = ProgressiveTestGenWorkflow()

        # Then
        assert workflow.config is not None
        assert isinstance(workflow.config, EscalationConfig)
        assert workflow.target_file is None

    def test_init_with_custom_config_uses_provided_config(self):
        """
        Given: Custom configuration provided
        When: Workflow is initialized
        Then: Provided configuration is used
        """
        # Given
        custom_config = EscalationConfig(
            enabled=True,
            max_cost=50.0,
            approval_threshold=10.0
        )

        # When
        workflow = ProgressiveTestGenWorkflow(config=custom_config)

        # Then
        assert workflow.config == custom_config
        assert workflow.config.max_cost == 50.0
        assert workflow.config.approval_threshold == 10.0

    def test_init_with_none_config_creates_default(self):
        """
        Given: None explicitly passed as config
        When: Workflow is initialized
        Then: Default configuration is created
        """
        # When
        workflow = ProgressiveTestGenWorkflow(config=None)

        # Then
        assert workflow.config is not None
        assert isinstance(workflow.config, EscalationConfig)


class TestProgressiveTestGenWorkflowExecute:
    """Test suite for execute method."""

    @pytest.fixture
    def mock_workflow(self):
        """Create a workflow instance with mocked dependencies."""
        config = EscalationConfig(enabled=True, max_cost=100.0)
        workflow = ProgressiveTestGenWorkflow(config=config)
        return workflow

    @pytest.fixture
    def temp_target_file(self, tmp_path):
        """Create a temporary Python file with sample functions."""
        target_file = tmp_path / "sample.py"
        target_file.write_text("""
def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

class Calculator:
    def divide(self, a, b):
        return a / b
""")
        return target_file

    def test_execute_with_nonexistent_file_raises_error(self, mock_workflow):
        """
        Given: A nonexistent file path
        When: Execute is called
        Then: FileNotFoundError is raised
        """
        # Given
        nonexistent_file = "/path/to/nonexistent/file.py"

        # When/Then
        with pytest.raises(FileNotFoundError, match="Target file not found"):
            mock_workflow.execute(target_file=nonexistent_file)

    @patch.object(ProgressiveTestGenWorkflow, "_parse_functions")
    @patch.object(ProgressiveTestGenWorkflow, "_create_empty_result")
    def test_execute_with_existing_file_sets_target_file(
        self, mock_create_empty, mock_parse, mock_workflow, temp_target_file
    ):
        """
        Given: An existing target file
        When: Execute is called
        Then: Target file path is stored as Path object
        """
        # Given
        mock_parse.return_value = []
        mock_create_empty.return_value = ProgressiveWorkflowResult(
            task_type="test-gen",
            tier_progression=[],
            final_result=TierResult(
                tier=Tier.CHEAP,
                success=True,
                generated_items=[],
                cost=0.0,
                latency_ms=0,
                quality_score=0.0,
                failure_analysis=None,
            ),
            total_cost=0.0,
            total_latency_ms=0,
            started_at=datetime.now(),
            completed_at=datetime.now(),
        )

        # When
        mock_workflow.execute(target_file=str(temp_target_file))

        # Then
        assert mock_workflow.target_file == temp_target_file
        assert isinstance(mock_workflow.target_file, Path)

    @patch.object(ProgressiveTestGenWorkflow, "_parse_functions")
    @patch.object(ProgressiveTestGenWorkflow, "_create_empty_result")
    def test_execute_with_no_functions_returns_empty_result(
        self, mock_create_empty, mock_parse, mock_workflow, temp_target_file
    ):
        """
        Given: A file with no functions
        When: Execute is called
        Then: Empty result is returned
        """
        # Given
        mock_parse.return_value = []
        expected_result = ProgressiveWorkflowResult(
            task_type="test-gen",
            tier_progression=[],
            final_result=TierResult(
                tier=Tier.CHEAP,
                success=True,
                generated_items=[],
                cost=0.0,
                latency_ms=0,
                quality_score=0.0,
                failure_analysis=None,
            ),
            total_cost=0.0,
            total_latency_ms=0,
            started_at=datetime.now(),
            completed_at=datetime.now(),
        )
        mock_create_empty.return_value = expected_result

        # When
        result = mock_workflow.execute(target_file=str(temp_target_file))

        # Then
        assert result == expected_result
        mock_create_empty.assert_called_once_with("test-gen")

    @patch.object(ProgressiveTestGenWorkflow, "_parse_functions")
    def test_execute_with_functions_logs_count(
        self, mock_parse, mock_workflow, temp_target_file, caplog
    ):
        """
        Given: A file with functions
        When: Execute is called
        Then: Function count is logged
        """
        # Given
        mock_parse.return_value = ["add", "multiply", "divide"]

        # When
        with caplog.at_level(logging.INFO):
            try:
                # This will fail since we're not mocking the entire execution chain
                # but we can still test the logging
                mock_workflow.execute(target_file=str(temp_target_file))
            except (AttributeError, TypeError):
                # Expected to fail due to incomplete mocking
                pass

        # Then
        assert "Found 3 functions to test" in caplog.text

    @patch.object(ProgressiveTestGenWorkflow, "_parse_functions")
    def test_execute_logs_generation_start(
        self, mock_parse, mock_workflow, temp_target_file, caplog
    ):
        """
        Given: A valid target file
        When: Execute is called
        Then: Generation start is logged
        """
        # Given
        mock_parse.return_value = []

        # When
        with caplog.at_level(logging.INFO):
            try:
                mock_workflow.execute(target_file=str(temp_target_file))
            except (AttributeError, TypeError):
                pass

        # Then
        assert f"Generating tests for {temp_target_file}" in caplog.text

    @patch.object(ProgressiveTestGenWorkflow, "_parse_functions")
    @patch.object(ProgressiveTestGenWorkflow, "_create_empty_result")
    def test_execute_with_empty_file_logs_warning(
        self, mock_create_empty, mock_parse, mock_workflow, temp_target_file, caplog
    ):
        """
        Given: A file with no functions
        When: Execute is called
        Then: Warning is logged about no functions found
        """
        # Given
        mock_parse.return_value = []
        mock_create_empty.return_value = MagicMock()

        # When
        with caplog.at_level(logging.WARNING):
            mock_workflow.execute(target_file=str(temp_target_file))

        # Then
        assert f"No functions found in {temp_target_file}" in caplog.text

    def test_execute_accepts_additional_kwargs(self, mock_workflow, temp_target_file):
        """
        Given: Additional keyword arguments
        When: Execute is called with kwargs
        Then: Execution proceeds without error
        """
        # Given
        with patch.object(mock_workflow, "_parse_functions", return_value=[]):
            with patch.object(mock_workflow, "_create_empty_result", return_value=MagicMock()):
                # When
                result = mock_workflow.execute(
                    target_file=str(temp_target_file),
                    extra_param="value",
                    another_param=123
                )

                # Then
                assert result is not None


class TestProgressiveTestGenWorkflowParseFunctions:
    """Test suite for _parse_functions method."""

    @pytest.fixture
    def workflow(self):
        """Create workflow instance for testing."""
        return ProgressiveTestGenWorkflow()

    def test_parse_functions_with_simple_functions(self, workflow, tmp_path):
        """
        Given: A file with simple function definitions
        When: _parse_functions is called
        Then: All function names are returned
        """
        # Given
        target_file = tmp_path / "simple.py"
        target_file.write_text("""
def func1():
    pass

def func2(a, b):
    return a + b

def func3(x, y, z=10):
    return x * y * z
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert len(functions) == 3
        assert "func1" in functions
        assert "func2" in functions
        assert "func3" in functions

    def test_parse_functions_with_class_methods(self, workflow, tmp_path):
        """
        Given: A file with class methods
        When: _parse_functions is called
        Then: Class methods are included
        """
        # Given
        target_file = tmp_path / "classes.py"
        target_file.write_text("""
class MyClass:
    def method1(self):
        pass

    def method2(self, x):
        return x * 2

def standalone_func():
    pass
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert len(functions) == 3
        assert "method1" in functions
        assert "method2" in functions
        assert "standalone_func" in functions

    def test_parse_functions_with_nested_functions(self, workflow, tmp_path):
        """
        Given: A file with nested functions
        When: _parse_functions is called
        Then: Only top-level and class methods are returned
        """
        # Given
        target_file = tmp_path / "nested.py"
        target_file.write_text("""
def outer():
    def inner():
        pass
    return inner

class Container:
    def method(self):
        def nested():
            pass
        return nested
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert "outer" in functions
        assert "method" in functions
        # Nested functions should not be included
        assert "inner" not in functions
        assert "nested" not in functions

    def test_parse_functions_with_empty_file(self, workflow, tmp_path):
        """
        Given: An empty Python file
        When: _parse_functions is called
        Then: Empty list is returned
        """
        # Given
        target_file = tmp_path / "empty.py"
        target_file.write_text("")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert functions == []

    def test_parse_functions_with_only_comments(self, workflow, tmp_path):
        """
        Given: A file with only comments and docstrings
        When: _parse_functions is called
        Then: Empty list is returned
        """
        # Given
        target_file = tmp_path / "comments.py"
        target_file.write_text("""
# This is a comment
'''
This is a module docstring
'''

# More comments
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert functions == []

    def test_parse_functions_with_private_methods(self, workflow, tmp_path):
        """
        Given: A file with private methods (prefixed with _)
        When: _parse_functions is called
        Then: Private methods are included
        """
        # Given
        target_file = tmp_path / "private.py"
        target_file.write_text("""
def _private_func():
    pass

def public_func():
    pass

class MyClass:
    def _private_method(self):
        pass

    def public_method(self):
        pass
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert "_private_func" in functions
        assert "public_func" in functions
        assert "_private_method" in functions
        assert "public_method" in functions

    def test_parse_functions_with_decorators(self, workflow, tmp_path):
        """
        Given: A file with decorated functions
        When: _parse_functions is called
        Then: Decorated functions are included
        """
        # Given
        target_file = tmp_path / "decorators.py"
        target_file.write_text("""
@decorator
def decorated_func():
    pass

@property
def prop_func(self):
    pass

@staticmethod
def static_func():
    pass
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert "decorated_func" in functions
        assert "prop_func" in functions
        assert "static_func" in functions

    def test_parse_functions_with_async_functions(self, workflow, tmp_path):
        """
        Given: A file with async functions
        When: _parse_functions is called
        Then: Async functions are included
        """
        # Given
        target_file = tmp_path / "async.py"
        target_file.write_text("""
async def async_func():
    pass

def sync_func():
    pass

class AsyncClass:
    async def async_method(self):
        pass
""")

        # When
        functions = workflow._parse_functions(target_file)

        # Then
        assert "async_func" in functions
        assert "sync_func" in functions
        assert "async_method" in functions

    def test_parse_functions_with_syntax_error_raises_exception(self, workflow, tmp_path):
        """
        Given: A file with syntax errors
        When: _parse_functions is called
        Then: SyntaxError is raised
        """
        # Given
        target_file = tmp_path / "invalid.py"
        target_file.write_text("""
def invalid_syntax(
    # Missing closing parenthesis and colon
""")

        # When/Then
        with pytest.raises(SyntaxError):
            workflow._parse_functions(target_file)

    def test_