"""Behavioral tests for security_audit_phase3.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import ast
import logging
from pathlib import Path
from unittest.mock import Mock, patch, mock_open

import pytest

from empathy_os.workflows.security_audit_phase3 import (
    EvalExecDetector,
    analyze_file_for_eval_exec,
)


@pytest.fixture
def sample_python_file(tmp_path):
    """Create a temporary Python file for testing."""
    def _create_file(content: str, filename: str = "test.py") -> Path:
        file_path = tmp_path / filename
        file_path.write_text(content, encoding="utf-8")
        return file_path
    return _create_file


@pytest.fixture
def mock_logger():
    """Mock logger for testing logging behavior."""
    with patch("empathy_os.workflows.security_audit_phase3.logger") as mock_log:
        yield mock_log


class TestEvalExecDetectorInitialization:
    """Tests for EvalExecDetector initialization."""

    def test_given_file_path_when_initialized_then_stores_path(self):
        """Given a file path, when detector is initialized, then it stores the path."""
        # Given
        file_path = "/path/to/test.py"

        # When
        detector = EvalExecDetector(file_path)

        # Then
        assert detector.file_path == file_path

    def test_given_file_path_when_initialized_then_findings_empty(self):
        """Given a file path, when detector is initialized, then findings list is empty."""
        # Given
        file_path = "/path/to/test.py"

        # When
        detector = EvalExecDetector(file_path)

        # Then
        assert detector.findings == []

    def test_given_file_path_when_initialized_then_current_function_is_none(self):
        """Given a file path, when detector is initialized, then current function is None."""
        # Given
        file_path = "/path/to/test.py"

        # When
        detector = EvalExecDetector(file_path)

        # Then
        assert detector._current_function is None


class TestEvalExecDetectorVisitFunctionDef:
    """Tests for EvalExecDetector function definition visiting."""

    def test_given_function_def_when_visited_then_tracks_function_name(self):
        """Given a function definition, when visited, then tracks the function name."""
        # Given
        code = """
def test_function():
    pass
"""
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")
        func_node = tree.body[0]

        # When
        with patch.object(detector, 'generic_visit') as mock_generic:
            detector.visit_FunctionDef(func_node)
            
            # Then (during visit)
            mock_generic.assert_called_once_with(func_node)

        # Then (after visit)
        assert detector._current_function is None  # Reset after visit

    def test_given_nested_functions_when_visited_then_resets_context(self):
        """Given nested functions, when visited, then properly resets context."""
        # Given
        code = """
def outer():
    def inner():
        pass
"""
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert detector._current_function is None


class TestEvalExecDetectorVisitCall:
    """Tests for EvalExecDetector call node visiting."""

    def test_given_eval_call_when_visited_then_records_finding(self):
        """Given an eval() call, when visited, then records a finding."""
        # Given
        code = "eval('1 + 1')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 1
        assert detector.findings[0]["type"] == "command_injection"
        assert detector.findings[0]["function"] == "eval"
        assert detector.findings[0]["line"] == 1

    def test_given_exec_call_when_visited_then_records_finding(self):
        """Given an exec() call, when visited, then records a finding."""
        # Given
        code = "exec('print(1)')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 1
        assert detector.findings[0]["type"] == "command_injection"
        assert detector.findings[0]["function"] == "exec"
        assert detector.findings[0]["line"] == 1

    def test_given_eval_in_function_when_visited_then_records_context(self):
        """Given eval() in a function, when visited, then records function context."""
        # Given
        code = """
def my_function():
    eval('1 + 1')
"""
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 1
        assert detector.findings[0]["context"] == "my_function"

    def test_given_attribute_eval_call_when_visited_then_records_finding(self):
        """Given obj.eval() call, when visited, then records a finding."""
        # Given
        code = "obj.eval('test')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 1
        assert detector.findings[0]["function"] == "eval"

    def test_given_attribute_exec_call_when_visited_then_records_finding(self):
        """Given obj.exec() call, when visited, then records a finding."""
        # Given
        code = "obj.exec('test')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 1
        assert detector.findings[0]["function"] == "exec"

    def test_given_multiple_eval_exec_calls_when_visited_then_records_all(self):
        """Given multiple eval/exec calls, when visited, then records all findings."""
        # Given
        code = """
eval('1 + 1')
exec('print(1)')
eval('2 + 2')
"""
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 3
        assert detector.findings[0]["function"] == "eval"
        assert detector.findings[1]["function"] == "exec"
        assert detector.findings[2]["function"] == "eval"

    def test_given_normal_function_call_when_visited_then_no_finding(self):
        """Given a normal function call, when visited, then no finding recorded."""
        # Given
        code = "print('hello')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 0

    def test_given_eval_string_literal_when_visited_then_no_finding(self):
        """Given 'eval' as string literal, when visited, then no finding recorded."""
        # Given
        code = "x = 'eval is dangerous'"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 0

    def test_given_eval_in_comment_when_visited_then_no_finding(self):
        """Given 'eval' in comment, when visited, then no finding recorded."""
        # Given
        code = "# This code doesn't use eval\nprint('safe')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 0

    def test_given_eval_in_docstring_when_visited_then_no_finding(self):
        """Given 'eval' in docstring, when visited, then no finding recorded."""
        # Given
        code = '''
def my_function():
    """This function avoids eval for security."""
    pass
'''
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert len(detector.findings) == 0

    def test_given_call_with_line_and_col_when_visited_then_records_position(self):
        """Given a call with line/col info, when visited, then records position."""
        # Given
        code = "    eval('test')"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When
        detector.visit(tree)

        # Then
        assert detector.findings[0]["line"] == 1
        assert detector.findings[0]["col"] == 4

    def test_given_call_without_name_or_attribute_when_visited_then_no_crash(self):
        """Given a call that's neither Name nor Attribute, when visited, then no crash."""
        # Given
        code = "(lambda: None)()"
        tree = ast.parse(code)
        detector = EvalExecDetector("test.py")

        # When/Then
        detector.visit(tree)  # Should not crash
        assert len(detector.findings) == 0


class TestAnalyzeFileForEvalExec:
    """Tests for analyze_file_for_eval_exec function."""

    def test_given_file_with_eval_when_analyzed_then_returns_findings(self, sample_python_file):
        """Given a file with eval(), when analyzed, then returns findings."""
        # Given
        code = "eval('1 + 1')"
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert len(findings) == 1
        assert findings[0]["function"] == "eval"
        assert findings[0]["type"] == "command_injection"

    def test_given_file_with_exec_when_analyzed_then_returns_findings(self, sample_python_file):
        """Given a file with exec(), when analyzed, then returns findings."""
        # Given
        code = "exec('print(1)')"
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert len(findings) == 1
        assert findings[0]["function"] == "exec"

    def test_given_safe_file_when_analyzed_then_returns_empty_list(self, sample_python_file):
        """Given a file without eval/exec, when analyzed, then returns empty list."""
        # Given
        code = "print('hello world')"
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert findings == []

    def test_given_nonexistent_file_when_analyzed_then_returns_empty_list(self):
        """Given a nonexistent file, when analyzed, then returns empty list."""
        # Given
        file_path = Path("/nonexistent/path/to/file.py")

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert findings == []

    def test_given_string_path_when_analyzed_then_converts_to_path(self, sample_python_file):
        """Given a string path, when analyzed, then converts to Path object."""
        # Given
        code = "eval('test')"
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(str(file_path))

        # Then
        assert len(findings) == 1

    def test_given_file_with_syntax_error_when_analyzed_then_returns_empty_list(
        self, sample_python_file, mock_logger
    ):
        """Given a file with syntax error, when analyzed, then returns empty list."""
        # Given
        code = "def broken(\n  # Invalid syntax"
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert findings == []

    def test_given_file_with_encoding_issues_when_analyzed_then_handles_gracefully(
        self, tmp_path
    ):
        """Given a file with encoding issues, when analyzed, then handles gracefully."""
        # Given
        file_path = tmp_path / "test.py"
        # Write binary content with invalid UTF-8
        file_path.write_bytes(b"eval('test') \xff\xfe")

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        # Should handle with errors='ignore' and still detect eval
        assert len(findings) == 1

    def test_given_file_with_multiple_findings_when_analyzed_then_returns_all(
        self, sample_python_file
    ):
        """Given a file with multiple eval/exec, when analyzed, then returns all findings."""
        # Given
        code = """
def func1():
    eval('test1')

def func2():
    exec('test2')
    
eval('test3')
"""
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert len(findings) == 3
        assert findings[0]["context"] == "func1"
        assert findings[1]["context"] == "func2"
        assert findings[2]["context"] is None

    def test_given_complex_code_when_analyzed_then_detects_only_actual_calls(
        self, sample_python_file
    ):
        """Given complex code with eval mentions, when analyzed, then detects only actual calls."""
        # Given
        code = '''
"""
This module avoids eval() for security.
"""

# Don't use eval here
dangerous_string = "eval('malicious')"

def check_for_eval(code):
    """Check if code contains eval."""
    return "eval" in code

# Actual eval call - should be detected
result = eval('1 + 1')
'''
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert len(findings) == 1  # Only the actual eval call
        assert findings[0]["function"] == "eval"

    def test_given_nested_functions_with_eval_when_analyzed_then_tracks_context(
        self, sample_python_file
    ):
        """Given nested functions with eval, when analyzed, then tracks outer context."""
        # Given
        code = """
def outer():
    def inner():
        eval('test')
"""
        file_path = sample_python_file(code)

        # When
        findings = analyze_file_for_eval_exec(file_path)

        # Then
        assert len(findings) == 1
        # Context tracks the immediate function