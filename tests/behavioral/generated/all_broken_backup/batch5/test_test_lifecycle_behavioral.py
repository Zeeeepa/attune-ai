"""Behavioral tests for test_lifecycle.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import json
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, Mock, patch, call

import pytest

from empathy_os.workflows.test_lifecycle import (
    TestLifecycleManager,
    TestTask,
)
from empathy_os.workflows.test_maintenance import TestAction, TestPriority


@pytest.fixture
def temp_project_root(tmp_path):
    """Create a temporary project root directory."""
    project_root = tmp_path / "test_project"
    project_root.mkdir()
    (project_root / ".empathy").mkdir()
    return project_root


@pytest.fixture
def mock_project_index():
    """Create a mock ProjectIndex."""
    mock_index = MagicMock()
    mock_index.is_excluded.return_value = False
    mock_index.get_file_info.return_value = {
        "path": "src/test_file.py",
        "type": "source",
        "has_tests": False,
    }
    return mock_index


@pytest.fixture
def lifecycle_manager(temp_project_root, mock_project_index):
    """Create a TestLifecycleManager instance."""
    manager = TestLifecycleManager(
        project_root=str(temp_project_root),
        index=mock_project_index,
        auto_execute=False,
    )
    return manager


@pytest.fixture
def sample_test_task():
    """Create a sample TestTask."""
    return TestTask(
        id="task-001",
        file_path="src/test_file.py",
        action=TestAction.GENERATE,
        priority=TestPriority.HIGH,
        created_at=datetime(2025, 1, 1, 12, 0, 0),
    )


class TestTestTask:
    """Test the TestTask dataclass."""

    def test_given_task_when_to_dict_then_returns_serializable_dict(self, sample_test_task):
        """Given a TestTask, when converting to dict, then returns serializable dictionary."""
        # When
        result = sample_test_task.to_dict()

        # Then
        assert result["id"] == "task-001"
        assert result["file_path"] == "src/test_file.py"
        assert result["action"] == "generate"
        assert result["priority"] == "high"
        assert result["created_at"] == "2025-01-01T12:00:00"
        assert result["scheduled_for"] is None
        assert result["status"] == "pending"
        assert result["result"] is None

    def test_given_task_with_scheduled_time_when_to_dict_then_includes_scheduled_time(self):
        """Given a TestTask with scheduled_for, when converting to dict, then includes ISO formatted time."""
        # Given
        scheduled_time = datetime(2025, 1, 2, 10, 0, 0)
        task = TestTask(
            id="task-002",
            file_path="src/file.py",
            action=TestAction.UPDATE,
            priority=TestPriority.MEDIUM,
            scheduled_for=scheduled_time,
        )

        # When
        result = task.to_dict()

        # Then
        assert result["scheduled_for"] == "2025-01-02T10:00:00"

    def test_given_task_with_result_when_to_dict_then_includes_result(self):
        """Given a TestTask with result, when converting to dict, then includes result data."""
        # Given
        task = TestTask(
            id="task-003",
            file_path="src/file.py",
            action=TestAction.GENERATE,
            priority=TestPriority.LOW,
            status="completed",
            result={"tests_generated": 5, "coverage": 85.5},
        )

        # When
        result = task.to_dict()

        # Then
        assert result["result"] == {"tests_generated": 5, "coverage": 85.5}
        assert result["status"] == "completed"

    def test_given_new_task_when_created_then_has_default_values(self):
        """Given a new TestTask, when created, then has appropriate default values."""
        # When
        task = TestTask(
            id="task-004",
            file_path="src/new_file.py",
            action=TestAction.GENERATE,
            priority=TestPriority.HIGH,
        )

        # Then
        assert task.status == "pending"
        assert task.result is None
        assert task.scheduled_for is None
        assert isinstance(task.created_at, datetime)


class TestTestLifecycleManagerInitialization:
    """Test TestLifecycleManager initialization."""

    def test_given_project_root_when_initialized_then_creates_manager(self, temp_project_root):
        """Given a project root, when initializing manager, then creates instance with correct attributes."""
        # When
        manager = TestLifecycleManager(project_root=str(temp_project_root))

        # Then
        assert manager.project_root == temp_project_root
        assert manager.auto_execute is False
        assert manager._queue == []
        assert manager._history == []
        assert manager._task_counter == 0

    def test_given_custom_queue_file_when_initialized_then_uses_custom_path(self, temp_project_root):
        """Given a custom queue file path, when initializing, then uses the custom path."""
        # Given
        custom_queue = str(temp_project_root / "custom_queue.json")

        # When
        manager = TestLifecycleManager(
            project_root=str(temp_project_root),
            queue_file=custom_queue,
        )

        # Then
        assert manager._queue_file == Path(custom_queue)

    def test_given_auto_execute_when_initialized_then_sets_auto_execute(self, temp_project_root):
        """Given auto_execute=True, when initializing, then sets auto_execute flag."""
        # When
        manager = TestLifecycleManager(
            project_root=str(temp_project_root),
            auto_execute=True,
        )

        # Then
        assert manager.auto_execute is True

    def test_given_existing_queue_file_when_initialized_then_loads_queue(self, temp_project_root):
        """Given an existing queue file, when initializing, then loads tasks from file."""
        # Given
        queue_file = temp_project_root / ".empathy" / "test_queue.json"
        queue_data = {
            "tasks": [
                {
                    "id": "task-001",
                    "file_path": "src/file.py",
                    "action": "generate",
                    "priority": "high",
                    "created_at": "2025-01-01T12:00:00",
                    "scheduled_for": None,
                    "status": "pending",
                    "result": None,
                }
            ]
        }
        queue_file.write_text(json.dumps(queue_data))

        # When
        manager = TestLifecycleManager(project_root=str(temp_project_root))

        # Then
        assert len(manager._queue) == 1
        assert manager._queue[0].id == "task-001"
        assert manager._queue[0].file_path == "src/file.py"

    def test_given_corrupted_queue_file_when_initialized_then_starts_with_empty_queue(
        self, temp_project_root
    ):
        """Given a corrupted queue file, when initializing, then starts with empty queue."""
        # Given
        queue_file = temp_project_root / ".empathy" / "test_queue.json"
        queue_file.write_text("invalid json{{{")

        # When
        manager = TestLifecycleManager(project_root=str(temp_project_root))

        # Then
        assert manager._queue == []


class TestOnFileCreated:
    """Test on_file_created event handler."""

    @pytest.mark.asyncio
    async def test_given_new_source_file_when_created_then_queues_generate_task(
        self, lifecycle_manager
    ):
        """Given a new source file, when file created event occurs, then queues generate task."""
        # Given
        file_path = "src/new_module.py"

        # When
        task = await lifecycle_manager.on_file_created(file_path)

        # Then
        assert task is not None
        assert task.file_path == file_path
        assert task.action == TestAction.GENERATE
        assert task.priority == TestPriority.HIGH
        assert task.status == "pending"
        assert len(lifecycle_manager._queue) == 1

    @pytest.mark.asyncio
    async def test_given_excluded_file_when_created_then_returns_none(self, lifecycle_manager):
        """Given an excluded file, when file created event occurs, then returns None."""
        # Given
        lifecycle_manager.index.is_excluded.return_value = True
        file_path = "node_modules/package.js"

        # When
        task = await lifecycle_manager.on_file_created(file_path)

        # Then
        assert task is None
        assert len(lifecycle_manager._queue) == 0

    @pytest.mark.asyncio
    async def test_given_test_file_when_created_then_returns_none(self, lifecycle_manager):
        """Given a test file, when file created event occurs, then returns None (no test for tests)."""
        # Given
        file_path = "tests/test_module.py"
        lifecycle_manager.index.get_file_info.return_value = {"type": "test"}

        # When
        task = await lifecycle_manager.on_file_created(file_path)

        # Then
        assert task is None
        assert len(lifecycle_manager._queue) == 0

    @pytest.mark.asyncio
    async def test_given_callback_when_task_queued_then_invokes_callback(self, lifecycle_manager):
        """Given a registered callback, when task is queued, then invokes callback with task."""
        # Given
        callback = Mock()
        lifecycle_manager._on_task_queued.append(callback)
        file_path = "src/module.py"

        # When
        await lifecycle_manager.on_file_created(file_path)

        # Then
        assert callback.call_count == 1
        task = callback.call_args[0][0]
        assert isinstance(task, TestTask)
        assert task.file_path == file_path


class TestOnFileModified:
    """Test on_file_modified event handler."""

    @pytest.mark.asyncio
    async def test_given_modified_source_file_when_modified_then_queues_update_task(
        self, lifecycle_manager
    ):
        """Given a modified source file, when file modified event occurs, then queues update task."""
        # Given
        file_path = "src/existing_module.py"
        lifecycle_manager.index.get_file_info.return_value = {
            "has_tests": True,
            "type": "source",
        }

        # When
        task = await lifecycle_manager.on_file_modified(file_path)

        # Then
        assert task is not None
        assert task.action == TestAction.UPDATE
        assert task.priority == TestPriority.MEDIUM

    @pytest.mark.asyncio
    async def test_given_source_without_tests_when_modified_then_queues_generate_task(
        self, lifecycle_manager
    ):
        """Given a source file without tests, when modified, then queues generate task."""
        # Given
        file_path = "src/no_test_module.py"
        lifecycle_manager.index.get_file_info.return_value = {
            "has_tests": False,
            "type": "source",
        }

        # When
        task = await lifecycle_manager.on_file_modified(file_path)

        # Then
        assert task is not None
        assert task.action == TestAction.GENERATE
        assert task.priority == TestPriority.HIGH

    @pytest.mark.asyncio
    async def test_given_excluded_file_when_modified_then_returns_none(self, lifecycle_manager):
        """Given an excluded file, when modified, then returns None."""
        # Given
        lifecycle_manager.index.is_excluded.return_value = True
        file_path = ".git/config"

        # When
        task = await lifecycle_manager.on_file_modified(file_path)

        # Then
        assert task is None


class TestOnFileDeleted:
    """Test on_file_deleted event handler."""

    @pytest.mark.asyncio
    async def test_given_deleted_source_file_when_deleted_then_queues_cleanup_task(
        self, lifecycle_manager
    ):
        """Given a deleted source file, when file deleted event occurs, then queues cleanup task."""
        # Given
        file_path = "src/removed_module.py"

        # When
        task = await lifecycle_manager.on_file_deleted(file_path)

        # Then
        assert task is not None
        assert task.action == TestAction.CLEANUP
        assert task.priority == TestPriority.LOW

    @pytest.mark.asyncio
    async def test_given_excluded_file_when_deleted_then_returns_none(self, lifecycle_manager):
        """Given an excluded file, when deleted, then returns None."""
        # Given
        lifecycle_manager.index.is_excluded.return_value = True
        file_path = "__pycache__/module.pyc"

        # When
        task = await lifecycle_manager.on_file_deleted(file_path)

        # Then
        assert task is None


class TestQueueManagement:
    """Test queue management methods."""

    def test_given_task_when_queue_task_then_adds_to_queue(self, lifecycle_manager, sample_test_task):
        """Given a task, when queuing, then adds task to queue."""
        # When
        lifecycle_manager._queue_task(sample_test_task)

        # Then
        assert len(lifecycle_manager._queue) == 1
        assert lifecycle_manager._queue[0] == sample_test_task

    def test_given_task_when_queue_task_then_saves_queue(self, lifecycle_manager, sample_test_task):
        """Given a task, when queuing, then persists queue to disk."""
        # When
        lifecycle_manager._queue_task(sample_test_task)

        # Then
        assert lifecycle_manager._queue_file.exists()
        queue_data = json.loads(lifecycle_manager._queue_file.read_text())
        assert len(queue_data["tasks"]) == 1
        assert queue_data["tasks"][0]["id"] == "task-001"

    def test_given_multiple_tasks_when_get_next_task_then_returns_highest_priority(
        self, lifecycle_manager
    ):
        """Given multiple tasks, when getting next task, then returns highest priority task."""
        # Given
        low_task = TestTask(
            id="low", file_path="file1.py", action=TestAction.GENERATE, priority=TestPriority.LOW
        )
        high_task = TestTask(
            id="high", file_path="file2.py", action=TestAction.GENERATE, priority=TestPriority.HIGH
        )
        medium_task = TestTask(
            id="med",
            file_path="file3.py",
            action=TestAction.UPDATE,
            priority=TestPriority.MEDIUM,
        )

        lifecycle_manager._queue = [low_task, high_task, medium_task]

        # When
        next_task = lifecycle_manager.get_next