"""Behavioral tests for timeout.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import logging
import platform
import signal
import time
from typing import Any
from unittest.mock import AsyncMock, Mock, patch

import pytest

from empathy_os.resilience.timeout import TimeoutError, timeout


class TestTimeoutError:
    """Test suite for TimeoutError exception."""

    def test_given_operation_and_timeout_when_created_then_contains_correct_message(
        self,
    ):
        """Given an operation name and timeout value,
        When TimeoutError is created,
        Then it contains the correct error message."""
        # Given
        operation = "test_operation"
        timeout_seconds = 5.0

        # When
        error = TimeoutError(operation, timeout_seconds)

        # Then
        assert error.operation == operation
        assert error.timeout == timeout_seconds
        assert str(error) == f"Operation '{operation}' timed out after {timeout_seconds}s"

    def test_given_special_characters_when_created_then_preserves_operation_name(self):
        """Given an operation name with special characters,
        When TimeoutError is created,
        Then the operation name is preserved correctly."""
        # Given
        operation = "complex.module::function_name"
        timeout_seconds = 10.5

        # When
        error = TimeoutError(operation, timeout_seconds)

        # Then
        assert error.operation == operation
        assert operation in str(error)


class TestTimeoutDecoratorAsync:
    """Test suite for timeout decorator with async functions."""

    @pytest.mark.asyncio
    async def test_given_fast_async_function_when_executed_then_returns_result(self):
        """Given a fast async function,
        When executed with timeout decorator,
        Then it returns the expected result."""
        # Given
        @timeout(seconds=1.0)
        async def fast_function():
            await asyncio.sleep(0.1)
            return "success"

        # When
        result = await fast_function()

        # Then
        assert result == "success"

    @pytest.mark.asyncio
    async def test_given_slow_async_function_when_timeout_exceeded_then_raises_timeout_error(
        self,
    ):
        """Given a slow async function,
        When timeout is exceeded,
        Then TimeoutError is raised."""
        # Given
        @timeout(seconds=0.1)
        async def slow_function():
            await asyncio.sleep(1.0)
            return "should not reach"

        # When/Then
        with pytest.raises(TimeoutError) as exc_info:
            await slow_function()

        assert exc_info.value.timeout == 0.1
        assert "slow_function" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_given_custom_error_message_when_timeout_then_uses_custom_message(
        self,
    ):
        """Given a custom error message,
        When timeout occurs,
        Then the custom message is used."""
        # Given
        custom_msg = "Custom operation failed"

        @timeout(seconds=0.1, error_message=custom_msg)
        async def slow_function():
            await asyncio.sleep(1.0)

        # When/Then
        with pytest.raises(TimeoutError) as exc_info:
            await slow_function()

        assert exc_info.value.operation == custom_msg
        assert custom_msg in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_given_async_fallback_when_timeout_then_calls_fallback(self):
        """Given an async fallback function,
        When timeout occurs,
        Then the fallback is called and returns its value."""
        # Given
        async def async_fallback(*args, **kwargs):
            return "fallback_value"

        @timeout(seconds=0.1, fallback=async_fallback)
        async def slow_function():
            await asyncio.sleep(1.0)
            return "original"

        # When
        result = await slow_function()

        # Then
        assert result == "fallback_value"

    @pytest.mark.asyncio
    async def test_given_sync_fallback_when_timeout_then_calls_fallback(self):
        """Given a sync fallback function,
        When timeout occurs,
        Then the fallback is called and returns its value."""
        # Given
        def sync_fallback(*args, **kwargs):
            return "sync_fallback_value"

        @timeout(seconds=0.1, fallback=sync_fallback)
        async def slow_function():
            await asyncio.sleep(1.0)
            return "original"

        # When
        result = await slow_function()

        # Then
        assert result == "sync_fallback_value"

    @pytest.mark.asyncio
    async def test_given_function_with_args_when_timeout_then_fallback_receives_args(
        self,
    ):
        """Given a function with arguments,
        When timeout occurs,
        Then fallback receives the same arguments."""
        # Given
        received_args = []
        received_kwargs = {}

        def fallback_with_args(*args, **kwargs):
            received_args.extend(args)
            received_kwargs.update(kwargs)
            return "fallback"

        @timeout(seconds=0.1, fallback=fallback_with_args)
        async def slow_function(arg1, arg2, kwarg1=None):
            await asyncio.sleep(1.0)

        # When
        result = await slow_function("val1", "val2", kwarg1="val3")

        # Then
        assert result == "fallback"
        assert received_args == ["val1", "val2"]
        assert received_kwargs == {"kwarg1": "val3"}

    @pytest.mark.asyncio
    async def test_given_async_function_when_timeout_then_logs_warning(self, caplog):
        """Given an async function,
        When timeout occurs,
        Then a warning is logged."""
        # Given
        @timeout(seconds=0.1)
        async def slow_function():
            await asyncio.sleep(1.0)

        # When
        with caplog.at_level(logging.WARNING):
            with pytest.raises(TimeoutError):
                await slow_function()

        # Then
        assert any("Timeout after 0.1s" in record.message for record in caplog.records)

    @pytest.mark.asyncio
    async def test_given_fallback_when_called_then_logs_info(self, caplog):
        """Given a fallback function,
        When it is called due to timeout,
        Then an info log is generated."""
        # Given
        @timeout(seconds=0.1, fallback=lambda: "fallback")
        async def slow_function():
            await asyncio.sleep(1.0)

        # When
        with caplog.at_level(logging.INFO):
            await slow_function()

        # Then
        assert any(
            "Using fallback for slow_function" in record.message
            for record in caplog.records
        )

    @pytest.mark.asyncio
    async def test_given_zero_timeout_when_executed_then_raises_immediately(self):
        """Given a timeout of zero seconds,
        When function is executed,
        Then it raises TimeoutError immediately."""
        # Given
        @timeout(seconds=0.0)
        async def any_function():
            return "result"

        # When/Then
        with pytest.raises(TimeoutError):
            await any_function()

    @pytest.mark.asyncio
    async def test_given_exception_in_function_when_executed_then_propagates_exception(
        self,
    ):
        """Given a function that raises an exception,
        When executed with timeout,
        Then the exception propagates correctly."""
        # Given
        @timeout(seconds=1.0)
        async def failing_function():
            await asyncio.sleep(0.1)
            raise ValueError("Test error")

        # When/Then
        with pytest.raises(ValueError, match="Test error"):
            await failing_function()

    @pytest.mark.asyncio
    async def test_given_async_function_with_return_type_when_executed_then_preserves_type(
        self,
    ):
        """Given an async function with a specific return type,
        When executed with timeout,
        Then the return type is preserved."""
        # Given
        @timeout(seconds=1.0)
        async def typed_function() -> dict[str, int]:
            await asyncio.sleep(0.1)
            return {"count": 42}

        # When
        result = await typed_function()

        # Then
        assert isinstance(result, dict)
        assert result == {"count": 42}

    @pytest.mark.asyncio
    async def test_given_multiple_concurrent_calls_when_one_times_out_then_others_continue(
        self,
    ):
        """Given multiple concurrent calls to the same timeout-decorated function,
        When one times out,
        Then others continue executing."""
        # Given
        call_count = 0

        @timeout(seconds=0.2)
        async def conditional_slow_function(delay: float):
            nonlocal call_count
            call_count += 1
            await asyncio.sleep(delay)
            return f"completed_{delay}"

        # When
        tasks = [
            conditional_slow_function(0.1),
            conditional_slow_function(0.5),
            conditional_slow_function(0.15),
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Then
        assert call_count == 3
        assert results[0] == "completed_0.1"
        assert isinstance(results[1], TimeoutError)
        assert results[2] == "completed_0.15"


class TestTimeoutDecoratorSync:
    """Test suite for timeout decorator with sync functions."""

    @pytest.mark.skipif(
        platform.system() == "Windows",
        reason="Signal-based timeout not supported on Windows",
    )
    def test_given_fast_sync_function_when_executed_then_returns_result(self):
        """Given a fast sync function,
        When executed with timeout decorator,
        Then it returns the expected result."""
        # Given
        @timeout(seconds=1.0)
        def fast_sync_function():
            time.sleep(0.1)
            return "sync_success"

        # When
        result = fast_sync_function()

        # Then
        assert result == "sync_success"

    @pytest.mark.skipif(
        platform.system() == "Windows",
        reason="Signal-based timeout not supported on Windows",
    )
    def test_given_slow_sync_function_when_timeout_exceeded_then_raises_timeout_error(
        self,
    ):
        """Given a slow sync function,
        When timeout is exceeded,
        Then TimeoutError is raised."""
        # Given
        @timeout(seconds=0.1)
        def slow_sync_function():
            time.sleep(1.0)
            return "should not reach"

        # When/Then
        with pytest.raises(TimeoutError) as exc_info:
            slow_sync_function()

        assert exc_info.value.timeout == 0.1

    @pytest.mark.skipif(
        platform.system() == "Windows",
        reason="Signal-based timeout not supported on Windows",
    )
    def test_given_sync_fallback_when_timeout_then_calls_fallback(self):
        """Given a sync fallback function,
        When timeout occurs on sync function,
        Then the fallback is called."""
        # Given
        def sync_fallback(*args, **kwargs):
            return "sync_fallback_result"

        @timeout(seconds=0.1, fallback=sync_fallback)
        def slow_sync_function():
            time.sleep(1.0)
            return "original"

        # When
        result = slow_sync_function()

        # Then
        assert result == "sync_fallback_result"

    @pytest.mark.skipif(
        platform.system() != "Windows",
        reason="Windows-specific test",
    )
    def test_given_windows_platform_when_sync_function_then_logs_warning(self, caplog):
        """Given Windows platform,
        When sync function with timeout is executed,
        Then a warning is logged."""
        # Given
        @timeout(seconds=1.0)
        def sync_function():
            return "result"

        # When
        with caplog.at_level(logging.WARNING):
            result = sync_function()

        # Then
        assert result == "result"
        assert any(
            "Timeout not supported on Windows" in record.message
            for record in caplog.records
        )

    @pytest.mark.skipif(
        platform.system() == "Windows",
        reason="Signal-based timeout not supported on Windows",
    )
    def test_given_sync_function_with_args_when_timeout_then_fallback_receives_args(
        self,
    ):
        """Given a sync function with arguments,
        When timeout occurs,
        Then fallback receives the same arguments."""
        # Given
        received_args = []
        received_kwargs = {}

        def fallback_with_args(*args, **kwargs):
            received_args.extend(args)
            received_kwargs.update(kwargs)
            return "fallback"

        @timeout(seconds=0.1, fallback=fallback_with_args)
        def slow_sync_function(arg1, arg2, kwarg1=None):
            time.sleep(1.0)

        # When
        result = slow_sync_function("val1", "val2", kwarg1="val3")

        # Then
        assert result == "fallback"
        assert received_args == ["val1", "val2"]
        assert received_kwargs == {"kwarg1": "val3"}

    @pytest.mark.skipif(
        platform.system() == "Windows",
        reason="Signal-based timeout not supported on Windows",
    )
    def test_given_sync_function_when_timeout_then_restores_signal_handler(self):
        """Given a sync function with timeout,
        When timeout occurs,
        Then the original signal handler is restored."""
        # Given
        original_handler = signal.signal(signal.SIGALRM, signal.SIG_DFL)
        signal.signal(signal.SIGALRM, original_handler)

        @timeout(seconds=0.1)
        def slow_sync_function():
            time.sleep(1.0)

        # When
        try:
            slow_sync_function()
        except TimeoutError:
            pass

        # Then
        current_handler = signal.signal(signal.SIGALRM, signal.SIG_DFL)
        signal.signal(signal.SIGALRM, current_handler)
        # Handler should be restored (can't easily assert equality)

    @pytest.mark.skipif(
        platform.system() == "Windows",
        reason="Signal-based timeout not supported on Windows",
    )
    def test_given_sync_function_completes_when_executed_then_cancels_alarm(self):
        """Given a sync function that completes,
        When executed with timeout,
        Then the alarm is cancelled."""
        # Given
        @timeout(seconds=1.0)
        def fast_sync_function():
            time.sleep(0.1)
            return "result"

        # When
        result = fast_sync_function()

        # Then
        assert result == "result"
        # Alarm should be cancelled (no way to directly verify)

    @pytest.mark.skipif(
        platform.system() != "Windows",
        reason="Windows-specific test",
    )
    def test_given_windows_when_sync_function_with_exception_then_propagates(self):
        """Given Windows platform,
        When sync function raises exception,
        Then exception propagates even without timeout support."""