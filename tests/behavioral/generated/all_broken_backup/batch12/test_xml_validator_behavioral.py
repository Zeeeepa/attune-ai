"""Behavioral tests for xml_validator.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from pathlib import Path
from unittest.mock import Mock, patch, mock_open
from xml.etree import ElementTree as ET

from empathy_os.validation.xml_validator import (
    ValidationResult,
    XMLValidator,
)


# Fixtures


@pytest.fixture
def schema_dir(tmp_path):
    """Given a temporary schema directory."""
    schema_path = tmp_path / ".empathy" / "schemas"
    schema_path.mkdir(parents=True, exist_ok=True)
    return str(schema_path)


@pytest.fixture
def validator(schema_dir):
    """Given a basic XMLValidator instance."""
    return XMLValidator(schema_dir=schema_dir, strict=False, enable_xsd=False)


@pytest.fixture
def strict_validator(schema_dir):
    """Given a strict XMLValidator instance."""
    return XMLValidator(schema_dir=schema_dir, strict=True, enable_xsd=False)


@pytest.fixture
def xsd_validator(schema_dir):
    """Given an XSD-enabled XMLValidator instance."""
    return XMLValidator(schema_dir=schema_dir, strict=False, enable_xsd=True)


@pytest.fixture
def valid_xml():
    """Given valid XML content."""
    return "<thinking><step>Process data</step><conclusion>Done</conclusion></thinking>"


@pytest.fixture
def invalid_xml():
    """Given invalid XML content."""
    return "<thinking><step>Unclosed tag</thinking>"


@pytest.fixture
def empty_xml():
    """Given empty XML content."""
    return ""


@pytest.fixture
def complex_xml():
    """Given complex nested XML."""
    return """
    <response>
        <thinking>
            <step number="1">First step</step>
            <step number="2">Second step</step>
        </thinking>
        <answer>Final answer</answer>
        <metadata>
            <confidence>0.95</confidence>
            <sources>
                <source>doc1.txt</source>
                <source>doc2.txt</source>
            </sources>
        </metadata>
    </response>
    """


# ValidationResult Tests


class TestValidationResult:
    """Behavioral tests for ValidationResult dataclass."""

    def test_valid_result_creation(self):
        """
        Given valid parameters
        When creating a ValidationResult
        Then it should initialize correctly with all fields.
        """
        # Given
        parsed_data = {"key": "value"}

        # When
        result = ValidationResult(
            is_valid=True,
            error_message=None,
            parsed_data=parsed_data,
            fallback_used=False,
        )

        # Then
        assert result.is_valid is True
        assert result.error_message is None
        assert result.parsed_data == parsed_data
        assert result.fallback_used is False

    def test_invalid_result_creation(self):
        """
        Given error parameters
        When creating a ValidationResult for invalid XML
        Then it should store the error message.
        """
        # Given
        error_msg = "XML parsing failed"

        # When
        result = ValidationResult(
            is_valid=False,
            error_message=error_msg,
            parsed_data=None,
            fallback_used=True,
        )

        # Then
        assert result.is_valid is False
        assert result.error_message == error_msg
        assert result.parsed_data is None
        assert result.fallback_used is True

    def test_minimal_result_creation(self):
        """
        Given minimal parameters
        When creating a ValidationResult with only is_valid
        Then it should use default values for optional fields.
        """
        # When
        result = ValidationResult(is_valid=True)

        # Then
        assert result.is_valid is True
        assert result.error_message is None
        assert result.parsed_data is None
        assert result.fallback_used is False


# XMLValidator Initialization Tests


class TestXMLValidatorInitialization:
    """Behavioral tests for XMLValidator initialization."""

    def test_default_initialization(self):
        """
        Given no parameters
        When creating an XMLValidator
        Then it should use default settings.
        """
        # When
        validator = XMLValidator()

        # Then
        assert validator.schema_dir == Path(".empathy/schemas")
        assert validator.strict is False
        assert validator.enable_xsd is False
        assert validator._schema_cache == {}
        assert validator._lxml_available is False

    def test_custom_schema_dir(self, schema_dir):
        """
        Given a custom schema directory
        When initializing the validator
        Then it should use the provided directory.
        """
        # When
        validator = XMLValidator(schema_dir=schema_dir)

        # Then
        assert validator.schema_dir == Path(schema_dir)

    def test_strict_mode_initialization(self, schema_dir):
        """
        Given strict mode enabled
        When initializing the validator
        Then it should set strict flag to True.
        """
        # When
        validator = XMLValidator(schema_dir=schema_dir, strict=True)

        # Then
        assert validator.strict is True

    def test_xsd_initialization_without_lxml(self, schema_dir):
        """
        Given XSD validation enabled but lxml not available
        When initializing the validator
        Then it should mark lxml as unavailable.
        """
        # Given
        with patch.dict("sys.modules", {"lxml": None}):
            # When
            validator = XMLValidator(schema_dir=schema_dir, enable_xsd=True)

            # Then
            assert validator.enable_xsd is True
            assert validator._lxml_available is False

    def test_xsd_initialization_with_lxml(self, schema_dir):
        """
        Given XSD validation enabled and lxml available
        When initializing the validator
        Then it should mark lxml as available.
        """
        # Given
        mock_lxml = Mock()
        with patch.dict("sys.modules", {"lxml": mock_lxml, "lxml.etree": Mock()}):
            # When
            validator = XMLValidator(schema_dir=schema_dir, enable_xsd=True)

            # Then
            assert validator.enable_xsd is True
            # Note: _lxml_available might still be False due to import mechanics


# XML Validation Tests


class TestXMLValidation:
    """Behavioral tests for XML validation."""

    def test_valid_xml_parsing(self, validator, valid_xml):
        """
        Given valid XML content
        When validating the XML
        Then it should return a valid result with parsed data.
        """
        # When
        result = validator.validate(valid_xml)

        # Then
        assert result.is_valid is True
        assert result.error_message is None
        assert result.parsed_data is not None
        assert result.fallback_used is False

    def test_invalid_xml_non_strict(self, validator, invalid_xml):
        """
        Given invalid XML content in non-strict mode
        When validating the XML
        Then it should use fallback parsing.
        """
        # Given
        with patch.object(validator, "_fallback_parse") as mock_fallback:
            mock_fallback.return_value = ValidationResult(
                is_valid=True,
                parsed_data={"fallback": "data"},
                fallback_used=True,
            )

            # When
            result = validator.validate(invalid_xml)

            # Then
            mock_fallback.assert_called_once()
            assert result.fallback_used is True

    def test_invalid_xml_strict_mode(self, strict_validator, invalid_xml):
        """
        Given invalid XML content in strict mode
        When validating the XML
        Then it should return an error without fallback.
        """
        # When
        result = strict_validator.validate(invalid_xml)

        # Then
        assert result.is_valid is False
        assert result.error_message is not None
        assert "XML parsing failed" in result.error_message
        assert result.fallback_used is False

    def test_empty_xml(self, validator, empty_xml):
        """
        Given empty XML content
        When validating the XML
        Then it should handle the empty string gracefully.
        """
        # When
        result = validator.validate(empty_xml)

        # Then
        assert result.is_valid is False or result.fallback_used is True

    def test_complex_xml_validation(self, validator, complex_xml):
        """
        Given complex nested XML
        When validating the XML
        Then it should parse successfully.
        """
        # When
        result = validator.validate(complex_xml)

        # Then
        assert result.is_valid is True
        assert result.parsed_data is not None

    def test_xml_with_attributes(self, validator):
        """
        Given XML with attributes
        When validating the XML
        Then it should parse attributes correctly.
        """
        # Given
        xml_with_attrs = '<root type="test" id="123"><child>content</child></root>'

        # When
        result = validator.validate(xml_with_attrs)

        # Then
        assert result.is_valid is True
        assert result.parsed_data is not None

    def test_xml_with_namespaces(self, validator):
        """
        Given XML with namespaces
        When validating the XML
        Then it should handle namespaces.
        """
        # Given
        xml_with_ns = '<root xmlns="http://example.com"><child>test</child></root>'

        # When
        result = validator.validate(xml_with_ns)

        # Then
        assert result.is_valid is True

    def test_xml_with_cdata(self, validator):
        """
        Given XML with CDATA sections
        When validating the XML
        Then it should parse CDATA correctly.
        """
        # Given
        xml_with_cdata = "<root><![CDATA[Some <special> content]]></root>"

        # When
        result = validator.validate(xml_with_cdata)

        # Then
        assert result.is_valid is True

    def test_malformed_xml_characters(self, validator):
        """
        Given XML with malformed characters
        When validating the XML
        Then it should handle the error appropriately.
        """
        # Given
        malformed_xml = "<root>Invalid & character</root>"

        # When
        result = validator.validate(malformed_xml)

        # Then
        # Should either fail or use fallback depending on strict mode
        assert result.is_valid is False or result.fallback_used is True

    def test_xml_with_special_entities(self, validator):
        """
        Given XML with special entities
        When validating the XML
        Then it should decode entities correctly.
        """
        # Given
        xml_with_entities = "<root>Text with &lt; and &gt; and &amp;</root>"

        # When
        result = validator.validate(xml_with_entities)

        # Then
        assert result.is_valid is True


# Schema Validation Tests


class TestSchemaValidation:
    """Behavioral tests for XSD schema validation."""

    def test_validate_with_schema_name(self, validator, valid_xml):
        """
        Given a schema name
        When validating XML with schema
        Then it should attempt schema validation.
        """
        # When
        result = validator.validate(valid_xml, schema_name="agent_response")

        # Then
        # Should still parse even without actual XSD validation
        assert result.is_valid is True or result.fallback_used is True

    def test_xsd_validation_without_lxml(self, validator, valid_xml):
        """
        Given XSD validation requested but lxml unavailable
        When validating with schema
        Then it should skip XSD validation and parse normally.
        """
        # Given
        validator.enable_xsd = True
        validator._lxml_available = False

        # When
        result = validator.validate(valid_xml, schema_name="test_schema")

        # Then
        assert result.is_valid is True

    def test_schema_caching(self, xsd_validator):
        """
        Given a schema that has been loaded
        When validating multiple times with the same schema
        Then it should use cached schema.
        """
        # Given
        xsd_validator._schema_cache["test_schema"] = Mock()

        # When
        result1 = xsd_validator.validate("<root/>", schema_name="test_schema")
        result2 = xsd_validator.validate("<root/>", schema_name="test_schema")

        # Then
        assert "test_schema" in xsd_validator._schema_cache


# Fallback Parsing Tests


class TestFallbackParsing:
    """Behavioral tests for fallback parsing mechanism."""

    def test_fallback_parse_called_on_error(self, validator):
        """
        Given invalid XML in non-strict mode
        When validation fails
        Then it should call fallback parsing.
        """
        # Given
        bad_xml = "<unclosed>"

        with patch.object(validator, "_fallback_parse") as mock_fallback:
            mock_fallback.return_value = ValidationResult(
                is_valid=True,
                parsed_data={},
                fallback_used=True,
            )

            # When
            result = validator.validate(bad_xml)

            # Then
            mock_fallback.assert_called_once()
            assert result.fallback_used is True

    def test_fallback_parse_not_called_in_strict(self, strict_validator):
        """
        Given invalid XML in strict mode
        When validation fails
        Then it should not call fallback parsing.
        """
        # Given
        bad_xml = "<unclosed>"

        with patch.object(strict_validator, "_fallback_parse") as mock_fallback:
            # When
            result = strict_validator.validate(bad_xml)

            # Then
            mock_fallback.assert_not_called()
            assert result.is_valid is False


# Edge Cases and Error Handling Tests


class TestEdgeCases:
    """Behavioral tests for edge cases and error handling."""

    def test_none_input(self, validator):
        """
        Given None as input
        When validating
        Then it should handle the error gracefully.
        """
        # When/Then
        with pytest.raises((TypeError, AttributeError)):
            validator.validate(None)

    def test_non_string_input(self, validator):
        """
        Given non-string input
        When validating
        Then it should handle the type error.
        """
        # When/Then
        with pytest.raises((TypeError, AttributeError)):
            validator.validate(12345)

    def test_very_large_xml(self, validator):
        """
        Given very large XML content
        When validating
        Then it should handle it without issues.
        """
        # Given
        large_xml = "<root>" + "<item>data</item>" * 10000 + "</root>"

        # When
        result = validator.validate(large_xml)

        # Then
        assert result.is_valid is True or result.fallback_used is True

    def test_xml_with_unicode(self, validator):
        """
        Given XML with Unicode characters
        When validating
        Then it should handle Unicode correctly.
        """
        # Given
        unicode_xml = "<root>Unicode: ‰Ω†Â•Ω –º–∏—Ä üåç</root>"

        # When
        result = validator.validate(unicode_xml)

        # Then
        assert result.is_valid is True

    def test_xml_with_whitespace(self, validator):
        """
        Given XML with significant whitespace
        When validating
        Then it should preserve or handle whitespace appropriately.
        """
        # Given
        whitespace_xml = """
        <root>
            <child>
                content with spaces
            </child>
        </root>
        """

        # When
        result = validator.validate(whitespace_xml