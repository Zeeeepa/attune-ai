"""Behavioral tests for storage.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import time
from pathlib import Path
from unittest.mock import MagicMock, mock_open, patch

import pytest

from empathy_os.cache.base import CacheEntry
from empathy_os.cache.storage import CacheStorage


@pytest.fixture
def temp_cache_dir(tmp_path):
    """Provide a temporary cache directory for testing.
    
    Given a test needs isolated storage
    When creating a cache directory
    Then return a temporary path that will be cleaned up
    """
    cache_dir = tmp_path / "cache"
    cache_dir.mkdir(parents=True, exist_ok=True)
    return cache_dir


@pytest.fixture
def sample_cache_entry():
    """Provide a sample cache entry for testing.
    
    Given a test needs a cache entry
    When creating test data
    Then return a valid CacheEntry instance
    """
    return CacheEntry(
        key="test_key",
        response="test_response",
        workflow="test_workflow",
        stage="test_stage",
        model="test_model",
        prompt_hash="abc123",
        timestamp=time.time(),
        ttl=3600,
    )


@pytest.fixture
def expired_cache_entry():
    """Provide an expired cache entry for testing.
    
    Given a test needs an expired entry
    When creating test data
    Then return a CacheEntry that is already expired
    """
    return CacheEntry(
        key="expired_key",
        response="expired_response",
        workflow="test_workflow",
        stage="test_stage",
        model="test_model",
        prompt_hash="def456",
        timestamp=time.time() - 7200,  # 2 hours ago
        ttl=3600,  # 1 hour TTL
    )


class TestCacheStorageInitialization:
    """Test cache storage initialization behavior."""

    def test_init_with_default_cache_dir(self):
        """Test initialization with default cache directory.
        
        Given no cache directory is specified
        When creating a CacheStorage instance
        Then it should use the default ~/.empathy/cache/ directory
        """
        with patch.object(Path, "mkdir"):
            with patch.object(CacheStorage, "load", return_value=0):
                storage = CacheStorage()
                
                assert storage.cache_dir == Path.home() / ".empathy" / "cache"
                assert storage.cache_file == storage.cache_dir / "responses.json"
                assert storage.max_disk_mb == 500
                assert storage.auto_save is True

    def test_init_with_custom_cache_dir(self, temp_cache_dir):
        """Test initialization with custom cache directory.
        
        Given a custom cache directory path
        When creating a CacheStorage instance
        Then it should use the specified directory
        """
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert storage.cache_dir == temp_cache_dir
        assert storage.cache_file == temp_cache_dir / "responses.json"

    def test_init_with_custom_max_disk_mb(self, temp_cache_dir):
        """Test initialization with custom disk size limit.
        
        Given a custom max_disk_mb value
        When creating a CacheStorage instance
        Then it should use the specified limit
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, max_disk_mb=1000)
        
        assert storage.max_disk_mb == 1000

    def test_init_with_auto_save_disabled(self, temp_cache_dir):
        """Test initialization with auto_save disabled.
        
        Given auto_save is set to False
        When creating a CacheStorage instance
        Then it should not automatically save on put
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, auto_save=False)
        
        assert storage.auto_save is False

    def test_init_creates_cache_directory(self, tmp_path):
        """Test that initialization creates cache directory.
        
        Given a non-existent cache directory
        When creating a CacheStorage instance
        Then it should create the directory structure
        """
        cache_dir = tmp_path / "new_cache_dir"
        assert not cache_dir.exists()
        
        storage = CacheStorage(cache_dir=cache_dir)
        
        assert cache_dir.exists()
        assert cache_dir.is_dir()

    def test_init_loads_existing_cache(self, temp_cache_dir):
        """Test that initialization loads existing cache data.
        
        Given an existing cache file with entries
        When creating a CacheStorage instance
        Then it should load the entries into memory
        """
        # Create a cache file with test data
        cache_file = temp_cache_dir / "responses.json"
        cache_data = {
            "version": "1.0",
            "entries": [
                {
                    "key": "test_key",
                    "response": "test_response",
                    "workflow": "test_workflow",
                    "stage": "test_stage",
                    "model": "test_model",
                    "prompt_hash": "abc123",
                    "timestamp": time.time(),
                    "ttl": 3600,
                }
            ],
        }
        with open(cache_file, "w") as f:
            json.dump(cache_data, f)
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert len(storage._entries) == 1
        assert "test_key" in storage._entries


class TestCacheStorageLoad:
    """Test cache loading behavior."""

    def test_load_nonexistent_file(self, temp_cache_dir):
        """Test loading when cache file doesn't exist.
        
        Given no cache file exists
        When calling load
        Then it should return 0 and initialize empty cache
        """
        storage = CacheStorage(cache_dir=temp_cache_dir)
        storage._entries = {"existing": MagicMock()}
        
        count = storage.load()
        
        assert count == 0
        assert len(storage._entries) == 0

    def test_load_valid_cache_file(self, temp_cache_dir):
        """Test loading a valid cache file.
        
        Given a valid cache file with entries
        When calling load
        Then it should load all non-expired entries
        """
        cache_file = temp_cache_dir / "responses.json"
        current_time = time.time()
        cache_data = {
            "version": "1.0",
            "entries": [
                {
                    "key": "key1",
                    "response": "response1",
                    "workflow": "workflow1",
                    "stage": "stage1",
                    "model": "model1",
                    "prompt_hash": "hash1",
                    "timestamp": current_time,
                    "ttl": 3600,
                },
                {
                    "key": "key2",
                    "response": "response2",
                    "workflow": "workflow2",
                    "stage": "stage2",
                    "model": "model2",
                    "prompt_hash": "hash2",
                    "timestamp": current_time,
                    "ttl": 3600,
                },
            ],
        }
        with open(cache_file, "w") as f:
            json.dump(cache_data, f)
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert len(storage._entries) == 2
        assert "key1" in storage._entries
        assert "key2" in storage._entries

    def test_load_skips_expired_entries(self, temp_cache_dir):
        """Test that load skips expired entries.
        
        Given a cache file with expired entries
        When calling load
        Then it should skip expired entries
        """
        cache_file = temp_cache_dir / "responses.json"
        current_time = time.time()
        cache_data = {
            "version": "1.0",
            "entries": [
                {
                    "key": "valid_key",
                    "response": "valid_response",
                    "workflow": "workflow1",
                    "stage": "stage1",
                    "model": "model1",
                    "prompt_hash": "hash1",
                    "timestamp": current_time,
                    "ttl": 3600,
                },
                {
                    "key": "expired_key",
                    "response": "expired_response",
                    "workflow": "workflow2",
                    "stage": "stage2",
                    "model": "model2",
                    "prompt_hash": "hash2",
                    "timestamp": current_time - 7200,  # 2 hours ago
                    "ttl": 3600,  # 1 hour TTL
                },
            ],
        }
        with open(cache_file, "w") as f:
            json.dump(cache_data, f)
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert len(storage._entries) == 1
        assert "valid_key" in storage._entries
        assert "expired_key" not in storage._entries

    def test_load_handles_missing_ttl(self, temp_cache_dir):
        """Test loading entries without TTL field.
        
        Given a cache file with entries missing TTL
        When calling load
        Then it should load entries with None TTL
        """
        cache_file = temp_cache_dir / "responses.json"
        cache_data = {
            "version": "1.0",
            "entries": [
                {
                    "key": "no_ttl_key",
                    "response": "response",
                    "workflow": "workflow",
                    "stage": "stage",
                    "model": "model",
                    "prompt_hash": "hash",
                    "timestamp": time.time(),
                }
            ],
        }
        with open(cache_file, "w") as f:
            json.dump(cache_data, f)
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert len(storage._entries) == 1
        assert storage._entries["no_ttl_key"].ttl is None

    def test_load_handles_corrupt_json(self, temp_cache_dir):
        """Test loading a corrupt JSON file.
        
        Given a cache file with invalid JSON
        When calling load
        Then it should handle the error gracefully
        """
        cache_file = temp_cache_dir / "responses.json"
        with open(cache_file, "w") as f:
            f.write("invalid json {{{")
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        # Should not crash and should have empty cache
        assert len(storage._entries) == 0

    def test_load_handles_missing_version(self, temp_cache_dir):
        """Test loading cache file without version field.
        
        Given a cache file missing version field
        When calling load
        Then it should default to 'unknown' and still load entries
        """
        cache_file = temp_cache_dir / "responses.json"
        cache_data = {
            "entries": [
                {
                    "key": "test_key",
                    "response": "test_response",
                    "workflow": "workflow",
                    "stage": "stage",
                    "model": "model",
                    "prompt_hash": "hash",
                    "timestamp": time.time(),
                    "ttl": 3600,
                }
            ]
        }
        with open(cache_file, "w") as f:
            json.dump(cache_data, f)
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert len(storage._entries) == 1

    def test_load_handles_empty_entries(self, temp_cache_dir):
        """Test loading cache file with empty entries list.
        
        Given a cache file with empty entries
        When calling load
        Then it should load successfully with no entries
        """
        cache_file = temp_cache_dir / "responses.json"
        cache_data = {"version": "1.0", "entries": []}
        with open(cache_file, "w") as f:
            json.dump(cache_data, f)
        
        storage = CacheStorage(cache_dir=temp_cache_dir)
        
        assert len(storage._entries) == 0


class TestCacheStoragePut:
    """Test cache entry storage behavior."""

    def test_put_new_entry(self, temp_cache_dir, sample_cache_entry):
        """Test putting a new cache entry.
        
        Given a new cache entry
        When calling put
        Then it should add the entry to the cache
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, auto_save=False)
        
        storage.put(sample_cache_entry)
        
        assert sample_cache_entry.key in storage._entries
        assert storage._entries[sample_cache_entry.key] == sample_cache_entry

    def test_put_overwrites_existing_entry(self, temp_cache_dir, sample_cache_entry):
        """Test putting an entry with existing key.
        
        Given an existing cache entry
        When putting a new entry with the same key
        Then it should overwrite the existing entry
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, auto_save=False)
        old_entry = CacheEntry(
            key=sample_cache_entry.key,
            response="old_response",
            workflow="old_workflow",
            stage="old_stage",
            model="old_model",
            prompt_hash="old_hash",
            timestamp=time.time() - 3600,
            ttl=3600,
        )
        storage._entries[old_entry.key] = old_entry
        
        storage.put(sample_cache_entry)
        
        assert storage._entries[sample_cache_entry.key] == sample_cache_entry
        assert storage._entries[sample_cache_entry.key].response == "test_response"

    def test_put_with_auto_save_enabled(self, temp_cache_dir, sample_cache_entry):
        """Test that put saves to disk when auto_save is enabled.
        
        Given auto_save is enabled
        When putting an entry
        Then it should automatically save to disk
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, auto_save=True)
        
        with patch.object(storage, "save") as mock_save:
            storage.put(sample_cache_entry)
            mock_save.assert_called_once()

    def test_put_with_auto_save_disabled(self, temp_cache_dir, sample_cache_entry):
        """Test that put doesn't save to disk when auto_save is disabled.
        
        Given auto_save is disabled
        When putting an entry
        Then it should not save to disk
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, auto_save=False)
        
        with patch.object(storage, "save") as mock_save:
            storage.put(sample_cache_entry)
            mock_save.assert_not_called()

    def test_put_multiple_entries(self, temp_cache_dir):
        """Test putting multiple different entries.
        
        Given multiple different cache entries
        When putting all entries
        Then all should be stored in the cache
        """
        storage = CacheStorage(cache_dir=temp_cache_dir, auto_save=False)
        entries = [
            CacheEntry(
                key=f"key_{i}",
                response=f"response_{i}",
                workflow="workflow",
                stage="stage",
                model="model