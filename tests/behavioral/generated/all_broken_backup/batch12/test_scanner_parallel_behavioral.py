"""Behavioral tests for scanner_parallel.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import multiprocessing as mp
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch, call

import pytest

from empathy_os.project_index.scanner_parallel import (
    ParallelProjectScanner,
    _analyze_file_worker,
)
from empathy_os.project_index.models import FileRecord, IndexConfig, ProjectSummary


class TestAnalyzeFileWorker:
    """Behavioral tests for _analyze_file_worker function."""

    def test_analyze_file_worker_returns_file_record(self, tmp_path):
        """
        GIVEN a valid Python file path and configuration
        WHEN _analyze_file_worker is called
        THEN it should return a FileRecord object
        """
        # Given
        test_file = tmp_path / "test_module.py"
        test_file.write_text("def hello():\n    pass\n")
        
        config_dict = IndexConfig().model_dump()
        test_file_map = {}
        
        # When
        result = _analyze_file_worker(
            file_path_str=str(test_file),
            project_root_str=str(tmp_path),
            config_dict=config_dict,
            test_file_map=test_file_map,
        )
        
        # Then
        assert result is not None
        assert isinstance(result, FileRecord)
        assert result.path == "test_module.py"

    def test_analyze_file_worker_with_test_file_map(self, tmp_path):
        """
        GIVEN a file path with associated test file mapping
        WHEN _analyze_file_worker is called
        THEN it should use the test_file_map correctly
        """
        # Given
        source_file = tmp_path / "source.py"
        source_file.write_text("def func():\n    pass\n")
        
        config_dict = IndexConfig().model_dump()
        test_file_map = {str(source_file): "test_source.py"}
        
        # When
        result = _analyze_file_worker(
            file_path_str=str(source_file),
            project_root_str=str(tmp_path),
            config_dict=config_dict,
            test_file_map=test_file_map,
        )
        
        # Then
        assert result is not None
        assert isinstance(result, FileRecord)

    def test_analyze_file_worker_with_custom_config(self, tmp_path):
        """
        GIVEN a custom IndexConfig with specific settings
        WHEN _analyze_file_worker is called
        THEN it should respect the custom configuration
        """
        # Given
        test_file = tmp_path / "module.py"
        test_file.write_text("class MyClass:\n    pass\n")
        
        custom_config = IndexConfig(
            include_patterns=["*.py"],
            exclude_patterns=["test_*"],
        )
        config_dict = custom_config.model_dump()
        test_file_map = {}
        
        # When
        result = _analyze_file_worker(
            file_path_str=str(test_file),
            project_root_str=str(tmp_path),
            config_dict=config_dict,
            test_file_map=test_file_map,
        )
        
        # Then
        assert result is not None
        assert isinstance(result, FileRecord)

    def test_analyze_file_worker_with_nonexistent_file(self, tmp_path):
        """
        GIVEN a path to a nonexistent file
        WHEN _analyze_file_worker is called
        THEN it should handle the error gracefully
        """
        # Given
        nonexistent_file = tmp_path / "does_not_exist.py"
        config_dict = IndexConfig().model_dump()
        test_file_map = {}
        
        # When
        result = _analyze_file_worker(
            file_path_str=str(nonexistent_file),
            project_root_str=str(tmp_path),
            config_dict=config_dict,
            test_file_map=test_file_map,
        )
        
        # Then
        assert result is None

    def test_analyze_file_worker_recreates_scanner_instance(self, tmp_path):
        """
        GIVEN a file to analyze
        WHEN _analyze_file_worker is called
        THEN it should create its own ProjectScanner instance
        """
        # Given
        test_file = tmp_path / "test.py"
        test_file.write_text("x = 1\n")
        
        config_dict = IndexConfig().model_dump()
        test_file_map = {"key": "value"}
        
        # When
        with patch('empathy_os.project_index.scanner_parallel.ProjectScanner') as mock_scanner_class:
            mock_scanner = MagicMock()
            mock_scanner._analyze_file.return_value = FileRecord(
                path="test.py",
                size=10,
                language="python",
                symbols=[],
            )
            mock_scanner_class.return_value = mock_scanner
            
            result = _analyze_file_worker(
                file_path_str=str(test_file),
                project_root_str=str(tmp_path),
                config_dict=config_dict,
                test_file_map=test_file_map,
            )
            
            # Then
            mock_scanner_class.assert_called_once()
            assert mock_scanner._test_file_map == test_file_map


class TestParallelProjectScannerInit:
    """Behavioral tests for ParallelProjectScanner initialization."""

    def test_init_with_defaults(self, tmp_path):
        """
        GIVEN no specific workers count or config
        WHEN ParallelProjectScanner is initialized
        THEN it should use default values
        """
        # Given / When
        scanner = ParallelProjectScanner(project_root=str(tmp_path))
        
        # Then
        assert scanner.project_root == tmp_path
        assert scanner.workers == mp.cpu_count()
        assert isinstance(scanner.config, IndexConfig)

    def test_init_with_custom_workers(self, tmp_path):
        """
        GIVEN a custom worker count
        WHEN ParallelProjectScanner is initialized
        THEN it should use the specified worker count
        """
        # Given
        custom_workers = 2
        
        # When
        scanner = ParallelProjectScanner(
            project_root=str(tmp_path),
            workers=custom_workers,
        )
        
        # Then
        assert scanner.workers == custom_workers

    def test_init_with_custom_config(self, tmp_path):
        """
        GIVEN a custom IndexConfig
        WHEN ParallelProjectScanner is initialized
        THEN it should use the provided configuration
        """
        # Given
        custom_config = IndexConfig(
            include_patterns=["*.py", "*.txt"],
            exclude_patterns=["*.pyc"],
        )
        
        # When
        scanner = ParallelProjectScanner(
            project_root=str(tmp_path),
            config=custom_config,
        )
        
        # Then
        assert scanner.config == custom_config

    def test_init_inherits_from_project_scanner(self, tmp_path):
        """
        GIVEN ParallelProjectScanner class
        WHEN an instance is created
        THEN it should inherit from ProjectScanner
        """
        # Given / When
        scanner = ParallelProjectScanner(project_root=str(tmp_path))
        
        # Then
        from empathy_os.project_index.scanner import ProjectScanner
        assert isinstance(scanner, ProjectScanner)

    def test_init_with_string_path(self):
        """
        GIVEN a string path to project root
        WHEN ParallelProjectScanner is initialized
        THEN it should convert to Path internally
        """
        # Given
        root_path = "."
        
        # When
        scanner = ParallelProjectScanner(project_root=root_path)
        
        # Then
        assert isinstance(scanner.project_root, Path)

    def test_init_with_zero_workers(self, tmp_path):
        """
        GIVEN workers count of 0
        WHEN ParallelProjectScanner is initialized
        THEN it should accept the value (edge case)
        """
        # Given / When
        scanner = ParallelProjectScanner(
            project_root=str(tmp_path),
            workers=0,
        )
        
        # Then
        assert scanner.workers == 0

    def test_init_with_negative_workers(self, tmp_path):
        """
        GIVEN negative workers count
        WHEN ParallelProjectScanner is initialized
        THEN it should accept the value (no validation in __init__)
        """
        # Given / When
        scanner = ParallelProjectScanner(
            project_root=str(tmp_path),
            workers=-1,
        )
        
        # Then
        assert scanner.workers == -1


class TestParallelProjectScannerScan:
    """Behavioral tests for ParallelProjectScanner.scan method."""

    @patch('empathy_os.project_index.scanner_parallel.mp.Pool')
    def test_scan_uses_multiprocessing_pool(self, mock_pool_class, tmp_path):
        """
        GIVEN a ParallelProjectScanner instance
        WHEN scan is called
        THEN it should create a multiprocessing Pool with correct worker count
        """
        # Given
        scanner = ParallelProjectScanner(project_root=str(tmp_path), workers=4)
        mock_pool = MagicMock()
        mock_pool.__enter__ = MagicMock(return_value=mock_pool)
        mock_pool.__exit__ = MagicMock(return_value=None)
        mock_pool.map.return_value = []
        mock_pool_class.return_value = mock_pool
        
        with patch.object(scanner, '_collect_files', return_value=[]):
            with patch.object(scanner, '_build_test_file_map', return_value={}):
                with patch.object(scanner, '_create_summary', return_value=ProjectSummary(
                    total_files=0,
                    total_size=0,
                    languages={},
                    total_symbols=0,
                )):
                    # When
                    scanner.scan()
        
        # Then
        mock_pool_class.assert_called_once_with(processes=4)

    @patch('empathy_os.project_index.scanner_parallel.mp.Pool')
    def test_scan_returns_records_and_summary(self, mock_pool_class, tmp_path):
        """
        GIVEN files to scan
        WHEN scan is called
        THEN it should return FileRecords and ProjectSummary
        """
        # Given
        test_file = tmp_path / "test.py"
        test_file.write_text("x = 1\n")
        
        scanner = ParallelProjectScanner(project_root=str(tmp_path), workers=2)
        
        mock_record = FileRecord(
            path="test.py",
            size=10,
            language="python",
            symbols=[],
        )
        
        mock_pool = MagicMock()
        mock_pool.__enter__ = MagicMock(return_value=mock_pool)
        mock_pool.__exit__ = MagicMock(return_value=None)
        mock_pool.map.return_value = [mock_record]
        mock_pool_class.return_value = mock_pool
        
        with patch.object(scanner, '_collect_files', return_value=[test_file]):
            with patch.object(scanner, '_build_test_file_map', return_value={}):
                # When
                records, summary = scanner.scan()
        
        # Then
        assert len(records) == 1
        assert records[0] == mock_record
        assert isinstance(summary, ProjectSummary)

    @patch('empathy_os.project_index.scanner_parallel.mp.Pool')
    def test_scan_filters_none_results(self, mock_pool_class, tmp_path):
        """
        GIVEN worker results containing None values
        WHEN scan processes results
        THEN it should filter out None values
        """
        # Given
        scanner = ParallelProjectScanner(project_root=str(tmp_path), workers=2)
        
        mock_record = FileRecord(
            path="valid.py",
            size=10,
            language="python",
            symbols=[],
        )
        
        mock_pool = MagicMock()
        mock_pool.__enter__ = MagicMock(return_value=mock_pool)
        mock_pool.__exit__ = MagicMock(return_value=None)
        mock_pool.map.return_value = [mock_record, None, None]
        mock_pool_class.return_value = mock_pool
        
        with patch.object(scanner, '_collect_files', return_value=[Path("f1"), Path("f2"), Path("f3")]):
            with patch.object(scanner, '_build_test_file_map', return_value={}):
                # When
                records, summary = scanner.scan()
        
        # Then
        assert len(records) == 1
        assert records[0] == mock_record

    @patch('empathy_os.project_index.scanner_parallel.mp.Pool')
    def test_scan_with_empty_file_list(self, mock_pool_class, tmp_path):
        """
        GIVEN no files to scan
        WHEN scan is called
        THEN it should return empty results
        """
        # Given
        scanner = ParallelProjectScanner(project_root=str(tmp_path), workers=2)
        
        mock_pool = MagicMock()
        mock_pool.__enter__ = MagicMock(return_value=mock_pool)
        mock_pool.__exit__ = MagicMock(return_value=None)
        mock_pool.map.return_value = []
        mock_pool_class.return_value = mock_pool
        
        with patch.object(scanner, '_collect_files', return_value=[]):
            with patch.object(scanner, '_build_test_file_map', return_value={}):
                # When
                records, summary = scanner.scan()
        
        # Then
        assert len(records) == 0
        assert summary.total_files == 0

    @patch('empathy_os.project_index.scanner_parallel.mp.Pool')
    def test_scan_passes_test_file_map_to_workers(self, mock_pool_class, tmp_path):
        """
        GIVEN a test file mapping
        WHEN scan is called
        THEN it should pass the mapping to worker function
        """
        # Given
        scanner = ParallelProjectScanner(project_root=str(tmp_path), workers=2)
        test_file_map = {"source.py": "test_source.py"}
        
        mock_pool = MagicMock()
        mock_pool.__enter__ = MagicMock(return_value=mock_pool)
        mock_pool.__exit__ = MagicMock(return_value=None)
        mock_pool.map.return_value = []
        mock_pool_class.return_value = mock_pool
        
        with patch.object(scanner, '_collect_files', return_value=[Path("test.py")]):
            with patch.object(scanner, '_build_test_file_map', return_value=test_file_map):
                # When
                scanner.scan()
        
        # Then
        # Verify that map was called with a partial function containing test_file_map
        assert mock