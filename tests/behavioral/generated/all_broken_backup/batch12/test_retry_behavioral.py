"""Behavioral tests for retry.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import asyncio
import logging
import random
from unittest.mock import AsyncMock, Mock, call, patch

import pytest

from empathy_os.resilience.retry import RetryConfig, retry


class TestRetryConfig:
    """Test suite for RetryConfig class."""

    def test_given_default_config_when_created_then_has_expected_defaults(self):
        """GIVEN default RetryConfig
        WHEN created
        THEN should have expected default values
        """
        # When
        config = RetryConfig()

        # Then
        assert config.max_attempts == 3
        assert config.backoff_factor == 2.0
        assert config.initial_delay == 1.0
        assert config.max_delay == 60.0
        assert config.jitter is True
        assert config.retryable_exceptions == (Exception,)

    def test_given_custom_values_when_created_then_uses_custom_values(self):
        """GIVEN custom configuration values
        WHEN RetryConfig is created
        THEN should use the custom values
        """
        # Given
        custom_exceptions = (ValueError, KeyError)

        # When
        config = RetryConfig(
            max_attempts=5,
            backoff_factor=3.0,
            initial_delay=2.0,
            max_delay=120.0,
            jitter=False,
            retryable_exceptions=custom_exceptions,
        )

        # Then
        assert config.max_attempts == 5
        assert config.backoff_factor == 3.0
        assert config.initial_delay == 2.0
        assert config.max_delay == 120.0
        assert config.jitter is False
        assert config.retryable_exceptions == custom_exceptions

    def test_given_attempt_1_when_get_delay_then_returns_initial_delay(self):
        """GIVEN first retry attempt
        WHEN get_delay is called with jitter disabled
        THEN should return initial delay
        """
        # Given
        config = RetryConfig(initial_delay=1.0, jitter=False)

        # When
        delay = config.get_delay(attempt=1)

        # Then
        assert delay == 1.0

    def test_given_attempt_2_when_get_delay_then_applies_backoff(self):
        """GIVEN second retry attempt
        WHEN get_delay is called with jitter disabled
        THEN should apply exponential backoff
        """
        # Given
        config = RetryConfig(
            initial_delay=1.0, backoff_factor=2.0, jitter=False
        )

        # When
        delay = config.get_delay(attempt=2)

        # Then
        assert delay == 2.0  # 1.0 * 2^(2-1)

    def test_given_attempt_3_when_get_delay_then_applies_exponential_backoff(self):
        """GIVEN third retry attempt
        WHEN get_delay is called with jitter disabled
        THEN should apply exponential backoff correctly
        """
        # Given
        config = RetryConfig(
            initial_delay=1.0, backoff_factor=2.0, jitter=False
        )

        # When
        delay = config.get_delay(attempt=3)

        # Then
        assert delay == 4.0  # 1.0 * 2^(3-1)

    def test_given_high_attempt_when_get_delay_then_caps_at_max_delay(self):
        """GIVEN high retry attempt number
        WHEN get_delay is called
        THEN should cap delay at max_delay
        """
        # Given
        config = RetryConfig(
            initial_delay=1.0, backoff_factor=2.0, max_delay=10.0, jitter=False
        )

        # When
        delay = config.get_delay(attempt=10)

        # Then
        assert delay == 10.0  # Capped at max_delay

    def test_given_jitter_enabled_when_get_delay_then_adds_randomness(self):
        """GIVEN jitter is enabled
        WHEN get_delay is called multiple times
        THEN should return different values with randomness
        """
        # Given
        config = RetryConfig(initial_delay=1.0, jitter=True)
        
        # When
        with patch('random.random') as mock_random:
            mock_random.return_value = 0.5  # Middle of range
            delay = config.get_delay(attempt=1)

        # Then
        # With random() = 0.5, jitter multiplier = 0.75 + 0.5 * 0.5 = 1.0
        assert delay == 1.0

    def test_given_jitter_when_get_delay_then_stays_within_bounds(self):
        """GIVEN jitter is enabled
        WHEN get_delay is called
        THEN should stay within 75% to 125% of base delay
        """
        # Given
        config = RetryConfig(initial_delay=10.0, backoff_factor=1.0, jitter=True)
        
        # When - test multiple times with different random values
        delays = []
        for random_val in [0.0, 0.25, 0.5, 0.75, 1.0]:
            with patch('random.random', return_value=random_val):
                delays.append(config.get_delay(attempt=1))

        # Then
        assert min(delays) >= 7.5  # 10.0 * 0.75
        assert max(delays) <= 12.5  # 10.0 * 1.25


class TestRetryDecorator:
    """Test suite for retry decorator."""

    @pytest.mark.asyncio
    async def test_given_successful_call_when_decorated_then_returns_result(self):
        """GIVEN a successful async function
        WHEN decorated with retry and called
        THEN should return the result without retrying
        """
        # Given
        @retry(max_attempts=3)
        async def successful_func():
            return "success"

        # When
        result = await successful_func()

        # Then
        assert result == "success"

    @pytest.mark.asyncio
    async def test_given_failing_call_when_decorated_then_retries_max_attempts(self):
        """GIVEN a function that always fails
        WHEN decorated with retry and called
        THEN should retry max_attempts times and raise exception
        """
        # Given
        call_count = 0

        @retry(max_attempts=3, initial_delay=0.01, jitter=False)
        async def failing_func():
            nonlocal call_count
            call_count += 1
            raise ValueError("Test error")

        # When/Then
        with pytest.raises(ValueError, match="Test error"):
            await failing_func()

        assert call_count == 3

    @pytest.mark.asyncio
    async def test_given_transient_failure_when_decorated_then_succeeds_on_retry(self):
        """GIVEN a function that fails then succeeds
        WHEN decorated with retry and called
        THEN should succeed on second attempt
        """
        # Given
        call_count = 0

        @retry(max_attempts=3, initial_delay=0.01)
        async def transient_failure():
            nonlocal call_count
            call_count += 1
            if call_count < 2:
                raise ValueError("Transient error")
            return "success"

        # When
        result = await transient_failure()

        # Then
        assert result == "success"
        assert call_count == 2

    @pytest.mark.asyncio
    async def test_given_specific_exceptions_when_other_raised_then_no_retry(self):
        """GIVEN retry configured for specific exceptions
        WHEN a different exception is raised
        THEN should not retry and raise immediately
        """
        # Given
        call_count = 0

        @retry(max_attempts=3, retryable_exceptions=(ValueError,))
        async def raises_different_exception():
            nonlocal call_count
            call_count += 1
            raise KeyError("Not retryable")

        # When/Then
        with pytest.raises(KeyError, match="Not retryable"):
            await raises_different_exception()

        assert call_count == 1

    @pytest.mark.asyncio
    async def test_given_specific_exceptions_when_matching_raised_then_retries(self):
        """GIVEN retry configured for specific exceptions
        WHEN a matching exception is raised
        THEN should retry the operation
        """
        # Given
        call_count = 0

        @retry(
            max_attempts=3,
            retryable_exceptions=(ValueError, KeyError),
            initial_delay=0.01,
        )
        async def raises_retryable_exception():
            nonlocal call_count
            call_count += 1
            raise ValueError("Retryable")

        # When/Then
        with pytest.raises(ValueError):
            await raises_retryable_exception()

        assert call_count == 3

    @pytest.mark.asyncio
    async def test_given_on_retry_callback_when_retry_occurs_then_calls_callback(self):
        """GIVEN an on_retry callback is provided
        WHEN retry occurs
        THEN should call the callback with exception and attempt number
        """
        # Given
        callback_calls = []

        def on_retry_callback(exception: Exception, attempt: int):
            callback_calls.append((exception, attempt))

        @retry(
            max_attempts=3,
            initial_delay=0.01,
            on_retry=on_retry_callback,
        )
        async def failing_func():
            raise ValueError("Test error")

        # When
        with pytest.raises(ValueError):
            await failing_func()

        # Then
        assert len(callback_calls) == 2  # Called on attempt 1 and 2 (not on final)
        assert callback_calls[0][1] == 1
        assert callback_calls[1][1] == 2
        assert all(isinstance(e, ValueError) for e, _ in callback_calls)

    @pytest.mark.asyncio
    async def test_given_backoff_factor_when_retrying_then_delays_increase(self):
        """GIVEN a backoff factor is configured
        WHEN retrying occurs
        THEN delays should increase exponentially
        """
        # Given
        delays = []

        async def mock_sleep(delay: float):
            delays.append(delay)

        @retry(
            max_attempts=4,
            initial_delay=1.0,
            backoff_factor=2.0,
            jitter=False,
        )
        async def failing_func():
            raise ValueError("Test")

        # When
        with patch("asyncio.sleep", side_effect=mock_sleep):
            with pytest.raises(ValueError):
                await failing_func()

        # Then
        assert len(delays) == 3  # 3 retries after first attempt
        assert delays[0] == 1.0
        assert delays[1] == 2.0
        assert delays[2] == 4.0

    @pytest.mark.asyncio
    async def test_given_max_delay_when_backoff_exceeds_then_caps_delay(self):
        """GIVEN a max_delay is configured
        WHEN exponential backoff would exceed it
        THEN should cap the delay at max_delay
        """
        # Given
        delays = []

        async def mock_sleep(delay: float):
            delays.append(delay)

        @retry(
            max_attempts=5,
            initial_delay=1.0,
            backoff_factor=10.0,
            max_delay=5.0,
            jitter=False,
        )
        async def failing_func():
            raise ValueError("Test")

        # When
        with patch("asyncio.sleep", side_effect=mock_sleep):
            with pytest.raises(ValueError):
                await failing_func()

        # Then
        assert all(delay <= 5.0 for delay in delays)
        assert delays[-1] == 5.0  # Should be capped

    @pytest.mark.asyncio
    async def test_given_jitter_enabled_when_retrying_then_adds_randomness(self):
        """GIVEN jitter is enabled
        WHEN retrying occurs
        THEN delays should have randomness applied
        """
        # Given
        delays = []

        async def mock_sleep(delay: float):
            delays.append(delay)

        @retry(
            max_attempts=3,
            initial_delay=10.0,
            backoff_factor=1.0,
            jitter=True,
        )
        async def failing_func():
            raise ValueError("Test")

        # When
        with patch("asyncio.sleep", side_effect=mock_sleep):
            with pytest.raises(ValueError):
                await failing_func()

        # Then
        # With jitter, delays should be in range [7.5, 12.5] (75% to 125% of 10.0)
        for delay in delays:
            assert 7.5 <= delay <= 12.5

    @pytest.mark.asyncio
    async def test_given_function_with_args_when_decorated_then_passes_args(self):
        """GIVEN a function that takes arguments
        WHEN decorated with retry and called with args
        THEN should pass arguments correctly
        """
        # Given
        @retry(max_attempts=2)
        async def func_with_args(a: int, b: str, c: bool = False):
            return f"{a}-{b}-{c}"

        # When
        result = await func_with_args(42, "test", c=True)

        # Then
        assert result == "42-test-True"

    @pytest.mark.asyncio
    async def test_given_function_with_kwargs_when_decorated_then_passes_kwargs(self):
        """GIVEN a function that takes keyword arguments
        WHEN decorated with retry and called with kwargs
        THEN should pass keyword arguments correctly
        """
        # Given
        @retry(max_attempts=2)
        async def func_with_kwargs(**kwargs):
            return kwargs

        # When
        result = await func_with_kwargs(x=1, y=2, z=3)

        # Then
        assert result == {"x": 1, "y": 2, "z": 3}

    @pytest.mark.asyncio
    async def test_given_decorated_function_when_inspected_then_preserves_metadata(self):
        """GIVEN a decorated function
        WHEN inspecting function metadata
        THEN should preserve original function name and docstring
        """
        # Given
        @retry(max_attempts=3)
        async def my_function():
            """My docstring."""
            return "result"

        # Then
        assert my_function.__name__ == "my_function"
        assert my_function.__doc__ == "My docstring."

    @pytest.mark.asyncio
    async def test_given_no_retryable_exceptions_when_decorated_then_uses_default(self):
        """GIVEN retry decorator with no retryable_exceptions specified
        WHEN an Exception is raised
        THEN should retry on any Exception
        """
        # Given
        call_count = 0

        @retry(max_attempts=3, initial_delay=0.01)
        async def raises_any_exception():
            nonlocal call_count
            call_count += 1
            raise RuntimeError("Any error")

        # When/Then
        with pytest.raises(RuntimeError):
            await raises_any_exception()

        assert call_count == 3

    @pytest.mark.asyncio
    async def test_given_on_retry_none_when_retrying_then_no_error(self):
        """GIVEN on_retry callback is None