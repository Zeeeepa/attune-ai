"""Behavioral tests for fallback.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import time
from datetime import datetime, timedelta
from unittest.mock import Mock, patch

from attune.models.fallback import (
    CircuitBreaker,
    CircuitBreakerState,
    FallbackPolicy,
    FallbackStep,
    FallbackStrategy,
    RetryPolicy,
)


class TestFallbackStrategy:
    """Test suite for FallbackStrategy enum."""

    def test_given_fallback_strategy_enum_when_accessing_values_then_returns_correct_strings(
        self,
    ):
        """Verify FallbackStrategy enum values are correctly defined."""
        # Given/When
        same_tier = FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        cheaper_tier = FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER
        different_provider = FallbackStrategy.DIFFERENT_PROVIDER_ANY_TIER
        custom = FallbackStrategy.CUSTOM

        # Then
        assert same_tier.value == "same_tier_different_provider"
        assert cheaper_tier.value == "cheaper_tier_same_provider"
        assert different_provider.value == "different_provider_any_tier"
        assert custom.value == "custom"

    def test_given_fallback_strategy_when_comparing_members_then_equality_works(self):
        """Verify FallbackStrategy enum members can be compared."""
        # Given
        strategy1 = FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        strategy2 = FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        strategy3 = FallbackStrategy.CUSTOM

        # When/Then
        assert strategy1 == strategy2
        assert strategy1 != strategy3


class TestFallbackStep:
    """Test suite for FallbackStep dataclass."""

    @patch("attune.models.fallback.get_model")
    def test_given_valid_provider_and_tier_when_creating_fallback_step_then_initializes_correctly(
        self, mock_get_model
    ):
        """Verify FallbackStep initializes with valid parameters."""
        # Given
        provider = "anthropic"
        tier = "capable"
        description = "Primary fallback"

        # When
        step = FallbackStep(
            provider=provider, tier=tier, description=description
        )

        # Then
        assert step.provider == provider
        assert step.tier == tier
        assert step.description == description

    @patch("attune.models.fallback.get_model")
    def test_given_fallback_step_when_accessing_model_id_then_returns_correct_id(
        self, mock_get_model
    ):
        """Verify model_id property returns correct model ID."""
        # Given
        mock_model = Mock()
        mock_model.id = "claude-3-sonnet"
        mock_get_model.return_value = mock_model
        step = FallbackStep(provider="anthropic", tier="capable")

        # When
        model_id = step.model_id

        # Then
        assert model_id == "claude-3-sonnet"
        mock_get_model.assert_called_once_with("anthropic", "capable")

    @patch("attune.models.fallback.get_model")
    def test_given_nonexistent_model_when_accessing_model_id_then_returns_empty_string(
        self, mock_get_model
    ):
        """Verify model_id returns empty string when model not found."""
        # Given
        mock_get_model.return_value = None
        step = FallbackStep(provider="unknown", tier="unknown")

        # When
        model_id = step.model_id

        # Then
        assert model_id == ""

    def test_given_fallback_step_without_description_when_creating_then_uses_default(
        self,
    ):
        """Verify FallbackStep uses default empty description."""
        # Given/When
        step = FallbackStep(provider="anthropic", tier="capable")

        # Then
        assert step.description == ""


class TestFallbackPolicy:
    """Test suite for FallbackPolicy class."""

    def test_given_no_params_when_creating_policy_then_uses_defaults(self):
        """Verify FallbackPolicy uses correct default values."""
        # Given/When
        policy = FallbackPolicy()

        # Then
        assert policy.primary_provider == "anthropic"
        assert policy.primary_tier == "capable"
        assert (
            policy.strategy == FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        )
        assert policy.custom_chain == []
        assert policy.max_retries == 2
        assert policy.retry_delay_ms == 1000
        assert policy.exponential_backoff is True
        assert policy.timeout_ms == 30000

    def test_given_custom_params_when_creating_policy_then_stores_values(self):
        """Verify FallbackPolicy accepts custom parameters."""
        # Given
        custom_chain = [
            FallbackStep("anthropic", "premium", "First"),
            FallbackStep("anthropic", "capable", "Second"),
        ]

        # When
        policy = FallbackPolicy(
            primary_provider="openai",
            primary_tier="premium",
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=custom_chain,
            max_retries=5,
            retry_delay_ms=2000,
            exponential_backoff=False,
            timeout_ms=60000,
        )

        # Then
        assert policy.primary_provider == "openai"
        assert policy.primary_tier == "premium"
        assert policy.strategy == FallbackStrategy.CUSTOM
        assert policy.custom_chain == custom_chain
        assert policy.max_retries == 5
        assert policy.retry_delay_ms == 2000
        assert policy.exponential_backoff is False
        assert policy.timeout_ms == 60000

    def test_given_custom_strategy_when_getting_fallback_chain_then_returns_custom_chain(
        self,
    ):
        """Verify get_fallback_chain returns custom chain for CUSTOM strategy."""
        # Given
        custom_chain = [
            FallbackStep("anthropic", "premium", "First"),
            FallbackStep("anthropic", "capable", "Second"),
        ]
        policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM, custom_chain=custom_chain
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert chain == custom_chain

    def test_given_same_tier_strategy_when_getting_fallback_chain_then_returns_same_tier_different_providers(
        self,
    ):
        """Verify get_fallback_chain returns same tier with different providers."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # Since only anthropic is available as of v5.0.0, chain should be empty
        # (no other providers for same tier)
        assert isinstance(chain, list)
        # All steps should have the same tier as primary
        for step in chain:
            assert step.tier == "capable"
            assert step.provider != "anthropic"  # Different provider

    def test_given_cheaper_tier_strategy_when_getting_fallback_chain_then_returns_cheaper_tiers(
        self,
    ):
        """Verify get_fallback_chain returns cheaper tiers with same provider."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="premium",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert isinstance(chain, list)
        # All steps should have the same provider
        for step in chain:
            assert step.provider == "anthropic"
        # Tiers should be cheaper than premium (capable, cheap)
        if len(chain) > 0:
            assert chain[0].tier in ["capable", "cheap"]

    def test_given_different_provider_strategy_when_getting_fallback_chain_then_returns_different_providers(
        self,
    ):
        """Verify get_fallback_chain returns different providers with any tier."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.DIFFERENT_PROVIDER_ANY_TIER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert isinstance(chain, list)
        # All steps should have different providers
        for step in chain:
            assert step.provider != "anthropic"

    def test_given_empty_custom_chain_when_getting_fallback_chain_then_returns_empty_list(
        self,
    ):
        """Verify get_fallback_chain returns empty list for empty custom chain."""
        # Given
        policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM, custom_chain=[]
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert chain == []

    def test_given_capable_tier_when_getting_cheaper_tiers_then_returns_only_cheap(
        self,
    ):
        """Verify cheaper tiers for capable tier."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # Should only include 'cheap' tier (cheaper than capable)
        for step in chain:
            assert step.tier in ["cheap"]
            assert step.provider == "anthropic"

    def test_given_cheap_tier_when_getting_cheaper_tiers_then_returns_empty_chain(
        self,
    ):
        """Verify no cheaper tiers available for cheap tier."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="cheap",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # No tiers cheaper than 'cheap'
        assert chain == []

    def test_given_unknown_tier_when_getting_fallback_chain_then_handles_gracefully(
        self,
    ):
        """Verify handling of unknown tier in fallback chain."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="unknown_tier",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # Should handle gracefully and return a list
        assert isinstance(chain, list)


class TestCircuitBreakerState:
    """Test suite for CircuitBreakerState dataclass."""

    def test_given_circuit_breaker_state_when_creating_then_initializes_with_defaults(
        self,
    ):
        """Verify CircuitBreakerState initializes with default values."""
        # Given/When
        state = CircuitBreakerState()

        # Then
        assert state.failure_count == 0
        assert state.last_failure is None
        assert state.is_open is False
        assert state.opened_at is None

    def test_given_circuit_breaker_state_when_creating_with_values_then_stores_values(
        self,
    ):
        """Verify CircuitBreakerState accepts custom values."""
        # Given
        now = datetime.now()

        # When
        state = CircuitBreakerState(
            failure_count=5,
            last_failure=now,
            is_open=True,
            opened_at=now
        )

        # Then
        assert state.failure_count == 5
        assert state.last_failure == now
        assert state.is_open is True
        assert state.opened_at == now


class TestCircuitBreaker:
    """Test suite for CircuitBreaker class."""

    def test_given_no_params_when_creating_circuit_breaker_then_uses_defaults(
        self,
    ):
        """Verify CircuitBreaker uses correct default values."""
        # Given/When
        cb = CircuitBreaker()

        # Then
        assert cb.failure_threshold == 5
        assert cb.recovery_timeout == timedelta(seconds=60)
        assert cb.half_open_calls == 1
        assert cb._states == {}

    def test_given_custom_params_when_creating_circuit_breaker_then_stores_values(
        self,
    ):
        """Verify CircuitBreaker accepts custom parameters."""
        # Given/When
        cb = CircuitBreaker(
            failure_threshold=10,
            recovery_timeout_seconds=120,
            half_open_calls=2,
        )

        # Then
        assert cb.failure_threshold == 10
        assert cb.recovery_timeout == timedelta(seconds=120)
        assert cb.half_open_calls == 2

    def test_given_closed_state_when_recording_success_then_resets_failure_count(
        self,
    ):
        """Verify recording success resets failure count."""
        # Given
        cb = CircuitBreaker()
        provider = "anthropic"
        tier = "capable"

        # Manually set failure count
        state = cb._get_state(provider, tier)
        state.failure_count = 3

        # When
        cb.record_success(provider, tier)

        # Then
        state = cb._get_state(provider, tier)
        assert state.failure_count == 0
        assert state.is_open is False
        assert state.opened_at is None

    def test_given_closed_state_when_recording_failures_then_opens_circuit(self):
        """Verify circuit opens after threshold failures."""
        # Given
        cb = CircuitBreaker(failure_threshold=3)
        provider = "anthropic"
        tier = "capable"

        # When
        for _ in range(3):
            cb.record_failure(provider, tier)

        # Then
        state = cb._get_state(provider, tier)
        assert state.is_open is True
        assert state.failure_count == 3
        assert state.last_failure is not None

    def test_given_closed_state_when_recording_below_threshold_then_stays_closed(
        self,
    ):
        """Verify circuit stays closed below failure threshold."""
        # Given
        cb = CircuitBreaker(failure_threshold=5)
        provider = "anthropic"
        tier = "capable"

        # When
        for _ in range(4):
            cb.record_failure(provider, tier)

        # Then
        state = cb._get_state(provider, tier)
        assert state.is_open is False
        assert state.failure_count == 4

    def test_given_open_state_when_timeout_not_elapsed_then_is_available_returns_false(
        self,
    ):
        """Verify is_available returns False when circuit is open and timeout not elapsed."""
        # Given
        cb = CircuitBreaker(recovery_timeout_seconds=60)
        provider = "anthropic"
        tier = "capable"

        state = cb._get_state(provider, tier)
        state.is_open = True
        state.opened_at = datetime.now()

        # When
        result = cb.is_available(provider, tier)

        # Then
        assert result is False

    def test_given_open_state_when_timeout_elapsed_then_is_available_returns_true(
        self,
    ):
        """Verify circuit allows calls after timeout (half-open behavior)."""
        # Given
        cb = CircuitBreaker(recovery_timeout_seconds=1)
        provider = "anthropic"
        tier = "capable"

        state = cb._get_state(provider, tier)
        state.is_open = True
        state.opened_at = datetime.now() - timedelta(seconds=2)

        # When
        result = cb.is_available(provider, tier)

        # Then
        assert result is True

    def test_given_circuit_when_recording_success_then_resets_state(
        self,
    ):
        """Verify success resets circuit state."""
        # Given
        cb = CircuitBreaker()
        provider = "anthropic"
        tier = "capable"

        state = cb._get_state(provider, tier)
        state.is_open = True
        state.failure_count = 5

        # When
        cb.record_success(provider, tier)

        # Then
        state = cb._get_state(provider, tier)
        assert state.failure_count == 0
        assert state.is_open is False
        assert state.opened_at is None

    def test_given_circuit_when_recording_failure_then_increments_count(
        self,
    ):
        """Verify failure increments count and opens circuit at threshold."""
        # Given
        cb = CircuitBreaker(failure_threshold=2)
        provider = "anthropic"
        tier = "capable"

        # When
        cb.record_failure(provider, tier)
        state = cb._get_state(provider, tier)
        assert state.failure_count == 1
        assert state.is_open is False

        cb.record_failure(provider, tier)
        state = cb._get_state(provider, tier)

        # Then
        assert state.failure_count == 2
        assert state.is_open is True
        assert state.opened_at is not None

    def test_given_closed_state_when_is_available_then_returns_true(self):
        """Verify is_available returns True for closed state."""
        # Given
        cb = CircuitBreaker()
        provider = "anthropic"
        tier = "capable"

        # When
        result = cb.is_available(provider, tier)

        # Then
        assert result is True

    def test_given_circuit_breaker_when_resetting_then_restores_initial_state(
        self,
    ):
        """Verify reset method restores initial state."""
        # Given
        cb = CircuitBreaker()
        provider = "anthropic"
        tier = "capable"

        state = cb._get_state(provider, tier)
        state.is_open = True
        state.failure_count = 5
        state.last_failure = datetime.now()

        # When
        cb.reset(provider, tier)

        # Then
        state = cb._get_state(provider, tier)
        assert state.failure_count == 0
        assert state.is_open is False
        assert state.last_failure is None
        assert state.opened_at is None

    def test_given_open_state_with_no_opened_at_when_is_available_then_returns_true(
        self,
    ):
        """Verify handling of open state without opened_at."""
        # Given
        cb = CircuitBreaker()
        provider = "anthropic"
        tier = "capable"

        state = cb._get_state(provider, tier)
        state.is_open = True
        state.opened_at = None

        # When
        result = cb.is_available(provider, tier)

        # Then
        # Should return False since circuit is open
        assert result is False


class TestRetryPolicy:
    """Test suite for RetryPolicy class."""

    def test_given_no_params_when_creating_retry_policy_then_uses_defaults(self):
        """Verify RetryPolicy uses correct default values."""
        # Given/When
        policy = RetryPolicy()

        # Then
        assert policy.max_retries == 3
        assert policy.initial_delay_ms == 1000
        assert policy.max_delay_ms == 30000
        assert policy.backoff_multiplier == 2.0
        assert policy.exponential_backoff is True

    def test_given_custom_params_when_creating_retry_policy_then_stores_values(
        self,
    ):
        """Verify RetryPolicy accepts custom parameters."""
        # Given/When
        policy = RetryPolicy(
            max_retries=5,
            initial_delay_ms=500,
            max_delay_ms=60000,
            backoff_multiplier=3.0,
            exponential_backoff=False,
        )

        # Then
        assert policy.max_retries == 5
        assert policy.initial_delay_ms == 500
        assert policy.max_delay_ms == 60000
        assert policy.backoff_multiplier == 3.0
        assert policy.exponential_backoff is False

    def test_given_first_attempt_when_getting_delay_ms_then_returns_initial_delay(
        self,
    ):
        """Verify first retry uses initial delay."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, exponential_backoff=False)

        # When
        delay = policy.get_delay_ms(attempt=1)

        # Then
        assert delay == 1000

    def test_given_multiple_attempts_when_getting_delay_ms_then_applies_exponential_backoff(
        self,
    ):
        """Verify exponential backoff is applied correctly."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000,
            backoff_multiplier=2.0,
            exponential_backoff=True
        )

        # When
        delay1 = policy.get_delay_ms(attempt=1)
        delay2 = policy.get_delay_ms(attempt=2)
        delay3 = policy.get_delay_ms(attempt=3)

        # Then
        assert delay1 == 1000  # 1000ms
        assert delay2 == 2000  # 1000 * 2^1
        assert delay3 == 4000  # 1000 * 2^2

    def test_given_max_delay_when_getting_delay_ms_then_caps_at_max(self):
        """Verify delay is capped at max_delay_ms."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000,
            max_delay_ms=5000,
            backoff_multiplier=2.0,
            exponential_backoff=True,
        )

        # When
        delay = policy.get_delay_ms(attempt=10)  # Would be 1000 * 2^9 = 512000ms

        # Then
        assert delay == 5000  # Capped at 5000ms

    def test_given_exponential_backoff_disabled_when_getting_delay_ms_then_returns_constant(
        self,
    ):
        """Verify constant delay when exponential backoff is disabled."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, exponential_backoff=False)

        # When
        delay1 = policy.get_delay_ms(attempt=1)
        delay2 = policy.get_delay_ms(attempt=2)
        delay3 = policy.get_delay_ms(attempt=3)

        # Then
        assert delay1 == 1000
        assert delay2 == 1000
        assert delay3 == 1000

    def test_given_should_retry_when_below_max_retries_then_returns_true(self):
        """Verify should_retry returns True below max retries."""
        # Given
        policy = RetryPolicy(max_retries=3)

        # When/Then
        assert policy.should_retry("rate_limit", 0) is True
        assert policy.should_retry("rate_limit", 1) is True
        assert policy.should_retry("rate_limit", 2) is True

    def test_given_should_retry_when_at_max_retries_then_returns_false(self):
        """Verify should_retry returns False at max retries."""
        # Given
        policy = RetryPolicy(max_retries=3)

        # When/Then
        assert policy.should_retry("rate_limit", 3) is False

    def test_given_should_retry_when_exceeding_max_retries_then_returns_false(
        self,
    ):
        """Verify should_retry returns False beyond max retries."""
        # Given
        policy = RetryPolicy(max_retries=3)

        # When/Then
        assert policy.should_retry("rate_limit", 4) is False
        assert policy.should_retry("rate_limit", 10) is False

    def test_given_should_retry_when_error_not_retryable_then_returns_false(self):
        """Verify should_retry returns False for non-retryable errors."""
        # Given
        policy = RetryPolicy(max_retries=3)

        # When/Then
        assert policy.should_retry("unknown", 1) is False
        assert policy.should_retry("validation_error", 1) is False

    @patch("time.sleep")
    def test_given_retry_policy_when_executing_with_sleep_then_waits_between_retries(
        self, mock_sleep
    ):
        """Verify retry delays are applied between attempts."""
        # Given
        policy = RetryPolicy(
            max_retries=3, initial_delay_ms=1000, exponential_backoff=False
        )

        # When
        for attempt in range(1, 3):
            if policy.should_retry("rate_limit", attempt):
                delay_ms = policy.get_delay_ms(attempt)
                time.sleep(delay_ms / 1000)

        # Then
        assert mock_sleep.call_count == 2

    def test_given_custom_backoff_multiplier_when_getting_delay_ms_then_uses_custom_multiplier(
        self,
    ):
        """Verify custom backoff multiplier is used."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000,
            backoff_multiplier=3.0,
            exponential_backoff=True
        )

        # When
        delay1 = policy.get_delay_ms(attempt=1)
        delay2 = policy.get_delay_ms(attempt=2)

        # Then
        assert delay1 == 1000  # 1000ms
        assert delay2 == 3000  # 1000 * 3^1

    def test_given_very_large_attempt_when_getting_delay_ms_then_handles_overflow(
        self,
    ):
        """Verify handling of very large attempt numbers."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000,
            max_delay_ms=30000,
            exponential_backoff=True
        )

        # When
        delay = policy.get_delay_ms(attempt=1000)

        # Then
        # Should be capped at max_delay
        assert delay == 30000


class TestIntegration:
    """Integration tests for fallback components."""

    @patch("attune.models.fallback.get_model")
    def test_given_fallback_policy_with_circuit_breaker_when_provider_fails_then_uses_fallback(
        self, mock_get_model
    ):
        """Verify fallback policy integrates with circuit breaker."""
        # Given
        mock_model = Mock()
        mock_model.id = "claude-3-sonnet"
        mock_get_model.return_value = mock_model

        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=[
                FallbackStep("anthropic", "capable", "Primary"),
                FallbackStep("anthropic", "cheap", "Fallback"),
            ],
        )
        cb = CircuitBreaker(failure_threshold=5)
        provider = "anthropic"
        tier = "capable"

        # When
        # Simulate failures to open circuit
        for _ in range(5):
            cb.record_failure(provider, tier)

        chain = policy.get_fallback_chain()
        state = cb._get_state(provider, tier)

        # Then
        assert state.is_open is True
        assert len(chain) == 2
        assert chain[1].tier == "cheap"

    def test_given_retry_policy_with_fallback_when_retries_exhausted_then_uses_fallback(
        self,
    ):
        """Verify retry policy integrates with fallback policy."""
        # Given
        retry_policy = RetryPolicy(max_retries=3)
        fallback_policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=[
                FallbackStep("anthropic", "capable", "Primary"),
                FallbackStep("anthropic", "cheap", "Fallback"),
            ],
        )

        # When
        attempt = 0
        while retry_policy.should_retry("rate_limit", attempt):
            attempt += 1

        # If retries exhausted, use fallback
        if attempt >= retry_policy.max_retries:
            chain = fallback_policy.get_fallback_chain()

        # Then
        assert attempt == 3
        assert len(chain) == 2

    @patch("time.sleep")
    def test_given_complete_fallback_scenario_when_all_retries_fail_then_follows_full_chain(
        self, mock_sleep
    ):
        """Verify complete fallback scenario with retries and circuit breaker."""
        # Given
        retry_policy = RetryPolicy(
            max_retries=5, initial_delay_ms=100, exponential_backoff=False
        )
        fallback_policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=[
                FallbackStep("anthropic", "premium", "Primary"),
                FallbackStep("anthropic", "capable", "Secondary"),
                FallbackStep("anthropic", "cheap", "Tertiary"),
            ],
        )
        # Set failure threshold to match max_retries to ensure circuit opens
        cb = CircuitBreaker(failure_threshold=5)

        # When
        chain = fallback_policy.get_fallback_chain()
        for step in chain:
            attempt = 0

            while retry_policy.should_retry("rate_limit", attempt) and cb.is_available(step.provider, step.tier):
                attempt += 1
                # Simulate failure
                cb.record_failure(step.provider, step.tier)
                if retry_policy.should_retry("rate_limit", attempt):
                    delay_ms = retry_policy.get_delay_ms(attempt)
                    time.sleep(delay_ms / 1000)

        # Then
        assert len(chain) == 3
        # All provider:tier combinations should be open after 5 failures each
        for step in chain:
            state = cb._get_state(step.provider, step.tier)
            assert state.is_open is True
            assert state.failure_count == 5
