"""Behavioral tests for fallback.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import time
from datetime import datetime, timedelta
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.models.fallback import (
    CircuitBreaker,
    CircuitBreakerState,
    FallbackPolicy,
    FallbackStep,
    FallbackStrategy,
    RetryPolicy,
)


class TestFallbackStrategy:
    """Test suite for FallbackStrategy enum."""

    def test_given_fallback_strategy_enum_when_accessing_values_then_returns_correct_strings(
        self,
    ):
        """Verify FallbackStrategy enum values are correctly defined."""
        # Given/When
        same_tier = FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        cheaper_tier = FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER
        different_provider = FallbackStrategy.DIFFERENT_PROVIDER_ANY_TIER
        custom = FallbackStrategy.CUSTOM

        # Then
        assert same_tier.value == "same_tier_different_provider"
        assert cheaper_tier.value == "cheaper_tier_same_provider"
        assert different_provider.value == "different_provider_any_tier"
        assert custom.value == "custom"

    def test_given_fallback_strategy_when_comparing_members_then_equality_works(self):
        """Verify FallbackStrategy enum members can be compared."""
        # Given
        strategy1 = FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        strategy2 = FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        strategy3 = FallbackStrategy.CUSTOM

        # When/Then
        assert strategy1 == strategy2
        assert strategy1 != strategy3


class TestFallbackStep:
    """Test suite for FallbackStep dataclass."""

    @patch("empathy_os.models.fallback.get_model")
    def test_given_valid_provider_and_tier_when_creating_fallback_step_then_initializes_correctly(
        self, mock_get_model
    ):
        """Verify FallbackStep initializes with valid parameters."""
        # Given
        provider = "anthropic"
        tier = "capable"
        description = "Primary fallback"

        # When
        step = FallbackStep(
            provider=provider, tier=tier, description=description
        )

        # Then
        assert step.provider == provider
        assert step.tier == tier
        assert step.description == description

    @patch("empathy_os.models.fallback.get_model")
    def test_given_fallback_step_when_accessing_model_id_then_returns_correct_id(
        self, mock_get_model
    ):
        """Verify model_id property returns correct model ID."""
        # Given
        mock_model = Mock()
        mock_model.id = "claude-3-sonnet"
        mock_get_model.return_value = mock_model
        step = FallbackStep(provider="anthropic", tier="capable")

        # When
        model_id = step.model_id

        # Then
        assert model_id == "claude-3-sonnet"
        mock_get_model.assert_called_once_with("anthropic", "capable")

    @patch("empathy_os.models.fallback.get_model")
    def test_given_nonexistent_model_when_accessing_model_id_then_returns_empty_string(
        self, mock_get_model
    ):
        """Verify model_id returns empty string when model not found."""
        # Given
        mock_get_model.return_value = None
        step = FallbackStep(provider="unknown", tier="unknown")

        # When
        model_id = step.model_id

        # Then
        assert model_id == ""

    def test_given_fallback_step_without_description_when_creating_then_uses_default(
        self,
    ):
        """Verify FallbackStep uses default empty description."""
        # Given/When
        step = FallbackStep(provider="anthropic", tier="capable")

        # Then
        assert step.description == ""


class TestFallbackPolicy:
    """Test suite for FallbackPolicy class."""

    def test_given_no_params_when_creating_policy_then_uses_defaults(self):
        """Verify FallbackPolicy uses correct default values."""
        # Given/When
        policy = FallbackPolicy()

        # Then
        assert policy.primary_provider == "anthropic"
        assert policy.primary_tier == "capable"
        assert (
            policy.strategy == FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER
        )
        assert policy.custom_chain == []
        assert policy.max_retries == 2
        assert policy.retry_delay_ms == 1000
        assert policy.exponential_backoff is True
        assert policy.timeout_ms == 30000

    def test_given_custom_params_when_creating_policy_then_stores_values(self):
        """Verify FallbackPolicy accepts custom parameters."""
        # Given
        custom_chain = [
            FallbackStep("anthropic", "premium", "First"),
            FallbackStep("anthropic", "capable", "Second"),
        ]

        # When
        policy = FallbackPolicy(
            primary_provider="openai",
            primary_tier="premium",
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=custom_chain,
            max_retries=5,
            retry_delay_ms=2000,
            exponential_backoff=False,
            timeout_ms=60000,
        )

        # Then
        assert policy.primary_provider == "openai"
        assert policy.primary_tier == "premium"
        assert policy.strategy == FallbackStrategy.CUSTOM
        assert policy.custom_chain == custom_chain
        assert policy.max_retries == 5
        assert policy.retry_delay_ms == 2000
        assert policy.exponential_backoff is False
        assert policy.timeout_ms == 60000

    def test_given_custom_strategy_when_getting_fallback_chain_then_returns_custom_chain(
        self,
    ):
        """Verify get_fallback_chain returns custom chain for CUSTOM strategy."""
        # Given
        custom_chain = [
            FallbackStep("anthropic", "premium", "First"),
            FallbackStep("anthropic", "capable", "Second"),
        ]
        policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM, custom_chain=custom_chain
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert chain == custom_chain

    def test_given_same_tier_strategy_when_getting_fallback_chain_then_returns_same_tier_different_providers(
        self,
    ):
        """Verify get_fallback_chain returns same tier with different providers."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.SAME_TIER_DIFFERENT_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # Since only anthropic is available as of v5.0.0, chain should be empty
        # (no other providers for same tier)
        assert isinstance(chain, list)
        # All steps should have the same tier as primary
        for step in chain:
            assert step.tier == "capable"
            assert step.provider != "anthropic"  # Different provider

    def test_given_cheaper_tier_strategy_when_getting_fallback_chain_then_returns_cheaper_tiers(
        self,
    ):
        """Verify get_fallback_chain returns cheaper tiers with same provider."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="premium",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert isinstance(chain, list)
        # All steps should have the same provider
        for step in chain:
            assert step.provider == "anthropic"
        # Tiers should be cheaper than premium (capable, cheap)
        if len(chain) > 0:
            assert chain[0].tier in ["capable", "cheap"]

    def test_given_different_provider_strategy_when_getting_fallback_chain_then_returns_different_providers(
        self,
    ):
        """Verify get_fallback_chain returns different providers with any tier."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.DIFFERENT_PROVIDER_ANY_TIER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert isinstance(chain, list)
        # All steps should have different providers
        for step in chain:
            assert step.provider != "anthropic"

    def test_given_empty_custom_chain_when_getting_fallback_chain_then_returns_empty_list(
        self,
    ):
        """Verify get_fallback_chain returns empty list for empty custom chain."""
        # Given
        policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM, custom_chain=[]
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        assert chain == []

    def test_given_capable_tier_when_getting_cheaper_tiers_then_returns_only_cheap(
        self,
    ):
        """Verify cheaper tiers for capable tier."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # Should only include 'cheap' tier (cheaper than capable)
        for step in chain:
            assert step.tier in ["cheap"]
            assert step.provider == "anthropic"

    def test_given_cheap_tier_when_getting_cheaper_tiers_then_returns_empty_chain(
        self,
    ):
        """Verify no cheaper tiers available for cheap tier."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="cheap",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # No tiers cheaper than 'cheap'
        assert chain == []

    def test_given_unknown_tier_when_getting_fallback_chain_then_handles_gracefully(
        self,
    ):
        """Verify handling of unknown tier in fallback chain."""
        # Given
        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="unknown_tier",
            strategy=FallbackStrategy.CHEAPER_TIER_SAME_PROVIDER,
        )

        # When
        chain = policy.get_fallback_chain()

        # Then
        # Should handle gracefully and return a list
        assert isinstance(chain, list)


class TestCircuitBreakerState:
    """Test suite for CircuitBreakerState enum."""

    def test_given_circuit_breaker_state_when_accessing_values_then_returns_correct_strings(
        self,
    ):
        """Verify CircuitBreakerState enum values."""
        # Given/When
        closed = CircuitBreakerState.CLOSED
        open_state = CircuitBreakerState.OPEN
        half_open = CircuitBreakerState.HALF_OPEN

        # Then
        assert closed.value == "closed"
        assert open_state.value == "open"
        assert half_open.value == "half_open"


class TestCircuitBreaker:
    """Test suite for CircuitBreaker class."""

    def test_given_no_params_when_creating_circuit_breaker_then_uses_defaults(
        self,
    ):
        """Verify CircuitBreaker uses correct default values."""
        # Given/When
        cb = CircuitBreaker(provider="anthropic", tier="capable")

        # Then
        assert cb.provider == "anthropic"
        assert cb.tier == "capable"
        assert cb.failure_threshold == 5
        assert cb.success_threshold == 2
        assert cb.timeout_seconds == 60
        assert cb.state == CircuitBreakerState.CLOSED
        assert cb.failure_count == 0
        assert cb.success_count == 0
        assert cb.last_failure_time is None

    def test_given_custom_params_when_creating_circuit_breaker_then_stores_values(
        self,
    ):
        """Verify CircuitBreaker accepts custom parameters."""
        # Given/When
        cb = CircuitBreaker(
            provider="openai",
            tier="premium",
            failure_threshold=10,
            success_threshold=3,
            timeout_seconds=120,
        )

        # Then
        assert cb.provider == "openai"
        assert cb.tier == "premium"
        assert cb.failure_threshold == 10
        assert cb.success_threshold == 3
        assert cb.timeout_seconds == 120

    def test_given_closed_state_when_recording_success_then_resets_failure_count(
        self,
    ):
        """Verify recording success resets failure count."""
        # Given
        cb = CircuitBreaker(provider="anthropic", tier="capable")
        cb.failure_count = 3

        # When
        cb.record_success()

        # Then
        assert cb.failure_count == 0
        assert cb.success_count == 0
        assert cb.state == CircuitBreakerState.CLOSED

    def test_given_closed_state_when_recording_failures_then_opens_circuit(self):
        """Verify circuit opens after threshold failures."""
        # Given
        cb = CircuitBreaker(
            provider="anthropic", tier="capable", failure_threshold=3
        )

        # When
        for _ in range(3):
            cb.record_failure()

        # Then
        assert cb.state == CircuitBreakerState.OPEN
        assert cb.failure_count == 3
        assert cb.last_failure_time is not None

    def test_given_closed_state_when_recording_below_threshold_then_stays_closed(
        self,
    ):
        """Verify circuit stays closed below failure threshold."""
        # Given
        cb = CircuitBreaker(
            provider="anthropic", tier="capable", failure_threshold=5
        )

        # When
        for _ in range(4):
            cb.record_failure()

        # Then
        assert cb.state == CircuitBreakerState.CLOSED
        assert cb.failure_count == 4

    def test_given_open_state_when_timeout_not_elapsed_then_can_request_returns_false(
        self,
    ):
        """Verify can_request returns False when circuit is open and timeout not elapsed."""
        # Given
        cb = CircuitBreaker(
            provider="anthropic", tier="capable", timeout_seconds=60
        )
        cb.state = CircuitBreakerState.OPEN
        cb.last_failure_time = datetime.now()

        # When
        result = cb.can_request()

        # Then
        assert result is False

    def test_given_open_state_when_timeout_elapsed_then_transitions_to_half_open(
        self,
    ):
        """Verify circuit transitions to half-open after timeout."""
        # Given
        cb = CircuitBreaker(
            provider="anthropic", tier="capable", timeout_seconds=1
        )
        cb.state = CircuitBreakerState.OPEN
        cb.last_failure_time = datetime.now() - timedelta(seconds=2)

        # When
        result = cb.can_request()

        # Then
        assert result is True
        assert cb.state == CircuitBreakerState.HALF_OPEN
        assert cb.failure_count == 0
        assert cb.success_count == 0

    def test_given_half_open_state_when_recording_success_then_increments_success_count(
        self,
    ):
        """Verify success count increments in half-open state."""
        # Given
        cb = CircuitBreaker(
            provider="anthropic", tier="capable", success_threshold=2
        )
        cb.state = CircuitBreakerState.HALF_OPEN

        # When
        cb.record_success()

        # Then
        assert cb.success_count == 1
        assert cb.state == CircuitBreakerState.HALF_OPEN

    def test_given_half_open_state_when_reaching_success_threshold_then_closes_circuit(
        self,
    ):
        """Verify circuit closes after reaching success threshold."""
        # Given
        cb = CircuitBreaker(
            provider="anthropic", tier="capable", success_threshold=2
        )
        cb.state = CircuitBreakerState.HALF_OPEN

        # When
        cb.record_success()
        cb.record_success()

        # Then
        assert cb.state == CircuitBreakerState.CLOSED
        assert cb.success_count == 0
        assert cb.failure_count == 0

    def test_given_half_open_state_when_recording_failure_then_opens_circuit(
        self,
    ):
        """Verify circuit opens on failure in half-open state."""
        # Given
        cb = CircuitBreaker(provider="anthropic", tier="capable")
        cb.state = CircuitBreakerState.HALF_OPEN

        # When
        cb.record_failure()

        # Then
        assert cb.state == CircuitBreakerState.OPEN
        assert cb.failure_count == 1
        assert cb.success_count == 0
        assert cb.last_failure_time is not None

    def test_given_closed_state_when_can_request_then_returns_true(self):
        """Verify can_request returns True for closed state."""
        # Given
        cb = CircuitBreaker(provider="anthropic", tier="capable")

        # When
        result = cb.can_request()

        # Then
        assert result is True

    def test_given_half_open_state_when_can_request_then_returns_true(self):
        """Verify can_request returns True for half-open state."""
        # Given
        cb = CircuitBreaker(provider="anthropic", tier="capable")
        cb.state = CircuitBreakerState.HALF_OPEN

        # When
        result = cb.can_request()

        # Then
        assert result is True

    def test_given_circuit_breaker_when_resetting_then_restores_initial_state(
        self,
    ):
        """Verify reset method restores initial state."""
        # Given
        cb = CircuitBreaker(provider="anthropic", tier="capable")
        cb.state = CircuitBreakerState.OPEN
        cb.failure_count = 5
        cb.success_count = 2
        cb.last_failure_time = datetime.now()

        # When
        cb.reset()

        # Then
        assert cb.state == CircuitBreakerState.CLOSED
        assert cb.failure_count == 0
        assert cb.success_count == 0
        assert cb.last_failure_time is None

    def test_given_open_state_with_no_last_failure_time_when_can_request_then_transitions_to_half_open(
        self,
    ):
        """Verify handling of open state without last_failure_time."""
        # Given
        cb = CircuitBreaker(provider="anthropic", tier="capable")
        cb.state = CircuitBreakerState.OPEN
        cb.last_failure_time = None

        # When
        result = cb.can_request()

        # Then
        # Should transition to half-open since we can't determine timeout
        assert result is True
        assert cb.state == CircuitBreakerState.HALF_OPEN


class TestRetryPolicy:
    """Test suite for RetryPolicy class."""

    def test_given_no_params_when_creating_retry_policy_then_uses_defaults(self):
        """Verify RetryPolicy uses correct default values."""
        # Given/When
        policy = RetryPolicy()

        # Then
        assert policy.max_attempts == 3
        assert policy.initial_delay_ms == 1000
        assert policy.max_delay_ms == 30000
        assert policy.exponential_base == 2.0
        assert policy.jitter == True

    def test_given_custom_params_when_creating_retry_policy_then_stores_values(
        self,
    ):
        """Verify RetryPolicy accepts custom parameters."""
        # Given/When
        policy = RetryPolicy(
            max_attempts=5,
            initial_delay_ms=500,
            max_delay_ms=60000,
            exponential_base=3.0,
            jitter=False,
        )

        # Then
        assert policy.max_attempts == 5
        assert policy.initial_delay_ms == 500
        assert policy.max_delay_ms == 60000
        assert policy.exponential_base == 3.0
        assert policy.jitter is False

    def test_given_first_attempt_when_getting_delay_then_returns_initial_delay(
        self,
    ):
        """Verify first retry uses initial delay."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, jitter=False)

        # When
        delay = policy.get_delay(attempt=1)

        # Then
        assert delay == 1.0  # 1000ms = 1.0s

    def test_given_multiple_attempts_when_getting_delay_then_applies_exponential_backoff(
        self,
    ):
        """Verify exponential backoff is applied correctly."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000, exponential_base=2.0, jitter=False
        )

        # When
        delay1 = policy.get_delay(attempt=1)
        delay2 = policy.get_delay(attempt=2)
        delay3 = policy.get_delay(attempt=3)

        # Then
        assert delay1 == 1.0  # 1000ms
        assert delay2 == 2.0  # 1000 * 2^1
        assert delay3 == 4.0  # 1000 * 2^2

    def test_given_max_delay_when_getting_delay_then_caps_at_max(self):
        """Verify delay is capped at max_delay_ms."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000,
            max_delay_ms=5000,
            exponential_base=2.0,
            jitter=False,
        )

        # When
        delay = policy.get_delay(attempt=10)  # Would be 1000 * 2^9 = 512000ms

        # Then
        assert delay == 5.0  # Capped at 5000ms = 5.0s

    def test_given_jitter_enabled_when_getting_delay_then_adds_randomness(self):
        """Verify jitter adds randomness to delay."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, jitter=True)

        # When
        delays = [policy.get_delay(attempt=1) for _ in range(10)]

        # Then
        # Not all delays should be exactly 1.0
        assert len(set(delays)) > 1
        # All delays should be between 0.5 and 1.5 (50% jitter)
        for delay in delays:
            assert 0.5 <= delay <= 1.5

    def test_given_jitter_disabled_when_getting_delay_then_returns_exact_value(
        self,
    ):
        """Verify no jitter returns exact delay values."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, jitter=False)

        # When
        delays = [policy.get_delay(attempt=1) for _ in range(10)]

        # Then
        # All delays should be exactly 1.0
        assert all(delay == 1.0 for delay in delays)

    def test_given_zero_attempt_when_getting_delay_then_returns_initial_delay(
        self,
    ):
        """Verify attempt 0 uses initial delay."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, jitter=False)

        # When
        delay = policy.get_delay(attempt=0)

        # Then
        assert delay == 1.0

    def test_given_negative_attempt_when_getting_delay_then_returns_initial_delay(
        self,
    ):
        """Verify negative attempt uses initial delay."""
        # Given
        policy = RetryPolicy(initial_delay_ms=1000, jitter=False)

        # When
        delay = policy.get_delay(attempt=-1)

        # Then
        assert delay == 1.0

    def test_given_should_retry_when_below_max_attempts_then_returns_true(self):
        """Verify should_retry returns True below max attempts."""
        # Given
        policy = RetryPolicy(max_attempts=3)

        # When/Then
        assert policy.should_retry(attempt=1) is True
        assert policy.should_retry(attempt=2) is True

    def test_given_should_retry_when_at_max_attempts_then_returns_false(self):
        """Verify should_retry returns False at max attempts."""
        # Given
        policy = RetryPolicy(max_attempts=3)

        # When/Then
        assert policy.should_retry(attempt=3) is False

    def test_given_should_retry_when_exceeding_max_attempts_then_returns_false(
        self,
    ):
        """Verify should_retry returns False beyond max attempts."""
        # Given
        policy = RetryPolicy(max_attempts=3)

        # When/Then
        assert policy.should_retry(attempt=4) is False
        assert policy.should_retry(attempt=10) is False

    @patch("time.sleep")
    def test_given_retry_policy_when_executing_with_sleep_then_waits_between_retries(
        self, mock_sleep
    ):
        """Verify retry delays are applied between attempts."""
        # Given
        policy = RetryPolicy(
            max_attempts=3, initial_delay_ms=1000, jitter=False
        )

        # When
        for attempt in range(1, 3):
            if policy.should_retry(attempt):
                delay = policy.get_delay(attempt)
                time.sleep(delay)

        # Then
        assert mock_sleep.call_count == 2

    def test_given_custom_exponential_base_when_getting_delay_then_uses_custom_base(
        self,
    ):
        """Verify custom exponential base is used."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000, exponential_base=3.0, jitter=False
        )

        # When
        delay1 = policy.get_delay(attempt=1)
        delay2 = policy.get_delay(attempt=2)

        # Then
        assert delay1 == 1.0  # 1000ms
        assert delay2 == 3.0  # 1000 * 3^1

    def test_given_very_large_attempt_when_getting_delay_then_handles_overflow(
        self,
    ):
        """Verify handling of very large attempt numbers."""
        # Given
        policy = RetryPolicy(
            initial_delay_ms=1000, max_delay_ms=30000, jitter=False
        )

        # When
        delay = policy.get_delay(attempt=1000)

        # Then
        # Should be capped at max_delay
        assert delay == 30.0


class TestIntegration:
    """Integration tests for fallback components."""

    @patch("empathy_os.models.fallback.get_model")
    def test_given_fallback_policy_with_circuit_breaker_when_provider_fails_then_uses_fallback(
        self, mock_get_model
    ):
        """Verify fallback policy integrates with circuit breaker."""
        # Given
        mock_model = Mock()
        mock_model.id = "claude-3-sonnet"
        mock_get_model.return_value = mock_model

        policy = FallbackPolicy(
            primary_provider="anthropic",
            primary_tier="capable",
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=[
                FallbackStep("anthropic", "capable", "Primary"),
                FallbackStep("anthropic", "cheap", "Fallback"),
            ],
        )
        cb = CircuitBreaker(provider="anthropic", tier="capable")

        # When
        # Simulate failures to open circuit
        for _ in range(5):
            cb.record_failure()

        chain = policy.get_fallback_chain()

        # Then
        assert cb.state == CircuitBreakerState.OPEN
        assert len(chain) == 2
        assert chain[1].tier == "cheap"

    def test_given_retry_policy_with_fallback_when_retries_exhausted_then_uses_fallback(
        self,
    ):
        """Verify retry policy integrates with fallback policy."""
        # Given
        retry_policy = RetryPolicy(max_attempts=3)
        fallback_policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=[
                FallbackStep("anthropic", "capable", "Primary"),
                FallbackStep("anthropic", "cheap", "Fallback"),
            ],
        )

        # When
        attempt = 0
        while retry_policy.should_retry(attempt):
            attempt += 1

        # If retries exhausted, use fallback
        if attempt >= retry_policy.max_attempts:
            chain = fallback_policy.get_fallback_chain()

        # Then
        assert attempt == 3
        assert len(chain) == 2

    @patch("time.sleep")
    def test_given_complete_fallback_scenario_when_all_retries_fail_then_follows_full_chain(
        self, mock_sleep
    ):
        """Verify complete fallback scenario with retries and circuit breaker."""
        # Given
        retry_policy = RetryPolicy(
            max_attempts=2, initial_delay_ms=100, jitter=False
        )
        fallback_policy = FallbackPolicy(
            strategy=FallbackStrategy.CUSTOM,
            custom_chain=[
                FallbackStep("anthropic", "premium", "Primary"),
                FallbackStep("anthropic", "capable", "Secondary"),
                FallbackStep("anthropic", "cheap", "Tertiary"),
            ],
        )
        circuit_breakers = {
            ("anthropic", "premium"): CircuitBreaker(
                "anthropic", "premium"
            ),
            ("anthropic", "capable"): CircuitBreaker(
                "anthropic", "capable"
            ),
            ("anthropic", "cheap"): CircuitBreaker("anthropic", "cheap"),
        }

        # When
        chain = fallback_policy.get_fallback_chain()
        for step in chain:
            cb = circuit_breakers[(step.provider, step.tier)]
            attempt = 0

            while retry_policy.should_retry(attempt) and cb.can_request():
                attempt += 1
                # Simulate failure
                cb.record_failure()
                if retry_policy.should_retry(attempt):
                    delay = retry_policy.get_delay(attempt)
                    time.sleep(delay)

        # Then
        assert len(chain) == 3
        # All circuit breakers should be open after failures
        for cb in circuit_breakers.values():
            assert cb.state == CircuitBreakerState.OPEN