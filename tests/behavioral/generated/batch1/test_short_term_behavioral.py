"""Behavioral tests for short_term.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

import pytest

pytest.importorskip("redis")

from attune.memory.short_term import RedisShortTermMemory  # noqa: E402
from attune.memory.types import (
    AccessTier,
    AgentCredentials,
    PaginatedResult,
    RedisConfig,
    SecurityError,
    StagedPattern,
    TimeWindowQuery,
    TTLStrategy,
)

# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def redis_config():
    """Given a basic Redis configuration."""
    return RedisConfig(
        host="localhost",
        port=6379,
        db=0,
        password=None,
        ssl=False,
        socket_timeout=5.0,
        socket_connect_timeout=5.0,
        retry_on_timeout=True,
        max_connections=50,
    )


@pytest.fixture
def admin_credentials():
    """Given admin-level agent credentials (using STEWARD tier)."""
    return AgentCredentials(agent_id="admin_agent", tier=AccessTier.STEWARD)


@pytest.fixture
def contributor_credentials():
    """Given contributor-level agent credentials."""
    return AgentCredentials(agent_id="contributor_agent", tier=AccessTier.CONTRIBUTOR)


@pytest.fixture
def reader_credentials():
    """Given reader-level agent credentials (using OBSERVER tier)."""
    return AgentCredentials(agent_id="reader_agent", tier=AccessTier.OBSERVER)


@pytest.fixture
def mock_redis_client():
    """Given a mocked Redis client."""
    mock_client = MagicMock()
    mock_client.ping.return_value = True
    mock_client.set.return_value = True
    mock_client.get.return_value = None
    mock_client.delete.return_value = 1
    mock_client.keys.return_value = []
    mock_client.scan_iter.return_value = iter([])
    mock_client.pipeline.return_value = MagicMock()
    mock_client.pubsub.return_value = MagicMock()
    mock_client.xadd.return_value = b"1234567890-0"
    mock_client.xread.return_value = []
    mock_client.zadd.return_value = 1
    mock_client.zrangebyscore.return_value = []
    mock_client.lpush.return_value = 1
    mock_client.rpop.return_value = None
    mock_client.llen.return_value = 0
    return mock_client


@pytest.fixture
def memory_instance(mock_redis_client, redis_config):
    """Given a RedisShortTermMemory instance with mocked Redis."""
    with patch("attune.memory.short_term.base.redis.Redis", return_value=mock_redis_client):
        with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
            memory = RedisShortTermMemory(config=redis_config)
            yield memory


@pytest.fixture
def pii_scrubber_mock():
    """Given a mocked PII scrubber."""
    scrubber = MagicMock()
    scrubber.scrub.return_value = {"data": "scrubbed"}
    return scrubber


@pytest.fixture
def secrets_detector_mock():
    """Given a mocked secrets detector."""
    detector = MagicMock()
    detector.scan.return_value = []
    return detector


# ============================================================================
# Initialization Tests
# ============================================================================


class TestRedisShortTermMemoryInitialization:
    """Test suite for RedisShortTermMemory initialization."""

    def test_given_redis_available_when_init_then_connects_successfully(
        self, mock_redis_client, redis_config
    ):
        """Given Redis is available, when initializing, then connects successfully."""
        with patch("attune.memory.short_term.base.redis.Redis", return_value=mock_redis_client):
            with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
                memory = RedisShortTermMemory(config=redis_config)
                assert memory.client is not None
                mock_redis_client.ping.assert_called_once()

    def test_given_redis_unavailable_when_init_then_uses_mock_mode(self):
        """Given Redis is unavailable, when initializing, then uses mock mode."""
        with patch("attune.memory.short_term.base.REDIS_AVAILABLE", False):
            memory = RedisShortTermMemory()
            assert memory.use_mock is True

    def test_given_connection_fails_when_init_then_raises_connection_error(self, redis_config):
        """Given connection fails, when initializing, then raises ConnectionError."""
        mock_client = MagicMock()
        mock_client.ping.side_effect = Exception("Connection failed")

        with patch("attune.memory.short_term.base.redis.Redis", return_value=mock_client):
            with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
                with pytest.raises(Exception, match="Connection failed"):
                    RedisShortTermMemory(config=redis_config)

    def test_given_ssl_config_when_init_then_enables_ssl(self, redis_config):
        """Given SSL configuration, when initializing, then enables SSL."""
        redis_config.ssl = True
        mock_client = MagicMock()
        mock_client.ping.return_value = True

        with patch(
            "attune.memory.short_term.base.redis.Redis", return_value=mock_client
        ) as mock_redis:
            with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
                RedisShortTermMemory(config=redis_config)
                assert mock_redis.call_args[1]["ssl"] is True

    def test_given_default_config_when_init_then_uses_defaults(self, mock_redis_client):
        """Given default configuration, when initializing, then uses default values."""
        with patch("attune.memory.short_term.base.redis.Redis", return_value=mock_redis_client):
            with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
                memory = RedisShortTermMemory()
                assert memory.metrics.total_requests == 0


# ============================================================================
# Stash Tests
# ============================================================================


class TestStash:
    """Test suite for stash operation."""

    def test_given_valid_data_when_stash_then_stores_successfully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given valid data, when stashing, then stores successfully."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}
        mock_redis_client.setex.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True
        mock_redis_client.setex.assert_called_once()

    def test_given_reader_tier_when_stash_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier credentials, when stashing, then raises PermissionError."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}

        # When/Then
        with pytest.raises(PermissionError, match="Requires CONTRIBUTOR or higher"):
            memory_instance.stash(key, data, reader_credentials)

    def test_given_ttl_strategy_when_stash_then_applies_ttl(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given TTL strategy, when stashing, then applies appropriate TTL."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}
        ttl_strategy = TTLStrategy.WORKING_RESULTS
        mock_redis_client.setex.return_value = True

        # When
        memory_instance.stash(key, data, contributor_credentials, ttl=ttl_strategy)

        # Then
        # Verify setex was called with correct TTL
        assert mock_redis_client.setex.called

    def test_given_pii_in_data_when_stash_then_scrubs_pii(
        self, memory_instance, contributor_credentials, mock_redis_client, pii_scrubber_mock
    ):
        """Given data with PII, when stashing, then scrubs PII before storing."""
        # Given
        key = "test_key"
        data = {"email": "user@example.com"}
        mock_redis_client.setex.return_value = True
        memory_instance._pii_scrubber = pii_scrubber_mock
        pii_scrubber_mock.scrub.return_value = (data, [])

        # When
        memory_instance.stash(key, data, contributor_credentials)

        # Then
        # PII scrubber should have been called
        assert pii_scrubber_mock.scrub.called

    def test_given_secrets_in_data_when_stash_then_raises_security_error(
        self, memory_instance, contributor_credentials, secrets_detector_mock
    ):
        """Given data with secrets, when stashing, then raises SecurityError."""
        # Given
        key = "test_key"
        data = {"api_key": "sk_live_12345"}
        from attune.memory.security.secrets_detector import SecretDetection, SecretType, Severity

        secret_detection = SecretDetection(
            secret_type=SecretType.GENERIC_API_KEY,
            severity=Severity.CRITICAL,
            line_number=1,
            column_start=10,
            column_end=25,
        )
        secrets_detector_mock.detect.return_value = [secret_detection]
        memory_instance._secrets_detector = secrets_detector_mock

        # When/Then
        with pytest.raises(SecurityError, match="Cannot store data containing secrets"):
            memory_instance.stash(key, data, contributor_credentials)

    def test_given_redis_error_when_stash_then_handles_gracefully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given Redis error, when stashing, then handles gracefully."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}
        mock_redis_client.setex.side_effect = Exception("Redis error")

        # When/Then - Should raise the exception (not return False)
        with pytest.raises(Exception, match="Redis error"):
            memory_instance.stash(key, data, contributor_credentials)


# ============================================================================
# Retrieve Tests
# ============================================================================


class TestRetrieve:
    """Test suite for retrieve operation."""

    def test_given_existing_key_when_retrieve_then_returns_data(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given existing key, when retrieving, then returns data."""
        # Given
        key = "test_key"
        stored_data = {"value": "test_value"}
        payload = {
            "data": stored_data,
            "agent_id": "reader_agent",
            "stashed_at": datetime.now().isoformat(),
        }
        mock_redis_client.get.return_value = json.dumps(payload)

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result == stored_data

    def test_given_nonexistent_key_when_retrieve_then_returns_none(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given nonexistent key, when retrieving, then returns None."""
        # Given
        key = "nonexistent_key"
        mock_redis_client.get.return_value = None

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result is None

    def test_given_invalid_json_when_retrieve_then_raises_error(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given invalid JSON data, when retrieving, then raises error."""
        # Given
        key = "test_key"
        mock_redis_client.get.return_value = "invalid json"

        # When/Then
        with pytest.raises(json.JSONDecodeError):
            memory_instance.retrieve(key, reader_credentials)

    def test_given_redis_error_when_retrieve_then_raises_error(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given Redis error, when retrieving, then raises error."""
        # Given
        key = "test_key"
        mock_redis_client.get.side_effect = Exception("Redis error")

        # When/Then
        with pytest.raises(Exception, match="Redis error"):
            memory_instance.retrieve(key, reader_credentials)


# ============================================================================
# Delete Tests (evict method doesn't exist, using _delete instead)
# ============================================================================


class TestDelete:
    """Test suite for delete operation (via _delete private method)."""

    def test_given_existing_key_when_delete_then_removes_successfully(
        self, memory_instance, mock_redis_client
    ):
        """Given existing key, when deleting, then removes successfully."""
        # Given
        key = "test_key"
        mock_redis_client.delete.return_value = 1

        # When
        result = memory_instance._delete(key)

        # Then
        assert result is True

    def test_given_nonexistent_key_when_delete_then_returns_false(
        self, memory_instance, mock_redis_client
    ):
        """Given nonexistent key, when deleting, then returns False."""
        # Given
        key = "nonexistent_key"
        mock_redis_client.delete.return_value = 0

        # When
        result = memory_instance._delete(key)

        # Then
        assert result is False


# ============================================================================
# List Keys Tests (using _keys private method)
# ============================================================================


class TestListKeys:
    """Test suite for list_keys operation (using _keys private method)."""

    def test_given_pattern_when_list_keys_then_returns_matching_keys(
        self, memory_instance, mock_redis_client
    ):
        """Given pattern, when listing keys, then returns matching keys."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan_iter.return_value = iter([b"test:key1", b"test:key2"])

        # When
        result = memory_instance._keys(pattern)

        # Then
        assert result == ["test:key1", "test:key2"]

    def test_given_no_matches_when_list_keys_then_returns_empty_list(
        self, memory_instance, mock_redis_client
    ):
        """Given no matches, when listing keys, then returns empty list."""
        # Given
        pattern = "nonexistent:*"
        mock_redis_client.keys.return_value = []

        # When
        result = memory_instance._keys(pattern)

        # Then
        assert result == []


# ============================================================================
# Batch Operations Tests
# ============================================================================


class TestBatchOperations:
    """Test suite for batch operations."""

    def test_given_multiple_items_when_stash_batch_then_stores_all(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given multiple items, when stashing batch, then stores all items."""
        # Given
        items = [("key1", {"value": 1}), ("key2", {"value": 2})]
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [True, True]

        # When
        result = memory_instance.stash_batch(items, contributor_credentials)

        # Then
        assert result == 2  # Should return count
        mock_redis_client.pipeline.assert_called_once()

    def test_given_reader_tier_when_stash_batch_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier, when stashing batch, then raises PermissionError."""
        # Given
        items = [("key1", {"value": 1})]

        # When/Then
        with pytest.raises(PermissionError, match="Requires CONTRIBUTOR tier or higher"):
            memory_instance.stash_batch(items, reader_credentials)

    def test_given_multiple_keys_when_retrieve_batch_then_returns_all(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given multiple keys, when retrieving batch, then returns all data."""
        # Given
        keys = ["key1", "key2"]
        payload1 = {"data": {"value": 1}, "agent_id": "agent", "stashed_at": "2024-01-01T00:00:00"}
        payload2 = {"data": {"value": 2}, "agent_id": "agent", "stashed_at": "2024-01-01T00:00:00"}
        mock_redis_client.mget.return_value = [
            json.dumps(payload1),
            json.dumps(payload2),
        ]

        # When
        result = memory_instance.retrieve_batch(keys, reader_credentials)

        # Then
        assert result == {"key1": {"value": 1}, "key2": {"value": 2}}

    def test_given_some_missing_keys_when_retrieve_batch_then_returns_found_keys(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given some missing keys, when retrieving batch, then returns only found keys."""
        # Given
        keys = ["key1", "key2"]
        payload1 = {"data": {"value": 1}, "agent_id": "agent", "stashed_at": "2024-01-01T00:00:00"}
        mock_redis_client.mget.return_value = [json.dumps(payload1), None]

        # When
        result = memory_instance.retrieve_batch(keys, reader_credentials)

        # Then
        assert result == {"key1": {"value": 1}}

    def test_given_redis_error_when_batch_operation_then_returns_empty(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given Redis error, when batch operation, then returns empty result."""
        # Given
        keys = ["key1", "key2"]
        mock_redis_client.pipeline.side_effect = Exception("Redis error")

        # When
        result = memory_instance.retrieve_batch(keys, reader_credentials)

        # Then
        assert result == {}


# ============================================================================
# Pagination Tests (using scan_keys method)
# ============================================================================


class TestPagination:
    """Test suite for pagination operations."""

    def test_given_keys_when_scan_keys_then_returns_page(self, memory_instance, mock_redis_client):
        """Given keys, when scanning paginated, then returns correct page."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan.return_value = (123, ["test:key1", "test:key2"])

        # When
        result = memory_instance.scan_keys(pattern, cursor="0")

        # Then
        assert isinstance(result, PaginatedResult)
        assert len(result.items) == 2
        assert result.cursor == "123"

    def test_given_last_page_when_scan_keys_then_cursor_is_zero(
        self, memory_instance, mock_redis_client
    ):
        """Given last page, when scanning paginated, then next cursor is zero."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan.return_value = (0, [b"test:key1"])

        # When
        result = memory_instance.scan_keys(pattern)

        # Then
        assert result.cursor == "0"
        assert result.has_more is False

    def test_given_custom_page_size_when_scan_keys_then_uses_size(
        self, memory_instance, mock_redis_client
    ):
        """Given custom page size, when scanning paginated, then uses specified size."""
        # Given
        pattern = "test:*"
        page_size = 50
        mock_redis_client.scan.return_value = (0, [])

        # When
        memory_instance.scan_keys(pattern, count=page_size)

        # Then
        mock_redis_client.scan.assert_called_once_with(cursor=0, match=pattern, count=page_size)


# ============================================================================
# Pub/Sub Tests
# ============================================================================


class TestPubSub:
    """Test suite for Pub/Sub operations."""

    def test_given_channel_when_publish_then_sends_message(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given channel, when publishing, then sends message."""
        # Given
        channel = "test_channel"
        message = {"event": "test_event"}
        mock_redis_client.publish.return_value = 1

        # When
        result = memory_instance.publish(channel, message, contributor_credentials)

        # Then
        assert result == 1
        mock_redis_client.publish.assert_called_once()

    def test_given_reader_tier_when_publish_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier, when publishing, then raises PermissionError."""
        # Given
        channel = "test_channel"
        message = {"event": "test_event"}

        # When/Then
        with pytest.raises(PermissionError, match="Requires CONTRIBUTOR tier or higher"):
            memory_instance.publish(channel, message, reader_credentials)

    def test_given_callback_when_subscribe_then_starts_listener(
        self, memory_instance, mock_redis_client
    ):
        """Given callback, when subscribing, then starts listener thread."""
        # Given
        channel = "test_channel"
        callback = MagicMock()
        mock_pubsub = MagicMock()
        mock_redis_client.pubsub.return_value = mock_pubsub

        # When
        result = memory_instance.subscribe(channel, callback)

        # Then
        assert result is True
        mock_redis_client.pubsub.assert_called_once()

    def test_given_channel_when_unsubscribe_then_stops_listener(
        self, memory_instance, mock_redis_client
    ):
        """Given channel, when unsubscribing, then stops listener."""
        # Given
        channel = "test_channel"
        callback = MagicMock()
        mock_pubsub = MagicMock()
        mock_redis_client.pubsub.return_value = mock_pubsub

        # Subscribe first
        memory_instance.subscribe(channel, callback)

        # When
        result = memory_instance.unsubscribe(channel)

        # Then
        assert result is True


# ============================================================================
# Audit Trail Tests (using stream_append method)
# ============================================================================


class TestAuditTrail:
    """Test suite for audit trail operations via streams."""

    def test_given_action_when_stream_append_then_adds_to_stream(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given action, when appending to stream, then adds entry."""
        # Given
        stream_name = "audit"
        data = {"action": "stash", "key": "test_key"}
        mock_redis_client.xadd.return_value = "1234567890-0"

        # When
        result = memory_instance.stream_append(stream_name, data, contributor_credentials)

        # Then
        assert result == "1234567890-0"
        mock_redis_client.xadd.assert_called_once()

    def test_given_stream_when_stream_read_then_returns_entries(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given stream, when reading, then returns entries."""
        # Given
        stream_name = "audit"
        mock_redis_client.xrange.return_value = [
            (
                "1234567890-0",
                {
                    "agent_id": "test_agent",
                    "action": "stash",
                },
            )
        ]

        # When
        result = memory_instance.stream_read(stream_name, reader_credentials)

        # Then
        assert len(result) == 1
        assert result[0][0] == "1234567890-0"

    def test_given_redis_error_when_stream_append_then_raises_error(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given Redis error, when appending to stream, then raises error."""
        # Given
        stream_name = "audit"
        data = {"action": "stash"}
        mock_redis_client.xadd.side_effect = Exception("Redis error")

        # When/Then
        with pytest.raises(Exception, match="Redis error"):
            memory_instance.stream_append(stream_name, data, contributor_credentials)


# ============================================================================
# Time Window Tests (using timeline methods)
# ============================================================================


class TestTimeWindow:
    """Test suite for time window operations."""

    def test_given_data_when_timeline_add_then_stores_with_timestamp(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given data, when adding to timeline, then stores with timestamp."""
        # Given
        timeline_name = "metrics_cpu"
        event_id = "event_1"
        data = {"value": 85.5}
        mock_redis_client.zadd.return_value = 1

        # When
        result = memory_instance.timeline_add(
            timeline_name, event_id, data, contributor_credentials
        )

        # Then
        assert result is True
        mock_redis_client.zadd.assert_called_once()

    def test_given_time_window_when_timeline_query_then_returns_data_in_range(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given time window, when querying timeline, then returns data in range."""
        # Given
        timeline_name = "metrics_cpu"
        start_time = datetime.now() - timedelta(hours=1)
        end_time = datetime.now()
        query = TimeWindowQuery(start_time=start_time, end_time=end_time)

        mock_redis_client.zrangebyscore.return_value = [
            json.dumps({"event_id": "event_1", "data": {"value": 85.5}})
        ]

        # When
        result = memory_instance.timeline_query(timeline_name, reader_credentials, query)

        # Then
        assert len(result) == 1

    def test_given_reader_tier_when_timeline_add_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier, when adding to timeline, then raises PermissionError."""
        # Given
        timeline_name = "metrics_cpu"
        event_id = "event_1"
        data = {"value": 85.5}

        # When/Then
        with pytest.raises(PermissionError, match="Requires CONTRIBUTOR tier or higher"):
            memory_instance.timeline_add(timeline_name, event_id, data, reader_credentials)


# ============================================================================
# Task Queue Tests (using queue_push/queue_pop methods)
# ============================================================================


class TestTaskQueue:
    """Test suite for task queue operations."""

    def test_given_task_when_queue_push_then_adds_to_queue(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given task, when pushing to queue, then adds to queue."""
        # Given
        queue_name = "tasks_pending"
        task = {"task_id": "123", "action": "process"}
        mock_redis_client.rpush.return_value = 1

        # When
        result = memory_instance.queue_push(queue_name, task, contributor_credentials)

        # Then
        assert result == 1
        mock_redis_client.rpush.assert_called_once()

    def test_given_queue_when_queue_pop_then_removes_and_returns_task(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given queue, when popping, then removes and returns task."""
        # Given
        queue_name = "tasks_pending"
        task_data = {
            "task": {"task_id": "123", "action": "process"},
            "queued_by": "agent",
            "queued_at": "2024-01-01T00:00:00",
        }
        mock_redis_client.lpop.return_value = json.dumps(task_data)

        # When
        result = memory_instance.queue_pop(queue_name, contributor_credentials)

        # Then
        assert result == task_data
        mock_redis_client.lpop.assert_called_once()

    def test_given_empty_queue_when_queue_pop_then_returns_none(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given empty queue, when popping, then returns None."""
        # Given
        queue_name = "tasks_pending"
        mock_redis_client.lpop.return_value = None

        # When
        result = memory_instance.queue_pop(queue_name, contributor_credentials)

        # Then
        assert result is None

    def test_given_queue_when_queue_length_then_returns_count(
        self, memory_instance, mock_redis_client
    ):
        """Given queue, when getting length, then returns count."""
        # Given
        queue_name = "tasks_pending"
        mock_redis_client.llen.return_value = 5

        # When
        result = memory_instance.queue_length(queue_name)

        # Then
        assert result == 5


# ============================================================================
# Pattern Staging Tests
# ============================================================================


class TestPatternStaging:
    """Test suite for pattern staging operations."""

    def test_given_pattern_when_stage_pattern_then_stores_in_staging(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given pattern, when staging, then stores in staging area."""
        # Given
        pattern = StagedPattern(
            pattern_id="pattern_123",
            agent_id="contributor_agent",
            pattern_type="code_review",
            name="test_pattern",
            description="Test pattern",
        )
        mock_redis_client.setex.return_value = True

        # When
        result = memory_instance.stage_pattern(pattern, contributor_credentials)

        # Then
        assert result is True

    def test_given_staged_pattern_when_get_staged_pattern_then_returns_pattern(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given staged pattern, when retrieving, then returns pattern."""
        # Given
        pattern_id = "pattern_123"
        pattern_dict = {
            "pattern_id": pattern_id,
            "agent_id": "contributor_agent",
            "pattern_type": "code_review",
            "name": "test_pattern",
            "description": "Test pattern",
            "code": None,
            "context": {},
            "confidence": 0.5,
            "staged_at": datetime.now().isoformat(),
            "interests": [],
        }
        mock_redis_client.get.return_value = json.dumps(pattern_dict)

        # When
        result = memory_instance.get_staged_pattern(pattern_id, reader_credentials)

        # Then
        assert result is not None
        assert result.pattern_id == pattern_id

    def test_given_pattern_when_promote_pattern_then_removes_from_staging(
        self, memory_instance, admin_credentials, mock_redis_client
    ):
        """Given pattern, when promoting, then removes from staging."""
        # Given
        pattern_id = "pattern_123"
        pattern_dict = {
            "pattern_id": pattern_id,
            "agent_id": "contributor_agent",
            "pattern_type": "code_review",
            "name": "test_pattern",
            "description": "Test pattern",
            "code": None,
            "context": {},
            "confidence": 0.5,
            "staged_at": datetime.now().isoformat(),
            "interests": [],
        }
        mock_redis_client.get.return_value = json.dumps(pattern_dict)
        mock_redis_client.delete.return_value = 1

        # When
        result = memory_instance.promote_pattern(pattern_id, admin_credentials)

        # Then
        assert result is not None
        assert result.pattern_id == pattern_id

    def test_given_non_validator_when_promote_pattern_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given non-validator, when promoting pattern, then raises PermissionError."""
        # Given
        pattern_id = "pattern_123"

        # When/Then
        with pytest.raises(PermissionError, match="Requires VALIDATOR tier or higher"):
            memory_instance.promote_pattern(pattern_id, reader_credentials)

    def test_given_pattern_when_reject_pattern_then_deletes_pattern(
        self, memory_instance, admin_credentials, mock_redis_client
    ):
        """Given pattern, when rejecting, then deletes pattern."""
        # Given
        pattern_id = "pattern_123"
        mock_redis_client.delete.return_value = 1

        # When
        result = memory_instance.reject_pattern(pattern_id, admin_credentials, "reason")

        # Then
        assert result is True


# ============================================================================
# Conflict Context Tests
# ============================================================================


class TestConflictContext:
    """Test suite for conflict context operations."""

    def test_given_conflict_when_create_conflict_context_then_stores_successfully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given conflict, when creating context, then stores successfully."""
        # Given
        conflict_id = "conflict_123"
        positions = {"agent1": "option_a", "agent2": "option_b"}
        interests = {"agent1": ["speed"], "agent2": ["accuracy"]}
        mock_redis_client.setex.return_value = True

        # When
        result = memory_instance.create_conflict_context(
            conflict_id, positions, interests, contributor_credentials
        )

        # Then
        assert result.conflict_id == conflict_id

    def test_given_conflict_id_when_get_conflict_context_then_returns_context(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given conflict ID, when retrieving context, then returns context."""
        # Given
        conflict_id = "conflict_123"
        context_dict = {
            "conflict_id": conflict_id,
            "positions": {"agent1": "option_a"},
            "interests": {"agent1": ["speed"]},
            "batna": None,
            "created_at": datetime.now().isoformat(),
            "resolved": False,
            "resolution": None,
        }
        mock_redis_client.get.return_value = json.dumps(context_dict)

        # When
        result = memory_instance.get_conflict_context(conflict_id, reader_credentials)

        # Then
        assert result is not None
        assert result.conflict_id == conflict_id


# ============================================================================
# Agent Working Memory Tests (using stash/retrieve methods)
# ============================================================================


class TestAgentWorkingMemory:
    """Test suite for agent working memory operations."""

    def test_given_agent_data_when_stash_then_stores_state(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given agent data, when stashing, then stores state."""
        # Given
        key = "agent_state"
        state = {"current_task": "analysis", "progress": 50}
        mock_redis_client.setex.return_value = True

        # When
        result = memory_instance.stash(key, state, contributor_credentials)

        # Then
        assert result is True

    def test_given_key_when_retrieve_then_returns_state(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given key, when retrieving, then returns state."""
        # Given
        key = "agent_state"
        state = {"current_task": "analysis", "progress": 50}
        payload = {
            "data": state,
            "agent_id": "reader_agent",
            "stashed_at": datetime.now().isoformat(),
        }
        mock_redis_client.get.return_value = json.dumps(payload)

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result == state

    def test_given_credentials_when_clear_working_memory_then_deletes_all(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given credentials, when clearing working memory, then deletes all keys."""
        # Given
        mock_redis_client.scan_iter.return_value = iter([b"empathy:working:contributor_agent:key1"])
        mock_redis_client.delete.return_value = 1

        # When
        result = memory_instance.clear_working_memory(contributor_credentials)

        # Then
        assert result == 1


# ============================================================================
# Metrics Tests (using metrics property)
# ============================================================================


class TestMetrics:
    """Test suite for metrics operations."""

    def test_given_operations_when_get_metrics_then_returns_metrics(self, memory_instance):
        """Given operations, when getting metrics, then returns metrics."""
        # Given
        memory_instance._metrics.operations_total = 100

        # When
        result = memory_instance.get_metrics()

        # Then
        assert isinstance(result, dict)
        assert result["operations_total"] == 100

    def test_given_metrics_when_reset_metrics_then_clears_metrics(self, memory_instance):
        """Given metrics, when resetting, then clears metrics."""
        # Given
        memory_instance._metrics.operations_total = 100

        # When
        memory_instance.reset_metrics()

        # Then
        assert memory_instance._metrics.operations_total == 0


# ============================================================================
# Transaction Tests (using atomic_promote_pattern method)
# ============================================================================


class TestTransactions:
    """Test suite for transaction operations."""

    def test_given_pattern_when_atomic_promote_then_runs_atomically(
        self, memory_instance, admin_credentials, mock_redis_client
    ):
        """Given pattern, when atomically promoting, then runs atomically."""
        # Given
        pattern_id = "pattern_123"
        pattern_dict = {
            "pattern_id": pattern_id,
            "agent_id": "contributor_agent",
            "pattern_type": "code_review",
            "name": "test_pattern",
            "description": "Test pattern",
            "code": None,
            "context": {},
            "confidence": 0.8,
            "staged_at": datetime.now().isoformat(),
            "interests": [],
        }
        mock_redis_client.get.return_value = json.dumps(pattern_dict)
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [1]

        # When
        success, pattern, msg = memory_instance.atomic_promote_pattern(
            pattern_id, admin_credentials, min_confidence=0.7
        )

        # Then
        assert success is True
        assert pattern.pattern_id == pattern_id

    def test_given_low_confidence_when_atomic_promote_then_fails(
        self, memory_instance, admin_credentials, mock_redis_client
    ):
        """Given low confidence pattern, when atomically promoting, then fails."""
        # Given
        pattern_id = "pattern_123"
        pattern_dict = {
            "pattern_id": pattern_id,
            "agent_id": "contributor_agent",
            "pattern_type": "code_review",
            "name": "test_pattern",
            "description": "Test pattern",
            "code": None,
            "context": {},
            "confidence": 0.3,
            "staged_at": datetime.now().isoformat(),
            "interests": [],
        }
        mock_redis_client.get.return_value = json.dumps(pattern_dict)

        # When
        success, pattern, msg = memory_instance.atomic_promote_pattern(
            pattern_id, admin_credentials, min_confidence=0.7
        )

        # Then
        assert success is False
        assert "below threshold" in msg


# ============================================================================
# Connection Retry Tests
# ============================================================================


class TestConnectionRetry:
    """Test suite for connection retry logic."""

    def test_given_connection_timeout_when_retry_then_reconnects(self, redis_config):
        """Given connection timeout, when retrying, then reconnects."""
        # Given
        mock_redis_client = MagicMock()
        # Third call succeeds
        mock_redis_client.ping.side_effect = [True]

        # When
        with patch("attune.memory.short_term.base.redis.Redis", return_value=mock_redis_client):
            with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
                memory = RedisShortTermMemory(config=redis_config)

        # Then
        assert memory.client is not None

    def test_given_max_retries_exceeded_when_retry_then_raises_error(self, redis_config):
        """Given max retries exceeded, when retrying, then raises error."""
        # Given
        mock_client = MagicMock()
        mock_client.ping.side_effect = Exception("Connection failed")

        # When/Then
        with patch("attune.memory.short_term.base.redis.Redis", return_value=mock_client):
            with patch("attune.memory.short_term.base.REDIS_AVAILABLE", True):
                with patch("time.sleep"):
                    with pytest.raises(Exception, match="Connection failed"):
                        RedisShortTermMemory(config=redis_config)


# ============================================================================
# Cleanup Tests
# ============================================================================


class TestCleanup:
    """Test suite for cleanup operations."""

    def test_given_memory_instance_when_close_then_closes_connections(
        self, memory_instance, mock_redis_client
    ):
        """Given memory instance, when closing, then closes connections."""
        # When
        memory_instance.close()

        # Then
        mock_redis_client.close.assert_called_once()

    def test_given_pubsub_listeners_when_close_then_stops_listeners(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given pub/sub listeners, when closing, then stops listeners."""
        # Given
        channel = "test_channel"
        callback = MagicMock()
        mock_pubsub = MagicMock()
        mock_redis_client.pubsub.return_value = mock_pubsub
        memory_instance.subscribe(channel, callback, reader_credentials)

        # When
        memory_instance.close()

        # Then
        mock_pubsub.close.assert_called()


# ============================================================================
# Edge Cases and Error Handling
# ============================================================================


class TestEdgeCases:
    """Test suite for edge cases and error handling."""

    def test_given_empty_data_when_stash_then_handles_gracefully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given empty data, when stashing, then handles gracefully."""
        # Given
        key = "test_key"
        data = {}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True

    def test_given_none_data_when_stash_then_handles_gracefully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given None data, when stashing, then handles gracefully."""
        # Given
        key = "test_key"
        data = None
        mock_redis_client.setex.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True  # Should succeed with None data

    def test_given_special_characters_in_key_when_stash_then_handles_correctly(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given special characters in key, when stashing, then handles correctly."""
        # Given
        key = "test:key:with:colons"
        data = {"value": "test"}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True

    def test_given_large_data_when_stash_then_handles_correctly(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given large data, when stashing, then handles correctly."""
        # Given
        key = "test_key"
        data = {"values": list(range(10000))}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True

    def test_given_nested_data_when_stash_then_serializes_correctly(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given nested data, when stashing, then serializes correctly."""
        # Given
        key = "test_key"
        data = {"level1": {"level2": {"level3": "value"}}}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True
