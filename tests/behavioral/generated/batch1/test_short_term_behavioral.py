"""Behavioral tests for short_term.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

import pytest

from empathy_os.memory.short_term import RedisShortTermMemory
from empathy_os.memory.types import (
    AccessTier,
    AgentCredentials,
    ConflictContext,
    PaginatedResult,
    RedisConfig,
    RedisMetrics,
    SecurityError,
    StagedPattern,
    TimeWindowQuery,
    TTLStrategy,
)

# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def redis_config():
    """Given a basic Redis configuration."""
    return RedisConfig(
        host="localhost",
        port=6379,
        db=0,
        password=None,
        ssl=False,
        socket_timeout=5.0,
        socket_connect_timeout=5.0,
        retry_on_timeout=True,
        max_connections=50,
    )


@pytest.fixture
def admin_credentials():
    """Given admin-level agent credentials."""
    return AgentCredentials(agent_id="admin_agent", tier=AccessTier.ADMIN)


@pytest.fixture
def contributor_credentials():
    """Given contributor-level agent credentials."""
    return AgentCredentials(agent_id="contributor_agent", tier=AccessTier.CONTRIBUTOR)


@pytest.fixture
def reader_credentials():
    """Given reader-level agent credentials."""
    return AgentCredentials(agent_id="reader_agent", tier=AccessTier.READER)


@pytest.fixture
def mock_redis_client():
    """Given a mocked Redis client."""
    mock_client = MagicMock()
    mock_client.ping.return_value = True
    mock_client.set.return_value = True
    mock_client.get.return_value = None
    mock_client.delete.return_value = 1
    mock_client.keys.return_value = []
    mock_client.scan_iter.return_value = iter([])
    mock_client.pipeline.return_value = MagicMock()
    mock_client.pubsub.return_value = MagicMock()
    mock_client.xadd.return_value = b"1234567890-0"
    mock_client.xread.return_value = []
    mock_client.zadd.return_value = 1
    mock_client.zrangebyscore.return_value = []
    mock_client.lpush.return_value = 1
    mock_client.rpop.return_value = None
    mock_client.llen.return_value = 0
    return mock_client


@pytest.fixture
def memory_instance(mock_redis_client, redis_config):
    """Given a RedisShortTermMemory instance with mocked Redis."""
    with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_redis_client):
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
            memory = RedisShortTermMemory(config=redis_config)
            yield memory


@pytest.fixture
def pii_scrubber_mock():
    """Given a mocked PII scrubber."""
    scrubber = MagicMock()
    scrubber.scrub.return_value = {"data": "scrubbed"}
    return scrubber


@pytest.fixture
def secrets_detector_mock():
    """Given a mocked secrets detector."""
    detector = MagicMock()
    detector.scan.return_value = []
    return detector


# ============================================================================
# Initialization Tests
# ============================================================================


class TestRedisShortTermMemoryInitialization:
    """Test suite for RedisShortTermMemory initialization."""

    def test_given_redis_available_when_init_then_connects_successfully(
        self, mock_redis_client, redis_config
    ):
        """Given Redis is available, when initializing, then connects successfully."""
        with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_redis_client):
            with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
                memory = RedisShortTermMemory(config=redis_config)
                assert memory.client is not None
                mock_redis_client.ping.assert_called_once()

    def test_given_redis_unavailable_when_init_then_raises_runtime_error(self):
        """Given Redis is unavailable, when initializing, then raises RuntimeError."""
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", False):
            with pytest.raises(RuntimeError, match="Redis is not available"):
                RedisShortTermMemory()

    def test_given_connection_fails_when_init_then_raises_connection_error(self, redis_config):
        """Given connection fails, when initializing, then raises ConnectionError."""
        mock_client = MagicMock()
        mock_client.ping.side_effect = Exception("Connection failed")

        with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_client):
            with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
                with pytest.raises(ConnectionError, match="Failed to connect to Redis"):
                    RedisShortTermMemory(config=redis_config)

    def test_given_ssl_config_when_init_then_enables_ssl(self, redis_config):
        """Given SSL configuration, when initializing, then enables SSL."""
        redis_config.ssl = True
        mock_client = MagicMock()
        mock_client.ping.return_value = True

        with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_client) as mock_redis:
            with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
                RedisShortTermMemory(config=redis_config)
                assert mock_redis.call_args[1]["ssl"] is True

    def test_given_default_config_when_init_then_uses_defaults(self, mock_redis_client):
        """Given default configuration, when initializing, then uses default values."""
        with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_redis_client):
            with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
                memory = RedisShortTermMemory()
                assert memory.metrics.total_requests == 0


# ============================================================================
# Stash Tests
# ============================================================================


class TestStash:
    """Test suite for stash operation."""

    def test_given_valid_data_when_stash_then_stores_successfully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given valid data, when stashing, then stores successfully."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True
        mock_redis_client.set.assert_called_once()
        call_args = mock_redis_client.set.call_args
        assert call_args[0][0] == key

    def test_given_reader_tier_when_stash_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier credentials, when stashing, then raises PermissionError."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}

        # When/Then
        with pytest.raises(PermissionError, match="requires CONTRIBUTOR or ADMIN"):
            memory_instance.stash(key, data, reader_credentials)

    def test_given_ttl_strategy_when_stash_then_applies_ttl(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given TTL strategy, when stashing, then applies appropriate TTL."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}
        ttl_strategy = TTLStrategy.LONG
        mock_redis_client.set.return_value = True

        # When
        memory_instance.stash(key, data, contributor_credentials, ttl_strategy=ttl_strategy)

        # Then
        call_args = mock_redis_client.set.call_args
        assert call_args[1]["ex"] == 3600  # LONG TTL

    def test_given_pii_in_data_when_stash_then_scrubs_pii(
        self, memory_instance, contributor_credentials, mock_redis_client, pii_scrubber_mock
    ):
        """Given data with PII, when stashing, then scrubs PII before storing."""
        # Given
        key = "test_key"
        data = {"email": "user@example.com"}
        mock_redis_client.set.return_value = True
        memory_instance.pii_scrubber = pii_scrubber_mock

        # When
        memory_instance.stash(key, data, contributor_credentials)

        # Then
        pii_scrubber_mock.scrub.assert_called_once_with(data)

    def test_given_secrets_in_data_when_stash_then_raises_security_error(
        self, memory_instance, contributor_credentials, secrets_detector_mock
    ):
        """Given data with secrets, when stashing, then raises SecurityError."""
        # Given
        key = "test_key"
        data = {"api_key": "sk_live_12345"}
        from empathy_os.memory.security.secrets_detector import SecretMatch, SecretType

        secret_match = SecretMatch(
            type=SecretType.API_KEY,
            value="sk_live_12345",
            line=1,
            column=10,
            severity=SecretSeverity.CRITICAL,
        )
        secrets_detector_mock.scan.return_value = [secret_match]
        memory_instance.secrets_detector = secrets_detector_mock

        # When/Then
        with pytest.raises(SecurityError, match="Critical secrets detected"):
            memory_instance.stash(key, data, contributor_credentials)

    def test_given_redis_error_when_stash_then_returns_false(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given Redis error, when stashing, then returns False."""
        # Given
        key = "test_key"
        data = {"value": "test_value"}
        mock_redis_client.set.side_effect = Exception("Redis error")

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is False


# ============================================================================
# Retrieve Tests
# ============================================================================


class TestRetrieve:
    """Test suite for retrieve operation."""

    def test_given_existing_key_when_retrieve_then_returns_data(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given existing key, when retrieving, then returns data."""
        # Given
        key = "test_key"
        stored_data = {"value": "test_value"}
        mock_redis_client.get.return_value = json.dumps(stored_data).encode()

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result == stored_data
        mock_redis_client.get.assert_called_once_with(key)

    def test_given_nonexistent_key_when_retrieve_then_returns_none(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given nonexistent key, when retrieving, then returns None."""
        # Given
        key = "nonexistent_key"
        mock_redis_client.get.return_value = None

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result is None

    def test_given_invalid_json_when_retrieve_then_returns_none(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given invalid JSON data, when retrieving, then returns None."""
        # Given
        key = "test_key"
        mock_redis_client.get.return_value = b"invalid json"

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result is None

    def test_given_redis_error_when_retrieve_then_returns_none(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given Redis error, when retrieving, then returns None."""
        # Given
        key = "test_key"
        mock_redis_client.get.side_effect = Exception("Redis error")

        # When
        result = memory_instance.retrieve(key, reader_credentials)

        # Then
        assert result is None


# ============================================================================
# Evict Tests
# ============================================================================


class TestEvict:
    """Test suite for evict operation."""

    def test_given_existing_key_when_evict_then_deletes_successfully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given existing key, when evicting, then deletes successfully."""
        # Given
        key = "test_key"
        mock_redis_client.delete.return_value = 1

        # When
        result = memory_instance.evict(key, contributor_credentials)

        # Then
        assert result is True
        mock_redis_client.delete.assert_called_once_with(key)

    def test_given_nonexistent_key_when_evict_then_returns_false(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given nonexistent key, when evicting, then returns False."""
        # Given
        key = "nonexistent_key"
        mock_redis_client.delete.return_value = 0

        # When
        result = memory_instance.evict(key, contributor_credentials)

        # Then
        assert result is False

    def test_given_reader_tier_when_evict_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier credentials, when evicting, then raises PermissionError."""
        # Given
        key = "test_key"

        # When/Then
        with pytest.raises(PermissionError, match="requires CONTRIBUTOR or ADMIN"):
            memory_instance.evict(key, reader_credentials)

    def test_given_redis_error_when_evict_then_returns_false(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given Redis error, when evicting, then returns False."""
        # Given
        key = "test_key"
        mock_redis_client.delete.side_effect = Exception("Redis error")

        # When
        result = memory_instance.evict(key, contributor_credentials)

        # Then
        assert result is False


# ============================================================================
# List Keys Tests
# ============================================================================


class TestListKeys:
    """Test suite for list_keys operation."""

    def test_given_pattern_when_list_keys_then_returns_matching_keys(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given pattern, when listing keys, then returns matching keys."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan_iter.return_value = iter([b"test:key1", b"test:key2"])

        # When
        result = memory_instance.list_keys(pattern, reader_credentials)

        # Then
        assert result == ["test:key1", "test:key2"]
        mock_redis_client.scan_iter.assert_called_once_with(match=pattern, count=100)

    def test_given_no_matches_when_list_keys_then_returns_empty_list(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given no matches, when listing keys, then returns empty list."""
        # Given
        pattern = "nonexistent:*"
        mock_redis_client.scan_iter.return_value = iter([])

        # When
        result = memory_instance.list_keys(pattern, reader_credentials)

        # Then
        assert result == []

    def test_given_redis_error_when_list_keys_then_returns_empty_list(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given Redis error, when listing keys, then returns empty list."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan_iter.side_effect = Exception("Redis error")

        # When
        result = memory_instance.list_keys(pattern, reader_credentials)

        # Then
        assert result == []


# ============================================================================
# Batch Operations Tests
# ============================================================================


class TestBatchOperations:
    """Test suite for batch operations."""

    def test_given_multiple_items_when_stash_batch_then_stores_all(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given multiple items, when stashing batch, then stores all items."""
        # Given
        items = [("key1", {"value": 1}), ("key2", {"value": 2})]
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [True, True]

        # When
        result = memory_instance.stash_batch(items, contributor_credentials)

        # Then
        assert result is True
        mock_redis_client.pipeline.assert_called_once()
        assert mock_pipeline.set.call_count == 2

    def test_given_reader_tier_when_stash_batch_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier, when stashing batch, then raises PermissionError."""
        # Given
        items = [("key1", {"value": 1})]

        # When/Then
        with pytest.raises(PermissionError, match="requires CONTRIBUTOR or ADMIN"):
            memory_instance.stash_batch(items, reader_credentials)

    def test_given_multiple_keys_when_retrieve_batch_then_returns_all(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given multiple keys, when retrieving batch, then returns all data."""
        # Given
        keys = ["key1", "key2"]
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [
            json.dumps({"value": 1}).encode(),
            json.dumps({"value": 2}).encode(),
        ]

        # When
        result = memory_instance.retrieve_batch(keys, reader_credentials)

        # Then
        assert result == {"key1": {"value": 1}, "key2": {"value": 2}}

    def test_given_some_missing_keys_when_retrieve_batch_then_returns_found_keys(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given some missing keys, when retrieving batch, then returns only found keys."""
        # Given
        keys = ["key1", "key2"]
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [json.dumps({"value": 1}).encode(), None]

        # When
        result = memory_instance.retrieve_batch(keys, reader_credentials)

        # Then
        assert result == {"key1": {"value": 1}}

    def test_given_redis_error_when_batch_operation_then_returns_empty(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given Redis error, when batch operation, then returns empty result."""
        # Given
        keys = ["key1", "key2"]
        mock_redis_client.pipeline.side_effect = Exception("Redis error")

        # When
        result = memory_instance.retrieve_batch(keys, reader_credentials)

        # Then
        assert result == {}


# ============================================================================
# Pagination Tests
# ============================================================================


class TestPagination:
    """Test suite for pagination operations."""

    def test_given_keys_when_list_keys_paginated_then_returns_page(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given keys, when listing paginated, then returns correct page."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan.return_value = (123, [b"test:key1", b"test:key2"])

        # When
        result = memory_instance.list_keys_paginated(pattern, reader_credentials, cursor=0)

        # Then
        assert isinstance(result, PaginatedResult)
        assert result.items == ["test:key1", "test:key2"]
        assert result.next_cursor == 123

    def test_given_last_page_when_list_keys_paginated_then_cursor_is_zero(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given last page, when listing paginated, then next cursor is zero."""
        # Given
        pattern = "test:*"
        mock_redis_client.scan.return_value = (0, [b"test:key1"])

        # When
        result = memory_instance.list_keys_paginated(pattern, reader_credentials)

        # Then
        assert result.next_cursor == 0
        assert result.has_more is False

    def test_given_custom_page_size_when_list_keys_paginated_then_uses_size(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given custom page size, when listing paginated, then uses specified size."""
        # Given
        pattern = "test:*"
        page_size = 50
        mock_redis_client.scan.return_value = (0, [])

        # When
        memory_instance.list_keys_paginated(
            pattern, reader_credentials, page_size=page_size
        )

        # Then
        mock_redis_client.scan.assert_called_once_with(
            cursor=0, match=pattern, count=page_size
        )


# ============================================================================
# Pub/Sub Tests
# ============================================================================


class TestPubSub:
    """Test suite for Pub/Sub operations."""

    def test_given_channel_when_publish_then_sends_message(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given channel, when publishing, then sends message."""
        # Given
        channel = "test_channel"
        message = {"event": "test_event"}
        mock_redis_client.publish.return_value = 1

        # When
        result = memory_instance.publish(channel, message, contributor_credentials)

        # Then
        assert result == 1
        mock_redis_client.publish.assert_called_once()

    def test_given_reader_tier_when_publish_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier, when publishing, then raises PermissionError."""
        # Given
        channel = "test_channel"
        message = {"event": "test_event"}

        # When/Then
        with pytest.raises(PermissionError, match="requires CONTRIBUTOR or ADMIN"):
            memory_instance.publish(channel, message, reader_credentials)

    def test_given_callback_when_subscribe_then_starts_listener(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given callback, when subscribing, then starts listener thread."""
        # Given
        channel = "test_channel"
        callback = MagicMock()
        mock_pubsub = MagicMock()
        mock_redis_client.pubsub.return_value = mock_pubsub

        # When
        memory_instance.subscribe(channel, callback, reader_credentials)

        # Then
        mock_pubsub.subscribe.assert_called_once_with(channel)

    def test_given_channel_when_unsubscribe_then_stops_listener(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given channel, when unsubscribing, then stops listener."""
        # Given
        channel = "test_channel"
        callback = MagicMock()
        mock_pubsub = MagicMock()
        mock_redis_client.pubsub.return_value = mock_pubsub

        # Subscribe first
        memory_instance.subscribe(channel, callback, reader_credentials)

        # When
        memory_instance.unsubscribe(channel, reader_credentials)

        # Then
        mock_pubsub.unsubscribe.assert_called_once_with(channel)


# ============================================================================
# Audit Trail Tests
# ============================================================================


class TestAuditTrail:
    """Test suite for audit trail operations."""

    def test_given_action_when_log_audit_then_adds_to_stream(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given action, when logging audit, then adds to stream."""
        # Given
        action = "stash"
        key = "test_key"
        mock_redis_client.xadd.return_value = b"1234567890-0"

        # When
        result = memory_instance.log_audit(action, key, contributor_credentials)

        # Then
        assert result == "1234567890-0"
        mock_redis_client.xadd.assert_called_once()

    def test_given_query_when_query_audit_then_returns_entries(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given query, when querying audit, then returns entries."""
        # Given
        mock_redis_client.xread.return_value = [
            (
                b"audit:trail",
                [
                    (
                        b"1234567890-0",
                        {
                            b"agent_id": b"test_agent",
                            b"action": b"stash",
                            b"key": b"test_key",
                        },
                    )
                ],
            )
        ]

        # When
        result = memory_instance.query_audit(reader_credentials, count=10)

        # Then
        assert len(result) == 1
        assert result[0]["agent_id"] == "test_agent"

    def test_given_redis_error_when_log_audit_then_returns_none(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given Redis error, when logging audit, then returns None."""
        # Given
        action = "stash"
        key = "test_key"
        mock_redis_client.xadd.side_effect = Exception("Redis error")

        # When
        result = memory_instance.log_audit(action, key, contributor_credentials)

        # Then
        assert result is None


# ============================================================================
# Time Window Tests
# ============================================================================


class TestTimeWindow:
    """Test suite for time window operations."""

    def test_given_data_when_add_time_series_then_stores_with_timestamp(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given data, when adding to time series, then stores with timestamp."""
        # Given
        key = "metrics:cpu"
        data = {"value": 85.5}
        mock_redis_client.zadd.return_value = 1

        # When
        result = memory_instance.add_time_series(key, data, contributor_credentials)

        # Then
        assert result is True
        mock_redis_client.zadd.assert_called_once()

    def test_given_time_window_when_query_time_window_then_returns_data_in_range(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given time window, when querying, then returns data in range."""
        # Given
        key = "metrics:cpu"
        start_time = datetime.now() - timedelta(hours=1)
        end_time = datetime.now()
        query = TimeWindowQuery(key=key, start_time=start_time, end_time=end_time)

        mock_redis_client.zrangebyscore.return_value = [
            json.dumps({"value": 85.5, "timestamp": start_time.timestamp()}).encode()
        ]

        # When
        result = memory_instance.query_time_window(query, reader_credentials)

        # Then
        assert len(result) == 1
        assert result[0]["value"] == 85.5

    def test_given_reader_tier_when_add_time_series_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given reader tier, when adding to time series, then raises PermissionError."""
        # Given
        key = "metrics:cpu"
        data = {"value": 85.5}

        # When/Then
        with pytest.raises(PermissionError, match="requires CONTRIBUTOR or ADMIN"):
            memory_instance.add_time_series(key, data, reader_credentials)


# ============================================================================
# Task Queue Tests
# ============================================================================


class TestTaskQueue:
    """Test suite for task queue operations."""

    def test_given_task_when_enqueue_task_then_adds_to_queue(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given task, when enqueuing, then adds to queue."""
        # Given
        queue_name = "tasks:pending"
        task = {"task_id": "123", "action": "process"}
        mock_redis_client.lpush.return_value = 1

        # When
        result = memory_instance.enqueue_task(queue_name, task, contributor_credentials)

        # Then
        assert result is True
        mock_redis_client.lpush.assert_called_once()

    def test_given_queue_when_dequeue_task_then_removes_and_returns_task(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given queue, when dequeuing, then removes and returns task."""
        # Given
        queue_name = "tasks:pending"
        task_data = {"task_id": "123", "action": "process"}
        mock_redis_client.rpop.return_value = json.dumps(task_data).encode()

        # When
        result = memory_instance.dequeue_task(queue_name, contributor_credentials)

        # Then
        assert result == task_data
        mock_redis_client.rpop.assert_called_once_with(queue_name)

    def test_given_empty_queue_when_dequeue_task_then_returns_none(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given empty queue, when dequeuing, then returns None."""
        # Given
        queue_name = "tasks:pending"
        mock_redis_client.rpop.return_value = None

        # When
        result = memory_instance.dequeue_task(queue_name, contributor_credentials)

        # Then
        assert result is None

    def test_given_queue_when_get_queue_length_then_returns_count(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given queue, when getting length, then returns count."""
        # Given
        queue_name = "tasks:pending"
        mock_redis_client.llen.return_value = 5

        # When
        result = memory_instance.get_queue_length(queue_name, reader_credentials)

        # Then
        assert result == 5


# ============================================================================
# Pattern Staging Tests
# ============================================================================


class TestPatternStaging:
    """Test suite for pattern staging operations."""

    def test_given_pattern_when_stage_pattern_then_stores_in_staging(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given pattern, when staging, then stores in staging area."""
        # Given
        pattern_data = {"name": "test_pattern", "rules": []}
        mock_redis_client.set.return_value = True

        # When
        pattern_id = memory_instance.stage_pattern(pattern_data, contributor_credentials)

        # Then
        assert pattern_id is not None
        assert pattern_id.startswith("pattern:")

    def test_given_staged_pattern_when_retrieve_staged_pattern_then_returns_pattern(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given staged pattern, when retrieving, then returns pattern."""
        # Given
        pattern_id = "pattern:123"
        pattern_data = {"name": "test_pattern", "rules": []}
        staged = StagedPattern(
            pattern_id=pattern_id,
            data=pattern_data,
            author=contributor_credentials.agent_id,
            staged_at=datetime.now(),
            status="pending",
        )
        mock_redis_client.get.return_value = json.dumps(staged.__dict__, default=str).encode()

        # When
        result = memory_instance.retrieve_staged_pattern(pattern_id, reader_credentials)

        # Then
        assert result is not None
        assert result["pattern_id"] == pattern_id

    def test_given_pattern_when_approve_pattern_then_updates_status(
        self, memory_instance, admin_credentials, mock_redis_client
    ):
        """Given pattern, when approving, then updates status."""
        # Given
        pattern_id = "pattern:123"
        pattern_data = {"name": "test_pattern", "rules": []}
        staged = StagedPattern(
            pattern_id=pattern_id,
            data=pattern_data,
            author="contributor",
            staged_at=datetime.now(),
            status="pending",
        )
        mock_redis_client.get.return_value = json.dumps(staged.__dict__, default=str).encode()
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.approve_pattern(pattern_id, admin_credentials)

        # Then
        assert result is True

    def test_given_non_admin_when_approve_pattern_then_raises_permission_error(
        self, memory_instance, contributor_credentials
    ):
        """Given non-admin, when approving pattern, then raises PermissionError."""
        # Given
        pattern_id = "pattern:123"

        # When/Then
        with pytest.raises(PermissionError, match="requires ADMIN"):
            memory_instance.approve_pattern(pattern_id, contributor_credentials)

    def test_given_pattern_when_reject_pattern_then_updates_status(
        self, memory_instance, admin_credentials, mock_redis_client
    ):
        """Given pattern, when rejecting, then updates status."""
        # Given
        pattern_id = "pattern:123"
        pattern_data = {"name": "test_pattern", "rules": []}
        staged = StagedPattern(
            pattern_id=pattern_id,
            data=pattern_data,
            author="contributor",
            staged_at=datetime.now(),
            status="pending",
        )
        mock_redis_client.get.return_value = json.dumps(staged.__dict__, default=str).encode()
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.reject_pattern(pattern_id, admin_credentials, "reason")

        # Then
        assert result is True


# ============================================================================
# Conflict Context Tests
# ============================================================================


class TestConflictContext:
    """Test suite for conflict context operations."""

    def test_given_conflict_when_store_conflict_context_then_stores_successfully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given conflict, when storing context, then stores successfully."""
        # Given
        context = ConflictContext(
            conflict_id="conflict:123",
            agents=["agent1", "agent2"],
            proposed_resolutions=[{"option": 1}],
            negotiation_round=1,
            created_at=datetime.now(),
        )
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.store_conflict_context(context, contributor_credentials)

        # Then
        assert result is True

    def test_given_conflict_id_when_retrieve_conflict_context_then_returns_context(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given conflict ID, when retrieving context, then returns context."""
        # Given
        conflict_id = "conflict:123"
        context = ConflictContext(
            conflict_id=conflict_id,
            agents=["agent1", "agent2"],
            proposed_resolutions=[],
            negotiation_round=1,
            created_at=datetime.now(),
        )
        mock_redis_client.get.return_value = json.dumps(context.__dict__, default=str).encode()

        # When
        result = memory_instance.retrieve_conflict_context(conflict_id, reader_credentials)

        # Then
        assert result is not None
        assert result["conflict_id"] == conflict_id


# ============================================================================
# Agent Working Memory Tests
# ============================================================================


class TestAgentWorkingMemory:
    """Test suite for agent working memory operations."""

    def test_given_agent_data_when_set_agent_state_then_stores_state(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given agent data, when setting state, then stores state."""
        # Given
        agent_id = "agent_1"
        state = {"current_task": "analysis", "progress": 50}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.set_agent_state(agent_id, state, contributor_credentials)

        # Then
        assert result is True

    def test_given_agent_id_when_get_agent_state_then_returns_state(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given agent ID, when getting state, then returns state."""
        # Given
        agent_id = "agent_1"
        state = {"current_task": "analysis", "progress": 50}
        mock_redis_client.get.return_value = json.dumps(state).encode()

        # When
        result = memory_instance.get_agent_state(agent_id, reader_credentials)

        # Then
        assert result == state

    def test_given_agent_id_when_clear_agent_state_then_deletes_state(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given agent ID, when clearing state, then deletes state."""
        # Given
        agent_id = "agent_1"
        mock_redis_client.delete.return_value = 1

        # When
        result = memory_instance.clear_agent_state(agent_id, contributor_credentials)

        # Then
        assert result is True


# ============================================================================
# Metrics Tests
# ============================================================================


class TestMetrics:
    """Test suite for metrics operations."""

    def test_given_operations_when_get_metrics_then_returns_metrics(
        self, memory_instance, admin_credentials
    ):
        """Given operations, when getting metrics, then returns metrics."""
        # Given
        memory_instance.metrics.total_requests = 100
        memory_instance.metrics.cache_hits = 80
        memory_instance.metrics.cache_misses = 20

        # When
        result = memory_instance.get_metrics(admin_credentials)

        # Then
        assert isinstance(result, RedisMetrics)
        assert result.total_requests == 100
        assert result.cache_hits == 80

    def test_given_non_admin_when_get_metrics_then_raises_permission_error(
        self, memory_instance, reader_credentials
    ):
        """Given non-admin, when getting metrics, then raises PermissionError."""
        # When/Then
        with pytest.raises(PermissionError, match="requires ADMIN"):
            memory_instance.get_metrics(reader_credentials)

    def test_given_metrics_when_reset_metrics_then_clears_metrics(
        self, memory_instance, admin_credentials
    ):
        """Given metrics, when resetting, then clears metrics."""
        # Given
        memory_instance.metrics.total_requests = 100

        # When
        memory_instance.reset_metrics(admin_credentials)

        # Then
        assert memory_instance.metrics.total_requests == 0


# ============================================================================
# Transaction Tests
# ============================================================================


class TestTransactions:
    """Test suite for transaction operations."""

    def test_given_operations_when_execute_transaction_then_runs_atomically(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given operations, when executing transaction, then runs atomically."""
        # Given
        operations = [
            ("set", "key1", {"value": 1}),
            ("set", "key2", {"value": 2}),
        ]
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.return_value = [True, True]

        # When
        result = memory_instance.execute_transaction(operations, contributor_credentials)

        # Then
        assert result is True
        mock_pipeline.multi.assert_called_once()
        mock_pipeline.execute.assert_called_once()

    def test_given_failed_operation_when_execute_transaction_then_rolls_back(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given failed operation, when executing transaction, then rolls back."""
        # Given
        operations = [("set", "key1", {"value": 1})]
        mock_pipeline = MagicMock()
        mock_redis_client.pipeline.return_value = mock_pipeline
        mock_pipeline.execute.side_effect = Exception("Transaction failed")

        # When
        result = memory_instance.execute_transaction(operations, contributor_credentials)

        # Then
        assert result is False


# ============================================================================
# Connection Retry Tests
# ============================================================================


class TestConnectionRetry:
    """Test suite for connection retry logic."""

    def test_given_connection_timeout_when_retry_then_reconnects(
        self, redis_config, mock_redis_client
    ):
        """Given connection timeout, when retrying, then reconnects."""
        # Given
        mock_redis_client.ping.side_effect = [
            Exception("Timeout"),
            Exception("Timeout"),
            True,
        ]

        # When
        with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_redis_client):
            with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
                with patch("empathy_os.memory.short_term.time.sleep"):
                    memory = RedisShortTermMemory(config=redis_config)

        # Then
        assert memory.client is not None

    def test_given_max_retries_exceeded_when_retry_then_raises_error(self, redis_config):
        """Given max retries exceeded, when retrying, then raises error."""
        # Given
        mock_client = MagicMock()
        mock_client.ping.side_effect = Exception("Connection failed")

        # When/Then
        with patch("empathy_os.memory.short_term.redis.Redis", return_value=mock_client):
            with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
                with patch("empathy_os.memory.short_term.time.sleep"):
                    with pytest.raises(ConnectionError):
                        RedisShortTermMemory(config=redis_config)


# ============================================================================
# Cleanup Tests
# ============================================================================


class TestCleanup:
    """Test suite for cleanup operations."""

    def test_given_memory_instance_when_close_then_closes_connections(
        self, memory_instance, mock_redis_client
    ):
        """Given memory instance, when closing, then closes connections."""
        # When
        memory_instance.close()

        # Then
        mock_redis_client.close.assert_called_once()

    def test_given_pubsub_listeners_when_close_then_stops_listeners(
        self, memory_instance, reader_credentials, mock_redis_client
    ):
        """Given pub/sub listeners, when closing, then stops listeners."""
        # Given
        channel = "test_channel"
        callback = MagicMock()
        mock_pubsub = MagicMock()
        mock_redis_client.pubsub.return_value = mock_pubsub
        memory_instance.subscribe(channel, callback, reader_credentials)

        # When
        memory_instance.close()

        # Then
        mock_pubsub.close.assert_called()


# ============================================================================
# Edge Cases and Error Handling
# ============================================================================


class TestEdgeCases:
    """Test suite for edge cases and error handling."""

    def test_given_empty_data_when_stash_then_handles_gracefully(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given empty data, when stashing, then handles gracefully."""
        # Given
        key = "test_key"
        data = {}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True

    def test_given_none_data_when_stash_then_handles_gracefully(
        self, memory_instance, contributor_credentials
    ):
        """Given None data, when stashing, then handles gracefully."""
        # Given
        key = "test_key"
        data = None

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is False

    def test_given_special_characters_in_key_when_stash_then_handles_correctly(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given special characters in key, when stashing, then handles correctly."""
        # Given
        key = "test:key:with:colons"
        data = {"value": "test"}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True

    def test_given_large_data_when_stash_then_handles_correctly(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given large data, when stashing, then handles correctly."""
        # Given
        key = "test_key"
        data = {"values": [i for i in range(10000)]}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True

    def test_given_nested_data_when_stash_then_serializes_correctly(
        self, memory_instance, contributor_credentials, mock_redis_client
    ):
        """Given nested data, when stashing, then serializes correctly."""
        # Given
        key = "test_key"
        data = {"level1": {"level2": {"level3": "value"}}}
        mock_redis_client.set.return_value = True

        # When
        result = memory_instance.stash(key, data, contributor_credentials)

        # Then
        assert result is True
