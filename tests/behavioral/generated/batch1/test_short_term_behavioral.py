"""Behavioral tests for short_term.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import time
from datetime import datetime, timedelta
from typing import Any
from unittest.mock import MagicMock, Mock, patch, call

import pytest

from empathy_os.memory.short_term import RedisShortTermMemory, REDIS_AVAILABLE
from empathy_os.memory.types import (
    AccessTier,
    AgentCredentials,
    ConflictContext,
    PaginatedResult,
    RedisConfig,
    RedisMetrics,
    SecurityError,
    StagedPattern,
    TimeWindowQuery,
    TTLStrategy,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def mock_redis():
    """Provide a mock Redis client."""
    with patch("empathy_os.memory.short_term.redis") as mock_redis_module:
        mock_client = MagicMock()
        mock_redis_module.Redis.return_value = mock_client
        mock_redis_module.ConnectionPool.return_value = MagicMock()
        yield mock_client


@pytest.fixture
def mock_redis_unavailable():
    """Simulate Redis not being available."""
    with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", False):
        yield


@pytest.fixture
def redis_config():
    """Provide a standard Redis configuration."""
    return RedisConfig(
        host="localhost",
        port=6379,
        db=0,
        password=None,
        ssl=False,
        socket_timeout=5.0,
        socket_connect_timeout=5.0,
        retry_on_timeout=True,
        max_connections=10,
    )


@pytest.fixture
def agent_creds():
    """Provide standard agent credentials."""
    return AgentCredentials(agent_id="test_agent", tier=AccessTier.CONTRIBUTOR)


@pytest.fixture
def admin_creds():
    """Provide admin credentials."""
    return AgentCredentials(agent_id="admin_agent", tier=AccessTier.ADMIN)


@pytest.fixture
def guest_creds():
    """Provide guest credentials."""
    return AgentCredentials(agent_id="guest_agent", tier=AccessTier.GUEST)


@pytest.fixture
def memory_instance(mock_redis, redis_config):
    """Provide a configured RedisShortTermMemory instance."""
    with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
        memory = RedisShortTermMemory(config=redis_config)
        return memory


@pytest.fixture
def mock_pii_scrubber():
    """Mock PII scrubber."""
    with patch("empathy_os.memory.short_term.PIIScrubber") as mock:
        scrubber_instance = MagicMock()
        scrubber_instance.scrub.return_value = ("scrubbed_data", [])
        mock.return_value = scrubber_instance
        yield scrubber_instance


@pytest.fixture
def mock_secrets_detector():
    """Mock secrets detector."""
    with patch("empathy_os.memory.short_term.SecretsDetector") as mock:
        detector_instance = MagicMock()
        detector_instance.scan.return_value = []
        mock.return_value = detector_instance
        yield detector_instance


# ============================================================================
# Initialization Tests
# ============================================================================


class TestRedisShortTermMemoryInitialization:
    """Test initialization and configuration of RedisShortTermMemory."""

    def test_given_redis_available_when_initialize_then_creates_client(
        self, mock_redis, redis_config
    ):
        """Given Redis is available, when initializing, then creates Redis client."""
        # Given
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
            # When
            memory = RedisShortTermMemory(config=redis_config)

            # Then
            assert memory._client is not None
            assert memory._config == redis_config

    def test_given_redis_unavailable_when_initialize_then_raises_import_error(
        self, redis_config
    ):
        """Given Redis is unavailable, when initializing, then raises ImportError."""
        # Given
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", False):
            # When/Then
            with pytest.raises(ImportError, match="redis.*not installed"):
                RedisShortTermMemory(config=redis_config)

    def test_given_default_config_when_initialize_then_uses_defaults(self, mock_redis):
        """Given no config, when initializing, then uses default configuration."""
        # Given/When
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
            memory = RedisShortTermMemory()

            # Then
            assert memory._config.host == "localhost"
            assert memory._config.port == 6379
            assert memory._config.db == 0

    def test_given_ssl_config_when_initialize_then_enables_ssl(self, mock_redis):
        """Given SSL config, when initializing, then enables SSL."""
        # Given
        config = RedisConfig(
            host="secure.redis.com",
            port=6380,
            ssl=True,
            ssl_cert_reqs="required",
            ssl_ca_certs="/path/to/ca.pem",
        )

        # When
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
            memory = RedisShortTermMemory(config=config)

            # Then
            assert memory._config.ssl is True

    def test_given_custom_ttl_strategy_when_initialize_then_stores_strategy(
        self, mock_redis
    ):
        """Given custom TTL strategy, when initializing, then stores it."""
        # Given
        ttl_strategy = TTLStrategy(
            default_ttl=600,
            pattern_staging_ttl=300,
            working_memory_ttl=60,
            conflict_context_ttl=1800,
        )

        # When
        with patch("empathy_os.memory.short_term.REDIS_AVAILABLE", True):
            memory = RedisShortTermMemory(ttl_strategy=ttl_strategy)

            # Then
            assert memory._ttl_strategy == ttl_strategy


# ============================================================================
# Stash/Retrieve Tests
# ============================================================================


class TestStashRetrieve:
    """Test basic stash and retrieve operations."""

    def test_given_valid_data_when_stash_then_stores_in_redis(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given valid data, when stashing, then stores in Redis."""
        # Given
        key = "test_key"
        data = {"value": "test_data"}

        # When
        memory_instance.stash(key, data, agent_creds)

        # Then
        mock_redis.setex.assert_called_once()
        call_args = mock_redis.setex.call_args
        assert key in call_args[0][0]
        assert call_args[0][1] == 300  # default TTL

    def test_given_custom_ttl_when_stash_then_uses_custom_ttl(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given custom TTL, when stashing, then uses custom TTL."""
        # Given
        key = "test_key"
        data = {"value": "test_data"}
        custom_ttl = 600

        # When
        memory_instance.stash(key, data, agent_creds, ttl=custom_ttl)

        # Then
        call_args = mock_redis.setex.call_args
        assert call_args[0][1] == custom_ttl

    def test_given_stored_data_when_retrieve_then_returns_data(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given stored data, when retrieving, then returns data."""
        # Given
        key = "test_key"
        stored_data = {"value": "test_data"}
        mock_redis.get.return_value = json.dumps(stored_data).encode()

        # When
        result = memory_instance.retrieve(key, agent_creds)

        # Then
        assert result == stored_data
        mock_redis.get.assert_called_once()

    def test_given_nonexistent_key_when_retrieve_then_returns_none(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given nonexistent key, when retrieving, then returns None."""
        # Given
        key = "nonexistent_key"
        mock_redis.get.return_value = None

        # When
        result = memory_instance.retrieve(key, agent_creds)

        # Then
        assert result is None

    def test_given_guest_tier_when_stash_then_raises_security_error(
        self, memory_instance, guest_creds
    ):
        """Given guest tier, when stashing, then raises SecurityError."""
        # Given
        key = "test_key"
        data = {"value": "test_data"}

        # When/Then
        with pytest.raises(SecurityError, match="insufficient.*access"):
            memory_instance.stash(key, data, guest_creds)

    def test_given_invalid_json_when_retrieve_then_handles_gracefully(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given invalid JSON, when retrieving, then handles gracefully."""
        # Given
        key = "test_key"
        mock_redis.get.return_value = b"invalid json {"

        # When
        result = memory_instance.retrieve(key, agent_creds)

        # Then
        assert result is None

    def test_given_serializable_data_when_stash_then_serializes_correctly(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given complex serializable data, when stashing, then serializes correctly."""
        # Given
        key = "test_key"
        data = {
            "string": "value",
            "number": 42,
            "list": [1, 2, 3],
            "nested": {"inner": "value"},
        }

        # When
        memory_instance.stash(key, data, agent_creds)

        # Then
        call_args = mock_redis.setex.call_args
        stored_json = call_args[0][2]
        assert json.loads(stored_json) == data


# ============================================================================
# Batch Operations Tests
# ============================================================================


class TestBatchOperations:
    """Test batch stash and retrieve operations."""

    def test_given_multiple_items_when_stash_batch_then_stores_all(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given multiple items, when batch stashing, then stores all."""
        # Given
        items = [
            ("key1", {"data": 1}),
            ("key2", {"data": 2}),
            ("key3", {"data": 3}),
        ]

        # When
        memory_instance.stash_batch(items, agent_creds)

        # Then
        assert mock_redis.setex.call_count == 3

    def test_given_multiple_keys_when_retrieve_batch_then_returns_all(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given multiple keys, when batch retrieving, then returns all."""
        # Given
        keys = ["key1", "key2", "key3"]
        mock_redis.get.side_effect = [
            json.dumps({"data": 1}).encode(),
            json.dumps({"data": 2}).encode(),
            json.dumps({"data": 3}).encode(),
        ]

        # When
        results = memory_instance.retrieve_batch(keys, agent_creds)

        # Then
        assert len(results) == 3
        assert results["key1"] == {"data": 1}
        assert results["key2"] == {"data": 2}
        assert results["key3"] == {"data": 3}

    def test_given_empty_list_when_stash_batch_then_does_nothing(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given empty list, when batch stashing, then does nothing."""
        # Given
        items = []

        # When
        memory_instance.stash_batch(items, agent_creds)

        # Then
        mock_redis.setex.assert_not_called()

    def test_given_some_missing_keys_when_retrieve_batch_then_returns_available(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given some missing keys, when batch retrieving, then returns available."""
        # Given
        keys = ["key1", "key2", "key3"]
        mock_redis.get.side_effect = [
            json.dumps({"data": 1}).encode(),
            None,
            json.dumps({"data": 3}).encode(),
        ]

        # When
        results = memory_instance.retrieve_batch(keys, agent_creds)

        # Then
        assert len(results) == 2
        assert "key1" in results
        assert "key2" not in results
        assert "key3" in results


# ============================================================================
# Pattern Staging Tests
# ============================================================================


class TestPatternStaging:
    """Test pattern staging workflow."""

    def test_given_valid_pattern_when_stage_pattern_then_stores_staged(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given valid pattern, when staging, then stores as staged."""
        # Given
        pattern_id = "pattern_123"
        pattern_data = {"type": "analysis", "confidence": 0.85}

        # When
        memory_instance.stage_pattern(pattern_id, pattern_data, agent_creds)

        # Then
        mock_redis.setex.assert_called_once()
        call_args = mock_redis.setex.call_args
        assert "staged_pattern:" in call_args[0][0]

    def test_given_staged_pattern_when_retrieve_staged_then_returns_pattern(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given staged pattern, when retrieving staged, then returns pattern."""
        # Given
        pattern_id = "pattern_123"
        pattern_data = {"type": "analysis", "confidence": 0.85}
        mock_redis.get.return_value = json.dumps(
            {
                "pattern_id": pattern_id,
                "data": pattern_data,
                "staged_by": agent_creds.agent_id,
                "staged_at": datetime.now().isoformat(),
            }
        ).encode()

        # When
        result = memory_instance.retrieve_staged_pattern(pattern_id, agent_creds)

        # Then
        assert result is not None
        assert result["pattern_id"] == pattern_id
        assert result["data"] == pattern_data

    def test_given_nonexistent_staged_pattern_when_retrieve_then_returns_none(
        self, memory_instance, mock_redis, agent_creds
    ):
        """Given nonexistent staged pattern, when retrieving, then returns None."""
        # Given
        pattern_id = "nonexistent"
        mock_redis.get.return_value = None

        # When
        result = memory_instance.retrieve_staged_pattern(pattern_id, agent_creds)

        # Then
        assert result is None

    def test_given_admin_tier_when_list_staged_patterns_then_returns_list(