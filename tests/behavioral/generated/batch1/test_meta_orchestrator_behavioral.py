"""Behavioral tests for meta_orchestrator.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from dataclasses import dataclass, field
from unittest.mock import patch

import pytest

from attune.orchestration.meta_orchestrator import (
    CompositionPattern,
    ExecutionPlan,
    MetaOrchestrator,
    TaskComplexity,
    TaskDomain,
    TaskRequirements,
)


@dataclass
class MockAgentTemplate:
    """Mock agent template for testing."""

    id: str  # Added to match AgentTemplate.id
    role: str
    capabilities: list[str] = field(default_factory=list)
    tier_preference: str = "CAPABLE"  # Added to match AgentTemplate
    tools: list[str] = field(default_factory=list)  # Added to match AgentTemplate
    default_instructions: str = "Default instructions"  # Added to match AgentTemplate
    quality_gates: dict = field(default_factory=dict)  # Added to match AgentTemplate

    @property
    def resource_requirements(self):
        """Mock resource requirements."""
        from attune.orchestration.agent_templates import ResourceRequirements

        return ResourceRequirements()


@pytest.fixture
def mock_agent_templates():
    """Provide mock agent templates for testing."""
    return {
        "test_coverage_expert": MockAgentTemplate(
            id="test_coverage_expert",
            role="Test Coverage Expert",
            capabilities=["testing", "coverage_analysis"],
        ),
        "test_generator": MockAgentTemplate(
            id="test_generator",
            role="Test Generation Specialist",
            capabilities=["testing", "code_generation"],
        ),
        "qa_validator": MockAgentTemplate(
            id="qa_validator",
            role="Quality Assurance Validator",
            capabilities=["testing", "validation"],
        ),
        "security_analyzer": MockAgentTemplate(
            id="security_analyzer",
            role="Security Analyzer",
            capabilities=["security", "vulnerability_detection"],
        ),
        "code_reviewer": MockAgentTemplate(
            id="code_reviewer",
            role="Code Reviewer",
            capabilities=["code_quality", "review"],
        ),
    }


@pytest.fixture
def orchestrator():
    """Provide a MetaOrchestrator instance for testing."""
    return MetaOrchestrator()


class TestTaskComplexityEnum:
    """Test TaskComplexity enumeration."""

    def test_given_simple_complexity_when_accessing_value_then_returns_correct_string(self):
        """Test SIMPLE complexity has correct value."""
        # Given/When
        complexity = TaskComplexity.SIMPLE

        # Then
        assert complexity.value == "simple"

    def test_given_moderate_complexity_when_accessing_value_then_returns_correct_string(self):
        """Test MODERATE complexity has correct value."""
        # Given/When
        complexity = TaskComplexity.MODERATE

        # Then
        assert complexity.value == "moderate"

    def test_given_complex_complexity_when_accessing_value_then_returns_correct_string(self):
        """Test COMPLEX complexity has correct value."""
        # Given/When
        complexity = TaskComplexity.COMPLEX

        # Then
        assert complexity.value == "complex"


class TestTaskDomainEnum:
    """Test TaskDomain enumeration."""

    def test_given_testing_domain_when_accessing_value_then_returns_correct_string(self):
        """Test TESTING domain has correct value."""
        # Given/When
        domain = TaskDomain.TESTING

        # Then
        assert domain.value == "testing"

    def test_given_security_domain_when_accessing_value_then_returns_correct_string(self):
        """Test SECURITY domain has correct value."""
        # Given/When
        domain = TaskDomain.SECURITY

        # Then
        assert domain.value == "security"

    def test_given_all_domains_when_iterating_then_contains_expected_domains(self):
        """Test all expected domains are present."""
        # Given
        expected_domains = {
            "testing",
            "security",
            "code_quality",
            "documentation",
            "performance",
            "architecture",
            "refactoring",
            "general",
        }

        # When
        actual_domains = {domain.value for domain in TaskDomain}

        # Then
        assert actual_domains == expected_domains


class TestCompositionPatternEnum:
    """Test CompositionPattern enumeration."""

    def test_given_sequential_pattern_when_accessing_value_then_returns_correct_string(self):
        """Test SEQUENTIAL pattern has correct value."""
        # Given/When
        pattern = CompositionPattern.SEQUENTIAL

        # Then
        assert pattern.value == "sequential"

    def test_given_parallel_pattern_when_accessing_value_then_returns_correct_string(self):
        """Test PARALLEL pattern has correct value."""
        # Given/When
        pattern = CompositionPattern.PARALLEL

        # Then
        assert pattern.value == "parallel"

    def test_given_debate_pattern_when_accessing_value_then_returns_correct_string(self):
        """Test DEBATE pattern has correct value."""
        # Given/When
        pattern = CompositionPattern.DEBATE

        # Then
        assert pattern.value == "debate"

    def test_given_tool_enhanced_pattern_when_accessing_value_then_returns_correct_string(self):
        """Test TOOL_ENHANCED pattern has correct value."""
        # Given/When
        pattern = CompositionPattern.TOOL_ENHANCED

        # Then
        assert pattern.value == "tool_enhanced"

    def test_given_all_patterns_when_counting_then_has_ten_patterns(self):
        """Test all 10 patterns are present."""
        # Given/When
        patterns = list(CompositionPattern)

        # Then
        assert len(patterns) == 10


class TestTaskRequirements:
    """Test TaskRequirements dataclass."""

    def test_given_minimal_requirements_when_creating_then_initializes_correctly(self):
        """Test TaskRequirements creation with minimal parameters."""
        # Given
        complexity = TaskComplexity.SIMPLE
        domain = TaskDomain.TESTING
        capabilities = ["testing"]

        # When
        requirements = TaskRequirements(
            complexity=complexity,
            domain=domain,
            capabilities_needed=capabilities,
        )

        # Then
        assert requirements.complexity == complexity
        assert requirements.domain == domain
        assert requirements.capabilities_needed == capabilities
        assert requirements.parallelizable is False
        assert requirements.quality_gates == {}
        assert requirements.context == {}

    def test_given_full_requirements_when_creating_then_initializes_all_fields(self):
        """Test TaskRequirements creation with all parameters."""
        # Given
        complexity = TaskComplexity.COMPLEX
        domain = TaskDomain.SECURITY
        capabilities = ["security", "analysis"]
        quality_gates = {"coverage": 90}
        context = {"current_coverage": 75}

        # When
        requirements = TaskRequirements(
            complexity=complexity,
            domain=domain,
            capabilities_needed=capabilities,
            parallelizable=True,
            quality_gates=quality_gates,
            context=context,
        )

        # Then
        assert requirements.complexity == complexity
        assert requirements.domain == domain
        assert requirements.capabilities_needed == capabilities
        assert requirements.parallelizable is True
        assert requirements.quality_gates == quality_gates
        assert requirements.context == context

    def test_given_requirements_when_modifying_defaults_then_does_not_share_state(self):
        """Test that default factory creates independent instances."""
        # Given
        req1 = TaskRequirements(
            complexity=TaskComplexity.SIMPLE,
            domain=TaskDomain.TESTING,
            capabilities_needed=["testing"],
        )
        req2 = TaskRequirements(
            complexity=TaskComplexity.SIMPLE,
            domain=TaskDomain.TESTING,
            capabilities_needed=["testing"],
        )

        # When
        req1.quality_gates["key"] = "value1"
        req2.quality_gates["key"] = "value2"

        # Then
        assert req1.quality_gates["key"] == "value1"
        assert req2.quality_gates["key"] == "value2"


class TestExecutionPlan:
    """Test ExecutionPlan dataclass."""

    def test_given_minimal_plan_when_creating_then_initializes_correctly(self):
        """Test ExecutionPlan creation with minimal parameters."""
        # Given
        strategy = CompositionPattern.SEQUENTIAL
        agents = []

        # When
        plan = ExecutionPlan(
            strategy=strategy,
            agents=agents,
        )

        # Then
        assert plan.strategy == strategy
        assert plan.agents == agents

    def test_given_plan_with_agents_when_creating_then_stores_agents(self):
        """Test ExecutionPlan stores agents correctly."""
        # Given
        strategy = CompositionPattern.PARALLEL
        agent1 = MockAgentTemplate(id="agent1", role="Role 1")
        agent2 = MockAgentTemplate(id="agent2", role="Role 2")
        agents = [agent1, agent2]

        # When
        plan = ExecutionPlan(
            strategy=strategy,
            agents=agents,
        )

        # Then
        assert len(plan.agents) == 2
        assert plan.agents[0].id == "agent1"
        assert plan.agents[1].id == "agent2"


class TestMetaOrchestratorInitialization:
    """Test MetaOrchestrator initialization."""

    def test_given_no_parameters_when_creating_orchestrator_then_initializes_successfully(self):
        """Test MetaOrchestrator can be instantiated."""
        # Given/When
        orchestrator = MetaOrchestrator()

        # Then
        assert orchestrator is not None
        assert isinstance(orchestrator, MetaOrchestrator)


class TestMetaOrchestratorAnalyzeAndCompose:
    """Test MetaOrchestrator.analyze_and_compose method."""

    @patch("attune.orchestration.meta_orchestrator.get_templates_by_capability")
    @patch("attune.orchestration.meta_orchestrator.get_template")
    def test_given_simple_testing_task_when_analyzing_then_returns_sequential_plan(
        self, mock_get_template, mock_get_templates, orchestrator, mock_agent_templates
    ):
        """Test simple testing task returns sequential execution plan."""
        # Given
        mock_get_templates.return_value = [
            mock_agent_templates["test_coverage_expert"],
            mock_agent_templates["test_generator"],
        ]
        mock_get_template.side_effect = lambda name: mock_agent_templates.get(name)

        task = "Boost test coverage to 90%"
        context = {"current_coverage": 75}

        # When
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.TESTING,
                capabilities_needed=["testing"],
                context=context,
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.SEQUENTIAL
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = [
                        mock_agent_templates["test_coverage_expert"],
                        mock_agent_templates["test_generator"],
                    ]
                    plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None
        assert plan.strategy == CompositionPattern.SEQUENTIAL

    @patch("attune.orchestration.meta_orchestrator.get_templates_by_capability")
    def test_given_complex_security_task_when_analyzing_then_returns_appropriate_plan(
        self, mock_get_templates, orchestrator, mock_agent_templates
    ):
        """Test complex security task returns appropriate execution plan."""
        # Given
        mock_get_templates.return_value = [
            mock_agent_templates["security_analyzer"],
        ]

        task = "Perform comprehensive security audit"
        context = {"scope": "full_codebase"}

        # When
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.COMPLEX,
                domain=TaskDomain.SECURITY,
                capabilities_needed=["security", "analysis"],
                context=context,
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.DEBATE
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = [
                        mock_agent_templates["security_analyzer"],
                    ]
                    plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None
        assert plan.strategy == CompositionPattern.DEBATE

    def test_given_empty_task_when_analyzing_then_raises_value_error(self, orchestrator):
        """Test empty task string raises ValueError."""
        # Given
        task = ""
        context = {}

        # When/Then
        with pytest.raises(ValueError, match="task must be a non-empty string"):
            orchestrator.analyze_and_compose(task, context)

    def test_given_none_context_when_analyzing_then_handles_gracefully(self, orchestrator):
        """Test None context is handled gracefully."""
        # Given
        task = "Test task"
        context = None

        # When/Then
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=[],
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.SEQUENTIAL
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = []
                    plan = orchestrator.analyze_and_compose(task, context or {})
                    assert plan is not None


class TestMetaOrchestratorAnalyzeTask:
    """Test MetaOrchestrator._analyze_task private method."""

    def test_given_testing_keywords_when_analyzing_then_identifies_testing_domain(
        self, orchestrator
    ):
        """Test task with testing keywords identified as testing domain."""
        # Given
        task = "Improve test coverage and add unit tests"
        context = {}

        # When
        with patch.object(orchestrator, "_analyze_task", wraps=orchestrator._analyze_task):
            requirements = orchestrator._analyze_task(task, context)

        # Then
        assert requirements.domain == TaskDomain.TESTING

    def test_given_security_keywords_when_analyzing_then_identifies_security_domain(
        self, orchestrator
    ):
        """Test task with security keywords identified as security domain."""
        # Given
        task = "Audit security vulnerabilities and fix exploits"
        context = {}

        # When
        requirements = orchestrator._analyze_task(task, context)

        # Then
        assert requirements.domain == TaskDomain.SECURITY

    def test_given_complex_task_when_analyzing_then_identifies_complex_complexity(
        self, orchestrator
    ):
        """Test complex task identified correctly."""
        # Given
        task = "Refactor entire architecture, improve performance, add security, and update documentation"
        context = {}

        # When
        requirements = orchestrator._analyze_task(task, context)

        # Then
        assert requirements.complexity in [TaskComplexity.MODERATE, TaskComplexity.COMPLEX]

    def test_given_simple_task_when_analyzing_then_identifies_simple_complexity(self, orchestrator):
        """Test simple task identified correctly."""
        # Given
        task = "Format code"  # Uses 'format' keyword which is in SIMPLE category
        context = {}

        # When
        requirements = orchestrator._analyze_task(task, context)

        # Then
        assert requirements.complexity == TaskComplexity.SIMPLE

    def test_given_task_with_context_when_analyzing_then_includes_context(self, orchestrator):
        """Test context is preserved in requirements."""
        # Given
        task = "Boost coverage"
        context = {"current_coverage": 50, "target": 90}

        # When
        requirements = orchestrator._analyze_task(task, context)

        # Then
        assert requirements.context == context
        assert "current_coverage" in requirements.context


class TestMetaOrchestratorSelectCompositionPattern:
    """Test MetaOrchestrator._choose_composition_pattern private method."""

    def test_given_simple_requirements_when_selecting_pattern_then_returns_sequential(
        self, orchestrator, mock_agent_templates
    ):
        """Test simple requirements return sequential pattern."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.SIMPLE,
            domain=TaskDomain.TESTING,
            capabilities_needed=["testing"],
        )
        agents = [mock_agent_templates["test_coverage_expert"]]

        # When
        pattern = orchestrator._choose_composition_pattern(requirements, agents)

        # Then
        assert pattern == CompositionPattern.SEQUENTIAL

    def test_given_parallelizable_requirements_when_selecting_pattern_then_returns_parallel(
        self, orchestrator, mock_agent_templates
    ):
        """Test parallelizable requirements return parallel pattern."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.MODERATE,
            domain=TaskDomain.TESTING,
            capabilities_needed=["testing"],
            parallelizable=True,
        )
        agents = [mock_agent_templates["test_coverage_expert"]]

        # When
        pattern = orchestrator._choose_composition_pattern(requirements, agents)

        # Then
        assert pattern == CompositionPattern.PARALLEL

    def test_given_complex_requirements_when_selecting_pattern_then_returns_advanced_pattern(
        self, orchestrator, mock_agent_templates
    ):
        """Test complex requirements return advanced pattern."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.COMPLEX,
            domain=TaskDomain.ARCHITECTURE,
            capabilities_needed=["architecture", "design"],
        )
        agents = [mock_agent_templates["security_analyzer"]]

        # When
        pattern = orchestrator._choose_composition_pattern(requirements, agents)

        # Then
        assert pattern in [
            CompositionPattern.PARALLEL,
            CompositionPattern.REFINEMENT,
            CompositionPattern.DELEGATION_CHAIN,
            CompositionPattern.ADAPTIVE,
        ]


class TestMetaOrchestratorSelectAgents:
    """Test MetaOrchestrator._select_agents private method."""

    @patch("attune.orchestration.meta_orchestrator.get_templates_by_capability")
    def test_given_testing_requirements_when_selecting_agents_then_returns_testing_agents(
        self, mock_get_templates, orchestrator, mock_agent_templates
    ):
        """Test testing requirements return testing agents."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.MODERATE,
            domain=TaskDomain.TESTING,
            capabilities_needed=["testing"],
        )
        mock_get_templates.return_value = [
            mock_agent_templates["test_coverage_expert"],
            mock_agent_templates["test_generator"],
        ]

        # When
        agents = orchestrator._select_agents(requirements)

        # Then
        assert len(agents) > 0
        assert any("test" in agent.role.lower() for agent in agents)

    @patch("attune.orchestration.meta_orchestrator.get_templates_by_capability")
    @patch("attune.orchestration.meta_orchestrator.get_template")
    def test_given_no_matching_agents_when_selecting_agents_then_returns_default_agent(
        self, mock_get_template, mock_get_templates, orchestrator, mock_agent_templates
    ):
        """Test no matching agents returns default agent for domain."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.SIMPLE,
            domain=TaskDomain.GENERAL,
            capabilities_needed=["nonexistent"],
        )
        mock_get_templates.return_value = []
        # Default agent for GENERAL domain is code_reviewer
        mock_get_template.return_value = mock_agent_templates["code_reviewer"]

        # When
        agents = orchestrator._select_agents(requirements)

        # Then
        assert len(agents) > 0  # Should return default agent
        assert agents[0].id == "code_reviewer"

    @patch("attune.orchestration.meta_orchestrator.get_templates_by_capability")
    def test_given_multiple_capabilities_when_selecting_agents_then_returns_diverse_agents(
        self, mock_get_templates, orchestrator, mock_agent_templates
    ):
        """Test multiple capabilities return diverse agents."""
        # Given
        requirements = TaskRequirements(
            complexity=TaskComplexity.COMPLEX,
            domain=TaskDomain.CODE_QUALITY,
            capabilities_needed=["testing", "security", "code_quality"],
        )
        mock_get_templates.side_effect = [
            [mock_agent_templates["test_generator"]],
            [mock_agent_templates["security_analyzer"]],
            [mock_agent_templates["code_reviewer"]],
        ]

        # When
        agents = orchestrator._select_agents(requirements)

        # Then
        assert len(agents) > 0


class TestMetaOrchestratorEdgeCases:
    """Test edge cases and error handling."""

    def test_given_very_long_task_when_analyzing_then_handles_gracefully(self, orchestrator):
        """Test very long task description is handled."""
        # Given
        task = "task " * 10000  # Very long task
        context = {}

        # When
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=[],
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.SEQUENTIAL
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = []
                    plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None

    def test_given_special_characters_in_task_when_analyzing_then_handles_gracefully(
        self, orchestrator
    ):
        """Test special characters in task are handled."""
        # Given
        task = 'Test @#$% special <>&" characters'
        context = {}

        # When
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=[],
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.SEQUENTIAL
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = []
                    plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None

    def test_given_unicode_task_when_analyzing_then_handles_gracefully(self, orchestrator):
        """Test unicode characters in task are handled."""
        # Given
        task = "测试 тест परीक्षण テスト"
        context = {}

        # When
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=[],
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.SEQUENTIAL
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = []
                    plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None

    def test_given_large_context_when_analyzing_then_handles_gracefully(self, orchestrator):
        """Test large context dictionary is handled."""
        # Given
        task = "Test task"
        context = {f"key_{i}": f"value_{i}" for i in range(1000)}

        # When
        with patch.object(orchestrator, "_analyze_task") as mock_analyze:
            mock_analyze.return_value = TaskRequirements(
                complexity=TaskComplexity.SIMPLE,
                domain=TaskDomain.GENERAL,
                capabilities_needed=[],
                context=context,
            )
            with patch.object(orchestrator, "_choose_composition_pattern") as mock_select:
                mock_select.return_value = CompositionPattern.SEQUENTIAL
                with patch.object(orchestrator, "_select_agents") as mock_select_agents:
                    mock_select_agents.return_value = []
                    plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None


class TestMetaOrchestratorIntegration:
    """Integration tests for MetaOrchestrator."""

    @patch("attune.orchestration.meta_orchestrator.get_templates_by_capability")
    @patch("attune.orchestration.meta_orchestrator.get_template")
    def test_given_real_world_scenario_when_composing_then_creates_valid_plan(
        self, mock_get_template, mock_get_templates, orchestrator, mock_agent_templates
    ):
        """Test real-world scenario creates valid execution plan."""
        # Given
        mock_get_templates.return_value = list(mock_agent_templates.values())
        mock_get_template.side_effect = lambda name: mock_agent_templates.get(name)

        task = "Improve code quality by adding tests and fixing security issues"
        context = {
            "current_coverage": 60,
            "target_coverage": 85,
            "security_issues": 5,
        }

        # When
        plan = orchestrator.analyze_and_compose(task, context)

        # Then
        assert plan is not None
        assert isinstance(plan, ExecutionPlan)
        assert isinstance(plan.strategy, CompositionPattern)
        assert isinstance(plan.agents, list)

    def test_given_all_composition_patterns_when_testing_then_all_are_valid(self, orchestrator):
        """Test all composition patterns are valid."""
        # Given
        patterns = list(CompositionPattern)

        # When/Then
        for pattern in patterns:
            assert isinstance(pattern, CompositionPattern)
            assert isinstance(pattern.value, str)
            assert len(pattern.value) > 0

    def test_given_all_task_domains_when_testing_then_all_are_valid(self, orchestrator):
        """Test all task domains are valid."""
        # Given
        domains = list(TaskDomain)

        # When/Then
        for domain in domains:
            assert isinstance(domain, TaskDomain)
            assert isinstance(domain.value, str)
            assert len(domain.value) > 0

    def test_given_all_complexity_levels_when_testing_then_all_are_valid(self, orchestrator):
        """Test all complexity levels are valid."""
        # Given
        complexities = list(TaskComplexity)

        # When/Then
        for complexity in complexities:
            assert isinstance(complexity, TaskComplexity)
            assert isinstance(complexity.value, str)
            assert len(complexity.value) > 0
