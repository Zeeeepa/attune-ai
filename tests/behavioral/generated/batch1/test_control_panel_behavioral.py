"""Behavioral tests for control_panel.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import os
import ssl
import tempfile
import threading
import time
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, Mock, PropertyMock, mock_open, patch

import pytest

from empathy_os.memory.control_panel import (
    PATTERN_ID_ALT_REGEX,
    PATTERN_ID_REGEX,
    RATE_LIMIT_MAX_REQUESTS,
    RATE_LIMIT_WINDOW_SECONDS,
    MemoryControlPanel,
    MemoryStats,
    SystemHealth,
    _hash_password,
    _sanitize_output,
    _validate_pattern_id,
    _verify_password,
    main,
)
from empathy_os.memory.long_term import Classification
from empathy_os.memory.redis_bootstrap import RedisStartMethod, RedisStatus
from empathy_os.memory.short_term import AccessTier, AgentCredentials


# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def temp_data_dir():
    """Provide a temporary data directory."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def mock_redis_client():
    """Provide a mocked Redis client."""
    client = MagicMock()
    client.ping.return_value = True
    client.info.return_value = {
        "used_memory": 1024000,
        "used_memory_human": "1.0M",
        "connected_clients": 5,
        "total_commands_processed": 1000,
        "uptime_in_seconds": 3600,
    }
    client.dbsize.return_value = 42
    client.keys.return_value = []
    return client


@pytest.fixture
def mock_short_term_memory(mock_redis_client):
    """Provide a mocked RedisShortTermMemory instance."""
    with patch("empathy_os.memory.control_panel.RedisShortTermMemory") as mock_class:
        memory = MagicMock()
        memory.client = mock_redis_client
        memory.is_connected.return_value = True
        mock_class.return_value = memory
        yield memory


@pytest.fixture
def mock_long_term_memory():
    """Provide a mocked SecureMemDocsIntegration instance."""
    with patch("empathy_os.memory.control_panel.SecureMemDocsIntegration") as mock_class:
        memory = MagicMock()
        memory.health_check.return_value = True
        memory.get_collection_stats.return_value = {
            "total_documents": 100,
            "total_size_bytes": 204800,
        }
        mock_class.return_value = memory
        yield memory


@pytest.fixture
def control_panel(temp_data_dir, mock_short_term_memory, mock_long_term_memory):
    """Provide a MemoryControlPanel instance with mocked dependencies."""
    with patch.dict(os.environ, {"EMPATHY_DATA_DIR": str(temp_data_dir)}):
        panel = MemoryControlPanel()
        yield panel


# =============================================================================
# Security Function Tests
# =============================================================================


class TestValidatePatternId:
    """Tests for pattern ID validation."""

    def test_given_valid_pattern_id_with_standard_format_when_validated_then_returns_true(self):
        """Valid standard format pattern IDs should pass validation."""
        # Given
        pattern_id = "pat_20250101120000_abc123def456"

        # When
        result = _validate_pattern_id(pattern_id)

        # Then
        assert result is True

    def test_given_valid_pattern_id_with_alternative_format_when_validated_then_returns_true(self):
        """Valid alternative format pattern IDs should pass validation."""
        # Given
        pattern_id = "valid_pattern_123"

        # When
        result = _validate_pattern_id(pattern_id)

        # Then
        assert result is True

    def test_given_pattern_id_with_path_traversal_when_validated_then_returns_false(self):
        """Pattern IDs with path traversal should be rejected."""
        # Given
        pattern_ids = ["../etc/passwd", "pat/../secret", "test/path", "test\\path"]

        # When/Then
        for pattern_id in pattern_ids:
            assert _validate_pattern_id(pattern_id) is False

    def test_given_pattern_id_with_null_byte_when_validated_then_returns_false(self):
        """Pattern IDs with null bytes should be rejected."""
        # Given
        pattern_id = "test\x00malicious"

        # When
        result = _validate_pattern_id(pattern_id)

        # Then
        assert result is False

    def test_given_pattern_id_too_short_when_validated_then_returns_false(self):
        """Pattern IDs shorter than 3 characters should be rejected."""
        # Given
        pattern_id = "ab"

        # When
        result = _validate_pattern_id(pattern_id)

        # Then
        assert result is False

    def test_given_pattern_id_too_long_when_validated_then_returns_false(self):
        """Pattern IDs longer than 64 characters should be rejected."""
        # Given
        pattern_id = "a" * 65

        # When
        result = _validate_pattern_id(pattern_id)

        # Then
        assert result is False

    def test_given_none_pattern_id_when_validated_then_returns_false(self):
        """None pattern ID should be rejected."""
        # Given
        pattern_id = None

        # When
        result = _validate_pattern_id(pattern_id)

        # Then
        assert result is False

    def test_given_non_string_pattern_id_when_validated_then_returns_false(self):
        """Non-string pattern IDs should be rejected."""
        # Given
        pattern_ids = [123, [], {}, True]

        # When/Then
        for pattern_id in pattern_ids:
            assert _validate_pattern_id(pattern_id) is False


class TestPasswordFunctions:
    """Tests for password hashing and verification."""

    def test_given_password_when_hashed_then_returns_valid_hash(self):
        """Password hashing should return a valid hash string."""
        # Given
        password = "test_password_123"

        # When
        hashed = _hash_password(password)

        # Then
        assert isinstance(hashed, str)
        assert len(hashed) == 64  # SHA-256 hex digest length

    def test_given_same_password_when_hashed_twice_then_returns_same_hash(self):
        """Same password should produce same hash."""
        # Given
        password = "consistent_password"

        # When
        hash1 = _hash_password(password)
        hash2 = _hash_password(password)

        # Then
        assert hash1 == hash2

    def test_given_correct_password_when_verified_then_returns_true(self):
        """Correct password should verify successfully."""
        # Given
        password = "correct_password"
        hashed = _hash_password(password)

        # When
        result = _verify_password(password, hashed)

        # Then
        assert result is True

    def test_given_incorrect_password_when_verified_then_returns_false(self):
        """Incorrect password should fail verification."""
        # Given
        correct_password = "correct_password"
        wrong_password = "wrong_password"
        hashed = _hash_password(correct_password)

        # When
        result = _verify_password(wrong_password, hashed)

        # Then
        assert result is False


class TestSanitizeOutput:
    """Tests for output sanitization."""

    def test_given_string_with_control_characters_when_sanitized_then_removes_them(self):
        """Control characters should be removed from output."""
        # Given
        text = "Hello\x00World\x1b[31mTest"

        # When
        result = _sanitize_output(text)

        # Then
        assert "\x00" not in result
        assert "\x1b" not in result

    def test_given_normal_string_when_sanitized_then_returns_unchanged(self):
        """Normal strings should pass through unchanged."""
        # Given
        text = "Hello World 123"

        # When
        result = _sanitize_output(text)

        # Then
        assert result == text

    def test_given_non_string_when_sanitized_then_converts_to_string(self):
        """Non-string inputs should be converted to strings."""
        # Given
        inputs = [123, None, True, [1, 2, 3]]

        # When/Then
        for inp in inputs:
            result = _sanitize_output(inp)
            assert isinstance(result, str)


# =============================================================================
# MemoryStats Tests
# =============================================================================


class TestMemoryStats:
    """Tests for MemoryStats dataclass."""

    def test_given_memory_stats_when_created_then_has_correct_fields(self):
        """MemoryStats should have all expected fields."""
        # Given/When
        stats = MemoryStats(
            redis_memory_used=1024,
            redis_memory_human="1K",
            redis_keys=10,
            redis_clients=2,
            redis_commands=100,
            redis_uptime=3600,
            long_term_documents=50,
            long_term_size=2048,
        )

        # Then
        assert stats.redis_memory_used == 1024
        assert stats.redis_memory_human == "1K"
        assert stats.redis_keys == 10
        assert stats.redis_clients == 2
        assert stats.redis_commands == 100
        assert stats.redis_uptime == 3600
        assert stats.long_term_documents == 50
        assert stats.long_term_size == 2048

    def test_given_memory_stats_when_converted_to_dict_then_returns_dict(self):
        """MemoryStats should be convertible to dictionary."""
        # Given
        stats = MemoryStats(
            redis_memory_used=1024,
            redis_memory_human="1K",
            redis_keys=10,
            redis_clients=2,
            redis_commands=100,
            redis_uptime=3600,
            long_term_documents=50,
            long_term_size=2048,
        )

        # When
        result = stats.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["redis_memory_used"] == 1024
        assert result["long_term_documents"] == 50


# =============================================================================
# SystemHealth Tests
# =============================================================================


class TestSystemHealth:
    """Tests for SystemHealth dataclass."""

    def test_given_system_health_when_created_then_has_correct_fields(self):
        """SystemHealth should have all expected fields."""
        # Given/When
        health = SystemHealth(
            redis_running=True,
            redis_responsive=True,
            long_term_healthy=True,
            overall_healthy=True,
            timestamp=datetime.now(),
        )

        # Then
        assert health.redis_running is True
        assert health.redis_responsive is True
        assert health.long_term_healthy is True
        assert health.overall_healthy is True
        assert isinstance(health.timestamp, datetime)

    def test_given_system_health_when_converted_to_dict_then_returns_dict(self):
        """SystemHealth should be convertible to dictionary."""
        # Given
        timestamp = datetime.now()
        health = SystemHealth(
            redis_running=True,
            redis_responsive=True,
            long_term_healthy=True,
            overall_healthy=True,
            timestamp=timestamp,
        )

        # When
        result = health.to_dict()

        # Then
        assert isinstance(result, dict)
        assert result["redis_running"] is True
        assert result["timestamp"] == timestamp.isoformat()


# =============================================================================
# MemoryControlPanel Tests
# =============================================================================


class TestMemoryControlPanelInit:
    """Tests for MemoryControlPanel initialization."""

    def test_given_no_data_dir_when_initialized_then_uses_default(self):
        """Control panel should use default data directory."""
        # Given/When
        with patch("empathy_os.memory.control_panel.RedisShortTermMemory"):
            with patch("empathy_os.memory.control_panel.SecureMemDocsIntegration"):
                panel = MemoryControlPanel()

                # Then
                assert panel.data_dir is not None
                assert isinstance(panel.data_dir, Path)

    def test_given_custom_data_dir_when_initialized_then_uses_custom(self, temp_data_dir):
        """Control panel should use custom data directory."""
        # Given/When
        with patch("empathy_os.memory.control_panel.RedisShortTermMemory"):
            with patch("empathy_os.memory.control_panel.SecureMemDocsIntegration"):
                panel = MemoryControlPanel(data_dir=str(temp_data_dir))

                # Then
                assert panel.data_dir == temp_data_dir

    def test_given_initialization_when_memories_created_then_sets_up_components(
        self, mock_short_term_memory, mock_long_term_memory
    ):
        """Control panel should set up memory components."""
        # Given/When
        panel = MemoryControlPanel()

        # Then
        assert panel.short_term is not None
        assert panel.long_term is not None


class TestMemoryControlPanelStatus:
    """Tests for status method."""

    @patch("empathy_os.memory.control_panel._check_redis_running")
    def test_given_redis_running_when_status_checked_then_returns_running(
        self, mock_check, control_panel
    ):
        """Status should show Redis as running when it is."""
        # Given
        mock_check.return_value = RedisStatus(
            running=True,
            pid=1234,
            port=6379,
            config_file="/path/to/redis.conf",
        )

        # When
        status = control_panel.status()

        # Then
        assert "running" in status.lower()
        assert "1234" in status

    @patch("empathy_os.memory.control_panel._check_redis_running")
    def test_given_redis_not_running_when_status_checked_then_returns_not_running(
        self, mock_check, control_panel
    ):
        """Status should show Redis as not running when it isn't."""
        # Given
        mock_check.return_value = RedisStatus(
            running=False, pid=None, port=None, config_file=None
        )

        # When
        status = control_panel.status()

        # Then
        assert "not running" in status.lower()


class TestMemoryControlPanelStartRedis:
    """Tests for start_redis method."""

    @patch("empathy_os.memory.control_panel.ensure_redis")
    def test_given_redis_not_running_when_started_then_starts_successfully(
        self, mock_ensure, control_panel
    ):
        """Starting Redis should succeed when not running."""
        # Given
        mock_ensure.return_value = RedisStatus(
            running=True,
            pid=1234,
            port=6379,
            config_file="/path/to/redis.conf",
            start_method=RedisStartMethod.SUBPROCESS,
        )

        # When
        result = control_panel.start_