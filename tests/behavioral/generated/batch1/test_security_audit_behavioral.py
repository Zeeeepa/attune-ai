"""Behavioral tests for security_audit.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import logging
from pathlib import Path
from typing import Any
from unittest.mock import AsyncMock, MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.workflows.security_audit import (
    DETECTION_PATTERNS,
    FAKE_CREDENTIAL_PATTERNS,
    SECURITY_EXAMPLE_PATHS,
    SECURITY_STEPS,
    SKIP_DIRECTORIES,
    SecurityAuditWorkflow,
)


@pytest.fixture
def mock_executor():
    """Fixture providing a mock executor for workflow execution."""
    executor = AsyncMock()
    executor.execute_step = AsyncMock(return_value={"result": "mock_result"})
    return executor


@pytest.fixture
def mock_memory():
    """Fixture providing a mock memory interface."""
    memory = Mock()
    memory.search = AsyncMock(return_value=[])
    memory.store = AsyncMock()
    return memory


@pytest.fixture
def temp_project_dir(tmp_path):
    """Fixture providing a temporary project directory structure."""
    # Create test files
    src_dir = tmp_path / "src"
    src_dir.mkdir()
    
    test_file = src_dir / "test.py"
    test_file.write_text("import os\npassword = 'hardcoded'\n")
    
    # Create skip directory
    skip_dir = tmp_path / "node_modules"
    skip_dir.mkdir()
    skip_file = skip_dir / "lib.js"
    skip_file.write_text("console.log('test');\n")
    
    return tmp_path


@pytest.fixture
def security_workflow(mock_executor, mock_memory):
    """Fixture providing a SecurityAuditWorkflow instance."""
    workflow = SecurityAuditWorkflow(
        executor=mock_executor,
        memory=mock_memory,
        config={"target_path": "/test/path"}
    )
    return workflow


class TestSecurityAuditWorkflowInitialization:
    """Test SecurityAuditWorkflow initialization and configuration."""

    def test_given_valid_config_when_initializing_then_workflow_created(
        self, mock_executor, mock_memory
    ):
        """Given valid configuration, when initializing workflow, then it is created successfully."""
        # Given
        config = {"target_path": "/test/path", "skip_remediation": False}
        
        # When
        workflow = SecurityAuditWorkflow(
            executor=mock_executor,
            memory=mock_memory,
            config=config
        )
        
        # Then
        assert workflow is not None
        assert workflow.executor == mock_executor
        assert workflow.memory == mock_memory

    def test_given_minimal_config_when_initializing_then_defaults_applied(
        self, mock_executor, mock_memory
    ):
        """Given minimal configuration, when initializing, then defaults are applied."""
        # Given
        config = {"target_path": "/test/path"}
        
        # When
        workflow = SecurityAuditWorkflow(
            executor=mock_executor,
            memory=mock_memory,
            config=config
        )
        
        # Then
        assert workflow is not None

    def test_given_no_executor_when_initializing_then_workflow_created(self):
        """Given no executor, when initializing, then workflow is created with None executor."""
        # Given/When
        workflow = SecurityAuditWorkflow(
            executor=None,
            memory=None,
            config={"target_path": "/test/path"}
        )
        
        # Then
        assert workflow.executor is None


class TestSecurityAuditWorkflowFileScanning:
    """Test file scanning and vulnerability detection."""

    def test_given_python_file_with_eval_when_scanning_then_vulnerability_detected(
        self, security_workflow, tmp_path
    ):
        """Given Python file with eval call, when scanning, then vulnerability is detected."""
        # Given
        test_file = tmp_path / "vulnerable.py"
        test_file.write_text("result = eval(user_input)")
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) > 0
        assert any("eval" in v["pattern"].lower() for v in vulnerabilities)

    def test_given_python_file_with_exec_when_scanning_then_vulnerability_detected(
        self, security_workflow, tmp_path
    ):
        """Given Python file with exec call, when scanning, then vulnerability is detected."""
        # Given
        test_file = tmp_path / "vulnerable.py"
        test_file.write_text("exec(code_string)")
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) > 0
        assert any("exec" in v["pattern"].lower() for v in vulnerabilities)

    def test_given_js_file_with_eval_when_scanning_then_vulnerability_detected(
        self, security_workflow, tmp_path
    ):
        """Given JavaScript file with eval, when scanning, then vulnerability is detected."""
        # Given
        test_file = tmp_path / "vulnerable.js"
        test_file.write_text("eval(userInput);")
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) > 0
        assert any("eval" in v["pattern"].lower() for v in vulnerabilities)

    def test_given_file_with_hardcoded_password_when_scanning_then_vulnerability_detected(
        self, security_workflow, tmp_path
    ):
        """Given file with hardcoded password, when scanning, then vulnerability is detected."""
        # Given
        test_file = tmp_path / "config.py"
        test_file.write_text('password = "MySecretPassword123!"')
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) > 0
        assert any("hardcoded" in v["pattern"].lower() for v in vulnerabilities)

    def test_given_file_with_sql_concatenation_when_scanning_then_vulnerability_detected(
        self, security_workflow, tmp_path
    ):
        """Given file with SQL concatenation, when scanning, then vulnerability is detected."""
        # Given
        test_file = tmp_path / "database.py"
        test_file.write_text('query = "SELECT * FROM users WHERE id=" + user_id')
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) > 0
        assert any("sql" in v["pattern"].lower() for v in vulnerabilities)

    def test_given_file_with_detection_pattern_when_scanning_then_false_positive_filtered(
        self, security_workflow, tmp_path
    ):
        """Given file with detection pattern, when scanning, then false positive is filtered."""
        # Given
        test_file = tmp_path / "scanner.py"
        test_file.write_text('if "eval(" in content: flag_vulnerability()')
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        # Should not detect the detection code itself as vulnerable
        eval_vulns = [v for v in vulnerabilities if "eval" in v["pattern"].lower() and "in content" in v["context"]]
        assert len(eval_vulns) == 0

    def test_given_file_with_fake_credential_when_scanning_then_false_positive_filtered(
        self, security_workflow, tmp_path
    ):
        """Given file with fake credential, when scanning, then false positive is filtered."""
        # Given
        test_file = tmp_path / "example.py"
        test_file.write_text('API_KEY = "EXAMPLE_KEY_abc123xyz"')
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        # Should not detect example keys as real vulnerabilities
        assert len(vulnerabilities) == 0

    def test_given_security_example_file_when_scanning_then_vulnerabilities_ignored(
        self, security_workflow, tmp_path
    ):
        """Given security example file, when scanning, then vulnerabilities are ignored."""
        # Given
        test_dir = tmp_path / "tests" / "security"
        test_dir.mkdir(parents=True)
        test_file = test_dir / "test_vulnerabilities.py"
        test_file.write_text('result = eval(user_input)  # Test vulnerability')
        
        # When
        with patch.object(security_workflow, '_is_security_example_path', return_value=True):
            vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) == 0

    def test_given_unreadable_file_when_scanning_then_error_handled_gracefully(
        self, security_workflow, tmp_path
    ):
        """Given unreadable file, when scanning, then error is handled gracefully."""
        # Given
        test_file = tmp_path / "binary.bin"
        test_file.write_bytes(b'\x00\x01\x02\xff\xfe')
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert isinstance(vulnerabilities, list)

    def test_given_empty_file_when_scanning_then_no_vulnerabilities_found(
        self, security_workflow, tmp_path
    ):
        """Given empty file, when scanning, then no vulnerabilities are found."""
        # Given
        test_file = tmp_path / "empty.py"
        test_file.write_text("")
        
        # When
        vulnerabilities = security_workflow._scan_file_for_vulnerabilities(test_file)
        
        # Then
        assert len(vulnerabilities) == 0


class TestSecurityAuditWorkflowDirectoryTraversal:
    """Test directory traversal and file filtering."""

    def test_given_directory_with_skip_folder_when_scanning_then_skip_folder_ignored(
        self, security_workflow, temp_project_dir
    ):
        """Given directory with skip folder, when scanning, then skip folder is ignored."""
        # Given
        target_path = temp_project_dir
        
        # When
        with patch.object(security_workflow, '_scan_file_for_vulnerabilities', return_value=[]) as mock_scan:
            security_workflow._collect_files_to_scan(target_path)
            
            # Then
            scanned_files = [call[0][0] for call in mock_scan.call_args_list]
            node_modules_files = [f for f in scanned_files if 'node_modules' in str(f)]
            assert len(node_modules_files) == 0

    def test_given_directory_with_python_files_when_collecting_then_python_files_found(
        self, security_workflow, temp_project_dir
    ):
        """Given directory with Python files, when collecting, then Python files are found."""
        # Given
        target_path = temp_project_dir
        
        # When
        files = list(security_workflow._collect_files_to_scan(target_path))
        
        # Then
        python_files = [f for f in files if f.suffix == '.py']
        assert len(python_files) > 0

    def test_given_nonexistent_directory_when_scanning_then_empty_result(
        self, security_workflow
    ):
        """Given nonexistent directory, when scanning, then empty result is returned."""
        # Given
        nonexistent_path = Path("/nonexistent/path")
        
        # When
        files = list(security_workflow._collect_files_to_scan(nonexistent_path))
        
        # Then
        assert len(files) == 0

    def test_given_file_path_when_collecting_then_single_file_returned(
        self, security_workflow, tmp_path
    ):
        """Given file path, when collecting, then single file is returned."""
        # Given
        test_file = tmp_path / "test.py"
        test_file.write_text("# Test file")
        
        # When
        files = list(security_workflow._collect_files_to_scan(test_file))
        
        # Then
        assert len(files) == 1
        assert files[0] == test_file


class TestSecurityAuditWorkflowExecution:
    """Test workflow execution stages."""

    @pytest.mark.asyncio
    async def test_given_valid_input_when_running_workflow_then_all_stages_complete(
        self, security_workflow, temp_project_dir
    ):
        """Given valid input, when running workflow, then all stages complete successfully."""
        # Given
        mock_input = {"target_path": str(temp_project_dir)}
        
        with patch.object(security_workflow, '_stage_triage') as mock_triage, \
             patch.object(security_workflow, '_stage_analyze') as mock_analyze, \
             patch.object(security_workflow, '_stage_assess') as mock_assess, \
             patch.object(security_workflow, '_stage_remediate') as mock_remediate:
            
            mock_triage.return_value = {"vulnerabilities": [{"severity": "high"}]}
            mock_analyze.return_value = {"analyzed_vulnerabilities": []}
            mock_assess.return_value = {"risk_score": 75}
            mock_remediate.return_value = {"remediation_plan": "Fix issues"}
            
            # When
            result = await security_workflow.run(mock_input)
            
            # Then
            assert result is not None
            mock_triage.assert_called_once()
            mock_analyze.assert_called_once()
            mock_assess.assert_called_once()

    @pytest.mark.asyncio
    async def test_given_no_vulnerabilities_when_running_then_remediation_skipped(
        self, security_workflow, temp_project_dir
    ):
        """Given no vulnerabilities, when running, then remediation is skipped."""
        # Given
        clean_dir = temp_project_dir / "clean"
        clean_dir.mkdir()
        clean_file = clean_dir / "safe.py"
        clean_file.write_text("def hello(): return 'world'")
        
        mock_input = {"target_path": str(clean_dir)}
        
        with patch.object(security_workflow, '_stage_remediate') as mock_remediate:
            # When
            result = await security_workflow.run(mock_input)
            
            # Then
            # Remediation should not be called for clean code
            assert result is not None

    @pytest.mark.asyncio
    async def test_given_skip_remediation_flag_when_running_then_remediation_skipped(
        self, security_workflow, temp_project_dir
    ):
        """Given skip_remediation flag, when running, then remediation is skipped."""
        # Given
        mock_input = {"target_path": str(temp_project_dir), "skip_remediation": True}
        
        with patch.object(security_workflow, '_stage_remediate') as mock_remediate:
            # When
            result = await security_workflow.run(mock_input)
            
            # Then
            mock_remediate.assert_not_called()

    def test_given_vulnerabilities_when_triaging_then_severity_assigned(
        self, security