"""Behavioral tests for test_gen.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import ast
import json
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.workflows.test_gen import (
    ASTFunctionAnalyzer,
    ClassSignature,
    FunctionSignature,
    TestGenWorkflow,
)


# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def sample_python_code():
    """Sample Python code for AST analysis."""
    return """
import os
from typing import Optional

class Calculator:
    '''A simple calculator.'''
    
    def __init__(self, initial: int = 0):
        self.value = initial
    
    def add(self, x: int, y: int) -> int:
        '''Add two numbers.'''
        if not isinstance(x, int) or not isinstance(y, int):
            raise TypeError("Arguments must be integers")
        return x + y
    
    async def async_divide(self, x: float, y: float) -> float:
        '''Divide two numbers asynchronously.'''
        if y == 0:
            raise ValueError("Cannot divide by zero")
        return x / y

def standalone_function(name: str, count: int = 1) -> list[str]:
    '''Generate list of names.'''
    return [name] * count
"""


@pytest.fixture
def sample_ast_tree(sample_python_code):
    """Parsed AST tree from sample code."""
    return ast.parse(sample_python_code)


@pytest.fixture
def mock_orchestrator():
    """Mock orchestrator for workflow testing."""
    orchestrator = Mock()
    orchestrator.execute_step = Mock()
    return orchestrator


@pytest.fixture
def temp_project_structure(tmp_path):
    """Create a temporary project structure for testing."""
    # Create source files
    src_dir = tmp_path / "src" / "myapp"
    src_dir.mkdir(parents=True)
    
    (src_dir / "__init__.py").write_text("")
    (src_dir / "calculator.py").write_text("""
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b
""")
    
    (src_dir / "database.py").write_text("""
class Database:
    def connect(self):
        pass
    
    def query(self, sql):
        pass
""")
    
    # Create test files
    test_dir = tmp_path / "tests"
    test_dir.mkdir()
    
    (test_dir / "__init__.py").write_text("")
    (test_dir / "test_calculator.py").write_text("""
def test_add():
    assert add(1, 2) == 3
""")
    
    # Create coverage report
    coverage_file = tmp_path / "coverage.json"
    coverage_data = {
        "files": {
            str(src_dir / "calculator.py"): {
                "summary": {"percent_covered": 50.0}
            },
            str(src_dir / "database.py"): {
                "summary": {"percent_covered": 20.0}
            }
        }
    }
    coverage_file.write_text(json.dumps(coverage_data))
    
    # Create bug history
    bug_history_file = tmp_path / "bug_history.json"
    bug_history = {
        str(src_dir / "calculator.py"): 3,
        str(src_dir / "database.py"): 1
    }
    bug_history_file.write_text(json.dumps(bug_history))
    
    return {
        "root": tmp_path,
        "src_dir": src_dir,
        "test_dir": test_dir,
        "coverage_file": coverage_file,
        "bug_history_file": bug_history_file
    }


@pytest.fixture
def workflow():
    """Create test generation workflow instance."""
    return TestGenWorkflow()


# =============================================================================
# FunctionSignature Tests
# =============================================================================


class TestFunctionSignature:
    """Tests for FunctionSignature dataclass."""
    
    def test_create_simple_function_signature(self):
        """
        Given: Basic function parameters
        When: Creating a FunctionSignature
        Then: All fields are properly initialized
        """
        sig = FunctionSignature(
            name="test_func",
            params=[("x", "int", None), ("y", "str", "'default'")],
            return_type="bool",
            is_async=False,
            raises={"ValueError", "TypeError"},
            has_side_effects=True,
            docstring="Test function",
            complexity=3,
            decorators=["@property"]
        )
        
        assert sig.name == "test_func"
        assert len(sig.params) == 2
        assert sig.return_type == "bool"
        assert not sig.is_async
        assert "ValueError" in sig.raises
        assert sig.has_side_effects
        assert sig.complexity == 3
        assert "@property" in sig.decorators
    
    def test_function_signature_defaults(self):
        """
        Given: Minimal function parameters
        When: Creating a FunctionSignature without optional fields
        Then: Default values are applied
        """
        sig = FunctionSignature(
            name="simple_func",
            params=[],
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None
        )
        
        assert sig.complexity == 1
        assert sig.decorators == []
        assert len(sig.raises) == 0


# =============================================================================
# ClassSignature Tests
# =============================================================================


class TestClassSignature:
    """Tests for ClassSignature dataclass."""
    
    def test_create_class_signature(self):
        """
        Given: Class analysis parameters
        When: Creating a ClassSignature
        Then: All fields are properly initialized
        """
        method = FunctionSignature(
            name="method",
            params=[("self", "", None)],
            return_type=None,
            is_async=False,
            raises=set(),
            has_side_effects=False,
            docstring=None
        )
        
        sig = ClassSignature(
            name="MyClass",
            methods=[method],
            init_params=[("x", "int", None)],
            base_classes=["BaseClass"],
            docstring="My class",
            is_enum=False,
            is_dataclass=True,
            required_init_params=1
        )
        
        assert sig.name == "MyClass"
        assert len(sig.methods) == 1
        assert sig.methods[0].name == "method"
        assert sig.is_dataclass
        assert not sig.is_enum
        assert sig.required_init_params == 1
    
    def test_class_signature_defaults(self):
        """
        Given: Minimal class parameters
        When: Creating a ClassSignature without optional fields
        Then: Default values are applied
        """
        sig = ClassSignature(
            name="SimpleClass",
            methods=[],
            init_params=[],
            base_classes=[],
            docstring=None
        )
        
        assert not sig.is_enum
        assert not sig.is_dataclass
        assert sig.required_init_params == 0


# =============================================================================
# ASTFunctionAnalyzer Tests
# =============================================================================


class TestASTFunctionAnalyzer:
    """Tests for ASTFunctionAnalyzer class."""
    
    def test_analyze_simple_function(self, sample_ast_tree):
        """
        Given: An AST tree with a simple function
        When: Analyzing the function with ASTFunctionAnalyzer
        Then: Function signature is correctly extracted
        """
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(sample_ast_tree)
        
        standalone = next(f for f in analyzer.functions if f.name == "standalone_function")
        
        assert standalone.name == "standalone_function"
        assert len(standalone.params) == 2
        assert standalone.params[0][0] == "name"
        assert standalone.params[0][1] == "str"
        assert standalone.params[1][2] == "1"  # Default value
        assert standalone.return_type == "list[str]"
        assert not standalone.is_async
    
    def test_analyze_async_function(self, sample_ast_tree):
        """
        Given: An AST tree with an async function
        When: Analyzing the async function
        Then: is_async flag is set correctly
        """
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(sample_ast_tree)
        
        async_func = next(f for f in analyzer.functions if f.name == "async_divide")
        
        assert async_func.is_async
        assert "ValueError" in async_func.raises
    
    def test_analyze_class_with_methods(self, sample_ast_tree):
        """
        Given: An AST tree with a class containing methods
        When: Analyzing the class
        Then: Class signature with methods is extracted
        """
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(sample_ast_tree)
        
        calc_class = next(c for c in analyzer.classes if c.name == "Calculator")
        
        assert calc_class.name == "Calculator"
        assert len(calc_class.methods) >= 2
        assert any(m.name == "add" for m in calc_class.methods)
        assert any(m.name == "async_divide" for m in calc_class.methods)
        assert len(calc_class.init_params) == 1
        assert calc_class.init_params[0][0] == "initial"
    
    def test_detect_exceptions_raised(self, sample_ast_tree):
        """
        Given: Functions that raise exceptions
        When: Analyzing exception handling
        Then: Raised exceptions are detected
        """
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(sample_ast_tree)
        
        add_method = next(
            f for c in analyzer.classes 
            for f in c.methods if f.name == "add"
        )
        
        assert "TypeError" in add_method.raises
    
    def test_detect_side_effects(self):
        """
        Given: Functions with various side effects
        When: Analyzing side effects
        Then: Side effects are correctly detected
        """
        code = """
def has_io():
    with open("file.txt") as f:
        return f.read()

def has_print():
    print("Hello")
    return True

def pure_function(x):
    return x * 2
"""
        tree = ast.parse(code)
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(tree)
        
        io_func = next(f for f in analyzer.functions if f.name == "has_io")
        print_func = next(f for f in analyzer.functions if f.name == "has_print")
        pure_func = next(f for f in analyzer.functions if f.name == "pure_function")
        
        assert io_func.has_side_effects
        assert print_func.has_side_effects
        assert not pure_func.has_side_effects
    
    def test_extract_decorators(self):
        """
        Given: Functions with decorators
        When: Analyzing decorators
        Then: Decorator names are extracted
        """
        code = """
class MyClass:
    @property
    def value(self):
        return self._value
    
    @staticmethod
    def static_method():
        pass
    
    @classmethod
    def class_method(cls):
        pass
"""
        tree = ast.parse(code)
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(tree)
        
        my_class = analyzer.classes[0]
        value_method = next(m for m in my_class.methods if m.name == "value")
        static_method = next(m for m in my_class.methods if m.name == "static_method")
        class_method = next(m for m in my_class.methods if m.name == "class_method")
        
        assert "property" in value_method.decorators
        assert "staticmethod" in static_method.decorators
        assert "classmethod" in class_method.decorators
    
    def test_complexity_estimation(self):
        """
        Given: Functions with different complexity levels
        When: Estimating complexity
        Then: Higher complexity for control structures
        """
        code = """
def simple():
    return 1

def complex_func(x):
    if x > 0:
        for i in range(x):
            if i % 2 == 0:
                continue
        return x
    return 0
"""
        tree = ast.parse(code)
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(tree)
        
        simple = next(f for f in analyzer.functions if f.name == "simple")
        complex_func = next(f for f in analyzer.functions if f.name == "complex_func")
        
        assert simple.complexity < complex_func.complexity
    
    def test_detect_dataclass(self):
        """
        Given: A class with @dataclass decorator
        When: Analyzing the class
        Then: is_dataclass flag is set
        """
        code = """
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
"""
        tree = ast.parse(code)
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(tree)
        
        person_class = analyzer.classes[0]
        assert person_class.is_dataclass
    
    def test_detect_enum(self):
        """
        Given: A class inheriting from Enum
        When: Analyzing the class
        Then: is_enum flag is set
        """
        code = """
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
"""
        tree = ast.parse(code)
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(tree)
        
        color_class = analyzer.classes[0]
        assert color_class.is_enum
    
    def test_empty_file(self):
        """
        Given: An empty Python file
        When: Analyzing with ASTFunctionAnalyzer
        Then: Returns empty lists
        """
        tree = ast.parse("")
        analyzer = ASTFunctionAnalyzer()
        analyzer.visit(tree)
        
        assert len(analyzer.functions) == 0
        assert len(analyzer.classes) == 0


# =============================================================================
# TestGenWorkflow Tests
# =============================================================================


class TestTestGenWorkflow:
    """Tests for TestGenWorkflow class."""
    
    def test_workflow_initialization(self, workflow):
        """
        Given: No parameters
        When: Creating a TestGenWorkflow instance
        Then: Workflow is properly initialized with correct steps
        """
        assert workflow.name == "test_generation"
        assert len(workflow.steps) == 4
        assert workflow.steps[0].name == "identify"
        assert workflow.steps[1].name == "analyze"
        assert workflow.steps[2].name == "generate"
        assert workflow.steps[3].name == "review"
    
    def test_identify_step_configuration(self, workflow):
        """
        Given: A TestGenWorkflow instance
        When: Checking identify step configuration
        Then: Step uses CHEAP tier and correct timeout
        """
        identify_step = workflow.steps[0]
        
        assert identify_step.tier.name == "CHEAP"
        assert identify_step.timeout == 300