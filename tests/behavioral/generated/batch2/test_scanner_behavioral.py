"""Behavioral tests for scanner.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import ast
import re
from datetime import datetime
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.project_index.models import (
    FileCategory,
    FileRecord,
    IndexConfig,
    ProjectSummary,
    TestRequirement,
)
from empathy_os.project_index.scanner import ProjectScanner


@pytest.fixture
def temp_project_dir(tmp_path):
    """Create a temporary project directory structure."""
    project_root = tmp_path / "test_project"
    project_root.mkdir()
    
    # Create source files
    src_dir = project_root / "src"
    src_dir.mkdir()
    (src_dir / "main.py").write_text("def main(): pass")
    (src_dir / "utils.py").write_text("def util(): pass")
    
    # Create test files
    test_dir = project_root / "tests"
    test_dir.mkdir()
    (test_dir / "test_main.py").write_text("def test_main(): pass")
    
    # Create config files
    (project_root / "config.yml").write_text("key: value")
    (project_root / "setup.toml").write_text("[tool]")
    
    # Create docs
    (project_root / "README.md").write_text("# Project")
    (project_root / "CHANGELOG.txt").write_text("v1.0")
    
    # Create assets
    assets_dir = project_root / "static"
    assets_dir.mkdir()
    (assets_dir / "style.css").write_text(".main { }")
    (assets_dir / "logo.png").write_bytes(b"\x89PNG")
    
    # Create excluded directories
    node_modules = project_root / "node_modules"
    node_modules.mkdir()
    (node_modules / "lib.js").write_text("exports = {}")
    
    venv = project_root / "venv"
    venv.mkdir()
    (venv / "activate").write_text("#!/bin/bash")
    
    return project_root


@pytest.fixture
def default_config():
    """Create default IndexConfig."""
    return IndexConfig()


@pytest.fixture
def scanner(temp_project_dir, default_config):
    """Create a ProjectScanner instance."""
    return ProjectScanner(str(temp_project_dir), default_config)


class TestProjectScannerInit:
    """Tests for ProjectScanner initialization."""

    def test_init_with_valid_project_root(self, temp_project_dir):
        """Given a valid project root path
        When initializing ProjectScanner
        Then it should set up correctly with default config.
        """
        scanner = ProjectScanner(str(temp_project_dir))
        
        assert scanner.project_root == temp_project_dir
        assert isinstance(scanner.config, IndexConfig)
        assert scanner._test_file_map == {}
        assert isinstance(scanner._compiled_patterns, dict)

    def test_init_with_custom_config(self, temp_project_dir):
        """Given a custom IndexConfig
        When initializing ProjectScanner
        Then it should use the custom config.
        """
        custom_config = IndexConfig(
            exclude_patterns=["custom/**"],
            no_test_patterns=["scripts/**"]
        )
        scanner = ProjectScanner(str(temp_project_dir), custom_config)
        
        assert scanner.config == custom_config
        assert "custom/**" in scanner.config.exclude_patterns

    def test_init_compiles_glob_patterns(self, temp_project_dir, default_config):
        """Given initialization
        When ProjectScanner is created
        Then it should pre-compile glob patterns.
        """
        scanner = ProjectScanner(str(temp_project_dir), default_config)
        
        assert len(scanner._compiled_patterns) > 0
        for pattern_key, (compiled, dir_name) in scanner._compiled_patterns.items():
            assert isinstance(compiled, re.Pattern)


class TestCompileGlobPatterns:
    """Tests for _compile_glob_patterns method."""

    def test_compile_simple_patterns(self, temp_project_dir):
        """Given simple glob patterns
        When compiling patterns
        Then they should be compiled correctly.
        """
        config = IndexConfig(exclude_patterns=["*.pyc", "*.log"])
        scanner = ProjectScanner(str(temp_project_dir), config)
        
        assert len(scanner._compiled_patterns) >= 2
        assert any("*.pyc" in key for key in scanner._compiled_patterns.keys())

    def test_compile_double_star_patterns(self, temp_project_dir):
        """Given double-star glob patterns
        When compiling patterns
        Then they should extract directory names.
        """
        config = IndexConfig(exclude_patterns=["**/node_modules/**"])
        scanner = ProjectScanner(str(temp_project_dir), config)
        
        pattern_data = scanner._compiled_patterns.get("**/node_modules/**")
        assert pattern_data is not None
        compiled, dir_name = pattern_data
        assert dir_name == "node_modules"

    def test_compile_patterns_with_trailing_double_star(self, temp_project_dir):
        """Given patterns ending with /**
        When compiling patterns
        Then they should handle directory matching.
        """
        config = IndexConfig(exclude_patterns=["build/**"])
        scanner = ProjectScanner(str(temp_project_dir), config)
        
        assert "build/**" in scanner._compiled_patterns

    def test_compile_invalid_pattern_fallback(self, temp_project_dir):
        """Given an invalid regex pattern
        When compiling patterns
        Then it should handle the error gracefully.
        """
        config = IndexConfig(exclude_patterns=["[invalid"])
        scanner = ProjectScanner(str(temp_project_dir), config)
        
        # Scanner should still initialize even with invalid patterns
        assert scanner._compiled_patterns is not None


class TestMatchesGlobPattern:
    """Tests for _matches_glob_pattern method."""

    def test_matches_simple_pattern(self, scanner):
        """Given a simple glob pattern
        When matching against a file path
        Then it should match correctly.
        """
        scanner._compiled_patterns["*.pyc"] = (re.compile(r".*\.pyc\Z"), None)
        
        assert scanner._matches_glob_pattern(Path("file.pyc"), "*.pyc")
        assert not scanner._matches_glob_pattern(Path("file.py"), "*.pyc")

    def test_matches_double_star_pattern_with_dir(self, scanner):
        """Given a ** pattern with directory name
        When matching against a path
        Then it should match directory components.
        """
        scanner._compiled_patterns["**/node_modules/**"] = (
            re.compile(r"node_modules/.*\Z"),
            "node_modules"
        )
        
        assert scanner._matches_glob_pattern(
            Path("project/node_modules/lib/index.js"),
            "**/node_modules/**"
        )
        assert not scanner._matches_glob_pattern(
            Path("project/src/index.js"),
            "**/node_modules/**"
        )

    def test_matches_pattern_without_compiled(self, scanner):
        """Given a pattern not in compiled patterns
        When matching
        Then it should use fallback matching.
        """
        path = Path("test.txt")
        result = scanner._matches_glob_pattern(path, "*.txt")
        
        assert result is True


class TestCategorizeFile:
    """Tests for _categorize_file method."""

    def test_categorize_test_file(self, scanner):
        """Given a test file path
        When categorizing
        Then it should return TEST category.
        """
        category = scanner._categorize_file(Path("tests/test_module.py"))
        assert category == FileCategory.TEST

    def test_categorize_config_file_by_suffix(self, scanner):
        """Given a config file with known suffix
        When categorizing
        Then it should return CONFIG category.
        """
        assert scanner._categorize_file(Path("config.yml")) == FileCategory.CONFIG
        assert scanner._categorize_file(Path("setup.toml")) == FileCategory.CONFIG
        assert scanner._categorize_file(Path("settings.json")) == FileCategory.CONFIG

    def test_categorize_doc_file_by_suffix(self, scanner):
        """Given a documentation file
        When categorizing
        Then it should return DOC category.
        """
        assert scanner._categorize_file(Path("guide.md")) == FileCategory.DOC
        assert scanner._categorize_file(Path("notes.rst")) == FileCategory.DOC

    def test_categorize_doc_file_by_name(self, scanner):
        """Given a file with doc-related name
        When categorizing
        Then it should return DOC category.
        """
        assert scanner._categorize_file(Path("README")) == FileCategory.DOC
        assert scanner._categorize_file(Path("CHANGELOG")) == FileCategory.DOC
        assert scanner._categorize_file(Path("LICENSE.txt")) == FileCategory.DOC

    def test_categorize_asset_file(self, scanner):
        """Given an asset file
        When categorizing
        Then it should return ASSET category.
        """
        assert scanner._categorize_file(Path("style.css")) == FileCategory.ASSET
        assert scanner._categorize_file(Path("logo.png")) == FileCategory.ASSET
        assert scanner._categorize_file(Path("image.svg")) == FileCategory.ASSET

    def test_categorize_source_file(self, scanner):
        """Given a source code file
        When categorizing
        Then it should return SOURCE category.
        """
        assert scanner._categorize_file(Path("main.py")) == FileCategory.SOURCE
        assert scanner._categorize_file(Path("app.js")) == FileCategory.SOURCE
        assert scanner._categorize_file(Path("component.tsx")) == FileCategory.SOURCE

    def test_categorize_other_file(self, scanner):
        """Given an unrecognized file type
        When categorizing
        Then it should return OTHER category.
        """
        assert scanner._categorize_file(Path("data.bin")) == FileCategory.OTHER
        assert scanner._categorize_file(Path("unknown")) == FileCategory.OTHER


class TestShouldExclude:
    """Tests for _should_exclude method."""

    def test_exclude_excluded_pattern(self, scanner):
        """Given a file matching exclude pattern
        When checking if should exclude
        Then it should return True.
        """
        with patch.object(scanner, '_matches_glob_pattern', return_value=True):
            assert scanner._should_exclude(Path("node_modules/lib.js")) is True

    def test_not_exclude_normal_file(self, scanner):
        """Given a normal file not matching exclude patterns
        When checking if should exclude
        Then it should return False.
        """
        with patch.object(scanner, '_matches_glob_pattern', return_value=False):
            assert scanner._should_exclude(Path("src/main.py")) is False

    def test_exclude_checks_all_patterns(self, scanner):
        """Given multiple exclude patterns
        When checking exclusion
        Then it should check against all patterns.
        """
        scanner.config.exclude_patterns = ["*.pyc", "*.log", "**/cache/**"]
        
        with patch.object(scanner, '_matches_glob_pattern') as mock_match:
            mock_match.side_effect = [False, False, True]
            result = scanner._should_exclude(Path("cache/data.db"))
            
            assert result is True
            assert mock_match.call_count == 3


class TestNeedsTests:
    """Tests for _needs_tests method."""

    def test_needs_tests_for_source_file(self, scanner):
        """Given a source file not matching no-test patterns
        When checking if needs tests
        Then it should return True.
        """
        with patch.object(scanner, '_matches_glob_pattern', return_value=False):
            assert scanner._needs_tests(Path("src/module.py"), FileCategory.SOURCE) is True

    def test_no_tests_for_non_source_file(self, scanner):
        """Given a non-source file
        When checking if needs tests
        Then it should return False.
        """
        assert scanner._needs_tests(Path("config.yml"), FileCategory.CONFIG) is False
        assert scanner._needs_tests(Path("README.md"), FileCategory.DOC) is False

    def test_no_tests_for_no_test_pattern(self, scanner):
        """Given a source file matching no-test pattern
        When checking if needs tests
        Then it should return False.
        """
        with patch.object(scanner, '_matches_glob_pattern', return_value=True):
            assert scanner._needs_tests(Path("src/settings.py"), FileCategory.SOURCE) is False


class TestFindTestFile:
    """Tests for _find_test_file method."""

    def test_find_test_file_with_exact_match(self, temp_project_dir):
        """Given a source file with corresponding test file
        When finding test file
        Then it should return the test file path.
        """
        scanner = ProjectScanner(str(temp_project_dir))
        source_path = temp_project_dir / "src" / "main.py"
        
        test_file = scanner._find_test_file(source_path)
        
        assert test_file is not None
        assert "test_main.py" in str(test_file)

    def test_find_test_file_no_match(self, temp_project_dir):
        """Given a source file without corresponding test file
        When finding test file
        Then it should return None.
        """
        scanner = ProjectScanner(str(temp_project_dir))
        source_path = temp_project_dir / "src" / "utils.py"
        
        test_file = scanner._find_test_file(source_path)
        
        assert test_file is None

    def test_find_test_file_caches_results(self, temp_project_dir):
        """Given repeated calls for same source file
        When finding test file
        Then it should cache the results.
        """
        scanner = ProjectScanner(str(temp_project_dir))
        source_path = temp_project_dir / "src" / "main.py"
        
        result1 = scanner._find_test_file(source_path)
        result2 = scanner._find_test_file(source_path)
        
        assert result1 == result2


class TestCalculateComplexity:
    """Tests for _calculate_complexity method."""

    def test_complexity_simple_function(self, scanner):
        """Given a simple function with no branches
        When calculating complexity
        Then it should return 1.
        """
        code = "def simple(): return 42"
        tree = ast.parse(code)
        
        complexity = scanner._calculate_complexity(tree)
        assert complexity == 1

    def test_complexity_with_if_statement(self, scanner):
        """Given a function with if statement
        When calculating complexity
        Then it should count the branch.
        """
        code = """
def func(x):
    if x > 0:
        return x
    return 0
"""
        tree = ast.parse(code)
        
        complexity = scanner._calculate_complexity(tree)
        assert complexity == 2  # 1 base + 1 if

    def test_complexity_with_for_loop(self, scanner):
        """Given a function with for loop
        When calculating complexity
        Then it should count the loop.
        """
        code = """
def func(items):
    for item in items:
        print(item)
"""
        tree = ast.parse(code)
        
        complexity = scanner._calculate_complexity(