"""Behavioral tests for code_review.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import AsyncMock, Mock, patch, MagicMock
from typing import Any

from empathy_os.workflows.code_review import (
    CodeReviewWorkflow,
    CODE_REVIEW_STEPS,
)
from empathy_os.workflows.base import ModelTier


@pytest.fixture
def mock_executor():
    """Fixture providing a mocked executor."""
    executor = AsyncMock()
    executor.execute_task = AsyncMock(return_value={"result": "success"})
    return executor


@pytest.fixture
def mock_crew():
    """Fixture providing a mocked CodeReviewCrew."""
    crew = Mock()
    crew.kickoff = AsyncMock(return_value={"crew_result": "completed"})
    return crew


@pytest.fixture
def basic_workflow():
    """Fixture providing a basic CodeReviewWorkflow instance."""
    return CodeReviewWorkflow(use_crew=False)


@pytest.fixture
def crew_enabled_workflow():
    """Fixture providing a CodeReviewWorkflow with crew enabled."""
    return CodeReviewWorkflow(use_crew=True)


@pytest.fixture
def custom_config_workflow():
    """Fixture providing a CodeReviewWorkflow with custom configuration."""
    return CodeReviewWorkflow(
        file_threshold=5,
        core_modules=["custom/core/", "custom/auth/"],
        use_crew=False,
    )


class TestCodeReviewStepsConfig:
    """Test suite for CODE_REVIEW_STEPS configuration."""

    def test_given_code_review_steps_when_accessed_then_contains_architect_review(self):
        """GIVEN CODE_REVIEW_STEPS configuration
        WHEN accessing the configuration
        THEN it should contain architect_review step."""
        # Given/When
        step = CODE_REVIEW_STEPS.get("architect_review")

        # Then
        assert step is not None
        assert step.name == "architect_review"
        assert step.task_type == "architectural_decision"
        assert step.tier_hint == "premium"
        assert step.max_tokens == 3000


class TestCodeReviewWorkflowInitialization:
    """Test suite for CodeReviewWorkflow initialization."""

    def test_given_no_params_when_initialized_then_has_default_values(self):
        """GIVEN no initialization parameters
        WHEN CodeReviewWorkflow is created
        THEN it should have default values."""
        # When
        workflow = CodeReviewWorkflow()

        # Then
        assert workflow.name == "code-review"
        assert workflow.file_threshold == 10
        assert workflow.use_crew is True
        assert len(workflow.core_modules) > 0
        assert "src/core/" in workflow.core_modules
        assert workflow._needs_architect_review is False
        assert workflow._change_type == "unknown"

    def test_given_custom_file_threshold_when_initialized_then_uses_custom_value(self):
        """GIVEN custom file_threshold parameter
        WHEN CodeReviewWorkflow is created
        THEN it should use the custom threshold."""
        # Given
        custom_threshold = 15

        # When
        workflow = CodeReviewWorkflow(file_threshold=custom_threshold)

        # Then
        assert workflow.file_threshold == custom_threshold

    def test_given_custom_core_modules_when_initialized_then_uses_custom_modules(self):
        """GIVEN custom core_modules parameter
        WHEN CodeReviewWorkflow is created
        THEN it should use the custom modules."""
        # Given
        custom_modules = ["custom/path/", "another/path/"]

        # When
        workflow = CodeReviewWorkflow(core_modules=custom_modules)

        # Then
        assert workflow.core_modules == custom_modules

    def test_given_use_crew_false_when_initialized_then_has_basic_stages(self):
        """GIVEN use_crew=False parameter
        WHEN CodeReviewWorkflow is created
        THEN it should have basic stages without crew_review."""
        # When
        workflow = CodeReviewWorkflow(use_crew=False)

        # Then
        assert "crew_review" not in workflow.stages
        assert "classify" in workflow.stages
        assert "scan" in workflow.stages
        assert "architect_review" in workflow.stages

    def test_given_use_crew_true_when_initialized_then_has_crew_stages(self):
        """GIVEN use_crew=True parameter
        WHEN CodeReviewWorkflow is created
        THEN it should have stages including crew_review."""
        # When
        workflow = CodeReviewWorkflow(use_crew=True)

        # Then
        assert "crew_review" in workflow.stages
        assert "classify" in workflow.stages
        assert "scan" in workflow.stages
        assert "architect_review" in workflow.stages
        assert workflow.tier_map["crew_review"] == ModelTier.CAPABLE

    def test_given_crew_config_when_initialized_then_stores_config(self):
        """GIVEN crew_config parameter
        WHEN CodeReviewWorkflow is created
        THEN it should store the crew configuration."""
        # Given
        config = {"max_agents": 3, "timeout": 120}

        # When
        workflow = CodeReviewWorkflow(crew_config=config, use_crew=True)

        # Then
        assert workflow.crew_config == config


class TestCodeReviewWorkflowTierMap:
    """Test suite for tier mapping configuration."""

    def test_given_basic_workflow_when_checking_tiers_then_has_correct_mapping(self):
        """GIVEN a basic workflow
        WHEN checking tier mappings
        THEN each stage should have correct model tier."""
        # Given
        workflow = CodeReviewWorkflow(use_crew=False)

        # Then
        assert workflow.tier_map["classify"] == ModelTier.CHEAP
        assert workflow.tier_map["scan"] == ModelTier.CAPABLE
        assert workflow.tier_map["architect_review"] == ModelTier.PREMIUM

    def test_given_crew_workflow_when_checking_tiers_then_includes_crew_tier(self):
        """GIVEN a crew-enabled workflow
        WHEN checking tier mappings
        THEN crew_review should map to CAPABLE tier."""
        # Given
        workflow = CodeReviewWorkflow(use_crew=True)

        # Then
        assert workflow.tier_map["crew_review"] == ModelTier.CAPABLE


class TestCodeReviewWorkflowClassifyStage:
    """Test suite for classify stage execution."""

    @pytest.mark.asyncio
    async def test_given_small_change_when_classify_then_identifies_change_type(
        self, basic_workflow, mock_executor
    ):
        """GIVEN a small code change
        WHEN classify stage is executed
        THEN it should identify the change type."""
        # Given
        basic_workflow.executor = mock_executor
        mock_executor.execute_task.return_value = {
            "change_type": "bugfix",
            "complexity": "low",
        }
        context = {
            "diff": "- old_line\n+ new_line",
            "files_changed": ["src/utils.py"],
        }

        # When
        result = await basic_workflow.run_stage("classify", context)

        # Then
        assert result is not None
        mock_executor.execute_task.assert_called_once()
        call_args = mock_executor.execute_task.call_args
        assert "diff" in str(call_args)

    @pytest.mark.asyncio
    async def test_given_classify_stage_when_error_occurs_then_handles_gracefully(
        self, basic_workflow, mock_executor
    ):
        """GIVEN classify stage execution
        WHEN an error occurs
        THEN it should handle the error gracefully."""
        # Given
        basic_workflow.executor = mock_executor
        mock_executor.execute_task.side_effect = Exception("API Error")
        context = {"diff": "test", "files_changed": ["test.py"]}

        # When/Then
        with pytest.raises(Exception):
            await basic_workflow.run_stage("classify", context)


class TestCodeReviewWorkflowScanStage:
    """Test suite for scan stage execution."""

    @pytest.mark.asyncio
    async def test_given_code_change_when_scan_then_performs_security_scan(
        self, basic_workflow, mock_executor
    ):
        """GIVEN a code change
        WHEN scan stage is executed
        THEN it should perform security and bug scanning."""
        # Given
        basic_workflow.executor = mock_executor
        mock_executor.execute_task.return_value = {
            "security_issues": [],
            "bug_patterns": [],
        }
        context = {
            "diff": "import os\nos.system('rm -rf /')",
            "files_changed": ["src/dangerous.py"],
        }

        # When
        result = await basic_workflow.run_stage("scan", context)

        # Then
        assert result is not None
        mock_executor.execute_task.assert_called_once()

    @pytest.mark.asyncio
    async def test_given_scan_stage_when_security_issues_found_then_reports_issues(
        self, basic_workflow, mock_executor
    ):
        """GIVEN scan stage execution
        WHEN security issues are found
        THEN it should report the issues."""
        # Given
        basic_workflow.executor = mock_executor
        security_issues = ["SQL Injection risk", "XSS vulnerability"]
        mock_executor.execute_task.return_value = {
            "security_issues": security_issues,
            "bug_patterns": ["Potential null pointer"],
        }
        context = {"diff": "SELECT * FROM users WHERE id = " + input}

        # When
        result = await basic_workflow.run_stage("scan", context)

        # Then
        assert result is not None
        assert result.get("security_issues") == security_issues


class TestCodeReviewWorkflowArchitectReview:
    """Test suite for architect review stage."""

    @pytest.mark.asyncio
    async def test_given_many_files_when_checking_threshold_then_triggers_architect_review(
        self, basic_workflow
    ):
        """GIVEN a change with many files
        WHEN checking if architect review is needed
        THEN it should trigger architect review."""
        # Given
        many_files = [f"src/file{i}.py" for i in range(15)]
        context = {"files_changed": many_files}

        # When
        needs_review = len(context["files_changed"]) >= basic_workflow.file_threshold

        # Then
        assert needs_review is True

    @pytest.mark.asyncio
    async def test_given_core_module_change_when_checking_then_triggers_architect_review(
        self, basic_workflow
    ):
        """GIVEN a change to core module
        WHEN checking if architect review is needed
        THEN it should trigger architect review."""
        # Given
        context = {"files_changed": ["src/core/main.py"]}

        # When
        is_core = any(
            core_path in context["files_changed"][0]
            for core_path in basic_workflow.core_modules
        )

        # Then
        assert is_core is True

    @pytest.mark.asyncio
    async def test_given_simple_change_when_checking_then_skips_architect_review(
        self, basic_workflow
    ):
        """GIVEN a simple change
        WHEN checking if architect review is needed
        THEN it should skip architect review."""
        # Given
        context = {"files_changed": ["tests/test_utils.py"]}

        # When
        needs_review = len(context["files_changed"]) >= basic_workflow.file_threshold
        is_core = any(
            core_path in context["files_changed"][0]
            for core_path in basic_workflow.core_modules
        )

        # Then
        assert needs_review is False
        assert is_core is False

    @pytest.mark.asyncio
    async def test_given_architect_review_needed_when_executed_then_uses_premium_tier(
        self, basic_workflow, mock_executor
    ):
        """GIVEN architect review is needed
        WHEN the stage is executed
        THEN it should use premium tier model."""
        # Given
        basic_workflow.executor = mock_executor
        basic_workflow._needs_architect_review = True
        mock_executor.execute_task.return_value = {
            "architectural_concerns": [],
            "recommendations": [],
        }
        context = {"diff": "major refactoring", "files_changed": [f"f{i}.py" for i in range(15)]}

        # When
        result = await basic_workflow.run_stage("architect_review", context)

        # Then
        assert result is not None
        assert basic_workflow.tier_map["architect_review"] == ModelTier.PREMIUM


class TestCodeReviewWorkflowCrewIntegration:
    """Test suite for crew integration."""

    @pytest.mark.asyncio
    async def test_given_crew_enabled_when_initializing_crew_then_creates_crew_instance(
        self, crew_enabled_workflow
    ):
        """GIVEN crew is enabled
        WHEN initializing crew
        THEN it should create a crew instance."""
        # Given/When
        with patch(
            "empathy_os.workflows.code_review.CodeReviewCrew"
        ) as mock_crew_class:
            mock_crew_instance = Mock()
            mock_crew_class.return_value = mock_crew_instance
            crew_enabled_workflow._initialize_crew()

            # Then
            assert crew_enabled_workflow._crew is not None
            assert crew_enabled_workflow._crew_available is True

    @pytest.mark.asyncio
    async def test_given_crew_unavailable_when_initializing_then_handles_gracefully(
        self, crew_enabled_workflow
    ):
        """GIVEN crew import fails
        WHEN initializing crew
        THEN it should handle gracefully and set crew_available to False."""
        # Given/When
        with patch(
            "empathy_os.workflows.code_review.CodeReviewCrew", side_effect=ImportError
        ):
            crew_enabled_workflow._initialize_crew()

            # Then
            assert crew_enabled_workflow._crew_available is False

    @pytest.mark.asyncio
    async def test_given_crew_review_stage_when_crew_available_then_executes_crew(
        self, crew_enabled_workflow, mock_crew
    ):
        """GIVEN crew review stage
        WHEN crew is available
        THEN it should execute crew analysis."""
        # Given
        crew_enabled_workflow._crew = mock_crew
        crew_enabled_workflow._crew_available = True
        context = {"diff": "test change", "files_changed": ["test.py"]}

        # When
        result = await crew_enabled_workflow.run_stage("crew_review", context)

        # Then
        assert result is not None
        mock_crew.kickoff.assert_called_once()

    @pytest.mark.asyncio
    async def test_given_crew_review_stage_when_crew_unavailable_then_skips_crew(
        self, crew_enabled_workflow
    ):
        """GIVEN crew review stage
        WHEN crew is unavailable
        THEN it should skip crew execution."""
        # Given
        crew_enabled_workflow._crew_available = False
        context = {"diff": "test change"}

        # When
        result = await crew_enabled_workflow.run_stage("crew_review", context)

        # Then
        # Should return None or skip without error
        assert result is None or result == {}


class TestCodeReviewWorkflowExecute:
    """Test suite for full workflow execution."""

    @pytest.mark.asyncio
    async def test_given_complete_workflow_when_execute_then_runs_all_stages