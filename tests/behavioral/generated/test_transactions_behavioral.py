"""Behavioral tests for transactions.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
from datetime import datetime
from typing import TYPE_CHECKING
from unittest.mock import MagicMock, Mock, patch

import pytest

from attune.memory.short_term.transactions import TransactionManager
from attune.memory.types import AccessTier, AgentCredentials, StagedPattern


@pytest.fixture
def mock_base_ops():
    """Create a mock BaseOperations instance.

    Returns:
        Mock instance with Redis client and necessary methods.
    """
    mock_base = Mock()
    mock_base.use_mock = False
    mock_base._client = Mock()
    mock_base._mock_storage = {}
    mock_base._metrics = Mock()
    return mock_base


@pytest.fixture
def mock_caching_ops():
    """Create a mock CachingOperations instance.

    Returns:
        Mock instance with cache invalidation methods.
    """
    mock_caching = Mock()
    mock_caching.invalidate = Mock()
    mock_caching.invalidate_all = Mock()
    return mock_caching


@pytest.fixture
def transaction_manager(mock_base_ops, mock_caching_ops):
    """Create a TransactionManager instance with mocked dependencies.

    Returns:
        TransactionManager instance for testing.
    """
    return TransactionManager(mock_base_ops, mock_caching_ops)


@pytest.fixture
def agent_credentials():
    """Create agent credentials for testing.

    Returns:
        AgentCredentials with VALIDATOR access tier.
    """
    return AgentCredentials("agent_1", AccessTier.VALIDATOR)


@pytest.fixture
def staged_pattern_data():
    """Create staged pattern test data.

    Returns:
        Dictionary representing a staged pattern.
    """
    return {
        "pattern_id": "pat_123",
        "agent_id": "agent_1",
        "pattern_type": "test",
        "name": "Test Pattern",
        "description": "A test pattern",
        "code": None,
        "context": {"source": "test"},
        "confidence": 0.85,
        "staged_at": datetime.now().isoformat(),
        "interests": ["testing"],
    }


@pytest.fixture
def staged_pattern(staged_pattern_data):
    """Create a StagedPattern instance.

    Returns:
        StagedPattern instance for testing.
    """
    return StagedPattern(
        pattern_id=staged_pattern_data["pattern_id"],
        agent_id=staged_pattern_data["agent_id"],
        pattern_type=staged_pattern_data["pattern_type"],
        name=staged_pattern_data["name"],
        description=staged_pattern_data["description"],
        confidence=staged_pattern_data["confidence"],
        staged_at=datetime.fromisoformat(staged_pattern_data["staged_at"]),
        context=staged_pattern_data["context"],
        interests=staged_pattern_data["interests"],
    )


class TestTransactionManagerInit:
    """Test TransactionManager initialization."""

    def test_given_base_and_caching_ops_when_init_then_stores_references(
        self, mock_base_ops, mock_caching_ops
    ):
        """Verify that initialization stores references to dependencies.

        Given: BaseOperations and CachingOperations instances
        When: TransactionManager is initialized
        Then: It stores references to both dependencies
        """
        # When
        manager = TransactionManager(mock_base_ops, mock_caching_ops)

        # Then
        assert manager._base is mock_base_ops
        assert manager._caching is mock_caching_ops

    def test_given_valid_ops_when_init_then_has_prefix_staged_constant(self, transaction_manager):
        """Verify that PREFIX_STAGED constant is set correctly.

        Given: A TransactionManager instance
        When: Checking the PREFIX_STAGED attribute
        Then: It should be set to the correct namespace
        """
        # Then
        assert transaction_manager.PREFIX_STAGED == "empathy:staged:"


class TestAtomicPromotePatternSuccess:
    """Test successful pattern promotion scenarios."""

    def test_given_valid_staged_pattern_when_atomic_promote_then_succeeds(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify successful atomic promotion of a valid staged pattern.

        Given: A valid staged pattern in Redis
        When: atomic_promote_pattern is called
        Then: Pattern is promoted and returns success
        """
        # Given
        pattern_id = "pat_123"
        key = f"{transaction_manager.PREFIX_STAGED}{pattern_id}"

        mock_pipeline = Mock()
        mock_pipeline.delete.return_value = None
        mock_pipeline.execute.return_value = [1]  # Successful delete

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)
        transaction_manager._base._client.pipeline.return_value = mock_pipeline

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials
        )

        # Then
        assert success is True
        assert pattern is not None
        assert pattern.pattern_id == pattern_id
        assert "promoted" in message.lower()
        transaction_manager._base._client.watch.assert_called_once_with(key)
        mock_pipeline.delete.assert_called_once_with(key)
        transaction_manager._caching.invalidate.assert_called_once_with(key)

    def test_given_high_confidence_pattern_when_promote_then_validates_confidence(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify promotion validates confidence threshold.

        Given: A pattern with high confidence
        When: Promoting with minimum confidence requirement
        Then: Pattern is promoted successfully
        """
        # Given
        pattern_id = "pat_123"
        staged_pattern_data["confidence"] = 0.9

        mock_pipeline = Mock()
        mock_pipeline.delete.return_value = None
        mock_pipeline.execute.return_value = [1]

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)
        transaction_manager._base._client.pipeline.return_value = mock_pipeline

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials, min_confidence=0.8
        )

        # Then
        assert success is True
        assert pattern is not None
        assert pattern.confidence == 0.9

    def test_given_pattern_with_context_when_promote_then_preserves_context(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify that pattern context is preserved during promotion.

        Given: A staged pattern with context
        When: Pattern is promoted
        Then: Context is preserved in the promoted pattern
        """
        # Given
        pattern_id = "pat_123"
        staged_pattern_data["context"] = {
            "source": "test",
            "priority": "high",
            "tags": ["important"],
        }

        mock_pipeline = Mock()
        mock_pipeline.delete.return_value = None
        mock_pipeline.execute.return_value = [1]

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)
        transaction_manager._base._client.pipeline.return_value = mock_pipeline

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials
        )

        # Then
        assert success is True
        assert pattern is not None
        assert pattern.context == staged_pattern_data["context"]


class TestAtomicPromotePatternFailure:
    """Test pattern promotion failure scenarios."""

    def test_given_nonexistent_pattern_when_atomic_promote_then_fails(
        self, transaction_manager, agent_credentials
    ):
        """Verify promotion fails for non-existent pattern.

        Given: A pattern ID that doesn't exist in Redis
        When: atomic_promote_pattern is called
        Then: Returns failure with appropriate message
        """
        # Given
        pattern_id = "nonexistent_pattern"
        transaction_manager._base._client.get.return_value = None

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials
        )

        # Then
        assert success is False
        assert pattern is None
        assert "not found" in message.lower()

    def test_given_low_confidence_pattern_when_promote_then_fails_validation(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify promotion fails when confidence is below threshold.

        Given: A pattern with low confidence
        When: Promoting with higher minimum confidence requirement
        Then: Returns failure due to insufficient confidence
        """
        # Given
        pattern_id = "pat_123"
        staged_pattern_data["confidence"] = 0.5

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials, min_confidence=0.7
        )

        # Then
        assert success is False
        assert pattern is None
        assert "confidence" in message.lower()

    def test_given_transaction_conflict_when_promote_then_fails_gracefully(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify promotion fails gracefully on transaction conflict.

        Given: A pattern that is modified during transaction
        When: Redis WATCH detects change and transaction fails
        Then: Returns failure with appropriate message
        """
        import redis as redis_lib

        # Given
        pattern_id = "pat_123"

        mock_pipeline = Mock()
        mock_pipeline.delete.return_value = None
        mock_pipeline.execute.side_effect = redis_lib.WatchError("Watched key changed")

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)
        transaction_manager._base._client.pipeline.return_value = mock_pipeline

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials
        )

        # Then
        assert success is False
        assert pattern is None
        assert "modified" in message.lower()

    def test_given_invalid_json_when_promote_then_fails_parsing(
        self, transaction_manager, agent_credentials
    ):
        """Verify promotion fails gracefully with invalid JSON data.

        Given: A pattern key with invalid JSON data
        When: Attempting to promote the pattern
        Then: Returns failure with appropriate error message
        """
        # Given
        pattern_id = "pat_123"
        transaction_manager._base._client.get.return_value = "invalid json data"

        # When - json.loads will raise, caught by the except in finally unwatch
        # The source doesn't catch JSONDecodeError explicitly, so it propagates
        # through the finally block. Since it's not a WatchError, it re-raises.
        with pytest.raises(json.JSONDecodeError):
            transaction_manager.atomic_promote_pattern(pattern_id, agent_credentials)

    def test_given_redis_connection_error_when_promote_then_raises(
        self, transaction_manager, agent_credentials
    ):
        """Verify promotion propagates Redis connection errors.

        Given: Redis connection failure
        When: Attempting to promote a pattern
        Then: Exception propagates (not a WatchError, so not caught)
        """
        # Given
        pattern_id = "pat_123"
        transaction_manager._base._client.watch.side_effect = ConnectionError("Connection error")

        # When/Then - ConnectionError is not redis.WatchError, so it propagates
        with pytest.raises(ConnectionError, match="Connection error"):
            transaction_manager.atomic_promote_pattern(pattern_id, agent_credentials)

    def test_given_zero_confidence_when_promote_with_min_confidence_then_fails(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify promotion fails for zero confidence pattern with threshold.

        Given: A pattern with zero confidence
        When: Promoting with any non-zero minimum confidence
        Then: Returns failure due to insufficient confidence
        """
        # Given
        pattern_id = "pat_123"
        staged_pattern_data["confidence"] = 0.0

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials, min_confidence=0.1
        )

        # Then
        assert success is False
        assert pattern is None
        assert "confidence" in message.lower()


class TestAtomicPromotePatternEdgeCases:
    """Test edge cases for atomic pattern promotion."""

    def test_given_exact_min_confidence_when_promote_then_succeeds(
        self, transaction_manager, agent_credentials, staged_pattern_data
    ):
        """Verify promotion succeeds when confidence exactly matches threshold.

        Given: A pattern with confidence equal to minimum required
        When: Promoting the pattern
        Then: Promotion succeeds
        """
        # Given
        pattern_id = "pat_123"
        staged_pattern_data["confidence"] = 0.7

        mock_pipeline = Mock()
        mock_pipeline.delete.return_value = None
        mock_pipeline.execute.return_value = [1]

        transaction_manager._base._client.get.return_value = json.dumps(staged_pattern_data)
        transaction_manager._base._client.pipeline.return_value = mock_pipeline

        # When
        success, pattern, message = transaction_manager.atomic_promote_pattern(
            pattern_id, agent_credentials, min_confidence=0.7
        )

        # Then
        assert success is True
        assert pattern is not None

    def test_given_empty_pattern_id_when_promote_then_raises_value_error(
        self, transaction_manager, agent_credentials
    ):
        """Verify promotion raises ValueError for empty pattern ID.

        Given: An empty pattern ID
        When: Attempting to promote
        Then: Raises ValueError
        """
        # When/Then
        with pytest.raises(ValueError, match="pattern_id cannot be empty"):
            transaction_manager.atomic_promote_pattern("", agent_credentials)
