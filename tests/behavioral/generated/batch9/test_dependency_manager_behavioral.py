"""Behavioral tests for dependency_manager.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import subprocess
import sys
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest
import yaml

from empathy_os.cache.dependency_manager import DependencyManager


@pytest.fixture
def temp_config_path(tmp_path):
    """Provide a temporary config path for testing.
    
    Args:
        tmp_path: pytest temporary path fixture
        
    Returns:
        Path to temporary config file
    """
    return tmp_path / ".empathy" / "config.yml"


@pytest.fixture
def dependency_manager(temp_config_path):
    """Provide a DependencyManager instance with temporary config.
    
    Args:
        temp_config_path: fixture providing temporary config path
        
    Returns:
        DependencyManager instance
    """
    return DependencyManager(config_path=temp_config_path)


@pytest.fixture
def mock_config_data():
    """Provide sample configuration data.
    
    Returns:
        Dictionary with sample config
    """
    return {
        "cache": {
            "install_declined": False,
            "auto_install": True
        }
    }


class TestDependencyManagerInit:
    """Test DependencyManager initialization behavior."""

    def test_given_no_config_path_when_init_then_uses_default_path(self):
        """Given no config path provided
        When initializing DependencyManager
        Then it should use default ~/.empathy/config.yml path
        """
        # When
        manager = DependencyManager()
        
        # Then
        expected_path = Path.home() / ".empathy" / "config.yml"
        assert manager.config_path == expected_path

    def test_given_custom_config_path_when_init_then_uses_custom_path(self, temp_config_path):
        """Given a custom config path
        When initializing DependencyManager
        Then it should use the provided path
        """
        # When
        manager = DependencyManager(config_path=temp_config_path)
        
        # Then
        assert manager.config_path == temp_config_path

    def test_given_no_existing_config_when_init_then_config_is_empty(self, temp_config_path):
        """Given no existing config file
        When initializing DependencyManager
        Then config should be empty dictionary
        """
        # When
        manager = DependencyManager(config_path=temp_config_path)
        
        # Then
        assert manager.config == {}

    def test_given_existing_config_when_init_then_loads_config(self, temp_config_path, mock_config_data):
        """Given an existing config file
        When initializing DependencyManager
        Then it should load the configuration
        """
        # Given
        temp_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(temp_config_path, "w") as f:
            yaml.safe_dump(mock_config_data, f)
        
        # When
        manager = DependencyManager(config_path=temp_config_path)
        
        # Then
        assert manager.config == mock_config_data


class TestLoadConfig:
    """Test configuration loading behavior."""

    def test_given_nonexistent_config_when_load_then_returns_empty_dict(self, temp_config_path):
        """Given a non-existent config file
        When loading config
        Then it should return empty dictionary
        """
        # Given
        manager = DependencyManager(config_path=temp_config_path)
        
        # When
        config = manager._load_config()
        
        # Then
        assert config == {}

    def test_given_valid_yaml_when_load_then_returns_parsed_config(self, temp_config_path, mock_config_data):
        """Given a valid YAML config file
        When loading config
        Then it should return parsed configuration
        """
        # Given
        temp_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(temp_config_path, "w") as f:
            yaml.safe_dump(mock_config_data, f)
        manager = DependencyManager(config_path=temp_config_path)
        
        # When
        config = manager._load_config()
        
        # Then
        assert config == mock_config_data

    def test_given_empty_yaml_when_load_then_returns_empty_dict(self, temp_config_path):
        """Given an empty YAML config file
        When loading config
        Then it should return empty dictionary
        """
        # Given
        temp_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(temp_config_path, "w") as f:
            f.write("")
        manager = DependencyManager(config_path=temp_config_path)
        
        # When
        config = manager._load_config()
        
        # Then
        assert config == {}

    def test_given_corrupt_yaml_when_load_then_returns_empty_dict_and_logs_warning(
        self, temp_config_path, caplog
    ):
        """Given a corrupt YAML config file
        When loading config
        Then it should return empty dict and log warning
        """
        # Given
        temp_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(temp_config_path, "w") as f:
            f.write("invalid: yaml: content: [")
        manager = DependencyManager(config_path=temp_config_path)
        
        # When
        config = manager._load_config()
        
        # Then
        assert config == {}
        assert "Failed to load config" in caplog.text

    def test_given_permission_error_when_load_then_returns_empty_dict_and_logs_warning(
        self, temp_config_path, caplog
    ):
        """Given a config file with permission error
        When loading config
        Then it should return empty dict and log warning
        """
        # Given
        temp_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(temp_config_path, "w") as f:
            yaml.safe_dump({"test": "data"}, f)
        
        manager = DependencyManager(config_path=temp_config_path)
        
        # Mock open to raise OSError
        with patch("builtins.open", side_effect=OSError("Permission denied")):
            # When
            config = manager._load_config()
        
        # Then
        assert config == {}
        assert "Failed to load config" in caplog.text


class TestSaveConfig:
    """Test configuration saving behavior."""

    @patch("empathy_os.cache.dependency_manager._validate_file_path")
    def test_given_valid_config_when_save_then_writes_to_disk(
        self, mock_validate, temp_config_path, mock_config_data
    ):
        """Given a valid configuration
        When saving config
        Then it should write to disk
        """
        # Given
        mock_validate.return_value = str(temp_config_path)
        manager = DependencyManager(config_path=temp_config_path)
        manager.config = mock_config_data
        
        # When
        manager._save_config()
        
        # Then
        assert temp_config_path.exists()
        with open(temp_config_path) as f:
            saved_config = yaml.safe_load(f)
        assert saved_config == mock_config_data

    @patch("empathy_os.cache.dependency_manager._validate_file_path")
    def test_given_nonexistent_directory_when_save_then_creates_directories(
        self, mock_validate, temp_config_path
    ):
        """Given a non-existent config directory
        When saving config
        Then it should create necessary directories
        """
        # Given
        mock_validate.return_value = str(temp_config_path)
        manager = DependencyManager(config_path=temp_config_path)
        manager.config = {"test": "data"}
        
        # When
        manager._save_config()
        
        # Then
        assert temp_config_path.parent.exists()
        assert temp_config_path.exists()

    @patch("empathy_os.cache.dependency_manager._validate_file_path")
    def test_given_yaml_error_when_save_then_logs_error(
        self, mock_validate, temp_config_path, caplog
    ):
        """Given a YAML serialization error
        When saving config
        Then it should log error
        """
        # Given
        mock_validate.return_value = str(temp_config_path)
        manager = DependencyManager(config_path=temp_config_path)
        manager.config = {"test": "data"}
        
        with patch("yaml.safe_dump", side_effect=yaml.YAMLError("Serialization error")):
            # When
            manager._save_config()
        
        # Then
        assert "Failed to save config" in caplog.text

    @patch("empathy_os.cache.dependency_manager._validate_file_path")
    def test_given_os_error_when_save_then_logs_error(
        self, mock_validate, temp_config_path, caplog
    ):
        """Given an OS error during save
        When saving config
        Then it should log error
        """
        # Given
        mock_validate.return_value = str(temp_config_path)
        manager = DependencyManager(config_path=temp_config_path)
        manager.config = {"test": "data"}
        
        with patch("builtins.open", side_effect=OSError("Write error")):
            # When
            manager._save_config()
        
        # Then
        assert "Failed to save config" in caplog.text

    @patch("empathy_os.cache.dependency_manager._validate_file_path")
    def test_given_validation_error_when_save_then_logs_error(
        self, mock_validate, temp_config_path, caplog
    ):
        """Given a validation error
        When saving config
        Then it should log error
        """
        # Given
        mock_validate.side_effect = ValueError("Invalid path")
        manager = DependencyManager(config_path=temp_config_path)
        manager.config = {"test": "data"}
        
        # When
        manager._save_config()
        
        # Then
        assert "Failed to save config" in caplog.text


class TestIsCacheInstalled:
    """Test cache installation detection behavior."""

    def test_given_installed_dependencies_when_check_then_returns_true(self, dependency_manager):
        """Given sentence-transformers and torch are installed
        When checking if cache is installed
        Then it should return True
        """
        # Given
        with patch.dict("sys.modules", {
            "sentence_transformers": MagicMock(),
            "torch": MagicMock()
        }):
            # When
            result = dependency_manager.is_cache_installed()
        
        # Then
        assert result is True

    def test_given_missing_sentence_transformers_when_check_then_returns_false(
        self, dependency_manager
    ):
        """Given sentence-transformers is not installed
        When checking if cache is installed
        Then it should return False
        """
        # Given
        with patch("builtins.__import__", side_effect=ImportError("No module named 'sentence_transformers'")):
            # When
            result = dependency_manager.is_cache_installed()
        
        # Then
        assert result is False

    def test_given_missing_torch_when_check_then_returns_false(self, dependency_manager):
        """Given torch is not installed
        When checking if cache is installed
        Then it should return False
        """
        # Given
        def mock_import(name, *args, **kwargs):
            if name == "sentence_transformers":
                return MagicMock()
            elif name == "torch":
                raise ImportError("No module named 'torch'")
            return MagicMock()
        
        with patch("builtins.__import__", side_effect=mock_import):
            # When
            result = dependency_manager.is_cache_installed()
        
        # Then
        assert result is False


class TestShouldPromptCacheInstall:
    """Test prompt decision logic behavior."""

    def test_given_cache_installed_when_check_prompt_then_returns_false(self, dependency_manager):
        """Given cache dependencies are already installed
        When checking if should prompt
        Then it should return False
        """
        # Given
        with patch.object(dependency_manager, "is_cache_installed", return_value=True):
            # When
            result = dependency_manager.should_prompt_cache_install()
        
        # Then
        assert result is False

    def test_given_install_declined_when_check_prompt_then_returns_false(self, dependency_manager):
        """Given user previously declined installation
        When checking if should prompt
        Then it should return False
        """
        # Given
        dependency_manager.config = {"cache": {"install_declined": True}}
        with patch.object(dependency_manager, "is_cache_installed", return_value=False):
            # When
            result = dependency_manager.should_prompt_cache_install()
        
        # Then
        assert result is False

    def test_given_not_installed_and_not_declined_when_check_prompt_then_returns_true(
        self, dependency_manager
    ):
        """Given cache not installed and user hasn't declined
        When checking if should prompt
        Then it should return True
        """
        # Given
        dependency_manager.config = {}
        with patch.object(dependency_manager, "is_cache_installed", return_value=False):
            # When
            result = dependency_manager.should_prompt_cache_install()
        
        # Then
        assert result is True

    def test_given_empty_cache_config_when_check_prompt_then_returns_true(
        self, dependency_manager
    ):
        """Given empty cache configuration
        When checking if should prompt
        Then it should return True
        """
        # Given
        dependency_manager.config = {"cache": {}}
        with patch.object(dependency_manager, "is_cache_installed", return_value=False):
            # When
            result = dependency_manager.should_prompt_cache_install()
        
        # Then
        assert result is True

    def test_given_install_declined_false_when_check_prompt_then_returns_true(
        self, dependency_manager
    ):
        """Given install_declined is explicitly False
        When checking if should prompt
        Then it should return True
        """
        # Given
        dependency_manager.config = {"cache": {"install_declined": False}}
        with patch.object(dependency_manager, "is_cache_installed", return_value=False):
            # When
            result = dependency_manager.should_prompt_cache_install()
        
        # Then
        assert result is True


class TestIntegration:
    """Test integration scenarios."""

    @patch("empathy_os.cache.dependency_manager._validate_file_path")
    def test_given_full_workflow_when_managing_dependencies_then_behaves_correctly(
        self, mock_validate, temp_config_path
    ):
        """Given a complete workflow
        When managing dependencies through multiple operations
        Then it should maintain consistent state
        """
        # Given
        mock_validate.return_value = str(temp_config_path)
        manager = DependencyManager(config_path=temp_config_path)
        
        # When - check initial state
        with patch.object(manager, "is_cache_installed", return_value=False):
            should_prompt = manager.should_prompt_cache_install()