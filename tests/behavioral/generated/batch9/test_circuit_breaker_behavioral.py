"""Behavioral tests for circuit_breaker.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from datetime import datetime, timedelta
from unittest.mock import Mock, patch

import pytest

from empathy_os.trust.circuit_breaker import (
    TrustCircuitBreaker,
    TrustDamageEvent,
    TrustDamageType,
    TrustRecoveryEvent,
    TrustState,
)


# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture
def circuit_breaker():
    """Given a trust circuit breaker with default settings."""
    return TrustCircuitBreaker(
        failure_threshold=3,
        recovery_threshold=5,
        timeout_seconds=60,
    )


@pytest.fixture
def custom_circuit_breaker():
    """Given a trust circuit breaker with custom settings."""
    return TrustCircuitBreaker(
        failure_threshold=5,
        recovery_threshold=3,
        timeout_seconds=120,
    )


@pytest.fixture
def damage_event():
    """Given a trust damage event."""
    return TrustDamageEvent(
        event_type=TrustDamageType.WRONG_ANSWER,
        context="Provided incorrect calculation",
        severity=0.8,
        user_explicit=True,
    )


@pytest.fixture
def recovery_event():
    """Given a trust recovery event."""
    return TrustRecoveryEvent(
        context="Successfully completed task as expected",
        value=1.0,
    )


# =============================================================================
# TrustState Tests
# =============================================================================


class TestTrustState:
    """Tests for TrustState enum."""

    def test_given_trust_states_when_checking_values_then_correct_mapping(self):
        """Given trust states, when checking values, then correct mapping exists."""
        # Given / When
        full_autonomy = TrustState.FULL_AUTONOMY
        reduced_autonomy = TrustState.REDUCED_AUTONOMY
        supervised = TrustState.SUPERVISED

        # Then
        assert full_autonomy.value == "full_autonomy"
        assert reduced_autonomy.value == "reduced_autonomy"
        assert supervised.value == "supervised"

    def test_given_trust_state_when_comparing_then_equality_works(self):
        """Given trust state, when comparing, then equality works."""
        # Given
        state1 = TrustState.FULL_AUTONOMY
        state2 = TrustState.FULL_AUTONOMY
        state3 = TrustState.REDUCED_AUTONOMY

        # When / Then
        assert state1 == state2
        assert state1 != state3


# =============================================================================
# TrustDamageType Tests
# =============================================================================


class TestTrustDamageType:
    """Tests for TrustDamageType enum."""

    def test_given_damage_types_when_checking_all_values_then_all_present(self):
        """Given damage types, when checking all values, then all types present."""
        # Given / When
        damage_types = {dtype.value for dtype in TrustDamageType}

        # Then
        expected = {
            "wrong_answer",
            "ignored_preference",
            "unexpected_action",
            "slow_response",
            "misunderstood_intent",
            "repetitive_error",
        }
        assert damage_types == expected


# =============================================================================
# TrustDamageEvent Tests
# =============================================================================


class TestTrustDamageEvent:
    """Tests for TrustDamageEvent dataclass."""

    def test_given_damage_event_when_created_with_defaults_then_initialized(self):
        """Given damage event, when created with defaults, then properly initialized."""
        # Given / When
        event = TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)

        # Then
        assert event.event_type == TrustDamageType.WRONG_ANSWER
        assert isinstance(event.timestamp, datetime)
        assert event.context == ""
        assert event.severity == 1.0
        assert event.user_explicit is False

    def test_given_damage_event_when_created_with_all_params_then_stored(self):
        """Given damage event, when created with all params, then stored correctly."""
        # Given
        timestamp = datetime.now()

        # When
        event = TrustDamageEvent(
            event_type=TrustDamageType.IGNORED_PREFERENCE,
            timestamp=timestamp,
            context="Ignored dark mode preference",
            severity=0.7,
            user_explicit=True,
        )

        # Then
        assert event.event_type == TrustDamageType.IGNORED_PREFERENCE
        assert event.timestamp == timestamp
        assert event.context == "Ignored dark mode preference"
        assert event.severity == 0.7
        assert event.user_explicit is True

    def test_given_string_event_type_when_creating_event_then_converted_to_enum(self):
        """Given string event type, when creating event, then converted to enum."""
        # Given / When
        event = TrustDamageEvent(event_type="wrong_answer")

        # Then
        assert event.event_type == TrustDamageType.WRONG_ANSWER
        assert isinstance(event.event_type, TrustDamageType)

    def test_given_invalid_string_when_creating_event_then_raises_error(self):
        """Given invalid string, when creating event, then raises ValueError."""
        # Given / When / Then
        with pytest.raises(ValueError):
            TrustDamageEvent(event_type="invalid_type")


# =============================================================================
# TrustRecoveryEvent Tests
# =============================================================================


class TestTrustRecoveryEvent:
    """Tests for TrustRecoveryEvent dataclass."""

    def test_given_recovery_event_when_created_with_defaults_then_initialized(self):
        """Given recovery event, when created with defaults, then initialized."""
        # Given / When
        event = TrustRecoveryEvent()

        # Then
        assert isinstance(event.timestamp, datetime)
        assert event.context == ""
        assert event.value == 1.0

    def test_given_recovery_event_when_created_with_params_then_stored(self):
        """Given recovery event, when created with params, then stored correctly."""
        # Given
        timestamp = datetime.now()

        # When
        event = TrustRecoveryEvent(
            timestamp=timestamp,
            context="Completed task successfully",
            value=0.5,
        )

        # Then
        assert event.timestamp == timestamp
        assert event.context == "Completed task successfully"
        assert event.value == 0.5


# =============================================================================
# TrustCircuitBreaker Initialization Tests
# =============================================================================


class TestTrustCircuitBreakerInit:
    """Tests for TrustCircuitBreaker initialization."""

    def test_given_default_params_when_creating_breaker_then_initialized(self):
        """Given default params, when creating breaker, then initialized correctly."""
        # Given / When
        breaker = TrustCircuitBreaker()

        # Then
        assert breaker.state == TrustState.FULL_AUTONOMY
        assert breaker.failure_threshold == 3
        assert breaker.recovery_threshold == 5
        assert breaker.timeout_seconds == 60
        assert breaker.failure_count == 0
        assert breaker.success_count == 0
        assert len(breaker.damage_history) == 0
        assert len(breaker.recovery_history) == 0

    def test_given_custom_params_when_creating_breaker_then_stored(self):
        """Given custom params, when creating breaker, then stored correctly."""
        # Given / When
        breaker = TrustCircuitBreaker(
            failure_threshold=10,
            recovery_threshold=8,
            timeout_seconds=300,
        )

        # Then
        assert breaker.failure_threshold == 10
        assert breaker.recovery_threshold == 8
        assert breaker.timeout_seconds == 300

    def test_given_negative_threshold_when_creating_breaker_then_accepts(self):
        """Given negative threshold, when creating breaker, then accepts value."""
        # Given / When
        breaker = TrustCircuitBreaker(failure_threshold=-1)

        # Then
        assert breaker.failure_threshold == -1


# =============================================================================
# TrustCircuitBreaker Damage Recording Tests
# =============================================================================


class TestTrustCircuitBreakerDamage:
    """Tests for recording trust damage."""

    def test_given_full_autonomy_when_recording_damage_then_count_increases(
        self, circuit_breaker, damage_event
    ):
        """Given full autonomy, when recording damage, then count increases."""
        # Given
        assert circuit_breaker.state == TrustState.FULL_AUTONOMY
        assert circuit_breaker.failure_count == 0

        # When
        circuit_breaker.record_damage(damage_event)

        # Then
        assert circuit_breaker.failure_count == 1
        assert len(circuit_breaker.damage_history) == 1

    def test_given_damage_below_threshold_when_recording_then_stays_full_autonomy(
        self, circuit_breaker
    ):
        """Given damage below threshold, when recording, then stays full autonomy."""
        # Given
        assert circuit_breaker.failure_threshold == 3

        # When
        for _ in range(2):
            event = TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
            circuit_breaker.record_damage(event)

        # Then
        assert circuit_breaker.failure_count == 2
        assert circuit_breaker.state == TrustState.FULL_AUTONOMY

    def test_given_damage_at_threshold_when_recording_then_moves_to_reduced(
        self, circuit_breaker
    ):
        """Given damage at threshold, when recording, then moves to reduced autonomy."""
        # Given
        assert circuit_breaker.failure_threshold == 3

        # When
        for _ in range(3):
            event = TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
            circuit_breaker.record_damage(event)

        # Then
        assert circuit_breaker.failure_count == 3
        assert circuit_breaker.state == TrustState.REDUCED_AUTONOMY
        assert circuit_breaker.last_state_change is not None

    def test_given_reduced_autonomy_when_recording_damage_then_stays_reduced(
        self, circuit_breaker
    ):
        """Given reduced autonomy, when recording damage, then stays reduced."""
        # Given
        for _ in range(3):
            event = TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
            circuit_breaker.record_damage(event)
        assert circuit_breaker.state == TrustState.REDUCED_AUTONOMY

        # When
        event = TrustDamageEvent(event_type=TrustDamageType.IGNORED_PREFERENCE)
        circuit_breaker.record_damage(event)

        # Then
        assert circuit_breaker.state == TrustState.REDUCED_AUTONOMY
        assert circuit_breaker.failure_count == 4

    def test_given_supervised_when_recording_damage_then_moves_to_reduced(
        self, circuit_breaker
    ):
        """Given supervised, when recording damage, then moves back to reduced."""
        # Given - move to reduced then supervised
        for _ in range(3):
            circuit_breaker.record_damage(
                TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
            )
        circuit_breaker._transition_to_supervised()
        assert circuit_breaker.state == TrustState.SUPERVISED

        # When
        circuit_breaker.record_damage(
            TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
        )

        # Then
        assert circuit_breaker.state == TrustState.REDUCED_AUTONOMY
        assert circuit_breaker.success_count == 0

    def test_given_high_severity_damage_when_recording_then_stored_correctly(
        self, circuit_breaker
    ):
        """Given high severity damage, when recording, then stored correctly."""
        # Given
        event = TrustDamageEvent(
            event_type=TrustDamageType.REPETITIVE_ERROR,
            severity=0.9,
            user_explicit=True,
        )

        # When
        circuit_breaker.record_damage(event)

        # Then
        assert len(circuit_breaker.damage_history) == 1
        assert circuit_breaker.damage_history[0].severity == 0.9
        assert circuit_breaker.damage_history[0].user_explicit is True


# =============================================================================
# TrustCircuitBreaker Recovery Recording Tests
# =============================================================================


class TestTrustCircuitBreakerRecovery:
    """Tests for recording trust recovery."""

    def test_given_full_autonomy_when_recording_recovery_then_stays_full(
        self, circuit_breaker, recovery_event
    ):
        """Given full autonomy, when recording recovery, then stays full autonomy."""
        # Given
        assert circuit_breaker.state == TrustState.FULL_AUTONOMY

        # When
        circuit_breaker.record_recovery(recovery_event)

        # Then
        assert circuit_breaker.state == TrustState.FULL_AUTONOMY
        assert len(circuit_breaker.recovery_history) == 1

    def test_given_reduced_autonomy_when_recording_recovery_then_stays_reduced(
        self, circuit_breaker, recovery_event
    ):
        """Given reduced autonomy, when recording recovery, then stays reduced."""
        # Given - move to reduced
        for _ in range(3):
            circuit_breaker.record_damage(
                TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
            )
        assert circuit_breaker.state == TrustState.REDUCED_AUTONOMY

        # When
        circuit_breaker.record_recovery(recovery_event)

        # Then
        assert circuit_breaker.state == TrustState.REDUCED_AUTONOMY
        assert circuit_breaker.success_count == 0

    def test_given_supervised_when_recording_recovery_then_count_increases(
        self, circuit_breaker, recovery_event
    ):
        """Given supervised, when recording recovery, then success count increases."""
        # Given - move to reduced then supervised
        for _ in range(3):
            circuit_breaker.record_damage(
                TrustDamageEvent(event_type=TrustDamageType.WRONG_ANSWER)
            )
        circuit_breaker._transition_to_supervised()
        assert circuit_breaker.state == TrustState.SUPERVISED

        # When
        circuit_breaker.record_recovery(recovery_event)

        # Then
        assert circuit_breaker.success_count == 1
        assert len(circuit_breaker.recovery_history) == 1

    def test_given_supervised_below_threshold_when_recovering_then_stays_supervised(
        self, circuit_breaker
    ):
        """Given supervised below threshold, when recovering, then stays supervised."""
        # Given - move to supervised
        for _ in range(3):
            circuit_breaker.record_damage(
                TrustDamageEvent(event_type=TrustDamageType.WRONG