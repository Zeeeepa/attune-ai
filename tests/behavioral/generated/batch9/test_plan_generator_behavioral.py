"""Behavioral tests for plan_generator.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from datetime import datetime
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.meta_workflows.models import (
    AgentCompositionRule,
    FormQuestion,
    MetaWorkflowTemplate,
    TierStrategy,
)
from empathy_os.meta_workflows.plan_generator import (
    AgentStep,
    ExecutionPlan,
    PlanGenerator,
)


# Fixtures


@pytest.fixture
def basic_form_question():
    """Given a basic form question."""
    return FormQuestion(
        question_id="test_question",
        prompt="What is your goal?",
        field_name="goal",
        required=True,
        default_value="default goal",
    )


@pytest.fixture
def optional_form_question():
    """Given an optional form question."""
    return FormQuestion(
        question_id="optional_question",
        prompt="Additional context?",
        field_name="context",
        required=False,
        default_value="",
    )


@pytest.fixture
def composition_rule():
    """Given a composition rule."""
    return AgentCompositionRule(
        role="analyst",
        tier_strategy=TierStrategy.CAPABLE_FIRST,
        tools=["search", "calculator"],
        prompt_template="Analyze: {goal}",
        success_criteria=["Complete analysis", "Provide recommendations"],
    )


@pytest.fixture
def composition_rule_with_conditional():
    """Given a composition rule with conditional."""
    return AgentCompositionRule(
        role="reviewer",
        tier_strategy=TierStrategy.PREMIUM_ONLY,
        tools=["review_tool"],
        prompt_template="Review: {goal}",
        success_criteria=["Thorough review"],
        only_if_field="enable_review",
    )


@pytest.fixture
def basic_template(basic_form_question, composition_rule):
    """Given a basic meta-workflow template."""
    return MetaWorkflowTemplate(
        template_id="test_template",
        name="Test Template",
        description="A test template",
        form_questions=[basic_form_question],
        composition_rules=[composition_rule],
        synthesis_prompt="Synthesize results: {goal}",
    )


@pytest.fixture
def complex_template(
    basic_form_question,
    optional_form_question,
    composition_rule,
    composition_rule_with_conditional,
):
    """Given a complex meta-workflow template with multiple rules."""
    return MetaWorkflowTemplate(
        template_id="complex_template",
        name="Complex Template",
        description="A complex template",
        form_questions=[basic_form_question, optional_form_question],
        composition_rules=[composition_rule, composition_rule_with_conditional],
        synthesis_prompt="Synthesize: {goal} with {context}",
    )


@pytest.fixture
def mock_agent_template():
    """Given a mock agent template."""
    return {
        "name": "test_agent",
        "description": "Test agent",
        "tools": ["tool1", "tool2"],
        "system_prompt": "You are a test agent",
    }


# Tests for AgentStep


class TestAgentStep:
    """Tests for AgentStep dataclass."""

    def test_agent_step_creation(self):
        """Given valid parameters
        When creating an AgentStep
        Then it should store all attributes correctly.
        """
        # When
        step = AgentStep(
            order=1,
            role="analyst",
            tier_recommendation="sonnet",
            tools=["search", "calculator"],
            prompt="Analyze data",
            success_criteria=["Complete analysis"],
            config={"temperature": 0.7},
        )

        # Then
        assert step.order == 1
        assert step.role == "analyst"
        assert step.tier_recommendation == "sonnet"
        assert step.tools == ["search", "calculator"]
        assert step.prompt == "Analyze data"
        assert step.success_criteria == ["Complete analysis"]
        assert step.config == {"temperature": 0.7}


# Tests for ExecutionPlan


class TestExecutionPlan:
    """Tests for ExecutionPlan dataclass."""

    def test_execution_plan_creation(self):
        """Given valid parameters
        When creating an ExecutionPlan
        Then it should store all attributes correctly.
        """
        # Given
        step = AgentStep(
            order=1,
            role="analyst",
            tier_recommendation="sonnet",
            tools=["search"],
            prompt="Analyze",
            success_criteria=["Done"],
            config={},
        )
        timestamp = datetime.now().isoformat()

        # When
        plan = ExecutionPlan(
            template_id="test_id",
            template_name="Test Plan",
            generated_at=timestamp,
            form_responses={"goal": "test goal"},
            steps=[step],
            synthesis_prompt="Synthesize results",
        )

        # Then
        assert plan.template_id == "test_id"
        assert plan.template_name == "Test Plan"
        assert plan.generated_at == timestamp
        assert plan.form_responses == {"goal": "test goal"}
        assert len(plan.steps) == 1
        assert plan.synthesis_prompt == "Synthesize results"


# Tests for PlanGenerator


class TestPlanGeneratorInitialization:
    """Tests for PlanGenerator initialization."""

    def test_initialization_with_template(self, basic_template):
        """Given a meta-workflow template
        When initializing PlanGenerator
        Then it should store the template.
        """
        # When
        generator = PlanGenerator(basic_template)

        # Then
        assert generator.template == basic_template

    def test_tier_to_model_mapping(self):
        """Given the PlanGenerator class
        When checking TIER_TO_MODEL mapping
        Then it should contain all tier strategies.
        """
        # Then
        assert TierStrategy.CHEAP_ONLY in PlanGenerator.TIER_TO_MODEL
        assert TierStrategy.PROGRESSIVE in PlanGenerator.TIER_TO_MODEL
        assert TierStrategy.CAPABLE_FIRST in PlanGenerator.TIER_TO_MODEL
        assert TierStrategy.PREMIUM_ONLY in PlanGenerator.TIER_TO_MODEL

    def test_tier_model_recommendations(self):
        """Given tier strategies
        When mapping to models
        Then recommendations should be appropriate.
        """
        # Then
        assert PlanGenerator.TIER_TO_MODEL[TierStrategy.CHEAP_ONLY] == "haiku"
        assert PlanGenerator.TIER_TO_MODEL[TierStrategy.PREMIUM_ONLY] == "opus"
        assert "sonnet" in PlanGenerator.TIER_TO_MODEL[TierStrategy.CAPABLE_FIRST]


class TestPlanGeneratorGenerate:
    """Tests for PlanGenerator.generate method."""

    def test_generate_with_provided_responses(self, basic_template):
        """Given a template and user responses
        When generating a plan
        Then it should create an execution plan with provided responses.
        """
        # Given
        generator = PlanGenerator(basic_template)
        responses = {"goal": "custom goal"}

        # When
        with patch.object(generator, "_build_steps", return_value=[]):
            with patch.object(
                generator, "_build_synthesis_prompt", return_value="synthesis"
            ):
                plan = generator.generate(form_responses=responses)

        # Then
        assert plan.template_id == "test_template"
        assert plan.template_name == "Test Template"
        assert plan.form_responses["goal"] == "custom goal"
        assert isinstance(plan.generated_at, str)
        assert plan.synthesis_prompt == "synthesis"

    def test_generate_with_defaults(self, basic_template):
        """Given a template without user responses
        When generating with use_defaults=True
        Then it should use default values.
        """
        # Given
        generator = PlanGenerator(basic_template)

        # When
        with patch.object(
            generator, "_collect_responses", return_value={"goal": "default goal"}
        ) as mock_collect:
            with patch.object(generator, "_build_steps", return_value=[]):
                with patch.object(
                    generator, "_build_synthesis_prompt", return_value="synthesis"
                ):
                    plan = generator.generate(use_defaults=True)

        # Then
        mock_collect.assert_called_once_with(None, True)
        assert plan.form_responses["goal"] == "default goal"

    def test_generate_without_defaults(self, basic_template):
        """Given a template without user responses
        When generating with use_defaults=False
        Then it should not use default values.
        """
        # Given
        generator = PlanGenerator(basic_template)

        # When
        with patch.object(
            generator, "_collect_responses", return_value={}
        ) as mock_collect:
            with patch.object(generator, "_build_steps", return_value=[]):
                with patch.object(
                    generator, "_build_synthesis_prompt", return_value="synthesis"
                ):
                    plan = generator.generate(use_defaults=False)

        # Then
        mock_collect.assert_called_once_with(None, False)

    def test_generate_calls_build_steps(self, basic_template):
        """Given a template
        When generating a plan
        Then it should call _build_steps with responses.
        """
        # Given
        generator = PlanGenerator(basic_template)
        responses = {"goal": "test"}

        # When
        with patch.object(
            generator, "_collect_responses", return_value=responses
        ):
            with patch.object(generator, "_build_steps", return_value=[]) as mock_build:
                with patch.object(
                    generator, "_build_synthesis_prompt", return_value="synthesis"
                ):
                    generator.generate()

        # Then
        mock_build.assert_called_once_with(responses)

    def test_generate_calls_build_synthesis(self, basic_template):
        """Given a template
        When generating a plan
        Then it should call _build_synthesis_prompt with steps.
        """
        # Given
        generator = PlanGenerator(basic_template)
        steps = [Mock()]

        # When
        with patch.object(generator, "_collect_responses", return_value={}):
            with patch.object(generator, "_build_steps", return_value=steps):
                with patch.object(
                    generator, "_build_synthesis_prompt", return_value="synthesis"
                ) as mock_synthesis:
                    generator.generate()

        # Then
        mock_synthesis.assert_called_once_with(steps)

    def test_generate_timestamp_format(self, basic_template):
        """Given a template
        When generating a plan
        Then the timestamp should be in ISO format.
        """
        # Given
        generator = PlanGenerator(basic_template)

        # When
        with patch.object(generator, "_build_steps", return_value=[]):
            with patch.object(
                generator, "_build_synthesis_prompt", return_value="synthesis"
            ):
                plan = generator.generate()

        # Then
        # Should not raise ValueError
        datetime.fromisoformat(plan.generated_at)


class TestPlanGeneratorCollectResponses:
    """Tests for PlanGenerator._collect_responses method."""

    def test_collect_responses_with_provided_values(self, basic_template):
        """Given provided responses
        When collecting responses
        Then it should use provided values.
        """
        # Given
        generator = PlanGenerator(basic_template)
        provided = {"goal": "custom goal"}

        # When
        responses = generator._collect_responses(provided, use_defaults=True)

        # Then
        assert responses["goal"] == "custom goal"

    def test_collect_responses_with_defaults(self, basic_template):
        """Given no provided responses and use_defaults=True
        When collecting responses
        Then it should use default values.
        """
        # Given
        generator = PlanGenerator(basic_template)

        # When
        responses = generator._collect_responses(None, use_defaults=True)

        # Then
        assert responses["goal"] == "default goal"

    def test_collect_responses_without_defaults(self, basic_template):
        """Given no provided responses and use_defaults=False
        When collecting responses
        Then it should not include missing values.
        """
        # Given
        generator = PlanGenerator(basic_template)

        # When
        responses = generator._collect_responses(None, use_defaults=False)

        # Then
        assert "goal" not in responses

    def test_collect_responses_optional_fields(self, complex_template):
        """Given optional form questions
        When collecting responses without values
        Then it should handle optional fields correctly.
        """
        # Given
        generator = PlanGenerator(complex_template)

        # When
        responses = generator._collect_responses(None, use_defaults=True)

        # Then
        assert "goal" in responses
        assert "context" in responses
        assert responses["context"] == ""

    def test_collect_responses_mixed_provided_and_defaults(self, complex_template):
        """Given some provided responses
        When collecting with use_defaults=True
        Then it should mix provided and default values.
        """
        # Given
        generator = PlanGenerator(complex_template)
        provided = {"goal": "custom"}

        # When
        responses = generator._collect_responses(provided, use_defaults=True)

        # Then
        assert responses["goal"] == "custom"
        assert "context" in responses

    def test_collect_responses_empty_provided_dict(self, basic_template):
        """Given an empty provided dict
        When collecting responses
        Then it should treat it as None.
        """
        # Given
        generator = PlanGenerator(basic_template)
        provided = {}

        # When
        responses = generator._collect_responses(provided, use_defaults=True)

        # Then
        assert responses["goal"] == "default goal"


class TestPlanGeneratorBuildSteps:
    """Tests for PlanGenerator._build_steps method."""

    @patch("empathy_os.meta_workflows.plan_generator.get_template")
    def test_build_steps_basic(self, mock_get_template, basic_template, mock_agent_template):
        """Given composition rules
        When building steps
        Then it should create AgentStep objects.
        """
        # Given
        mock_get_template.return_value = mock_agent_template
        generator = PlanGenerator(basic_template)
        responses = {"goal": "test goal"}

        # When
        steps = generator._build_steps(responses)

        # Then
        assert len(steps) == 1
        assert isinstance(steps[0], AgentStep)
        assert steps[0].order == 1
        assert steps[0].role == "analyst"

    @patch("empathy_os.meta_workflows.plan_generator.get_template")
    def test_build_steps_prompt_interpolation(
        self, mock_get_template, basic_template, mock_agent_template
    ):
        """Given a prompt template with variables
        When building steps
        Then it should interpolate variables.
        """
        # Given
        mock_get_template.return_value = mock_agent_template
        generator = PlanGenerator(basic_template)
        responses = {"goal": "test goal"}

        # When
        steps = generator._build_steps(responses)

        # Then
        assert "test goal" in steps[0].prompt

    @patch("empathy_os.meta_workflows.plan_generator.get_template")
    def test_build_steps_tier_recommendation(
        self, mock_get_template, basic_template, mock_agent_template
    ):
        """Given a tier strategy
        When building steps
        Then it should include tier recommendation.
        """
        # Given
        mock_get_template.return_value =