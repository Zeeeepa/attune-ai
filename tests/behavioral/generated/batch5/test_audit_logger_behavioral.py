"""Behavioral tests for audit_logger.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import os
import tempfile
import uuid
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.memory.security.audit_logger import (
    AuditEvent,
    AuditLogger,
    SecurityViolation,
)


class TestAuditEvent:
    """Behavioral tests for AuditEvent dataclass."""

    def test_audit_event_default_fields_are_populated(self):
        """
        Given: A new AuditEvent is created without explicit fields
        When: The event is instantiated
        Then: Default values for event_id, timestamp, and version are populated
        """
        # Given/When
        event = AuditEvent()

        # Then
        assert event.event_id.startswith("evt_")
        assert len(event.event_id) == 16  # evt_ + 12 hex chars
        assert event.timestamp.endswith("Z")
        assert event.version == "1.0"
        assert event.status == "success"

    def test_audit_event_accepts_custom_fields(self):
        """
        Given: Custom field values are provided
        When: An AuditEvent is created with those values
        Then: The event contains the custom values
        """
        # Given
        custom_data = {"key": "value", "count": 42}

        # When
        event = AuditEvent(
            event_type="test_event",
            user_id="user123",
            session_id="session456",
            status="failed",
            error="Test error",
            data=custom_data,
        )

        # Then
        assert event.event_type == "test_event"
        assert event.user_id == "user123"
        assert event.session_id == "session456"
        assert event.status == "failed"
        assert event.error == "Test error"
        assert event.data == custom_data

    def test_audit_event_to_dict_flattens_data_field(self):
        """
        Given: An AuditEvent with nested data dictionary
        When: to_dict() is called
        Then: The data dictionary is flattened into the top level
        """
        # Given
        event = AuditEvent(
            event_type="llm_request",
            user_id="user@test.com",
            data={"provider": "anthropic", "tokens": 150},
        )

        # When
        result = event.to_dict()

        # Then
        assert "data" not in result
        assert result["provider"] == "anthropic"
        assert result["tokens"] == 150
        assert result["event_type"] == "llm_request"
        assert result["user_id"] == "user@test.com"

    def test_audit_event_to_dict_handles_empty_data(self):
        """
        Given: An AuditEvent with empty data dictionary
        When: to_dict() is called
        Then: The result contains only standard fields
        """
        # Given
        event = AuditEvent(event_type="test", user_id="user1")

        # When
        result = event.to_dict()

        # Then
        assert "data" not in result
        assert result["event_type"] == "test"
        assert result["user_id"] == "user1"

    def test_audit_event_timestamp_is_utc_iso8601(self):
        """
        Given: A new AuditEvent is created
        When: The timestamp is examined
        Then: It is in ISO-8601 format with UTC timezone (Z suffix)
        """
        # Given/When
        event = AuditEvent()

        # Then
        assert event.timestamp.endswith("Z")
        # Verify it can be parsed as ISO-8601
        timestamp_without_z = event.timestamp[:-1]
        parsed = datetime.fromisoformat(timestamp_without_z)
        assert isinstance(parsed, datetime)


class TestSecurityViolation:
    """Behavioral tests for SecurityViolation dataclass."""

    def test_security_violation_creation_with_required_fields(self):
        """
        Given: Required fields for a security violation
        When: A SecurityViolation is created
        Then: The violation is properly initialized
        """
        # Given/When
        violation = SecurityViolation(
            violation_type="secrets_detected", severity="HIGH"
        )

        # Then
        assert violation.violation_type == "secrets_detected"
        assert violation.severity == "HIGH"
        assert violation.details == {}
        assert violation.user_notified is False
        assert violation.manager_notified is False
        assert violation.security_team_notified is False

    def test_security_violation_with_details_and_notifications(self):
        """
        Given: A security violation with details and notification flags
        When: The violation is created
        Then: All fields are properly set
        """
        # Given
        details = {"secret_type": "api_key", "location": "prompt"}

        # When
        violation = SecurityViolation(
            violation_type="pii_in_storage",
            severity="CRITICAL",
            details=details,
            user_notified=True,
            security_team_notified=True,
        )

        # Then
        assert violation.violation_type == "pii_in_storage"
        assert violation.severity == "CRITICAL"
        assert violation.details == details
        assert violation.user_notified is True
        assert violation.manager_notified is False
        assert violation.security_team_notified is True


class TestAuditLoggerInitialization:
    """Behavioral tests for AuditLogger initialization."""

    @patch("empathy_os.memory.security.audit_logger.Path")
    def test_audit_logger_uses_default_path_on_linux(self, mock_path):
        """
        Given: Running on Linux without custom log path
        When: AuditLogger is initialized
        Then: Uses /var/log/empathy/audit.jsonl as default
        """
        # Given
        with patch("os.name", "posix"):
            with patch("sys.platform", "linux"):
                mock_path_instance = MagicMock()
                mock_path.return_value = mock_path_instance

                # When
                logger = AuditLogger()

                # Then
                assert logger.log_path == mock_path_instance

    def test_audit_logger_uses_custom_path(self):
        """
        Given: A custom log path is provided
        When: AuditLogger is initialized
        Then: The custom path is used
        """
        # Given
        custom_path = Path("/custom/audit.jsonl")

        # When
        logger = AuditLogger(log_path=custom_path)

        # Then
        assert logger.log_path == custom_path

    @patch("empathy_os.memory.security.audit_logger.Path.mkdir")
    def test_audit_logger_creates_parent_directories(self, mock_mkdir):
        """
        Given: A log path whose parent directory doesn't exist
        When: AuditLogger is initialized
        Then: Parent directories are created
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "logs" / "audit" / "audit.jsonl"

            # When
            with patch.object(Path, "mkdir", mock_mkdir):
                logger = AuditLogger(log_path=log_path)

            # Then
            mock_mkdir.assert_called_once_with(parents=True, exist_ok=True)


class TestAuditLoggerWriteEvent:
    """Behavioral tests for AuditLogger._write_event method."""

    def test_write_event_appends_json_line_to_file(self):
        """
        Given: An audit event
        When: _write_event is called
        Then: The event is appended as a JSON line to the log file
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            logger = AuditLogger(log_path=log_path)
            event = AuditEvent(event_type="test", user_id="user1")

            # When
            logger._write_event(event)

            # Then
            assert log_path.exists()
            with open(log_path, "r") as f:
                line = f.readline()
                parsed = json.loads(line)
                assert parsed["event_type"] == "test"
                assert parsed["user_id"] == "user1"

    def test_write_event_appends_multiple_events(self):
        """
        Given: Multiple audit events
        When: _write_event is called multiple times
        Then: All events are appended to the file
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            logger = AuditLogger(log_path=log_path)

            # When
            logger._write_event(AuditEvent(event_type="event1"))
            logger._write_event(AuditEvent(event_type="event2"))
            logger._write_event(AuditEvent(event_type="event3"))

            # Then
            with open(log_path, "r") as f:
                lines = f.readlines()
                assert len(lines) == 3
                assert json.loads(lines[0])["event_type"] == "event1"
                assert json.loads(lines[1])["event_type"] == "event2"
                assert json.loads(lines[2])["event_type"] == "event3"

    @patch("empathy_os.memory.security.audit_logger.logger")
    def test_write_event_handles_write_errors_gracefully(self, mock_logger):
        """
        Given: A file write operation that fails
        When: _write_event is called
        Then: The error is logged but not raised
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            audit_logger = AuditLogger(log_path=log_path)
            event = AuditEvent(event_type="test")

            with patch("builtins.open", side_effect=IOError("Disk full")):
                # When
                audit_logger._write_event(event)

                # Then
                mock_logger.error.assert_called_once()
                assert "Failed to write audit event" in str(
                    mock_logger.error.call_args
                )


class TestAuditLoggerLLMRequest:
    """Behavioral tests for log_llm_request method."""

    def test_log_llm_request_creates_proper_audit_event(self):
        """
        Given: LLM request parameters
        When: log_llm_request is called
        Then: A properly formatted audit event is written
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            logger = AuditLogger(log_path=log_path)

            # When
            logger.log_llm_request(
                user_id="user@test.com",
                session_id="session123",
                empathy_level=3,
                provider="anthropic",
                model="claude-sonnet-4",
                memory_sources=["enterprise", "user"],
                prompt_tokens=100,
                completion_tokens=50,
                response_time_ms=250,
            )

            # Then
            with open(log_path, "r") as f:
                event = json.loads(f.readline())
                assert event["event_type"] == "llm_request"
                assert event["user_id"] == "user@test.com"
                assert event["session_id"] == "session123"
                assert event["empathy_level"] == 3
                assert event["provider"] == "anthropic"
                assert event["model"] == "claude-sonnet-4"
                assert event["memory_sources"] == ["enterprise", "user"]
                assert event["prompt_tokens"] == 100
                assert event["completion_tokens"] == 50
                assert event["response_time_ms"] == 250
                assert event["status"] == "success"

    def test_log_llm_request_with_failure(self):
        """
        Given: An LLM request that failed
        When: log_llm_request is called with error details
        Then: The failure is properly logged
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            logger = AuditLogger(log_path=log_path)

            # When
            logger.log_llm_request(
                user_id="user@test.com",
                empathy_level=2,
                provider="openai",
                model="gpt-4",
                status="failed",
                error="Rate limit exceeded",
            )

            # Then
            with open(log_path, "r") as f:
                event = json.loads(f.readline())
                assert event["event_type"] == "llm_request"
                assert event["status"] == "failed"
                assert event["error"] == "Rate limit exceeded"


class TestAuditLoggerStorePattern:
    """Behavioral tests for log_store_pattern method."""

    def test_log_store_pattern_creates_proper_audit_event(self):
        """
        Given: Pattern storage parameters
        When: log_store_pattern is called
        Then: A properly formatted audit event is written
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            logger = AuditLogger(log_path=log_path)

            # When
            logger.log_store_pattern(
                user_id="user@test.com",
                session_id="session456",
                pattern_id="pattern_abc123",
                pattern_type="preference",
                classification="CONFIDENTIAL",
                size_bytes=1024,
                storage_tier="hot",
            )

            # Then
            with open(log_path, "r") as f:
                event = json.loads(f.readline())
                assert event["event_type"] == "store_pattern"
                assert event["user_id"] == "user@test.com"
                assert event["session_id"] == "session456"
                assert event["pattern_id"] == "pattern_abc123"
                assert event["pattern_type"] == "preference"
                assert event["classification"] == "CONFIDENTIAL"
                assert event["size_bytes"] == 1024
                assert event["storage_tier"] == "hot"
                assert event["status"] == "success"

    def test_log_store_pattern_with_optional_fields(self):
        """
        Given: Pattern storage with minimal parameters
        When: log_store_pattern is called
        Then: Optional fields are omitted
        """
        # Given
        with tempfile.TemporaryDirectory() as tmpdir:
            log_path = Path(tmpdir) / "audit.jsonl"
            logger = AuditLogger(log_path=log_path)

            # When
            logger.log_store_pattern(
                user_id="user@test.com", pattern_id="pattern_xyz"
            )

            # Then
            with open(log_path, "r") as f:
                event = json.loads(f.readline())
                assert event["event_type"] == "store_pattern"
                assert event["pattern_id"] == "pattern_xyz"
                assert event.get("size_bytes") is None


class TestAuditLoggerRetrievePattern:
    """Behavioral tests for log_retrieve_