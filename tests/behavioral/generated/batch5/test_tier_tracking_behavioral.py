"""Behavioral tests for tier_tracking.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import uuid
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.workflows.tier_tracking import (
    TierAttempt,
    WorkflowTierProgression,
    WorkflowTierTracker,
)


@pytest.fixture
def temp_patterns_dir(tmp_path):
    """Given a temporary directory for tier progression patterns."""
    patterns_dir = tmp_path / "patterns" / "debugging"
    patterns_dir.mkdir(parents=True, exist_ok=True)
    return patterns_dir


@pytest.fixture
def tracker(temp_patterns_dir):
    """Given a WorkflowTierTracker instance."""
    return WorkflowTierTracker(
        workflow_name="test_workflow",
        workflow_description="Test workflow description",
        patterns_dir=temp_patterns_dir,
    )


@pytest.fixture
def mock_tier_recommender():
    """Given a mock TierRecommender."""
    with patch("empathy_os.workflows.tier_tracking.TierRecommender") as mock:
        recommender_instance = MagicMock()
        mock.return_value = recommender_instance
        yield recommender_instance


class TestTierAttempt:
    """Test TierAttempt dataclass."""

    def test_tier_attempt_creation_with_success(self):
        """
        Given: Valid tier attempt parameters with success
        When: Creating a TierAttempt instance
        Then: Instance is created with correct attributes
        """
        # Given
        tier = "cheap"
        attempt = 1
        success = True
        quality_gates_passed = ["syntax_check", "tests_pass"]

        # When
        tier_attempt = TierAttempt(
            tier=tier,
            attempt=attempt,
            success=success,
            quality_gates_passed=quality_gates_passed,
        )

        # Then
        assert tier_attempt.tier == tier
        assert tier_attempt.attempt == attempt
        assert tier_attempt.success is True
        assert tier_attempt.quality_gate_failed is None
        assert tier_attempt.quality_gates_passed == quality_gates_passed

    def test_tier_attempt_creation_with_failure(self):
        """
        Given: Valid tier attempt parameters with failure
        When: Creating a TierAttempt instance
        Then: Instance is created with failure information
        """
        # Given
        tier = "capable"
        attempt = 2
        success = False
        quality_gate_failed = "tests_fail"

        # When
        tier_attempt = TierAttempt(
            tier=tier,
            attempt=attempt,
            success=success,
            quality_gate_failed=quality_gate_failed,
        )

        # Then
        assert tier_attempt.tier == tier
        assert tier_attempt.attempt == attempt
        assert tier_attempt.success is False
        assert tier_attempt.quality_gate_failed == quality_gate_failed


class TestWorkflowTierProgression:
    """Test WorkflowTierProgression dataclass."""

    def test_workflow_tier_progression_creation(self):
        """
        Given: Valid workflow tier progression parameters
        When: Creating a WorkflowTierProgression instance
        Then: Instance is created with all required attributes
        """
        # Given
        workflow_name = "test_workflow"
        workflow_id = str(uuid.uuid4())
        bug_description = "Test bug"
        files_affected = ["file1.py", "file2.py"]
        bug_type = "syntax_error"
        recommended_tier = "cheap"
        starting_tier = "cheap"
        successful_tier = "capable"
        total_attempts = 2
        tier_history = [{"tier": "cheap", "success": False}]
        total_cost = 0.12
        cost_if_always_premium = 0.90
        savings_percent = 86.67
        tests_passed = True
        error_occurred = False
        started_at = "2025-01-01T00:00:00"
        completed_at = "2025-01-01T00:05:00"
        duration_seconds = 300.0

        # When
        progression = WorkflowTierProgression(
            workflow_name=workflow_name,
            workflow_id=workflow_id,
            bug_description=bug_description,
            files_affected=files_affected,
            bug_type=bug_type,
            recommended_tier=recommended_tier,
            starting_tier=starting_tier,
            successful_tier=successful_tier,
            total_attempts=total_attempts,
            tier_history=tier_history,
            total_cost=total_cost,
            cost_if_always_premium=cost_if_always_premium,
            savings_percent=savings_percent,
            tests_passed=tests_passed,
            error_occurred=error_occurred,
            started_at=started_at,
            completed_at=completed_at,
            duration_seconds=duration_seconds,
        )

        # Then
        assert progression.workflow_name == workflow_name
        assert progression.workflow_id == workflow_id
        assert progression.bug_description == bug_description
        assert progression.files_affected == files_affected
        assert progression.recommended_tier == recommended_tier
        assert progression.total_cost == total_cost
        assert progression.error_message is None

    def test_workflow_tier_progression_with_error(self):
        """
        Given: Workflow tier progression with error message
        When: Creating a WorkflowTierProgression instance
        Then: Instance includes error message
        """
        # Given
        error_message = "Test error occurred"

        # When
        progression = WorkflowTierProgression(
            workflow_name="test",
            workflow_id=str(uuid.uuid4()),
            bug_description="Test",
            files_affected=[],
            bug_type="error",
            recommended_tier="cheap",
            starting_tier="cheap",
            successful_tier="premium",
            total_attempts=3,
            tier_history=[],
            total_cost=0.57,
            cost_if_always_premium=1.35,
            savings_percent=57.78,
            tests_passed=False,
            error_occurred=True,
            started_at="2025-01-01T00:00:00",
            completed_at="2025-01-01T00:10:00",
            duration_seconds=600.0,
            error_message=error_message,
        )

        # Then
        assert progression.error_occurred is True
        assert progression.error_message == error_message


class TestWorkflowTierTrackerInit:
    """Test WorkflowTierTracker initialization."""

    def test_init_with_custom_patterns_dir(self, temp_patterns_dir):
        """
        Given: Custom patterns directory path
        When: Initializing WorkflowTierTracker
        Then: Tracker is created with specified directory
        """
        # When
        tracker = WorkflowTierTracker(
            workflow_name="test_workflow",
            workflow_description="Test description",
            patterns_dir=temp_patterns_dir,
        )

        # Then
        assert tracker.workflow_name == "test_workflow"
        assert tracker.workflow_description == "Test description"
        assert tracker.patterns_dir == temp_patterns_dir
        assert isinstance(tracker.workflow_id, str)
        assert tracker.recommended_tier is None
        assert tracker.starting_tier is None

    def test_init_with_default_patterns_dir(self):
        """
        Given: No patterns directory specified
        When: Initializing WorkflowTierTracker
        Then: Tracker creates default patterns directory
        """
        # When
        with patch("pathlib.Path.mkdir") as mock_mkdir:
            tracker = WorkflowTierTracker(
                workflow_name="test_workflow",
                workflow_description="Test description",
            )

            # Then
            assert tracker.patterns_dir == Path.cwd() / "patterns" / "debugging"
            mock_mkdir.assert_called_once_with(parents=True, exist_ok=True)

    def test_init_creates_workflow_id(self, temp_patterns_dir):
        """
        Given: WorkflowTierTracker initialization
        When: Creating tracker instance
        Then: Unique workflow ID is generated
        """
        # When
        tracker1 = WorkflowTierTracker(
            workflow_name="test1",
            workflow_description="Test 1",
            patterns_dir=temp_patterns_dir,
        )
        tracker2 = WorkflowTierTracker(
            workflow_name="test2",
            workflow_description="Test 2",
            patterns_dir=temp_patterns_dir,
        )

        # Then
        assert tracker1.workflow_id != tracker2.workflow_id
        assert len(tracker1.workflow_id) == 36  # UUID format


class TestShowRecommendation:
    """Test show_recommendation method."""

    def test_show_recommendation_with_files(
        self, tracker, mock_tier_recommender, capsys
    ):
        """
        Given: Files affected by workflow
        When: Showing tier recommendation
        Then: Recommendation is displayed and stored
        """
        # Given
        files_affected = ["test_file.py"]
        mock_tier_recommender.recommend_tier.return_value = "capable"

        with patch(
            "empathy_os.workflows.tier_tracking.TierRecommender",
            return_value=mock_tier_recommender,
        ):
            # When
            tracker.show_recommendation(
                files_affected=files_affected,
                bug_type="logic_error",
                bug_description="Test bug",
            )

            # Then
            assert tracker.recommended_tier == "capable"
            captured = capsys.readouterr()
            assert "Recommended tier: capable" in captured.out

    def test_show_recommendation_without_files(
        self, tracker, mock_tier_recommender, capsys
    ):
        """
        Given: No files affected by workflow
        When: Showing tier recommendation
        Then: Recommendation uses default parameters
        """
        # Given
        mock_tier_recommender.recommend_tier.return_value = "cheap"

        with patch(
            "empathy_os.workflows.tier_tracking.TierRecommender",
            return_value=mock_tier_recommender,
        ):
            # When
            tracker.show_recommendation()

            # Then
            assert tracker.recommended_tier == "cheap"

    def test_show_recommendation_handles_exception(self, tracker, capsys):
        """
        Given: TierRecommender raises exception
        When: Showing tier recommendation
        Then: Exception is handled gracefully
        """
        # Given
        with patch(
            "empathy_os.workflows.tier_tracking.TierRecommender"
        ) as mock_recommender_class:
            mock_recommender_class.side_effect = Exception("Test error")

            # When
            tracker.show_recommendation(files_affected=["test.py"])

            # Then
            captured = capsys.readouterr()
            assert "Could not get tier recommendation" in captured.out


class TestRecordAttempt:
    """Test record_attempt method."""

    def test_record_successful_attempt(self, tracker):
        """
        Given: Successful tier attempt
        When: Recording the attempt
        Then: Attempt is added to tier history
        """
        # Given
        tier = "cheap"
        success = True

        # When
        tracker.record_attempt(tier, success)

        # Then
        assert len(tracker.tier_history) == 1
        assert tracker.tier_history[0]["tier"] == tier
        assert tracker.tier_history[0]["success"] is True
        assert tracker.tier_history[0]["attempt"] == 1

    def test_record_failed_attempt_with_quality_gate(self, tracker):
        """
        Given: Failed tier attempt with quality gate failure
        When: Recording the attempt
        Then: Attempt includes failure information
        """
        # Given
        tier = "capable"
        success = False
        quality_gate_failed = "tests_fail"

        # When
        tracker.record_attempt(tier, success, quality_gate_failed=quality_gate_failed)

        # Then
        assert len(tracker.tier_history) == 1
        assert tracker.tier_history[0]["success"] is False
        assert tracker.tier_history[0]["quality_gate_failed"] == quality_gate_failed

    def test_record_multiple_attempts(self, tracker):
        """
        Given: Multiple tier attempts
        When: Recording each attempt
        Then: All attempts are tracked with correct attempt numbers
        """
        # When
        tracker.record_attempt("cheap", False)
        tracker.record_attempt("capable", False)
        tracker.record_attempt("premium", True)

        # Then
        assert len(tracker.tier_history) == 3
        assert tracker.tier_history[0]["attempt"] == 1
        assert tracker.tier_history[1]["attempt"] == 2
        assert tracker.tier_history[2]["attempt"] == 3

    def test_record_attempt_with_quality_gates_passed(self, tracker):
        """
        Given: Successful attempt with quality gates passed
        When: Recording the attempt
        Then: Quality gates information is stored
        """
        # Given
        quality_gates_passed = ["syntax_check", "tests_pass"]

        # When
        tracker.record_attempt(
            "cheap", True, quality_gates_passed=quality_gates_passed
        )

        # Then
        assert tracker.tier_history[0]["quality_gates_passed"] == quality_gates_passed


class TestCalculateCosts:
    """Test _calculate_costs method."""

    def test_calculate_costs_single_attempt(self, tracker):
        """
        Given: Single successful tier attempt
        When: Calculating costs
        Then: Costs and savings are calculated correctly
        """
        # Given
        tracker.record_attempt("cheap", True)

        # When
        total_cost, cost_if_premium, savings = tracker._calculate_costs()

        # Then
        assert total_cost == pytest.approx(0.030)
        assert cost_if_premium == pytest.approx(0.450)
        assert savings == pytest.approx(93.33, rel=0.01)

    def test_calculate_costs_multiple_attempts(self, tracker):
        """
        Given: Multiple tier attempts escalating to premium
        When: Calculating costs
        Then: Total cost reflects all attempts
        """
        # Given
        tracker.record_attempt("cheap", False)
        tracker.record_attempt("capable", False)
        tracker.record_attempt("premium", True)

        # When
        total_cost, cost_if_premium, savings = tracker._calculate_costs()

        # Then
        expected_cost = 0.030 + 0.090 + 0.450
        assert total_cost == pytest.approx(expected_cost)
        assert cost_if_premium == pytest.approx(1.350)  # 3 attempts * 0.450
        assert savings == pytest.approx(57.78, rel=0.01)

    def test_calculate_costs_no_attempts(self, tracker):
        """
        Given: No tier attempts recorded
        When: Calculating costs
        Then: Returns zero costs with 0% savings
        """
        # When
        total_cost, cost_if_premium, savings = tracker._calculate_costs()

        # Then
        assert total_cost == 0.0
        assert cost_if_premium == 0.0
        assert savings == 0.0


class TestSaveProgression:
    """Test save_progression method."""

    def test_save_progression_successful_workflow(self, tracker, temp_patterns_dir):
        """
        Given: Successful workflow with tier progression
        When: Saving progression data
        Then: JSON file is created with correct data
        """
        # Given
        tracker.recommended_tier =