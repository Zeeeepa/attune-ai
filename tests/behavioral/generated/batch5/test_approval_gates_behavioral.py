"""Behavioral tests for approval_gates.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import time
from datetime import datetime, timedelta
from typing import Any
from unittest.mock import MagicMock, patch

import pytest

from empathy_os.telemetry.approval_gates import (
    ApprovalGate,
    ApprovalRequest,
    ApprovalResponse,
)


class TestApprovalRequest:
    """Behavioral tests for ApprovalRequest dataclass."""

    def test_given_valid_data_when_creating_request_then_initializes_correctly(self):
        """Given valid approval request data, when creating request, then initializes with correct attributes."""
        # Given
        request_id = "req-123"
        approval_type = "deploy_to_production"
        agent_id = "code-review-workflow"
        context = {"version": "v2.0.0"}
        timestamp = datetime.utcnow()
        timeout_seconds = 300.0

        # When
        request = ApprovalRequest(
            request_id=request_id,
            approval_type=approval_type,
            agent_id=agent_id,
            context=context,
            timestamp=timestamp,
            timeout_seconds=timeout_seconds,
        )

        # Then
        assert request.request_id == request_id
        assert request.approval_type == approval_type
        assert request.agent_id == agent_id
        assert request.context == context
        assert request.timestamp == timestamp
        assert request.timeout_seconds == timeout_seconds
        assert request.status == "pending"

    def test_given_request_when_converting_to_dict_then_returns_serializable_dict(self):
        """Given an approval request, when converting to dict, then returns properly serialized dictionary."""
        # Given
        timestamp = datetime(2025, 1, 15, 12, 0, 0)
        request = ApprovalRequest(
            request_id="req-456",
            approval_type="delete_resource",
            agent_id="cleanup-agent",
            context={"resource_id": "res-789"},
            timestamp=timestamp,
            timeout_seconds=600.0,
            status="pending",
        )

        # When
        result = request.to_dict()

        # Then
        assert result["request_id"] == "req-456"
        assert result["approval_type"] == "delete_resource"
        assert result["agent_id"] == "cleanup-agent"
        assert result["context"] == {"resource_id": "res-789"}
        assert result["timestamp"] == timestamp.isoformat()
        assert result["timeout_seconds"] == 600.0
        assert result["status"] == "pending"

    def test_given_dict_with_datetime_when_from_dict_then_creates_request(self):
        """Given dictionary with datetime, when calling from_dict, then creates valid request."""
        # Given
        timestamp = datetime(2025, 1, 15, 12, 0, 0)
        data = {
            "request_id": "req-789",
            "approval_type": "refactor_code",
            "agent_id": "refactor-agent",
            "context": {"files": ["file1.py"]},
            "timestamp": timestamp,
            "timeout_seconds": 120.0,
            "status": "approved",
        }

        # When
        request = ApprovalRequest.from_dict(data)

        # Then
        assert request.request_id == "req-789"
        assert request.approval_type == "refactor_code"
        assert request.agent_id == "refactor-agent"
        assert request.context == {"files": ["file1.py"]}
        assert request.timestamp == timestamp
        assert request.timeout_seconds == 120.0
        assert request.status == "approved"

    def test_given_dict_with_iso_string_when_from_dict_then_parses_timestamp(self):
        """Given dictionary with ISO timestamp string, when calling from_dict, then parses correctly."""
        # Given
        timestamp_str = "2025-01-15T12:00:00"
        data = {
            "request_id": "req-999",
            "approval_type": "deploy",
            "agent_id": "deploy-agent",
            "timestamp": timestamp_str,
        }

        # When
        request = ApprovalRequest.from_dict(data)

        # Then
        assert isinstance(request.timestamp, datetime)
        assert request.timestamp.isoformat() == timestamp_str

    def test_given_dict_without_timestamp_when_from_dict_then_uses_current_time(self):
        """Given dictionary without timestamp, when calling from_dict, then uses current time."""
        # Given
        data = {
            "request_id": "req-111",
            "approval_type": "test",
            "agent_id": "test-agent",
        }

        # When
        before = datetime.utcnow()
        request = ApprovalRequest.from_dict(data)
        after = datetime.utcnow()

        # Then
        assert before <= request.timestamp <= after

    def test_given_dict_with_missing_optional_fields_when_from_dict_then_uses_defaults(self):
        """Given dictionary with missing optional fields, when calling from_dict, then uses default values."""
        # Given
        data = {
            "request_id": "req-222",
            "approval_type": "test",
            "agent_id": "test-agent",
            "timestamp": datetime.utcnow(),
        }

        # When
        request = ApprovalRequest.from_dict(data)

        # Then
        assert request.context == {}
        assert request.timeout_seconds == 300.0
        assert request.status == "pending"


class TestApprovalResponse:
    """Behavioral tests for ApprovalResponse dataclass."""

    def test_given_valid_data_when_creating_response_then_initializes_correctly(self):
        """Given valid response data, when creating response, then initializes with correct attributes."""
        # Given
        request_id = "req-123"
        approved = True
        responder = "user@example.com"
        reason = "Looks good"
        timestamp = datetime.utcnow()

        # When
        response = ApprovalResponse(
            request_id=request_id,
            approved=approved,
            responder=responder,
            reason=reason,
            timestamp=timestamp,
        )

        # Then
        assert response.request_id == request_id
        assert response.approved is True
        assert response.responder == responder
        assert response.reason == reason
        assert response.timestamp == timestamp

    def test_given_response_when_converting_to_dict_then_returns_serializable_dict(self):
        """Given approval response, when converting to dict, then returns properly serialized dictionary."""
        # Given
        timestamp = datetime(2025, 1, 15, 12, 30, 0)
        response = ApprovalResponse(
            request_id="req-456",
            approved=False,
            responder="admin@example.com",
            reason="Security concerns",
            timestamp=timestamp,
        )

        # When
        result = response.to_dict()

        # Then
        assert result["request_id"] == "req-456"
        assert result["approved"] is False
        assert result["responder"] == "admin@example.com"
        assert result["reason"] == "Security concerns"
        assert result["timestamp"] == timestamp.isoformat()

    def test_given_dict_when_from_dict_then_creates_response(self):
        """Given dictionary, when calling from_dict, then creates valid response."""
        # Given
        timestamp = datetime(2025, 1, 15, 13, 0, 0)
        data = {
            "request_id": "req-789",
            "approved": True,
            "responder": "reviewer@example.com",
            "reason": "All tests passed",
            "timestamp": timestamp,
        }

        # When
        response = ApprovalResponse.from_dict(data)

        # Then
        assert response.request_id == "req-789"
        assert response.approved is True
        assert response.responder == "reviewer@example.com"
        assert response.reason == "All tests passed"
        assert response.timestamp == timestamp

    def test_given_dict_with_iso_string_when_from_dict_then_parses_timestamp(self):
        """Given dictionary with ISO timestamp, when calling from_dict, then parses correctly."""
        # Given
        timestamp_str = "2025-01-15T14:00:00"
        data = {
            "request_id": "req-999",
            "approved": False,
            "responder": "user@test.com",
            "timestamp": timestamp_str,
        }

        # When
        response = ApprovalResponse.from_dict(data)

        # Then
        assert isinstance(response.timestamp, datetime)
        assert response.timestamp.isoformat() == timestamp_str

    def test_given_dict_without_timestamp_when_from_dict_then_uses_current_time(self):
        """Given dictionary without timestamp, when calling from_dict, then uses current time."""
        # Given
        data = {
            "request_id": "req-111",
            "approved": True,
            "responder": "user@test.com",
        }

        # When
        before = datetime.utcnow()
        response = ApprovalResponse.from_dict(data)
        after = datetime.utcnow()

        # Then
        assert before <= response.timestamp <= after

    def test_given_dict_without_reason_when_from_dict_then_uses_empty_string(self):
        """Given dictionary without reason, when calling from_dict, then uses empty string."""
        # Given
        data = {
            "request_id": "req-222",
            "approved": True,
            "responder": "user@test.com",
            "timestamp": datetime.utcnow(),
        }

        # When
        response = ApprovalResponse.from_dict(data)

        # Then
        assert response.reason == ""


class TestApprovalGate:
    """Behavioral tests for ApprovalGate class."""

    @pytest.fixture
    def approval_gate(self):
        """Fixture providing a fresh ApprovalGate instance."""
        return ApprovalGate(agent_id="test-agent")

    @pytest.fixture
    def mock_storage(self):
        """Fixture providing a mock storage backend."""
        with patch("empathy_os.telemetry.approval_gates.ApprovalGate._load_requests") as mock_load, \
             patch("empathy_os.telemetry.approval_gates.ApprovalGate._save_requests") as mock_save:
            mock_load.return_value = {}
            yield {"load": mock_load, "save": mock_save}

    def test_given_agent_id_when_creating_gate_then_initializes_correctly(self):
        """Given agent ID, when creating approval gate, then initializes with correct agent ID."""
        # Given
        agent_id = "my-workflow"

        # When
        gate = ApprovalGate(agent_id=agent_id)

        # Then
        assert gate.agent_id == agent_id

    def test_given_no_agent_id_when_creating_gate_then_uses_approval_gate(self):
        """Given no agent ID, when creating approval gate, then uses default 'approval-gate'."""
        # Given/When
        gate = ApprovalGate()

        # Then
        assert gate.agent_id == "approval-gate"

    def test_given_valid_request_when_requesting_approval_then_creates_request(self, approval_gate, mock_storage):
        """Given valid approval request, when requesting approval, then creates and stores request."""
        # Given
        approval_type = "deploy_to_production"
        context = {"version": "v2.0.0"}
        timeout = 300.0

        # When
        with patch.object(approval_gate, '_wait_for_response') as mock_wait:
            mock_response = ApprovalResponse(
                request_id="req-123",
                approved=True,
                responder="user@test.com",
                reason="Approved",
                timestamp=datetime.utcnow(),
            )
            mock_wait.return_value = mock_response
            
            result = approval_gate.request_approval(
                approval_type=approval_type,
                context=context,
                timeout=timeout,
            )

        # Then
        assert result.approved is True
        assert result.responder == "user@test.com"

    def test_given_request_when_waiting_for_response_then_polls_until_response(self, approval_gate):
        """Given approval request, when waiting for response, then polls until response received."""
        # Given
        request_id = "req-123"
        timeout = 5.0
        approval_gate._pending_requests[request_id] = ApprovalRequest(
            request_id=request_id,
            approval_type="test",
            agent_id="test-agent",
            context={},
            timestamp=datetime.utcnow(),
            timeout_seconds=timeout,
            status="pending",
        )

        # When
        with patch("time.sleep") as mock_sleep:
            # Simulate response after 2 polls
            call_count = [0]
            
            def check_response(*args):
                call_count[0] += 1
                if call_count[0] >= 2:
                    response = ApprovalResponse(
                        request_id=request_id,
                        approved=True,
                        responder="user@test.com",
                        reason="Approved",
                        timestamp=datetime.utcnow(),
                    )
                    approval_gate._responses[request_id] = response
                    approval_gate._pending_requests[request_id].status = "approved"
                    return response
                return None

            with patch.object(approval_gate, '_check_for_response', side_effect=check_response):
                result = approval_gate._wait_for_response(request_id, timeout)

        # Then
        assert result.approved is True
        assert result.request_id == request_id
        assert mock_sleep.call_count >= 1

    def test_given_timeout_when_waiting_for_response_then_returns_timeout_response(self, approval_gate):
        """Given timeout expires, when waiting for response, then returns timeout response."""
        # Given
        request_id = "req-456"
        timeout = 0.1  # Short timeout
        approval_gate._pending_requests[request_id] = ApprovalRequest(
            request_id=request_id,
            approval_type="test",
            agent_id="test-agent",
            context={},
            timestamp=datetime.utcnow(),
            timeout_seconds=timeout,
            status="pending",
        )

        # When
        with patch.object(approval_gate, '_check_for_response', return_value=None):
            with patch("time.sleep"):
                result = approval_gate._wait_for_response(request_id, timeout)

        # Then
        assert result.approved is False
        assert result.reason == "Approval request timed out"
        assert approval_gate._pending_requests[request_id].status == "timeout"

    def test_given_pending_requests_when_getting_pending_approvals_then_returns_pending_only(self, approval_gate):
        """Given multiple requests, when getting pending approvals, then returns only pending requests."""
        # Given
        pending_request = ApprovalRequest(
            request_id="req-1",
            approval_type="deploy",
            agent_id="test-agent",
            context={},
            timestamp=datetime.utcnow(),
            timeout_seconds=300.0,
            status="pending",
        )
        approved_request = ApprovalRequest(
            request_id="req-