"""Behavioral tests for output.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

from io import StringIO
from typing import Any
from unittest.mock import MagicMock, patch

import pytest

from empathy_os.workflows.output import (
    RICH_AVAILABLE,
    Finding,
    FindingsTable,
    MetricsPanel,
    ReportSection,
    WorkflowReport,
)


# =============================================================================
# FIXTURES
# =============================================================================


@pytest.fixture
def sample_finding() -> Finding:
    """Provide a sample finding for testing."""
    return Finding(
        severity="high",
        file="test.py",
        line=42,
        message="Test issue found",
        code="E001",
    )


@pytest.fixture
def sample_findings() -> list[Finding]:
    """Provide sample findings with various severities."""
    return [
        Finding(severity="high", file="test1.py", line=10, message="Critical error"),
        Finding(severity="medium", file="test2.py", line=20, message="Warning"),
        Finding(severity="low", file="test3.py", line=30, message="Minor issue"),
        Finding(severity="info", file="test4.py", message="Information"),
    ]


@pytest.fixture
def sample_report() -> WorkflowReport:
    """Provide a sample workflow report."""
    report = WorkflowReport(
        title="Test Report",
        summary="This is a test summary",
        score=85,
        level="success",
    )
    report.add_section("Section 1", "Content 1")
    report.add_section("Section 2", "Content 2", collapsed=True, style="warning")
    return report


@pytest.fixture
def mock_console() -> MagicMock:
    """Provide a mock Rich console."""
    console = MagicMock()
    console.print = MagicMock()
    return console


# =============================================================================
# FINDING TESTS
# =============================================================================


class TestFinding:
    """Test Finding dataclass behavior."""

    def test_finding_creation_with_all_fields(self) -> None:
        """Given all fields, When creating a Finding, Then it stores them correctly."""
        # Given
        severity = "high"
        file = "test.py"
        line = 42
        message = "Test message"
        code = "E001"

        # When
        finding = Finding(
            severity=severity,
            file=file,
            line=line,
            message=message,
            code=code,
        )

        # Then
        assert finding.severity == severity
        assert finding.file == file
        assert finding.line == line
        assert finding.message == message
        assert finding.code == code

    def test_finding_creation_with_minimal_fields(self) -> None:
        """Given minimal fields, When creating a Finding, Then defaults are applied."""
        # Given / When
        finding = Finding(severity="low", file="test.py")

        # Then
        assert finding.severity == "low"
        assert finding.file == "test.py"
        assert finding.line is None
        assert finding.message == ""
        assert finding.code is None

    def test_severity_icon_high(self, sample_finding: Finding) -> None:
        """Given high severity, When getting icon, Then returns appropriate icon."""
        # Given
        sample_finding.severity = "high"

        # When
        icon = sample_finding.severity_icon

        # Then
        if RICH_AVAILABLE:
            assert "[red]" in icon or "X" in icon
        else:
            assert icon == "X"

    def test_severity_icon_medium(self, sample_finding: Finding) -> None:
        """Given medium severity, When getting icon, Then returns appropriate icon."""
        # Given
        sample_finding.severity = "medium"

        # When
        icon = sample_finding.severity_icon

        # Then
        if RICH_AVAILABLE:
            assert "[yellow]" in icon or "!" in icon
        else:
            assert icon == "!"

    def test_severity_icon_low(self, sample_finding: Finding) -> None:
        """Given low severity, When getting icon, Then returns appropriate icon."""
        # Given
        sample_finding.severity = "low"

        # When
        icon = sample_finding.severity_icon

        # Then
        if RICH_AVAILABLE:
            assert "[blue]" in icon or "i" in icon
        else:
            assert icon == "i"

    def test_severity_icon_info(self, sample_finding: Finding) -> None:
        """Given info severity, When getting icon, Then returns appropriate icon."""
        # Given
        sample_finding.severity = "info"

        # When
        icon = sample_finding.severity_icon

        # Then
        assert "o" in icon

    def test_severity_icon_unknown(self, sample_finding: Finding) -> None:
        """Given unknown severity, When getting icon, Then returns default icon."""
        # Given
        sample_finding.severity = "unknown"

        # When
        icon = sample_finding.severity_icon

        # Then
        assert icon == "o"

    def test_location_with_line(self, sample_finding: Finding) -> None:
        """Given finding with line, When getting location, Then includes line number."""
        # Given / When
        location = sample_finding.location

        # Then
        assert location == "test.py:42"

    def test_location_without_line(self, sample_finding: Finding) -> None:
        """Given finding without line, When getting location, Then returns only file."""
        # Given
        sample_finding.line = None

        # When
        location = sample_finding.location

        # Then
        assert location == "test.py"


# =============================================================================
# REPORT SECTION TESTS
# =============================================================================


class TestReportSection:
    """Test ReportSection dataclass behavior."""

    def test_section_creation_with_defaults(self) -> None:
        """Given minimal fields, When creating section, Then defaults are applied."""
        # Given / When
        section = ReportSection(title="Test", content="Content")

        # Then
        assert section.title == "Test"
        assert section.content == "Content"
        assert section.collapsed is False
        assert section.style == "default"

    def test_section_creation_with_all_fields(self) -> None:
        """Given all fields, When creating section, Then all are stored."""
        # Given / When
        section = ReportSection(
            title="Test",
            content="Content",
            collapsed=True,
            style="warning",
        )

        # Then
        assert section.title == "Test"
        assert section.content == "Content"
        assert section.collapsed is True
        assert section.style == "warning"

    def test_section_with_list_content(self, sample_findings: list[Finding]) -> None:
        """Given list content, When creating section, Then stores list."""
        # Given / When
        section = ReportSection(title="Findings", content=sample_findings)

        # Then
        assert isinstance(section.content, list)
        assert len(section.content) == 4

    def test_section_with_dict_content(self) -> None:
        """Given dict content, When creating section, Then stores dict."""
        # Given
        content = {"key1": "value1", "key2": "value2"}

        # When
        section = ReportSection(title="Metrics", content=content)

        # Then
        assert isinstance(section.content, dict)
        assert section.content["key1"] == "value1"


# =============================================================================
# WORKFLOW REPORT TESTS
# =============================================================================


class TestWorkflowReport:
    """Test WorkflowReport dataclass behavior."""

    def test_report_creation_with_minimal_fields(self) -> None:
        """Given minimal fields, When creating report, Then defaults are applied."""
        # Given / When
        report = WorkflowReport(title="Test Report")

        # Then
        assert report.title == "Test Report"
        assert report.summary == ""
        assert report.sections == []
        assert report.score is None
        assert report.level == "info"
        assert report.metadata == {}

    def test_report_creation_with_all_fields(self) -> None:
        """Given all fields, When creating report, Then all are stored."""
        # Given / When
        report = WorkflowReport(
            title="Test Report",
            summary="Summary",
            score=85,
            level="success",
            metadata={"key": "value"},
        )

        # Then
        assert report.title == "Test Report"
        assert report.summary == "Summary"
        assert report.score == 85
        assert report.level == "success"
        assert report.metadata == {"key": "value"}

    def test_add_section_default_params(self, sample_report: WorkflowReport) -> None:
        """Given report, When adding section with defaults, Then section is added."""
        # Given
        initial_count = len(sample_report.sections)

        # When
        sample_report.add_section("New Section", "New Content")

        # Then
        assert len(sample_report.sections) == initial_count + 1
        new_section = sample_report.sections[-1]
        assert new_section.title == "New Section"
        assert new_section.content == "New Content"
        assert new_section.collapsed is False
        assert new_section.style == "default"

    def test_add_section_with_params(self, sample_report: WorkflowReport) -> None:
        """Given report, When adding section with params, Then all params are set."""
        # Given / When
        sample_report.add_section(
            "Warning Section",
            "Warning content",
            collapsed=True,
            style="warning",
        )

        # Then
        new_section = sample_report.sections[-1]
        assert new_section.title == "Warning Section"
        assert new_section.collapsed is True
        assert new_section.style == "warning"

    def test_add_multiple_sections(self) -> None:
        """Given report, When adding multiple sections, Then all are stored in order."""
        # Given
        report = WorkflowReport(title="Test")

        # When
        report.add_section("Section 1", "Content 1")
        report.add_section("Section 2", "Content 2")
        report.add_section("Section 3", "Content 3")

        # Then
        assert len(report.sections) == 3
        assert report.sections[0].title == "Section 1"
        assert report.sections[1].title == "Section 2"
        assert report.sections[2].title == "Section 3"

    @pytest.mark.skipif(not RICH_AVAILABLE, reason="Rich not available")
    def test_render_with_rich_available(
        self, sample_report: WorkflowReport, mock_console: MagicMock
    ) -> None:
        """Given Rich available, When rendering report, Then uses Rich components."""
        # Given / When
        sample_report.render(console=mock_console)

        # Then
        assert mock_console.print.called

    @pytest.mark.skipif(RICH_AVAILABLE, reason="Need Rich unavailable")
    def test_render_without_rich_fallback(self, sample_report: WorkflowReport) -> None:
        """Given Rich unavailable, When rendering, Then uses plain text fallback."""
        # Given / When / Then - should not raise
        output = StringIO()
        with patch("sys.stdout", output):
            sample_report.render()
        result = output.getvalue()
        assert "Test Report" in result


# =============================================================================
# FINDINGS TABLE TESTS
# =============================================================================


class TestFindingsTable:
    """Test FindingsTable behavior."""

    def test_findings_table_creation(self, sample_findings: list[Finding]) -> None:
        """Given findings, When creating table, Then stores findings."""
        # Given / When
        table = FindingsTable(findings=sample_findings, title="Test Findings")

        # Then
        assert len(table.findings) == 4
        assert table.title == "Test Findings"

    def test_findings_table_empty(self) -> None:
        """Given no findings, When creating table, Then handles empty list."""
        # Given / When
        table = FindingsTable(findings=[], title="Empty")

        # Then
        assert len(table.findings) == 0

    @pytest.mark.skipif(not RICH_AVAILABLE, reason="Rich not available")
    def test_render_with_rich(
        self, sample_findings: list[Finding], mock_console: MagicMock
    ) -> None:
        """Given Rich available, When rendering table, Then creates Rich Table."""
        # Given
        table = FindingsTable(findings=sample_findings)

        # When
        table.render(console=mock_console)

        # Then
        assert mock_console.print.called

    def test_render_plain_text(self, sample_findings: list[Finding]) -> None:
        """Given plain text mode, When rendering, Then outputs text format."""
        # Given
        table = FindingsTable(findings=sample_findings)

        # When / Then - should not raise
        output = StringIO()
        with patch("sys.stdout", output):
            table.render_plain()
        result = output.getvalue()
        assert "test1.py" in result

    def test_render_empty_table(self) -> None:
        """Given empty findings, When rendering, Then handles gracefully."""
        # Given
        table = FindingsTable(findings=[])

        # When / Then - should not raise
        output = StringIO()
        with patch("sys.stdout", output):
            table.render_plain()

    def test_findings_grouped_by_severity(self, sample_findings: list[Finding]) -> None:
        """Given mixed severities, When rendering, Then groups are correct."""
        # Given
        table = FindingsTable(findings=sample_findings)

        # When
        output = StringIO()
        with patch("sys.stdout", output):
            table.render_plain()
        result = output.getvalue()

        # Then
        assert "test1.py" in result  # high
        assert "test2.py" in result  # medium
        assert "test3.py" in result  # low
        assert "test4.py" in result  # info


# =============================================================================
# METRICS PANEL TESTS
# =============================================================================


class TestMetricsPanel:
    """Test MetricsPanel behavior."""

    def test_metrics_panel_creation(self) -> None:
        """Given metrics dict, When creating panel, Then stores metrics."""
        # Given
        metrics = {"score": 85, "issues": 5, "warnings": 2}

        # When
        panel = MetricsPanel(metrics=metrics, title="Test Metrics")

        # Then
        assert panel.metrics == metrics
        assert panel.title == "Test Metrics"

    def test_metrics_panel_empty(self) -> None:
        """Given empty metrics, When creating panel, Then handles empty dict."""
        # Given / When
        panel = MetricsPanel(metrics={}, title="Empty")

        # Then
        assert panel.metrics == {}

    @pytest.mark.skipif(not RICH_AVAILABLE, reason="Rich not available")
    def test_render_with_rich(self, mock_console: MagicMock) -> None:
        """Given Rich available, When rendering panel, Then creates Rich Panel."""
        # Given
        panel = MetricsPanel(metrics={"score": 85})

        # When
        panel.render(console=mock_console)

        # Then
        assert mock_console.print.called

    def test_render_plain_text(self) -> None:
        """Given plain text mode, When rendering, Then outputs text format."""
        # Given
        panel = MetricsPanel(metrics={"score": 85, "issues": 5})

        # When / Then - should not raise
        output = StringIO()
        with patch("sys.stdout", output):
            panel.render_plain()