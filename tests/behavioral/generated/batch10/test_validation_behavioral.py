"""Behavioral tests for validation.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from typing import Any

from empathy_os.models.validation import (
    ValidationError,
    ValidationResult,
    ConfigValidator,
)
from empathy_os.models.registry import ModelTier


class TestValidationError:
    """Tests for ValidationError dataclass."""

    def test_given_error_details_when_creating_then_stores_correctly(self):
        """Given error details, when creating ValidationError, then stores all attributes correctly."""
        # Given
        path = "config.stages[0].tier"
        message = "Invalid tier specified"
        severity = "error"

        # When
        error = ValidationError(path=path, message=message, severity=severity)

        # Then
        assert error.path == path
        assert error.message == message
        assert error.severity == severity

    def test_given_no_severity_when_creating_then_defaults_to_error(self):
        """Given no severity specified, when creating ValidationError, then defaults to 'error'."""
        # Given / When
        error = ValidationError(path="test.path", message="Test message")

        # Then
        assert error.severity == "error"

    def test_given_error_when_converting_to_string_then_formats_correctly(self):
        """Given a ValidationError, when converting to string, then formats with severity and details."""
        # Given
        error = ValidationError(path="config.name", message="Missing required field", severity="error")

        # When
        result = str(error)

        # Then
        assert result == "[ERROR] config.name: Missing required field"

    def test_given_warning_when_converting_to_string_then_formats_with_warning_prefix(self):
        """Given a warning ValidationError, when converting to string, then formats with WARNING prefix."""
        # Given
        warning = ValidationError(path="config.timeout", message="Value is high", severity="warning")

        # When
        result = str(warning)

        # Then
        assert result == "[WARNING] config.timeout: Value is high"


class TestValidationResult:
    """Tests for ValidationResult dataclass."""

    def test_given_no_errors_when_creating_then_valid_is_true(self):
        """Given no errors, when creating ValidationResult, then valid is True."""
        # Given / When
        result = ValidationResult(valid=True)

        # Then
        assert result.valid is True
        assert len(result.errors) == 0
        assert len(result.warnings) == 0

    def test_given_errors_when_creating_then_valid_is_false(self):
        """Given errors present, when creating ValidationResult, then valid is False."""
        # Given
        errors = [ValidationError("path", "message")]

        # When
        result = ValidationResult(valid=False, errors=errors)

        # Then
        assert result.valid is False
        assert len(result.errors) == 1

    def test_given_result_when_adding_error_then_sets_valid_to_false(self):
        """Given a valid result, when adding error, then sets valid to False and stores error."""
        # Given
        result = ValidationResult(valid=True)

        # When
        result.add_error("config.name", "Name is required")

        # Then
        assert result.valid is False
        assert len(result.errors) == 1
        assert result.errors[0].path == "config.name"
        assert result.errors[0].message == "Name is required"
        assert result.errors[0].severity == "error"

    def test_given_result_when_adding_warning_then_keeps_valid_status(self):
        """Given a result, when adding warning, then keeps valid status and stores warning."""
        # Given
        result = ValidationResult(valid=True)

        # When
        result.add_warning("config.timeout", "Timeout is high")

        # Then
        assert result.valid is True
        assert len(result.warnings) == 1
        assert result.warnings[0].path == "config.timeout"
        assert result.warnings[0].message == "Timeout is high"
        assert result.warnings[0].severity == "warning"

    def test_given_valid_result_when_converting_to_string_then_shows_valid_message(self):
        """Given a valid result, when converting to string, then shows 'Configuration is valid'."""
        # Given
        result = ValidationResult(valid=True)

        # When
        output = str(result)

        # Then
        assert "Configuration is valid" in output

    def test_given_invalid_result_when_converting_to_string_then_shows_errors(self):
        """Given an invalid result with errors, when converting to string, then shows all errors."""
        # Given
        result = ValidationResult(valid=False)
        result.add_error("config.name", "Missing name")
        result.add_error("config.stages", "Empty stages")

        # When
        output = str(result)

        # Then
        assert "Configuration has errors" in output
        assert "[ERROR] config.name: Missing name" in output
        assert "[ERROR] config.stages: Empty stages" in output

    def test_given_result_with_warnings_when_converting_to_string_then_shows_warnings(self):
        """Given a result with warnings, when converting to string, then shows all warnings."""
        # Given
        result = ValidationResult(valid=True)
        result.add_warning("config.timeout", "High timeout")

        # When
        output = str(result)

        # Then
        assert "[WARNING] config.timeout: High timeout" in output


class TestConfigValidator:
    """Tests for ConfigValidator class."""

    @pytest.fixture
    def validator(self):
        """Provide a ConfigValidator instance."""
        return ConfigValidator()

    @pytest.fixture
    def mock_registry(self):
        """Mock the MODEL_REGISTRY."""
        with patch("empathy_os.models.validation.MODEL_REGISTRY") as mock:
            mock.keys.return_value = ["openai", "anthropic", "gemini"]
            yield mock

    def test_given_validator_when_checking_class_attributes_then_has_valid_providers(self, validator):
        """Given a ConfigValidator, when checking class attributes, then has VALID_PROVIDERS set."""
        # Given / When / Then
        assert hasattr(validator, "VALID_PROVIDERS")
        assert isinstance(validator.VALID_PROVIDERS, set)

    def test_given_validator_when_checking_class_attributes_then_has_valid_tiers(self, validator):
        """Given a ConfigValidator, when checking class attributes, then has VALID_TIERS set."""
        # Given / When / Then
        assert hasattr(validator, "VALID_TIERS")
        assert isinstance(validator.VALID_TIERS, set)
        # Verify it contains expected tier values
        expected_tiers = {tier.value for tier in ModelTier}
        assert validator.VALID_TIERS == expected_tiers

    def test_given_validator_when_checking_schemas_then_has_workflow_schema(self, validator):
        """Given a ConfigValidator, when checking schemas, then has WORKFLOW_SCHEMA defined."""
        # Given / When / Then
        assert hasattr(validator, "WORKFLOW_SCHEMA")
        assert isinstance(validator.WORKFLOW_SCHEMA, dict)
        assert "name" in validator.WORKFLOW_SCHEMA
        assert "stages" in validator.WORKFLOW_SCHEMA

    def test_given_validator_when_checking_schemas_then_has_stage_schema(self, validator):
        """Given a ConfigValidator, when checking schemas, then has STAGE_SCHEMA defined."""
        # Given / When / Then
        assert hasattr(validator, "STAGE_SCHEMA")
        assert isinstance(validator.STAGE_SCHEMA, dict)
        assert "name" in validator.STAGE_SCHEMA
        assert "tier" in validator.STAGE_SCHEMA

    def test_given_valid_workflow_config_when_validating_then_returns_valid_result(self, validator, mock_registry):
        """Given a valid workflow config, when validating, then returns valid result."""
        # Given
        config = {
            "name": "test_workflow",
            "description": "Test workflow",
            "default_provider": "openai",
            "stages": []
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is True
        assert len(result.errors) == 0

    def test_given_missing_required_name_when_validating_then_returns_error(self, validator):
        """Given workflow config missing required name, when validating, then returns error."""
        # Given
        config = {
            "description": "Test workflow"
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert len(result.errors) > 0
        assert any("name" in error.path.lower() for error in result.errors)

    def test_given_wrong_type_name_when_validating_then_returns_error(self, validator):
        """Given workflow config with wrong type for name, when validating, then returns error."""
        # Given
        config = {
            "name": 123,  # Should be string
            "stages": []
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert any("name" in error.path.lower() for error in result.errors)

    def test_given_invalid_provider_when_validating_then_returns_error(self, validator, mock_registry):
        """Given workflow config with invalid provider, when validating, then returns error."""
        # Given
        config = {
            "name": "test_workflow",
            "default_provider": "invalid_provider",
            "stages": []
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert any("provider" in error.path.lower() for error in result.errors)

    def test_given_stages_not_list_when_validating_then_returns_error(self, validator):
        """Given workflow config with stages not as list, when validating, then returns error."""
        # Given
        config = {
            "name": "test_workflow",
            "stages": "not a list"
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert any("stages" in error.path.lower() for error in result.errors)

    def test_given_valid_stage_when_validating_then_returns_valid(self, validator, mock_registry):
        """Given a valid stage configuration, when validating, then returns valid result."""
        # Given
        with patch.object(validator, "VALID_TIERS", {"fast", "balanced", "quality"}):
            config = {
                "name": "test_workflow",
                "stages": [
                    {
                        "name": "stage1",
                        "tier": "fast",
                        "provider": "openai",
                        "timeout_ms": 5000,
                        "max_retries": 3
                    }
                ]
            }

            # When
            result = validator.validate_workflow_config(config)

            # Then
            assert result.valid is True

    def test_given_stage_missing_name_when_validating_then_returns_error(self, validator):
        """Given stage missing required name, when validating, then returns error."""
        # Given
        config = {
            "name": "test_workflow",
            "stages": [
                {
                    "tier": "fast"
                }
            ]
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert any("name" in error.path.lower() for error in result.errors)

    def test_given_stage_missing_tier_when_validating_then_returns_error(self, validator):
        """Given stage missing required tier, when validating, then returns error."""
        # Given
        config = {
            "name": "test_workflow",
            "stages": [
                {
                    "name": "stage1"
                }
            ]
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert any("tier" in error.path.lower() for error in result.errors)

    def test_given_stage_invalid_tier_when_validating_then_returns_error(self, validator, mock_registry):
        """Given stage with invalid tier, when validating, then returns error."""
        # Given
        config = {
            "name": "test_workflow",
            "stages": [
                {
                    "name": "stage1",
                    "tier": "invalid_tier"
                }
            ]
        }

        # When
        result = validator.validate_workflow_config(config)

        # Then
        assert result.valid is False
        assert any("tier" in error.path.lower() for error in result.errors)

    def test_given_stage_invalid_provider_when_validating_then_returns_error(self, validator, mock_registry):
        """Given stage with invalid provider, when validating, then returns error."""
        # Given
        with patch.object(validator, "VALID_TIERS", {"fast"}):
            config = {
                "name": "test_workflow",
                "stages": [
                    {
                        "name": "stage1",
                        "tier": "fast",
                        "provider": "invalid_provider"
                    }
                ]
            }

            # When
            result = validator.validate_workflow_config(config)

            # Then
            assert result.valid is False
            assert any("provider" in error.path.lower() for error in result.errors)

    def test_given_stage_timeout_negative_when_validating_then_returns_error(self, validator, mock_registry):
        """Given stage with negative timeout, when validating, then returns error."""
        # Given
        with patch.object(validator, "VALID_TIERS", {"fast"}):
            config = {
                "name": "test_workflow",
                "stages": [
                    {
                        "name": "stage1",
                        "tier": "fast",
                        "timeout_ms": -1
                    }
                ]
            }

            # When
            result = validator.validate_workflow_config(config)

            # Then
            assert result.valid is False
            assert any("timeout" in error.path.lower() for error in result.errors)

    def test_given_stage_timeout_too_high_when_validating_then_returns_error(self, validator, mock_registry):
        """Given stage with timeout exceeding maximum, when validating, then returns error."""
        # Given
        with patch.object(validator, "VALID_TIERS", {"fast"}):
            config = {
                "name": "test_workflow",
                "stages": [
                    {
                        "name": "stage1",
                        "tier": "fast",
                        "timeout_ms": 700000  # Exceeds max of 600000
                    }
                ]
            }

            # When
            result = validator.validate_workflow_config(config)

            # Then
            assert result.valid is False
            assert any("timeout" in error.path.lower() for error in result.errors)

    def test_given_stage_max_retries_negative_when_validating_then_returns_error(self, validator, mock_registry):
        """Given stage with negative max_retries, when validating, then returns error."""
        # Given
        with patch.object(validator, "VALID_TIERS", {"fast"}):
            config = {
                "name": "test_workflow",
                "stages": [
                    {
                        "name": "stage1",
                        "tier":