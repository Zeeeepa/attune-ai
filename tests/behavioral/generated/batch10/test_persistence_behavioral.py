"""Behavioral tests for persistence.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import json
import sqlite3
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import MagicMock, Mock, mock_open, patch

import pytest

from empathy_os.core import CollaborationState
from empathy_os.pattern_library import Pattern, PatternLibrary
from empathy_os.persistence import PatternPersistence


@pytest.fixture
def sample_pattern():
    """Create a sample pattern for testing."""
    return Pattern(
        id="test_pattern_1",
        agent_id="agent_alpha",
        pattern_type="solution",
        name="Test Pattern",
        description="A test pattern",
        context={"domain": "testing"},
        code="def test(): pass",
        confidence=0.85,
        tags=["test", "sample"],
        discovered_at=datetime(2025, 1, 1, 12, 0, 0),
    )


@pytest.fixture
def sample_pattern_with_usage():
    """Create a sample pattern with usage statistics."""
    pattern = Pattern(
        id="test_pattern_2",
        agent_id="agent_beta",
        pattern_type="optimization",
        name="Used Pattern",
        description="A pattern with usage history",
        context={"domain": "performance"},
        code="def optimize(): return True",
        confidence=0.92,
        tags=["optimization"],
        discovered_at=datetime(2025, 1, 1, 12, 0, 0),
    )
    pattern.usage_count = 10
    pattern.success_count = 8
    pattern.failure_count = 2
    pattern.last_used = datetime(2025, 1, 15, 14, 30, 0)
    return pattern


@pytest.fixture
def sample_library(sample_pattern, sample_pattern_with_usage):
    """Create a sample pattern library for testing."""
    library = PatternLibrary()
    library.add_pattern(sample_pattern)
    library.add_pattern(sample_pattern_with_usage)
    library.agent_contributions["agent_alpha"] = 1
    library.agent_contributions["agent_beta"] = 1
    return library


@pytest.fixture
def empty_library():
    """Create an empty pattern library for testing."""
    return PatternLibrary()


@pytest.fixture
def temp_json_file(tmp_path):
    """Create a temporary JSON file path."""
    return tmp_path / "test_patterns.json"


@pytest.fixture
def temp_db_file(tmp_path):
    """Create a temporary SQLite database file path."""
    return tmp_path / "test_patterns.db"


class TestPatternPersistenceSaveToJson:
    """Test PatternPersistence.save_to_json functionality."""

    def test_save_empty_library_to_json(self, empty_library, temp_json_file):
        """
        Given an empty pattern library
        When saving to JSON
        Then the file should contain empty patterns list with metadata
        """
        PatternPersistence.save_to_json(empty_library, str(temp_json_file))

        assert temp_json_file.exists()
        with open(temp_json_file, "r") as f:
            data = json.load(f)

        assert data["patterns"] == []
        assert data["agent_contributions"] == {}
        assert data["metadata"]["pattern_count"] == 0
        assert data["metadata"]["version"] == "1.0"
        assert "saved_at" in data["metadata"]

    def test_save_library_with_patterns_to_json(self, sample_library, temp_json_file):
        """
        Given a pattern library with multiple patterns
        When saving to JSON
        Then all patterns and metadata should be serialized correctly
        """
        PatternPersistence.save_to_json(sample_library, str(temp_json_file))

        with open(temp_json_file, "r") as f:
            data = json.load(f)

        assert len(data["patterns"]) == 2
        assert data["metadata"]["pattern_count"] == 2
        assert data["agent_contributions"]["agent_alpha"] == 1
        assert data["agent_contributions"]["agent_beta"] == 1

    def test_save_pattern_serialization_fields(self, sample_pattern_with_usage, temp_json_file):
        """
        Given a pattern with all fields populated
        When saving to JSON
        Then all pattern fields should be serialized correctly
        """
        library = PatternLibrary()
        library.add_pattern(sample_pattern_with_usage)

        PatternPersistence.save_to_json(library, str(temp_json_file))

        with open(temp_json_file, "r") as f:
            data = json.load(f)

        pattern_data = data["patterns"][0]
        assert pattern_data["id"] == "test_pattern_2"
        assert pattern_data["agent_id"] == "agent_beta"
        assert pattern_data["pattern_type"] == "optimization"
        assert pattern_data["name"] == "Used Pattern"
        assert pattern_data["description"] == "A pattern with usage history"
        assert pattern_data["context"] == {"domain": "performance"}
        assert pattern_data["code"] == "def optimize(): return True"
        assert pattern_data["confidence"] == 0.92
        assert pattern_data["usage_count"] == 10
        assert pattern_data["success_count"] == 8
        assert pattern_data["failure_count"] == 2
        assert pattern_data["tags"] == ["optimization"]
        assert pattern_data["discovered_at"] == "2025-01-01T12:00:00"
        assert pattern_data["last_used"] == "2025-01-15T14:30:00"

    def test_save_pattern_without_last_used(self, sample_pattern, temp_json_file):
        """
        Given a pattern without last_used timestamp
        When saving to JSON
        Then last_used should be serialized as None
        """
        library = PatternLibrary()
        library.add_pattern(sample_pattern)

        PatternPersistence.save_to_json(library, str(temp_json_file))

        with open(temp_json_file, "r") as f:
            data = json.load(f)

        pattern_data = data["patterns"][0]
        assert pattern_data["last_used"] is None

    def test_save_to_json_creates_directory(self, sample_library, tmp_path):
        """
        Given a filepath in a non-existent directory
        When saving to JSON
        Then the directory structure should be created
        """
        nested_path = tmp_path / "nested" / "dir" / "patterns.json"
        PatternPersistence.save_to_json(sample_library, str(nested_path))

        assert nested_path.exists()
        assert nested_path.parent.exists()

    def test_save_to_json_overwrites_existing_file(self, sample_library, temp_json_file):
        """
        Given an existing JSON file
        When saving a new library to the same path
        Then the file should be overwritten
        """
        # Create initial file
        PatternPersistence.save_to_json(sample_library, str(temp_json_file))

        # Create new library with different data
        new_library = PatternLibrary()
        new_pattern = Pattern(
            id="new_pattern",
            agent_id="agent_gamma",
            pattern_type="test",
            name="New Pattern",
            description="New description",
            context={},
            code="pass",
            confidence=0.5,
            tags=[],
            discovered_at=datetime.now(),
        )
        new_library.add_pattern(new_pattern)

        # Overwrite
        PatternPersistence.save_to_json(new_library, str(temp_json_file))

        with open(temp_json_file, "r") as f:
            data = json.load(f)

        assert len(data["patterns"]) == 1
        assert data["patterns"][0]["id"] == "new_pattern"

    @patch("empathy_os.persistence._validate_file_path")
    def test_save_to_json_validates_filepath(self, mock_validate, sample_library, temp_json_file):
        """
        Given a filepath
        When saving to JSON
        Then the filepath should be validated
        """
        mock_validate.return_value = str(temp_json_file)

        PatternPersistence.save_to_json(sample_library, "some_path.json")

        mock_validate.assert_called_once_with("some_path.json")

    @patch("builtins.open", side_effect=PermissionError("Access denied"))
    @patch("empathy_os.persistence._validate_file_path")
    def test_save_to_json_handles_permission_error(self, mock_validate, mock_file, sample_library):
        """
        Given insufficient file permissions
        When attempting to save to JSON
        Then a PermissionError should be raised
        """
        mock_validate.return_value = "/protected/path.json"

        with pytest.raises(PermissionError):
            PatternPersistence.save_to_json(sample_library, "/protected/path.json")

    def test_save_to_json_json_formatting(self, sample_library, temp_json_file):
        """
        Given a pattern library
        When saving to JSON
        Then the file should be formatted with proper indentation
        """
        PatternPersistence.save_to_json(sample_library, str(temp_json_file))

        content = temp_json_file.read_text()
        # Check that it's pretty-printed (has newlines and indentation)
        assert "\n" in content
        assert "  " in content  # indent=2


class TestPatternPersistenceLoadFromJson:
    """Test PatternPersistence.load_from_json functionality."""

    def test_load_empty_library_from_json(self, temp_json_file):
        """
        Given a JSON file with an empty pattern library
        When loading from JSON
        Then an empty PatternLibrary should be returned
        """
        data = {
            "patterns": [],
            "agent_contributions": {},
            "metadata": {
                "saved_at": datetime.now().isoformat(),
                "pattern_count": 0,
                "version": "1.0",
            },
        }
        with open(temp_json_file, "w") as f:
            json.dump(data, f)

        library = PatternPersistence.load_from_json(str(temp_json_file))

        assert len(library.patterns) == 0
        assert library.agent_contributions == {}

    def test_load_library_with_patterns_from_json(self, sample_library, temp_json_file):
        """
        Given a JSON file with saved patterns
        When loading from JSON
        Then all patterns should be restored correctly
        """
        PatternPersistence.save_to_json(sample_library, str(temp_json_file))
        loaded_library = PatternPersistence.load_from_json(str(temp_json_file))

        assert len(loaded_library.patterns) == 2
        assert "test_pattern_1" in loaded_library.patterns
        assert "test_pattern_2" in loaded_library.patterns
        assert loaded_library.agent_contributions["agent_alpha"] == 1
        assert loaded_library.agent_contributions["agent_beta"] == 1

    def test_load_pattern_fields_from_json(self, sample_pattern_with_usage, temp_json_file):
        """
        Given a JSON file with a complete pattern
        When loading from JSON
        Then all pattern fields should be restored correctly
        """
        library = PatternLibrary()
        library.add_pattern(sample_pattern_with_usage)
        PatternPersistence.save_to_json(library, str(temp_json_file))

        loaded_library = PatternPersistence.load_from_json(str(temp_json_file))
        pattern = loaded_library.patterns["test_pattern_2"]

        assert pattern.id == "test_pattern_2"
        assert pattern.agent_id == "agent_beta"
        assert pattern.pattern_type == "optimization"
        assert pattern.name == "Used Pattern"
        assert pattern.description == "A pattern with usage history"
        assert pattern.context == {"domain": "performance"}
        assert pattern.code == "def optimize(): return True"
        assert pattern.confidence == 0.92
        assert pattern.usage_count == 10
        assert pattern.success_count == 8
        assert pattern.failure_count == 2
        assert pattern.tags == ["optimization"]
        assert pattern.discovered_at == datetime(2025, 1, 1, 12, 0, 0)
        assert pattern.last_used == datetime(2025, 1, 15, 14, 30, 0)

    def test_load_pattern_without_last_used_from_json(self, sample_pattern, temp_json_file):
        """
        Given a JSON file with a pattern without last_used
        When loading from JSON
        Then last_used should be None
        """
        library = PatternLibrary()
        library.add_pattern(sample_pattern)
        PatternPersistence.save_to_json(library, str(temp_json_file))

        loaded_library = PatternPersistence.load_from_json(str(temp_json_file))
        pattern = loaded_library.patterns["test_pattern_1"]

        assert pattern.last_used is None

    def test_load_from_nonexistent_file_raises_error(self):
        """
        Given a non-existent file path
        When attempting to load from JSON
        Then FileNotFoundError should be raised
        """
        with pytest.raises(FileNotFoundError):
            PatternPersistence.load_from_json("/nonexistent/path.json")

    def test_load_from_invalid_json_raises_error(self, temp_json_file):
        """
        Given a file with invalid JSON
        When attempting to load from JSON
        Then json.JSONDecodeError should be raised
        """
        with open(temp_json_file, "w") as f:
            f.write("{ invalid json content }")

        with pytest.raises(json.JSONDecodeError):
            PatternPersistence.load_from_json(str(temp_json_file))

    def test_load_from_json_missing_required_fields(self, temp_json_file):
        """
        Given a JSON file missing required pattern fields
        When attempting to load from JSON
        Then KeyError should be raised
        """
        data = {
            "patterns": [
                {
                    "id": "incomplete_pattern",
                    # Missing required fields
                }
            ],
            "agent_contributions": {},
            "metadata": {},
        }
        with open(temp_json_file, "w") as f:
            json.dump(data, f)

        with pytest.raises(KeyError):
            PatternPersistence.load_from_json(str(temp_json_file))

    @patch("empathy_os.persistence._validate_file_path")
    def test_load_from_json_validates_filepath(self, mock_validate, temp_json_file):
        """
        Given a filepath
        When loading from JSON
        Then the filepath should be validated
        """
        mock_validate.return_value = str(temp_json_file)

        data = {
            "patterns": [],
            "agent_contributions": {},
            "metadata": {"saved_at": datetime.now().isoformat(), "pattern_count": 0, "version": "1.0"},
        }
        with open(temp_json_file, "w") as f:
            json.dump(data, f)

        PatternPersistence.load_from_json("some_path.json")

        mock_validate.assert_called_once_