"""Behavioral tests for tasks.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest

from empathy_os.models.registry import ModelTier
from empathy_os.models.tasks import (
    CHEAP_TASKS,
    CAPABLE_TASKS,
    PREMIUM_TASKS,
    TASK_REGISTRY,
    TaskInfo,
    TaskType,
    get_task_info,
    get_task_tier,
    normalize_task_name,
)


class TestTaskTypeEnum:
    """Tests for TaskType enumeration."""

    def test_given_task_type_enum_when_accessing_value_then_returns_string(self):
        """Given a TaskType enum member
        When accessing its value
        Then it returns the expected string."""
        # Given / When
        task_value = TaskType.SUMMARIZE.value

        # Then
        assert task_value == "summarize"
        assert isinstance(task_value, str)

    def test_given_task_type_enum_when_listing_all_members_then_contains_expected_tasks(
        self,
    ):
        """Given the TaskType enum
        When listing all members
        Then it contains all expected task categories."""
        # Given / When
        all_tasks = [task.value for task in TaskType]

        # Then - Check cheap tier tasks
        assert "summarize" in all_tasks
        assert "classify" in all_tasks
        assert "triage" in all_tasks

        # Then - Check capable tier tasks
        assert "generate_code" in all_tasks
        assert "fix_bug" in all_tasks
        assert "write_tests" in all_tasks

        # Then - Check premium tier tasks
        assert "coordinate" in all_tasks
        assert "architectural_decision" in all_tasks
        assert "complex_reasoning" in all_tasks

    def test_given_task_type_enum_when_comparing_members_then_equality_works(self):
        """Given TaskType enum members
        When comparing them
        Then equality comparison works correctly."""
        # Given
        task1 = TaskType.SUMMARIZE
        task2 = TaskType.SUMMARIZE
        task3 = TaskType.CLASSIFY

        # When / Then
        assert task1 == task2
        assert task1 != task3
        assert task1.value == task2.value

    def test_given_task_string_when_creating_from_value_then_returns_enum_member(self):
        """Given a task string value
        When creating TaskType from value
        Then it returns the correct enum member."""
        # Given
        task_string = "generate_code"

        # When
        task_type = TaskType(task_string)

        # Then
        assert task_type == TaskType.GENERATE_CODE
        assert task_type.value == "generate_code"


class TestTaskInfo:
    """Tests for TaskInfo dataclass."""

    def test_given_task_info_when_created_then_has_expected_fields(self):
        """Given a TaskInfo instance
        When created with valid data
        Then it has all expected fields."""
        # Given / When
        task_info = TaskInfo(
            task_type=TaskType.SUMMARIZE,
            tier=ModelTier.CHEAP,
            description="Test description",
        )

        # Then
        assert task_info.task_type == TaskType.SUMMARIZE
        assert task_info.tier == ModelTier.CHEAP
        assert task_info.description == "Test description"

    def test_given_task_info_when_frozen_then_immutable(self):
        """Given a TaskInfo instance
        When attempting to modify it
        Then it raises an error (frozen dataclass)."""
        # Given
        task_info = TaskInfo(
            task_type=TaskType.SUMMARIZE,
            tier=ModelTier.CHEAP,
            description="Test",
        )

        # When / Then
        with pytest.raises(AttributeError):
            task_info.tier = ModelTier.PREMIUM

    def test_given_two_task_infos_when_same_data_then_equal(self):
        """Given two TaskInfo instances with same data
        When comparing them
        Then they are equal."""
        # Given
        task_info1 = TaskInfo(
            task_type=TaskType.SUMMARIZE,
            tier=ModelTier.CHEAP,
            description="Test",
        )
        task_info2 = TaskInfo(
            task_type=TaskType.SUMMARIZE,
            tier=ModelTier.CHEAP,
            description="Test",
        )

        # When / Then
        assert task_info1 == task_info2


class TestTaskConstants:
    """Tests for task constant frozensets."""

    def test_given_cheap_tasks_when_checking_type_then_is_frozenset(self):
        """Given CHEAP_TASKS constant
        When checking its type
        Then it is a frozenset."""
        # Given / When / Then
        assert isinstance(CHEAP_TASKS, frozenset)

    def test_given_capable_tasks_when_checking_type_then_is_frozenset(self):
        """Given CAPABLE_TASKS constant
        When checking its type
        Then it is a frozenset."""
        # Given / When / Then
        assert isinstance(CAPABLE_TASKS, frozenset)

    def test_given_premium_tasks_when_checking_type_then_is_frozenset(self):
        """Given PREMIUM_TASKS constant
        When checking its type
        Then it is a frozenset."""
        # Given / When / Then
        assert isinstance(PREMIUM_TASKS, frozenset)

    def test_given_cheap_tasks_when_checking_contents_then_contains_expected_tasks(
        self,
    ):
        """Given CHEAP_TASKS frozenset
        When checking its contents
        Then it contains expected cheap tier tasks."""
        # Given / When / Then
        assert "summarize" in CHEAP_TASKS
        assert "classify" in CHEAP_TASKS
        assert "triage" in CHEAP_TASKS
        assert "match_pattern" in CHEAP_TASKS
        assert "simple_qa" in CHEAP_TASKS

    def test_given_capable_tasks_when_checking_contents_then_contains_expected_tasks(
        self,
    ):
        """Given CAPABLE_TASKS frozenset
        When checking its contents
        Then it contains expected capable tier tasks."""
        # Given / When / Then
        assert "generate_code" in CAPABLE_TASKS
        assert "fix_bug" in CAPABLE_TASKS
        assert "write_tests" in CAPABLE_TASKS
        assert "review_security" in CAPABLE_TASKS

    def test_given_premium_tasks_when_checking_contents_then_contains_expected_tasks(
        self,
    ):
        """Given PREMIUM_TASKS frozenset
        When checking its contents
        Then it contains expected premium tier tasks."""
        # Given / When / Then
        assert "coordinate" in PREMIUM_TASKS
        assert "synthesize_results" in PREMIUM_TASKS
        assert "architectural_decision" in PREMIUM_TASKS
        assert "complex_reasoning" in PREMIUM_TASKS

    def test_given_all_task_sets_when_checking_overlap_then_no_duplicates(self):
        """Given all task constant sets
        When checking for overlap
        Then there are no duplicate tasks across tiers."""
        # Given / When
        cheap_and_capable = CHEAP_TASKS & CAPABLE_TASKS
        cheap_and_premium = CHEAP_TASKS & PREMIUM_TASKS
        capable_and_premium = CAPABLE_TASKS & PREMIUM_TASKS

        # Then
        assert len(cheap_and_capable) == 0
        assert len(cheap_and_premium) == 0
        assert len(capable_and_premium) == 0

    def test_given_task_sets_when_immutable_then_cannot_modify(self):
        """Given task constant frozensets
        When attempting to modify them
        Then it raises an error."""
        # Given / When / Then
        with pytest.raises(AttributeError):
            CHEAP_TASKS.add("new_task")


class TestTaskRegistry:
    """Tests for TASK_REGISTRY dictionary."""

    def test_given_task_registry_when_checking_type_then_is_dict(self):
        """Given TASK_REGISTRY constant
        When checking its type
        Then it is a dictionary."""
        # Given / When / Then
        assert isinstance(TASK_REGISTRY, dict)

    def test_given_task_registry_when_accessing_cheap_task_then_returns_task_info(self):
        """Given TASK_REGISTRY
        When accessing a cheap task
        Then it returns TaskInfo with CHEAP tier."""
        # Given
        task_name = "summarize"

        # When
        task_info = TASK_REGISTRY[task_name]

        # Then
        assert isinstance(task_info, TaskInfo)
        assert task_info.tier == ModelTier.CHEAP
        assert task_info.task_type == TaskType.SUMMARIZE

    def test_given_task_registry_when_accessing_capable_task_then_returns_task_info(
        self,
    ):
        """Given TASK_REGISTRY
        When accessing a capable task
        Then it returns TaskInfo with CAPABLE tier."""
        # Given
        task_name = "generate_code"

        # When
        task_info = TASK_REGISTRY[task_name]

        # Then
        assert isinstance(task_info, TaskInfo)
        assert task_info.tier == ModelTier.CAPABLE
        assert task_info.task_type == TaskType.GENERATE_CODE

    def test_given_task_registry_when_accessing_premium_task_then_returns_task_info(
        self,
    ):
        """Given TASK_REGISTRY
        When accessing a premium task
        Then it returns TaskInfo with PREMIUM tier."""
        # Given
        task_name = "coordinate"

        # When
        task_info = TASK_REGISTRY[task_name]

        # Then
        assert isinstance(task_info, TaskInfo)
        assert task_info.tier == ModelTier.PREMIUM
        assert task_info.task_type == TaskType.COORDINATE

    def test_given_task_registry_when_checking_all_tasks_then_contains_all_enum_members(
        self,
    ):
        """Given TASK_REGISTRY
        When checking all tasks
        Then it contains entries for all TaskType enum members."""
        # Given
        all_task_values = {task.value for task in TaskType}

        # When
        registry_keys = set(TASK_REGISTRY.keys())

        # Then
        assert all_task_values == registry_keys

    def test_given_task_registry_when_checking_descriptions_then_all_have_descriptions(
        self,
    ):
        """Given TASK_REGISTRY
        When checking all entries
        Then all have non-empty descriptions."""
        # Given / When
        for task_name, task_info in TASK_REGISTRY.items():
            # Then
            assert task_info.description
            assert len(task_info.description) > 0
            assert isinstance(task_info.description, str)


class TestNormalizeTaskName:
    """Tests for normalize_task_name function."""

    def test_given_lowercase_task_when_normalized_then_returns_same(self):
        """Given a lowercase task name
        When normalizing
        Then it returns the same name."""
        # Given
        task_name = "summarize"

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "summarize"

    def test_given_uppercase_task_when_normalized_then_returns_lowercase(self):
        """Given an uppercase task name
        When normalizing
        Then it returns lowercase."""
        # Given
        task_name = "SUMMARIZE"

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "summarize"

    def test_given_mixed_case_task_when_normalized_then_returns_lowercase(self):
        """Given a mixed case task name
        When normalizing
        Then it returns lowercase."""
        # Given
        task_name = "GenerateCode"

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "generatecode"

    def test_given_task_with_spaces_when_normalized_then_returns_underscored(self):
        """Given a task name with spaces
        When normalizing
        Then it replaces spaces with underscores."""
        # Given
        task_name = "generate code"

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "generate_code"

    def test_given_task_with_hyphens_when_normalized_then_returns_underscored(self):
        """Given a task name with hyphens
        When normalizing
        Then it replaces hyphens with underscores."""
        # Given
        task_name = "generate-code"

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "generate_code"

    def test_given_task_with_multiple_separators_when_normalized_then_cleans_up(self):
        """Given a task name with multiple separators
        When normalizing
        Then it cleans up to single underscores."""
        # Given
        task_name = "Generate  Code--Test"

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "generate_code_test"

    def test_given_task_with_leading_trailing_spaces_when_normalized_then_strips(self):
        """Given a task name with leading/trailing spaces
        When normalizing
        Then it strips them."""
        # Given
        task_name = "  summarize  "

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == "summarize"

    def test_given_empty_string_when_normalized_then_returns_empty(self):
        """Given an empty string
        When normalizing
        Then it returns empty string."""
        # Given
        task_name = ""

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == ""

    def test_given_whitespace_only_when_normalized_then_returns_empty(self):
        """Given whitespace-only string
        When normalizing
        Then it returns empty string."""
        # Given
        task_name = "   "

        # When
        result = normalize_task_name(task_name)

        # Then
        assert result == ""


class TestGetTaskTier:
    """Tests for get_task_tier function."""

    def test_given_cheap_task_when_getting_tier_then_returns_cheap(self):
        """Given a cheap tier task
        When getting its tier
        Then it returns ModelTier.CHEAP."""
        # Given
        task_name = "summarize"

        # When
        tier = get_task_tier(task_name)

        # Then
        assert tier == ModelTier.CHEAP

    def test_given_capable_task_when_getting_tier_then_returns_capable(self):
        """Given a capable tier task
        When getting its tier
        Then it returns ModelTier.CAPABLE."""
        # Given
        task_name = "generate_code"

        # When
        tier = get_task_tier(task_name)

        # Then
        assert tier == ModelTier.CAPABLE

    def test_given_premium_task_when_getting_tier_then_returns_premium(self):
        """Given a premium tier task
        When getting its tier
        Then it returns ModelTier.PREMIUM."""
        # Given
        task_name = "coordinate"

        # When
        tier = get_task_tier(task_name)

        # Then
        assert tier == ModelTier.PREMIUM

    def test_given_uppercase_task_when_getting_tier_then_normalizes_and_returns(self):
        """