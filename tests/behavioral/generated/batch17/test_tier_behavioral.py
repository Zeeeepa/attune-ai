"""Behavioral tests for tier.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import argparse
from unittest.mock import MagicMock, Mock, patch

import pytest

from empathy_os.cli.parsers import tier


class TestRegisterParsers:
    """Behavioral tests for register_parsers function."""

    @pytest.fixture
    def mock_subparsers(self):
        """Create a mock subparsers object.

        Returns:
            Mock subparsers object with necessary methods
        """
        subparsers = Mock()
        tier_parser = Mock()
        tier_subparsers = Mock()
        
        # Setup the chain of mocks
        subparsers.add_parser.return_value = tier_parser
        tier_parser.add_subparsers.return_value = tier_subparsers
        
        # Mock parsers for subcommands
        recommend_parser = Mock()
        stats_parser = Mock()
        
        tier_subparsers.add_parser.side_effect = [recommend_parser, stats_parser]
        
        return {
            'subparsers': subparsers,
            'tier_parser': tier_parser,
            'tier_subparsers': tier_subparsers,
            'recommend_parser': recommend_parser,
            'stats_parser': stats_parser
        }

    def test_given_valid_subparsers_when_register_parsers_then_tier_parser_created(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then tier parser is created with correct parameters
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        mock_subparsers['subparsers'].add_parser.assert_called_once_with(
            "tier", help="Tier management commands"
        )

    def test_given_valid_subparsers_when_register_parsers_then_tier_subparsers_created(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then tier subparsers are created with correct destination
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        mock_subparsers['tier_parser'].add_subparsers.assert_called_once_with(
            dest="tier_command"
        )

    def test_given_valid_subparsers_when_register_parsers_then_recommend_parser_created(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then recommend subcommand parser is created
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        calls = mock_subparsers['tier_subparsers'].add_parser.call_args_list
        assert len(calls) == 2
        assert calls[0][0][0] == "recommend"
        assert calls[0][1]['help'] == "Get tier recommendation"

    def test_given_valid_subparsers_when_register_parsers_then_recommend_has_description_arg(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then recommend parser has description argument
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        recommend_parser = mock_subparsers['recommend_parser']
        add_arg_calls = recommend_parser.add_argument.call_args_list
        
        # Find description argument
        description_calls = [c for c in add_arg_calls if c[0][0] == "description"]
        assert len(description_calls) == 1
        assert description_calls[0][1]['help'] == "Bug or task description"

    def test_given_valid_subparsers_when_register_parsers_then_recommend_has_files_arg(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then recommend parser has files argument
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        recommend_parser = mock_subparsers['recommend_parser']
        add_arg_calls = recommend_parser.add_argument.call_args_list
        
        # Find files argument
        files_calls = [c for c in add_arg_calls if c[0][0] == "--files"]
        assert len(files_calls) == 1
        assert files_calls[0][1]['help'] == "Comma-separated list of files"

    def test_given_valid_subparsers_when_register_parsers_then_recommend_has_complexity_arg(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then recommend parser has complexity argument with choices
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        recommend_parser = mock_subparsers['recommend_parser']
        add_arg_calls = recommend_parser.add_argument.call_args_list
        
        # Find complexity argument
        complexity_calls = [c for c in add_arg_calls if c[0][0] == "--complexity"]
        assert len(complexity_calls) == 1
        assert complexity_calls[0][1]['choices'] == ["low", "medium", "high"]
        assert complexity_calls[0][1]['help'] == "Complexity hint"

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_valid_subparsers_when_register_parsers_then_recommend_has_default_func(
        self, mock_tier_commands, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then recommend parser has default function set
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        recommend_parser = mock_subparsers['recommend_parser']
        recommend_parser.set_defaults.assert_called_once_with(
            func=mock_tier_commands.cmd_tier_recommend
        )

    def test_given_valid_subparsers_when_register_parsers_then_stats_parser_created(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then stats subcommand parser is created
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        calls = mock_subparsers['tier_subparsers'].add_parser.call_args_list
        assert len(calls) == 2
        assert calls[1][0][0] == "stats"
        assert calls[1][1]['help'] == "Show tier statistics"

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_valid_subparsers_when_register_parsers_then_stats_has_default_func(
        self, mock_tier_commands, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then stats parser has default function set
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        stats_parser = mock_subparsers['stats_parser']
        stats_parser.set_defaults.assert_called_once_with(
            func=mock_tier_commands.cmd_tier_stats
        )

    def test_given_valid_subparsers_when_register_parsers_then_all_three_arguments_added_to_recommend(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then recommend parser has exactly three arguments
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        recommend_parser = mock_subparsers['recommend_parser']
        assert recommend_parser.add_argument.call_count == 3

    def test_given_valid_subparsers_when_register_parsers_then_stats_has_no_arguments(
        self, mock_subparsers
    ):
        """Given valid subparsers.

        When register_parsers is called
        Then stats parser has no arguments added
        """
        # When
        tier.register_parsers(mock_subparsers['subparsers'])

        # Then
        stats_parser = mock_subparsers['stats_parser']
        assert stats_parser.add_argument.call_count == 0


class TestIntegrationWithArgumentParser:
    """Integration tests with real ArgumentParser."""

    @pytest.fixture
    def parser(self):
        """Create a real ArgumentParser for integration testing.

        Returns:
            ArgumentParser with tier commands registered
        """
        main_parser = argparse.ArgumentParser()
        subparsers = main_parser.add_subparsers(dest="command")
        tier.register_parsers(subparsers)
        return main_parser

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_tier_recommend_command_when_parsed_then_correct_namespace(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with arguments.

        When command is parsed
        Then namespace contains correct values
        """
        # When
        args = parser.parse_args([
            "tier", "recommend", "Fix login bug", 
            "--files", "auth.py,login.py",
            "--complexity", "high"
        ])

        # Then
        assert args.command == "tier"
        assert args.tier_command == "recommend"
        assert args.description == "Fix login bug"
        assert args.files == "auth.py,login.py"
        assert args.complexity == "high"
        assert args.func == mock_tier_commands.cmd_tier_recommend

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_tier_recommend_minimal_when_parsed_then_optional_args_none(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with minimal arguments.

        When command is parsed
        Then optional arguments are None
        """
        # When
        args = parser.parse_args(["tier", "recommend", "Fix bug"])

        # Then
        assert args.description == "Fix bug"
        assert args.files is None
        assert args.complexity is None

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_tier_stats_command_when_parsed_then_correct_namespace(
        self, mock_tier_commands, parser
    ):
        """Given tier stats command.

        When command is parsed
        Then namespace contains correct values
        """
        # When
        args = parser.parse_args(["tier", "stats"])

        # Then
        assert args.command == "tier"
        assert args.tier_command == "stats"
        assert args.func == mock_tier_commands.cmd_tier_stats

    def test_given_invalid_complexity_when_parsed_then_raises_error(self, parser):
        """Given tier recommend command with invalid complexity.

        When command is parsed
        Then SystemExit is raised
        """
        # Then
        with pytest.raises(SystemExit):
            # When
            parser.parse_args([
                "tier", "recommend", "Fix bug",
                "--complexity", "invalid"
            ])

    def test_given_missing_description_when_parsed_then_raises_error(self, parser):
        """Given tier recommend command without description.

        When command is parsed
        Then SystemExit is raised
        """
        # Then
        with pytest.raises(SystemExit):
            # When
            parser.parse_args(["tier", "recommend"])

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_tier_recommend_with_low_complexity_when_parsed_then_accepted(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with low complexity.

        When command is parsed
        Then complexity is accepted
        """
        # When
        args = parser.parse_args([
            "tier", "recommend", "Simple fix",
            "--complexity", "low"
        ])

        # Then
        assert args.complexity == "low"

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_tier_recommend_with_medium_complexity_when_parsed_then_accepted(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with medium complexity.

        When command is parsed
        Then complexity is accepted
        """
        # When
        args = parser.parse_args([
            "tier", "recommend", "Moderate fix",
            "--complexity", "medium"
        ])

        # Then
        assert args.complexity == "medium"

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_tier_recommend_with_files_when_parsed_then_files_preserved(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with multiple files.

        When command is parsed
        Then files string is preserved as-is
        """
        # When
        args = parser.parse_args([
            "tier", "recommend", "Fix",
            "--files", "file1.py,file2.py,file3.py"
        ])

        # Then
        assert args.files == "file1.py,file2.py,file3.py"

    def test_given_tier_command_only_when_parsed_then_tier_command_none(self, parser):
        """Given tier command without subcommand.

        When command is parsed
        Then tier_command is None
        """
        # When
        args = parser.parse_args(["tier"])

        # Then
        assert args.command == "tier"
        assert args.tier_command is None

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_description_with_spaces_when_parsed_then_preserved(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with description containing spaces.

        When command is parsed
        Then spaces in description are preserved
        """
        # When
        args = parser.parse_args([
            "tier", "recommend", "Fix the critical login bug"
        ])

        # Then
        assert args.description == "Fix the critical login bug"

    @patch('empathy_os.cli.parsers.tier.tier_commands')
    def test_given_description_with_special_chars_when_parsed_then_preserved(
        self, mock_tier_commands, parser
    ):
        """Given tier recommend command with special characters in description.

        When command is parsed
        Then special characters are preserved
        """
        # When
        args = parser.parse_args([
            "tier", "recommend", "Fix bug: user@example.com can't login!"
        ])

        # Then
        assert args.description == "Fix bug: user@example.com can't login!"