"""Behavioral tests for security.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
from unittest.mock import Mock, patch

import pytest

from attune.memory.short_term.security import DataSanitizer
from attune.memory.security.secrets_detector import SecretType, Severity as SecretSeverity
from attune.memory.types import RedisMetrics, SecurityError

# Fixtures


@pytest.fixture
def mock_metrics():
    """Provide a mock RedisMetrics instance."""
    m = Mock(spec=RedisMetrics)
    m.pii_scrubbed_total = 0
    m.pii_scrub_operations = 0
    m.secrets_blocked_total = 0
    m.secrets_detected_total = 0
    return m


@pytest.fixture
def mock_pii_scrubber():
    """Provide a mock PIIScrubber instance."""
    with patch("attune.memory.short_term.security.PIIScrubber") as mock:
        scrubber_instance = Mock()
        # The actual PIIScrubber.scrub() returns (sanitized_str, list[PIIDetection])
        scrubber_instance.scrub.return_value = ("[REDACTED]", [])
        mock.return_value = scrubber_instance
        yield mock


@pytest.fixture
def mock_secrets_detector():
    """Provide a mock SecretsDetector instance."""
    with patch("attune.memory.short_term.security.SecretsDetector") as mock:
        detector_instance = Mock()
        # The actual SecretsDetector.detect() returns list[SecretDetection]
        detector_instance.detect.return_value = []
        mock.return_value = detector_instance
        yield mock


@pytest.fixture
def sanitizer_with_all_enabled(mock_metrics, mock_pii_scrubber, mock_secrets_detector):
    """Provide a DataSanitizer with all features enabled."""
    return DataSanitizer(
        pii_scrub_enabled=True,
        secrets_detection_enabled=True,
        metrics=mock_metrics,
    )


@pytest.fixture
def sanitizer_with_pii_only(mock_metrics, mock_pii_scrubber, mock_secrets_detector):
    """Provide a DataSanitizer with only PII scrubbing enabled."""
    return DataSanitizer(
        pii_scrub_enabled=True,
        secrets_detection_enabled=False,
        metrics=mock_metrics,
    )


@pytest.fixture
def sanitizer_with_secrets_only(mock_metrics, mock_pii_scrubber, mock_secrets_detector):
    """Provide a DataSanitizer with only secrets detection enabled."""
    return DataSanitizer(
        pii_scrub_enabled=False,
        secrets_detection_enabled=True,
        metrics=mock_metrics,
    )


@pytest.fixture
def sanitizer_disabled(mock_metrics, mock_pii_scrubber, mock_secrets_detector):
    """Provide a DataSanitizer with all features disabled."""
    return DataSanitizer(
        pii_scrub_enabled=False,
        secrets_detection_enabled=False,
        metrics=mock_metrics,
    )


def _make_pii_detection(pii_type: str = "email") -> Mock:
    """Create a mock PIIDetection object."""
    detection = Mock()
    detection.pii_type = pii_type
    return detection


# Test DataSanitizer.__init__()


class TestDataSanitizerInit:
    """Test DataSanitizer initialization."""

    def test_init_with_all_enabled(self, mock_metrics, mock_pii_scrubber, mock_secrets_detector):
        """Given PII and secrets enabled, when initializing, then both components are created."""
        # When
        sanitizer = DataSanitizer(
            pii_scrub_enabled=True,
            secrets_detection_enabled=True,
            metrics=mock_metrics,
        )

        # Then
        assert sanitizer.pii_enabled is True
        assert sanitizer.secrets_enabled is True
        assert sanitizer._metrics == mock_metrics
        mock_pii_scrubber.assert_called_once_with(enable_name_detection=False)
        mock_secrets_detector.assert_called_once()

    def test_init_with_pii_only(self, mock_metrics, mock_pii_scrubber, mock_secrets_detector):
        """Given only PII enabled, when initializing, then only PII scrubber is created."""
        # When
        sanitizer = DataSanitizer(
            pii_scrub_enabled=True,
            secrets_detection_enabled=False,
            metrics=mock_metrics,
        )

        # Then
        assert sanitizer.pii_enabled is True
        assert sanitizer.secrets_enabled is False
        mock_pii_scrubber.assert_called_once_with(enable_name_detection=False)
        mock_secrets_detector.assert_not_called()

    def test_init_with_secrets_only(self, mock_metrics, mock_pii_scrubber, mock_secrets_detector):
        """Given only secrets enabled, when initializing, then only secrets detector is created."""
        # When
        sanitizer = DataSanitizer(
            pii_scrub_enabled=False,
            secrets_detection_enabled=True,
            metrics=mock_metrics,
        )

        # Then
        assert sanitizer.pii_enabled is False
        assert sanitizer.secrets_enabled is True
        mock_pii_scrubber.assert_not_called()
        mock_secrets_detector.assert_called_once()

    def test_init_with_all_disabled(self, mock_pii_scrubber, mock_secrets_detector):
        """Given all features disabled, when initializing, then no components are created."""
        # When
        sanitizer = DataSanitizer(
            pii_scrub_enabled=False,
            secrets_detection_enabled=False,
            metrics=None,
        )

        # Then
        assert sanitizer.pii_enabled is False
        assert sanitizer.secrets_enabled is False
        # metrics=None triggers fallback to RedisMetrics()
        assert isinstance(sanitizer._metrics, RedisMetrics)
        mock_pii_scrubber.assert_not_called()
        mock_secrets_detector.assert_not_called()

    def test_init_without_metrics(self, mock_pii_scrubber, mock_secrets_detector):
        """Given no metrics provided, when initializing, then a default RedisMetrics is created."""
        # When
        sanitizer = DataSanitizer(
            pii_scrub_enabled=True,
            secrets_detection_enabled=True,
            metrics=None,
        )

        # Then - source uses `metrics or RedisMetrics()`, so None triggers default
        assert isinstance(sanitizer._metrics, RedisMetrics)


# Test DataSanitizer.metrics property


class TestDataSanitizerMetrics:
    """Test DataSanitizer metrics property."""

    def test_metrics_property_returns_metrics_instance(
        self, sanitizer_with_all_enabled, mock_metrics
    ):
        """Given a sanitizer with metrics, when accessing metrics property, then it returns the metrics instance."""
        # When
        result = sanitizer_with_all_enabled.metrics

        # Then
        assert result == mock_metrics

    def test_metrics_property_returns_default_when_none_passed(
        self, mock_pii_scrubber, mock_secrets_detector
    ):
        """Given a sanitizer with metrics=None, when accessing metrics property, then it returns a default RedisMetrics."""
        # Given
        sanitizer = DataSanitizer(
            pii_scrub_enabled=False,
            secrets_detection_enabled=False,
            metrics=None,
        )

        # When
        result = sanitizer.metrics

        # Then - source does `self._metrics = metrics or RedisMetrics()`
        assert isinstance(result, RedisMetrics)


# Test DataSanitizer.sanitize()


class TestDataSanitizerSanitize:
    """Test DataSanitizer.sanitize() method."""

    def test_sanitize_string_with_pii_enabled(self, sanitizer_with_pii_only):
        """Given PII enabled, when sanitizing a string, then PII is scrubbed."""
        # Given
        data = "Contact me at user@example.com"
        pii_detection = _make_pii_detection("email")
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = (
            "Contact me at [EMAIL]",
            [pii_detection],
        )

        # When
        result, count = sanitizer_with_pii_only.sanitize(data)

        # Then
        assert result == "Contact me at [EMAIL]"
        assert count == 1
        sanitizer_with_pii_only._pii_scrubber.scrub.assert_called_once_with(data)

    def test_sanitize_dict_with_pii_enabled(self, sanitizer_with_pii_only):
        """Given PII enabled, when sanitizing a dict, then PII is scrubbed from serialized dict."""
        # Given
        data = {"email": "user@example.com", "name": "John"}
        data_str = json.dumps(data)
        pii_detection = _make_pii_detection("email")
        sanitized_dict = {"email": "[EMAIL]", "name": "John"}
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = (
            json.dumps(sanitized_dict),
            [pii_detection],
        )

        # When
        result, count = sanitizer_with_pii_only.sanitize(data)

        # Then
        assert result == {"email": "[EMAIL]", "name": "John"}
        assert count == 1
        sanitizer_with_pii_only._pii_scrubber.scrub.assert_called_once_with(data_str)

    def test_sanitize_list_with_pii_enabled(self, sanitizer_with_pii_only):
        """Given PII enabled, when sanitizing a list, then PII is scrubbed from serialized list."""
        # Given
        data = ["user@example.com", "555-1234"]
        data_str = json.dumps(data)
        pii_detections = [_make_pii_detection("email"), _make_pii_detection("phone")]
        sanitized_list = ["[EMAIL]", "[PHONE]"]
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = (
            json.dumps(sanitized_list),
            pii_detections,
        )

        # When
        result, count = sanitizer_with_pii_only.sanitize(data)

        # Then
        assert result == ["[EMAIL]", "[PHONE]"]
        assert count == 2
        sanitizer_with_pii_only._pii_scrubber.scrub.assert_called_once_with(data_str)

    def test_sanitize_nested_structure_with_pii_enabled(self, sanitizer_with_pii_only):
        """Given PII enabled, when sanitizing nested data, then all PII is scrubbed."""
        # Given
        data = {
            "users": [
                {"email": "user1@example.com"},
                {"email": "user2@example.com"},
            ]
        }
        data_str = json.dumps(data)
        pii_detections = [_make_pii_detection("email"), _make_pii_detection("email")]
        sanitized_data = {
            "users": [
                {"email": "[EMAIL]"},
                {"email": "[EMAIL]"},
            ]
        }
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = (
            json.dumps(sanitized_data),
            pii_detections,
        )

        # When
        result, count = sanitizer_with_pii_only.sanitize(data)

        # Then
        assert count == 2
        assert "EMAIL" in str(result)
        sanitizer_with_pii_only._pii_scrubber.scrub.assert_called_once_with(data_str)

    def test_sanitize_with_secrets_detection_finds_secrets(self, sanitizer_with_secrets_only):
        """Given secrets detection enabled, when secrets are found, then SecurityError is raised."""
        # Given
        data = "API_KEY=sk_live_1234567890"

        secret_finding = Mock()
        secret_finding.severity = SecretSeverity.HIGH
        secret_finding.secret_type = SecretType.GENERIC_API_KEY
        sanitizer_with_secrets_only._secrets_detector.detect.return_value = [secret_finding]

        # When/Then
        with pytest.raises(SecurityError) as exc_info:
            sanitizer_with_secrets_only.sanitize(data)

        assert "Cannot store data containing secrets" in str(exc_info.value)

    def test_sanitize_with_secrets_detection_dict(self, sanitizer_with_secrets_only):
        """Given secrets detection enabled for dict, when secrets are found, then SecurityError is raised."""
        # Given
        data = {"api_key": "sk_live_1234567890"}

        secret_finding = Mock()
        secret_finding.severity = SecretSeverity.HIGH
        secret_finding.secret_type = SecretType.GENERIC_API_KEY
        sanitizer_with_secrets_only._secrets_detector.detect.return_value = [secret_finding]

        # When/Then
        with pytest.raises(SecurityError) as exc_info:
            sanitizer_with_secrets_only.sanitize(data)

        assert "Cannot store data containing secrets" in str(exc_info.value)

    def test_sanitize_with_both_enabled_pii_and_no_secrets(self, sanitizer_with_all_enabled):
        """Given both enabled, when only PII exists, then data is scrubbed without error."""
        # Given
        data = "Contact: user@example.com"
        pii_detection = _make_pii_detection("email")
        sanitizer_with_all_enabled._pii_scrubber.scrub.return_value = (
            "Contact: [EMAIL]",
            [pii_detection],
        )
        sanitizer_with_all_enabled._secrets_detector.detect.return_value = []

        # When
        result, count = sanitizer_with_all_enabled.sanitize(data)

        # Then
        assert result == "Contact: [EMAIL]"
        assert count == 1

    def test_sanitize_with_both_enabled_secrets_found(self, sanitizer_with_all_enabled):
        """Given both enabled, when secrets are found, then SecurityError is raised before PII scrubbing."""
        # Given
        data = "API_KEY=sk_live_123 and email user@example.com"

        secret_finding = Mock()
        secret_finding.severity = SecretSeverity.HIGH
        secret_finding.secret_type = SecretType.GENERIC_API_KEY
        sanitizer_with_all_enabled._secrets_detector.detect.return_value = [secret_finding]

        # When/Then
        with pytest.raises(SecurityError):
            sanitizer_with_all_enabled.sanitize(data)

    def test_sanitize_all_disabled(self, sanitizer_disabled):
        """Given all features disabled, when sanitizing, then data is returned unchanged."""
        # Given
        data = "Contact: user@example.com, API_KEY=secret"

        # When
        result, count = sanitizer_disabled.sanitize(data)

        # Then
        assert result == data
        assert count == 0

    def test_sanitize_with_none_input(self, sanitizer_with_pii_only):
        """Given None as input, when sanitizing, then None is returned with zero count."""
        # When
        result, count = sanitizer_with_pii_only.sanitize(None)

        # Then
        assert result is None
        assert count == 0

    def test_sanitize_with_empty_string(self, sanitizer_with_pii_only):
        """Given empty string, when sanitizing, then empty string is returned."""
        # Given - scrub returns no detections for empty string
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = ("", [])

        # When
        result, count = sanitizer_with_pii_only.sanitize("")

        # Then
        assert result == ""
        assert count == 0

    def test_sanitize_with_empty_dict(self, sanitizer_with_pii_only):
        """Given empty dict, when sanitizing, then empty dict is returned."""
        # Given - scrub returns no detections for empty dict serialized
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = ("{}", [])

        # When
        result, count = sanitizer_with_pii_only.sanitize({})

        # Then
        assert result == {}
        assert count == 0

    def test_sanitize_with_empty_list(self, sanitizer_with_pii_only):
        """Given empty list, when sanitizing, then empty list is returned."""
        # Given - scrub returns no detections for empty list serialized
        sanitizer_with_pii_only._pii_scrubber.scrub.return_value = ("[]", [])

        # When
        result, count = sanitizer_with_pii_only.sanitize([])

        # Then
        assert result == []
        assert count == 0
