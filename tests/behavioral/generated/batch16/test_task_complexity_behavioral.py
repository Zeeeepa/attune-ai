"""Behavioral tests for task_complexity.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from empathy_os.adaptive.task_complexity import (
    TaskComplexity,
    ComplexityScore,
    TaskComplexityScorer,
)


# Fixtures


@pytest.fixture
def mock_tiktoken_encoder():
    """Mock tiktoken encoder for testing."""
    encoder = Mock()
    encoder.encode = Mock(side_effect=lambda text: [0] * (len(text) // 4))
    return encoder


@pytest.fixture
def scorer_with_tiktoken(mock_tiktoken_encoder):
    """Create scorer with mocked tiktoken."""
    with patch("empathy_os.adaptive.task_complexity.tiktoken") as mock_tiktoken:
        mock_tiktoken.get_encoding.return_value = mock_tiktoken_encoder
        scorer = TaskComplexityScorer()
        return scorer


@pytest.fixture
def scorer_without_tiktoken():
    """Create scorer without tiktoken."""
    with patch("empathy_os.adaptive.task_complexity.tiktoken", None):
        scorer = TaskComplexityScorer()
        return scorer


@pytest.fixture
def simple_task_description():
    """Simple task description with <100 tokens."""
    return "Fix bug in login function"


@pytest.fixture
def moderate_task_description():
    """Moderate task description with 100-500 tokens."""
    return "Refactor the authentication module to use OAuth2 " * 50


@pytest.fixture
def complex_task_description():
    """Complex task description with 500-2000 tokens."""
    return "Implement comprehensive user authentication system with OAuth2, JWT, refresh tokens " * 200


@pytest.fixture
def very_complex_task_description():
    """Very complex task description with >2000 tokens."""
    return "Design and implement enterprise-scale authentication and authorization system " * 800


@pytest.fixture
def simple_context():
    """Simple context with <50 lines."""
    return "\n".join([f"line {i}" for i in range(30)])


@pytest.fixture
def moderate_context():
    """Moderate context with 50-200 lines."""
    return "\n".join([f"line {i}" for i in range(150)])


@pytest.fixture
def complex_context():
    """Complex context with 200-1000 lines."""
    return "\n".join([f"line {i}" for i in range(500)])


@pytest.fixture
def very_complex_context():
    """Very complex context with >1000 lines."""
    return "\n".join([f"line {i}" for i in range(1500)])


# TaskComplexity Enum Tests


class TestTaskComplexity:
    """Tests for TaskComplexity enum."""

    def test_given_complexity_levels_when_accessed_then_returns_correct_values(self):
        """Given complexity levels, when accessed, then returns correct string values."""
        assert TaskComplexity.SIMPLE.value == "simple"
        assert TaskComplexity.MODERATE.value == "moderate"
        assert TaskComplexity.COMPLEX.value == "complex"
        assert TaskComplexity.VERY_COMPLEX.value == "very_complex"

    def test_given_complexity_enum_when_comparing_then_equality_works(self):
        """Given complexity enum values, when comparing, then equality works correctly."""
        assert TaskComplexity.SIMPLE == TaskComplexity.SIMPLE
        assert TaskComplexity.SIMPLE != TaskComplexity.MODERATE

    def test_given_complexity_enum_when_iterating_then_contains_all_levels(self):
        """Given complexity enum, when iterating, then contains all four levels."""
        levels = list(TaskComplexity)
        assert len(levels) == 4
        assert TaskComplexity.SIMPLE in levels
        assert TaskComplexity.MODERATE in levels
        assert TaskComplexity.COMPLEX in levels
        assert TaskComplexity.VERY_COMPLEX in levels


# ComplexityScore Tests


class TestComplexityScore:
    """Tests for ComplexityScore dataclass."""

    def test_given_score_attributes_when_created_then_stores_all_values(self):
        """Given score attributes, when created, then stores all values correctly."""
        score = ComplexityScore(
            token_count=100,
            line_count=50,
            file_count=2,
            complexity_level=TaskComplexity.MODERATE,
            confidence=0.85,
        )
        assert score.token_count == 100
        assert score.line_count == 50
        assert score.file_count == 2
        assert score.complexity_level == TaskComplexity.MODERATE
        assert score.confidence == 0.85

    def test_given_score_when_accessing_complexity_level_then_returns_enum(self):
        """Given score, when accessing complexity level, then returns TaskComplexity enum."""
        score = ComplexityScore(
            token_count=50,
            line_count=30,
            file_count=1,
            complexity_level=TaskComplexity.SIMPLE,
            confidence=0.9,
        )
        assert isinstance(score.complexity_level, TaskComplexity)

    def test_given_two_identical_scores_when_comparing_then_equal(self):
        """Given two identical scores, when comparing, then they are equal."""
        score1 = ComplexityScore(100, 50, 2, TaskComplexity.MODERATE, 0.85)
        score2 = ComplexityScore(100, 50, 2, TaskComplexity.MODERATE, 0.85)
        assert score1 == score2


# TaskComplexityScorer Initialization Tests


class TestTaskComplexityScorerInitialization:
    """Tests for TaskComplexityScorer initialization."""

    def test_given_tiktoken_available_when_initialized_then_uses_tiktoken(self):
        """Given tiktoken available, when initialized, then uses tiktoken encoder."""
        with patch("empathy_os.adaptive.task_complexity.tiktoken") as mock_tiktoken:
            mock_encoder = Mock()
            mock_tiktoken.get_encoding.return_value = mock_encoder
            
            scorer = TaskComplexityScorer()
            
            mock_tiktoken.get_encoding.assert_called_once_with("cl100k_base")
            assert scorer.tokenizer == mock_encoder

    def test_given_tiktoken_unavailable_when_initialized_then_tokenizer_is_none(self):
        """Given tiktoken unavailable, when initialized, then tokenizer is None."""
        with patch("empathy_os.adaptive.task_complexity.tiktoken", None):
            scorer = TaskComplexityScorer()
            assert scorer.tokenizer is None


# Simple Task Tests


class TestSimpleTasks:
    """Tests for simple task complexity scoring."""

    def test_given_simple_description_when_scored_with_tiktoken_then_returns_simple(
        self, scorer_with_tiktoken, simple_task_description
    ):
        """Given simple description, when scored with tiktoken, then returns SIMPLE complexity."""
        score = scorer_with_tiktoken.score_task(simple_task_description)
        
        assert score.complexity_level == TaskComplexity.SIMPLE
        assert score.token_count < 100
        assert score.confidence > 0

    def test_given_simple_description_when_scored_without_tiktoken_then_returns_simple(
        self, scorer_without_tiktoken, simple_task_description
    ):
        """Given simple description, when scored without tiktoken, then returns SIMPLE complexity."""
        score = scorer_without_tiktoken.score_task(simple_task_description)
        
        assert score.complexity_level == TaskComplexity.SIMPLE
        assert score.token_count < 100

    def test_given_simple_task_with_context_when_scored_then_includes_context_tokens(
        self, scorer_with_tiktoken, simple_task_description, simple_context
    ):
        """Given simple task with context, when scored, then includes context in token count."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, context=simple_context
        )
        
        assert score.token_count > len(simple_task_description) // 4
        assert score.line_count == 30

    def test_given_simple_task_with_files_when_scored_then_includes_file_count(
        self, scorer_with_tiktoken, simple_task_description
    ):
        """Given simple task with files, when scored, then includes file count."""
        files = ["file1.py", "file2.py"]
        score = scorer_with_tiktoken.score_task(
            simple_task_description, files=files
        )
        
        assert score.file_count == 2


# Moderate Task Tests


class TestModerateTasks:
    """Tests for moderate task complexity scoring."""

    def test_given_moderate_description_when_scored_then_returns_moderate(
        self, scorer_with_tiktoken, moderate_task_description
    ):
        """Given moderate description, when scored, then returns MODERATE complexity."""
        score = scorer_with_tiktoken.score_task(moderate_task_description)
        
        assert score.complexity_level == TaskComplexity.MODERATE
        assert 100 <= score.token_count <= 500

    def test_given_moderate_context_when_scored_then_line_count_in_range(
        self, scorer_with_tiktoken, simple_task_description, moderate_context
    ):
        """Given moderate context, when scored, then line count in moderate range."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, context=moderate_context
        )
        
        assert score.line_count == 150
        assert 50 <= score.line_count <= 200

    def test_given_boundary_case_100_tokens_when_scored_then_returns_moderate(
        self, scorer_with_tiktoken
    ):
        """Given boundary case of exactly 100 tokens, when scored, then returns MODERATE."""
        # Create description that results in exactly 100 tokens
        description = "x" * 400  # 400 chars / 4 = 100 tokens
        score = scorer_with_tiktoken.score_task(description)
        
        assert score.complexity_level in [TaskComplexity.SIMPLE, TaskComplexity.MODERATE]


# Complex Task Tests


class TestComplexTasks:
    """Tests for complex task complexity scoring."""

    def test_given_complex_description_when_scored_then_returns_complex(
        self, scorer_with_tiktoken, complex_task_description
    ):
        """Given complex description, when scored, then returns COMPLEX complexity."""
        score = scorer_with_tiktoken.score_task(complex_task_description)
        
        assert score.complexity_level == TaskComplexity.COMPLEX
        assert 500 <= score.token_count <= 2000

    def test_given_complex_context_when_scored_then_line_count_in_range(
        self, scorer_with_tiktoken, simple_task_description, complex_context
    ):
        """Given complex context, when scored, then line count in complex range."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, context=complex_context
        )
        
        assert score.line_count == 500
        assert 200 <= score.line_count <= 1000

    def test_given_complex_task_with_multiple_files_when_scored_then_increases_confidence(
        self, scorer_with_tiktoken, complex_task_description
    ):
        """Given complex task with multiple files, when scored, then file count tracked."""
        files = [f"file{i}.py" for i in range(10)]
        score = scorer_with_tiktoken.score_task(
            complex_task_description, files=files
        )
        
        assert score.file_count == 10


# Very Complex Task Tests


class TestVeryComplexTasks:
    """Tests for very complex task complexity scoring."""

    def test_given_very_complex_description_when_scored_then_returns_very_complex(
        self, scorer_with_tiktoken, very_complex_task_description
    ):
        """Given very complex description, when scored, then returns VERY_COMPLEX."""
        score = scorer_with_tiktoken.score_task(very_complex_task_description)
        
        assert score.complexity_level == TaskComplexity.VERY_COMPLEX
        assert score.token_count > 2000

    def test_given_very_complex_context_when_scored_then_line_count_above_1000(
        self, scorer_with_tiktoken, simple_task_description, very_complex_context
    ):
        """Given very complex context, when scored, then line count above 1000."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, context=very_complex_context
        )
        
        assert score.line_count == 1500
        assert score.line_count > 1000

    def test_given_very_complex_task_when_scored_without_tiktoken_then_uses_fallback(
        self, scorer_without_tiktoken, very_complex_task_description
    ):
        """Given very complex task without tiktoken, when scored, then uses fallback estimation."""
        score = scorer_without_tiktoken.score_task(very_complex_task_description)
        
        assert score.complexity_level == TaskComplexity.VERY_COMPLEX
        # Fallback uses 4 chars per token
        expected_tokens = len(very_complex_task_description) // 4
        assert score.token_count == expected_tokens


# Edge Cases and Error Handling Tests


class TestEdgeCases:
    """Tests for edge cases and error handling."""

    def test_given_empty_description_when_scored_then_returns_simple(
        self, scorer_with_tiktoken
    ):
        """Given empty description, when scored, then returns SIMPLE complexity."""
        score = scorer_with_tiktoken.score_task("")
        
        assert score.complexity_level == TaskComplexity.SIMPLE
        assert score.token_count == 0

    def test_given_none_context_when_scored_then_handles_gracefully(
        self, scorer_with_tiktoken, simple_task_description
    ):
        """Given None context, when scored, then handles gracefully."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, context=None
        )
        
        assert score.line_count == 0
        assert score.complexity_level == TaskComplexity.SIMPLE

    def test_given_none_files_when_scored_then_file_count_zero(
        self, scorer_with_tiktoken, simple_task_description
    ):
        """Given None files list, when scored, then file count is zero."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, files=None
        )
        
        assert score.file_count == 0

    def test_given_empty_files_list_when_scored_then_file_count_zero(
        self, scorer_with_tiktoken, simple_task_description
    ):
        """Given empty files list, when scored, then file count is zero."""
        score = scorer_with_tiktoken.score_task(simple_task_description, files=[])
        
        assert score.file_count == 0

    def test_given_single_line_context_when_scored_then_line_count_one(
        self, scorer_with_tiktoken, simple_task_description
    ):
        """Given single line context, when scored, then line count is one."""
        score = scorer_with_tiktoken.score_task(
            simple_task_description, context="single line"
        )
        
        assert score.line_count == 1

    def test_given_context_with_empty_lines_when_scored_then_counts_all_lines(
        self,