"""Behavioral tests for utilities.

Generated by enhanced autonomous test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

import subprocess
from unittest.mock import Mock, patch, call

import pytest
import typer
from typer.testing import CliRunner

from empathy_os.cli.commands.utilities import (
    utilities_app,
    sync_claude,
    cheatsheet,
)


@pytest.fixture
def cli_runner():
    """Fixture to provide a CLI runner for testing."""
    return CliRunner()


@pytest.fixture
def mock_subprocess():
    """Fixture to mock subprocess.run calls."""
    with patch("empathy_os.cli.commands.utilities.subprocess.run") as mock_run:
        yield mock_run


@pytest.fixture
def mock_console():
    """Fixture to mock rich console output."""
    with patch("empathy_os.cli.commands.utilities.console") as mock_con:
        yield mock_con


class TestUtilitiesApp:
    """Test suite for the utilities Typer application."""

    def test_given_utilities_app_when_created_then_has_correct_config(self):
        """Given utilities_app is initialized, when accessed, then it has correct configuration."""
        # Then
        assert isinstance(utilities_app, typer.Typer)
        assert utilities_app.info.help == "Utility tools - project init, cheatsheet, dashboard, costs"
        assert utilities_app.info.no_args_is_help is True

    def test_given_utilities_app_when_listing_commands_then_contains_expected_commands(self):
        """Given utilities_app, when listing commands, then sync-claude and cheatsheet are present."""
        # Given
        command_names = [cmd.name for cmd in utilities_app.registered_commands]

        # Then
        assert "sync-claude" in command_names
        assert "cheatsheet" in command_names


class TestSyncClaude:
    """Test suite for sync_claude command."""

    def test_given_default_source_when_sync_claude_called_then_runs_with_patterns(
        self, mock_subprocess
    ):
        """Given default parameters, when sync_claude is called, then subprocess runs with 'patterns' source."""
        # When
        sync_claude()

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", "patterns"],
            check=False
        )

    def test_given_custom_source_when_sync_claude_called_then_runs_with_custom_source(
        self, mock_subprocess
    ):
        """Given custom source parameter, when sync_claude is called, then subprocess runs with that source."""
        # Given
        custom_source = "custom-patterns"

        # When
        sync_claude(source=custom_source)

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", custom_source],
            check=False
        )

    def test_given_empty_source_when_sync_claude_called_then_runs_with_empty_string(
        self, mock_subprocess
    ):
        """Given empty source string, when sync_claude is called, then subprocess runs with empty source."""
        # Given
        empty_source = ""

        # When
        sync_claude(source=empty_source)

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", ""],
            check=False
        )

    def test_given_sync_claude_command_when_subprocess_fails_then_does_not_raise(
        self, mock_subprocess
    ):
        """Given sync_claude command, when subprocess fails, then no exception is raised (check=False)."""
        # Given
        mock_subprocess.side_effect = subprocess.CalledProcessError(1, "cmd")

        # When / Then
        sync_claude()  # Should not raise exception

    def test_given_sync_claude_via_cli_when_no_options_then_uses_default_source(
        self, cli_runner, mock_subprocess
    ):
        """Given sync-claude via CLI, when no options provided, then uses default 'patterns' source."""
        # When
        result = cli_runner.invoke(utilities_app, ["sync-claude"])

        # Then
        assert result.exit_code == 0
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", "patterns"],
            check=False
        )

    def test_given_sync_claude_via_cli_when_source_option_then_uses_specified_source(
        self, cli_runner, mock_subprocess
    ):
        """Given sync-claude via CLI, when --source option provided, then uses specified source."""
        # When
        result = cli_runner.invoke(utilities_app, ["sync-claude", "--source", "custom"])

        # Then
        assert result.exit_code == 0
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", "custom"],
            check=False
        )

    def test_given_sync_claude_via_cli_when_short_option_then_uses_specified_source(
        self, cli_runner, mock_subprocess
    ):
        """Given sync-claude via CLI, when -s short option provided, then uses specified source."""
        # When
        result = cli_runner.invoke(utilities_app, ["sync-claude", "-s", "short-source"])

        # Then
        assert result.exit_code == 0
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", "short-source"],
            check=False
        )

    def test_given_special_characters_in_source_when_sync_claude_called_then_passes_to_subprocess(
        self, mock_subprocess
    ):
        """Given source with special characters, when sync_claude is called, then passes correctly."""
        # Given
        special_source = "path/to/patterns-v2.0"

        # When
        sync_claude(source=special_source)

        # Then
        mock_subprocess.assert_called_once_with(
            ["empathy-sync-claude", "--source", special_source],
            check=False
        )

    def test_given_sync_claude_when_called_multiple_times_then_each_call_invokes_subprocess(
        self, mock_subprocess
    ):
        """Given sync_claude, when called multiple times, then each invocation calls subprocess."""
        # When
        sync_claude(source="source1")
        sync_claude(source="source2")
        sync_claude(source="source3")

        # Then
        assert mock_subprocess.call_count == 3
        calls = [
            call(["empathy-sync-claude", "--source", "source1"], check=False),
            call(["empathy-sync-claude", "--source", "source2"], check=False),
            call(["empathy-sync-claude", "--source", "source3"], check=False),
        ]
        mock_subprocess.assert_has_calls(calls)


class TestCheatsheet:
    """Test suite for cheatsheet command."""

    def test_given_cheatsheet_called_when_executed_then_prints_panel(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then prints panel to console."""
        # When
        cheatsheet()

        # Then
        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0]
        assert len(call_args) == 1

    def test_given_cheatsheet_called_when_executed_then_contains_getting_started_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Getting Started section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Getting Started" in panel_content
        assert "empathy morning" in panel_content
        assert "empathy health" in panel_content
        assert "empathy ship" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_memory_system_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Memory System section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Memory System" in panel_content
        assert "empathy memory status" in panel_content
        assert "empathy memory start" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_service_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Cross-Session Service section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Cross-Session Service" in panel_content
        assert "empathy service start" in panel_content
        assert "empathy service status" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_provider_config_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Provider Config section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Provider Config" in panel_content
        assert "empathy provider" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_code_inspection_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Code Inspection section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Code Inspection" in panel_content
        assert "empathy scan" in panel_content
        assert "empathy inspect" in panel_content
        assert "empathy fix-all" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_profiling_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Profiling section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Profiling" in panel_content
        assert "empathy profile memory-scan" in panel_content
        assert "empathy profile hot-files" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_pattern_learning_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Pattern Learning section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Pattern Learning" in panel_content
        assert "empathy learn" in panel_content
        assert "empathy utilities sync-claude" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_workflows_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Workflows section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Workflows" in panel_content
        assert "empathy workflow list" in panel_content
        assert "empathy workflow run" in panel_content
        assert "empathy workflow create" in panel_content

    def test_given_cheatsheet_called_when_executed_then_contains_telemetry_section(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then output contains Usage Telemetry section."""
        # When
        cheatsheet()

        # Then
        panel_content = str(mock_console.print.call_args[0][0])
        assert "Usage Telemetry" in panel_content
        assert "empathy telemetry show" in panel_content
        assert "empathy telemetry savings" in panel_content
        assert "empathy telemetry export" in panel_content

    def test_given_cheatsheet_via_cli_when_invoked_then_exits_successfully(
        self, cli_runner, mock_console
    ):
        """Given cheatsheet via CLI, when invoked, then exits with code 0."""
        # When
        result = cli_runner.invoke(utilities_app, ["cheatsheet"])

        # Then
        assert result.exit_code == 0
        mock_console.print.assert_called_once()

    def test_given_cheatsheet_called_when_executed_then_uses_panel_fit(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then uses Panel.fit for formatting."""
        # When
        cheatsheet()

        # Then
        from rich.panel import Panel
        call_args = mock_console.print.call_args[0]
        assert isinstance(call_args[0], Panel)

    def test_given_cheatsheet_called_multiple_times_when_executed_then_each_prints_output(
        self, mock_console
    ):
        """Given cheatsheet function, when called multiple times, then each call prints output."""
        # When
        cheatsheet()
        cheatsheet()
        cheatsheet()

        # Then
        assert mock_console.print.call_count == 3

    def test_given_cheatsheet_called_when_executed_then_no_return_value(
        self, mock_console
    ):
        """Given cheatsheet function, when called, then returns None."""
        # When
        result = cheatsheet()

        # Then
        assert result is None

    def test_given_cheatsheet_called_when_console_raises_then_propagates_exception(
        self, mock_console
    ):
        """Given cheatsheet function, when console.print raises exception, then exception propagates."""
        # Given
        mock_console.print.side_effect = Exception("Console error")

        # When / Then
        with pytest.raises(Exception, match="Console error"):
            cheatsheet()


class TestUtilitiesAppIntegration:
    """Integration tests for utilities app."""

    def test_given_utilities_app_when_invoked_without_command_then_shows_help(
        self, cli_runner
    ):
        """Given utilities_app, when invoked without command, then shows help message."""
        # When
        result = cli_runner.invoke(utilities_app, [])

        # Then
        assert result.exit_code == 0
        assert "Utility tools" in result.output or "Commands:" in result.output

    def test_given_utilities_app_when_invoked_with_help_flag_then_shows_help(
        self, cli_runner
    ):
        """Given utilities_app, when invoked with --help, then shows help message."""
        # When
        result = cli_runner.invoke(utilities_app, ["--help"])

        # Then
        assert result.exit_code == 0
        assert "sync-claude" in result.output
        assert "cheatsheet" in result.output

    def test_given_utilities_app_when_invalid_command_then_fails(
        self, cli_runner
    ):
        """Given utilities_app, when invoked with invalid command, then fails."""
        # When
        result = cli_runner.invoke(utilities_app, ["invalid-command"])

        # Then
        assert result.exit_code != 0

    def test_given_sync_claude_command_when_help_requested_then_shows_source_option(
        self, cli_runner
    ):
        """Given sync-claude command, when --help requested, then shows --source option."""
        # When