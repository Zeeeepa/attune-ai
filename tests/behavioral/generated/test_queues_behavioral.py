"""Behavioral tests for queues.

Generated by LLM-enhanced test generation system.

Copyright 2026 Smart-AI-Memory
Licensed under Apache 2.0
"""

from __future__ import annotations

import json
from datetime import datetime
from typing import TYPE_CHECKING
from unittest.mock import MagicMock, Mock, patch

import pytest

from attune.memory.short_term.queues import QueueManager
from attune.memory.types import AccessTier, AgentCredentials

if TYPE_CHECKING:
    from attune.memory.short_term.base import BaseOperations


@pytest.fixture
def mock_base_ops() -> Mock:
    """Create a mock BaseOperations instance.

    Returns:
        Mock BaseOperations with _client attribute
    """
    base = Mock()
    base.use_mock = False
    base._client = Mock()
    base._metrics = Mock()
    return base


@pytest.fixture
def mock_base_ops_mock_mode() -> Mock:
    """Create a mock BaseOperations instance in mock mode.

    Returns:
        Mock BaseOperations with use_mock set to True
    """
    base = Mock()
    base.use_mock = True
    base._client = None
    base._metrics = Mock()
    return base


@pytest.fixture
def queue_manager(mock_base_ops: Mock) -> QueueManager:
    """Create a QueueManager instance.

    Args:
        mock_base_ops: Mock BaseOperations

    Returns:
        QueueManager instance
    """
    return QueueManager(mock_base_ops)


@pytest.fixture
def queue_manager_mock_mode(mock_base_ops_mock_mode: Mock) -> QueueManager:
    """Create a QueueManager instance in mock mode.

    Args:
        mock_base_ops_mock_mode: Mock BaseOperations in mock mode

    Returns:
        QueueManager instance in mock mode
    """
    return QueueManager(mock_base_ops_mock_mode)


@pytest.fixture
def contributor_creds() -> AgentCredentials:
    """Create contributor-level credentials.

    Returns:
        AgentCredentials with CONTRIBUTOR tier
    """
    return AgentCredentials("agent_contributor", AccessTier.CONTRIBUTOR)


@pytest.fixture
def reader_creds() -> AgentCredentials:
    """Create observer-level credentials.

    Returns:
        AgentCredentials with OBSERVER tier
    """
    return AgentCredentials("agent_reader", AccessTier.OBSERVER)


@pytest.fixture
def maintainer_creds() -> AgentCredentials:
    """Create steward-level credentials.

    Returns:
        AgentCredentials with STEWARD tier
    """
    return AgentCredentials("agent_maintainer", AccessTier.STEWARD)


class TestQueueManagerInit:
    """Tests for QueueManager initialization."""

    def test_init_stores_base_operations(self, mock_base_ops: Mock) -> None:
        """GIVEN a BaseOperations instance
        WHEN QueueManager is initialized
        THEN it stores the base operations reference
        """
        # When
        manager = QueueManager(mock_base_ops)

        # Then
        assert manager._base is mock_base_ops

    def test_init_creates_empty_mock_lists(self, mock_base_ops: Mock) -> None:
        """GIVEN a BaseOperations instance
        WHEN QueueManager is initialized
        THEN it creates an empty mock lists dictionary
        """
        # When
        manager = QueueManager(mock_base_ops)

        # Then
        assert manager._mock_lists == {}

    def test_init_sets_correct_prefix(self, mock_base_ops: Mock) -> None:
        """GIVEN a BaseOperations instance
        WHEN QueueManager is initialized
        THEN it has the correct PREFIX_QUEUE constant
        """
        # When
        manager = QueueManager(mock_base_ops)

        # Then
        assert manager.PREFIX_QUEUE == "queue:"


class TestQueueManagerPush:
    """Tests for QueueManager.push method."""

    def test_push_with_contributor_access_regular_priority(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue manager and contributor credentials
        WHEN pushing a task with regular priority
        THEN the task is added to the end of the queue and returns new length
        """
        # Given
        task = {"type": "analyze", "file": "main.py"}
        mock_base_ops._client.rpush.return_value = 1

        # When
        result = queue_manager.push("tasks", task, contributor_creds, priority=False)

        # Then
        assert result == 1
        mock_base_ops._client.rpush.assert_called_once()
        call_args = mock_base_ops._client.rpush.call_args
        assert call_args[0][0] == "queue:tasks"

    def test_push_with_contributor_access_high_priority(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue manager and contributor credentials
        WHEN pushing a task with high priority
        THEN the task is added to the front of the queue
        """
        # Given
        task = {"type": "urgent", "file": "critical.py"}
        mock_base_ops._client.lpush.return_value = 1

        # When
        result = queue_manager.push("tasks", task, contributor_creds, priority=True)

        # Then
        assert result == 1
        mock_base_ops._client.lpush.assert_called_once()
        call_args = mock_base_ops._client.lpush.call_args
        assert call_args[0][0] == "queue:tasks"

    def test_push_with_reader_access_raises_permission_error(
        self,
        queue_manager: QueueManager,
        reader_creds: AgentCredentials,
    ) -> None:
        """GIVEN a queue manager and observer credentials
        WHEN pushing a task
        THEN a PermissionError is raised
        """
        # Given
        task = {"type": "analyze", "file": "main.py"}

        # When/Then
        with pytest.raises(PermissionError) as exc_info:
            queue_manager.push("tasks", task, reader_creds)

        assert "cannot push to queue" in str(exc_info.value)
        assert "agent_reader" in str(exc_info.value)

    def test_push_serializes_task_as_envelope(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue manager and a task dictionary
        WHEN pushing the task
        THEN the task is wrapped in an envelope with metadata and serialized to JSON
        """
        # Given
        task = {"type": "analyze", "file": "main.py", "nested": {"key": "value"}}
        mock_base_ops._client.rpush.return_value = 1

        # When
        queue_manager.push("tasks", task, contributor_creds)

        # Then
        call_args = mock_base_ops._client.rpush.call_args
        serialized_payload = call_args[0][1]
        deserialized = json.loads(serialized_payload)
        assert deserialized["task"] == task
        assert deserialized["queued_by"] == "agent_contributor"
        assert "queued_at" in deserialized

    def test_push_in_mock_mode_uses_mock_lists(
        self,
        queue_manager_mock_mode: QueueManager,
        contributor_creds: AgentCredentials,
    ) -> None:
        """GIVEN a queue manager in mock mode
        WHEN pushing tasks
        THEN tasks are stored in mock_lists instead of Redis
        """
        # Given
        task1 = {"type": "task1"}
        task2 = {"type": "task2"}

        # When
        result1 = queue_manager_mock_mode.push("tasks", task1, contributor_creds)
        result2 = queue_manager_mock_mode.push("tasks", task2, contributor_creds)

        # Then
        assert result1 == 1
        assert result2 == 2
        assert len(queue_manager_mock_mode._mock_lists["queue:tasks"]) == 2

    def test_push_in_mock_mode_priority_adds_to_front(
        self,
        queue_manager_mock_mode: QueueManager,
        contributor_creds: AgentCredentials,
    ) -> None:
        """GIVEN a queue manager in mock mode with existing tasks
        WHEN pushing a high priority task
        THEN the task is added to the front of the queue
        """
        # Given
        task1 = {"type": "task1"}
        task2 = {"type": "priority_task"}
        queue_manager_mock_mode.push("tasks", task1, contributor_creds)

        # When
        queue_manager_mock_mode.push("tasks", task2, contributor_creds, priority=True)

        # Then
        first_envelope = json.loads(queue_manager_mock_mode._mock_lists["queue:tasks"][0])
        assert first_envelope["task"]["type"] == "priority_task"

    def test_push_with_maintainer_access_succeeds(
        self,
        queue_manager: QueueManager,
        maintainer_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue manager and steward credentials
        WHEN pushing a task
        THEN the operation succeeds
        """
        # Given
        task = {"type": "analyze"}
        mock_base_ops._client.rpush.return_value = 1

        # When
        result = queue_manager.push("tasks", task, maintainer_creds)

        # Then
        assert result == 1

    def test_push_with_empty_task(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue manager and empty task dictionary
        WHEN pushing the empty task
        THEN it is successfully stored
        """
        # Given
        task = {}
        mock_base_ops._client.rpush.return_value = 1

        # When
        result = queue_manager.push("tasks", task, contributor_creds)

        # Then
        assert result == 1


class TestQueueManagerPop:
    """Tests for QueueManager.pop method."""

    def test_pop_with_contributor_access_no_timeout(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue with tasks and contributor credentials
        WHEN popping without timeout
        THEN the full envelope is returned
        """
        # Given
        task_data = {"type": "analyze", "file": "main.py"}
        envelope = {
            "task": task_data,
            "queued_by": "agent_contributor",
            "queued_at": "2026-01-01T00:00:00",
        }
        mock_base_ops._client.lpop.return_value = json.dumps(envelope)

        # When
        result = queue_manager.pop("tasks", contributor_creds)

        # Then
        assert result == envelope
        assert result["task"] == task_data
        mock_base_ops._client.lpop.assert_called_once_with("queue:tasks")

    def test_pop_with_contributor_access_with_timeout(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue with tasks and contributor credentials
        WHEN popping with timeout
        THEN blocking pop is used and the full envelope is returned
        """
        # Given
        task_data = {"type": "analyze", "file": "main.py"}
        envelope = {
            "task": task_data,
            "queued_by": "agent_contributor",
            "queued_at": "2026-01-01T00:00:00",
        }
        mock_base_ops._client.blpop.return_value = (
            "queue:tasks",
            json.dumps(envelope),
        )

        # When
        result = queue_manager.pop("tasks", contributor_creds, timeout=5)

        # Then
        assert result == envelope
        assert result["task"] == task_data
        mock_base_ops._client.blpop.assert_called_once_with("queue:tasks", timeout=5)

    def test_pop_with_observer_access_succeeds(
        self,
        queue_manager: QueueManager,
        reader_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue manager and observer credentials
        WHEN popping a task
        THEN the operation succeeds (pop has no permission check)
        """
        # Given
        envelope = {
            "task": {"type": "analyze"},
            "queued_by": "agent_contributor",
            "queued_at": "2026-01-01T00:00:00",
        }
        mock_base_ops._client.lpop.return_value = json.dumps(envelope)

        # When
        result = queue_manager.pop("tasks", reader_creds)

        # Then
        assert result == envelope
        mock_base_ops._client.lpop.assert_called_once_with("queue:tasks")

    def test_pop_empty_queue_returns_none(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN an empty queue
        WHEN popping
        THEN None is returned
        """
        # Given
        mock_base_ops._client.lpop.return_value = None

        # When
        result = queue_manager.pop("tasks", contributor_creds)

        # Then
        assert result is None

    def test_pop_with_timeout_empty_queue_returns_none(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN an empty queue
        WHEN popping with timeout
        THEN None is returned after timeout
        """
        # Given
        mock_base_ops._client.blpop.return_value = None

        # When
        result = queue_manager.pop("tasks", contributor_creds, timeout=1)

        # Then
        assert result is None

    def test_pop_deserializes_json_envelope(
        self,
        queue_manager: QueueManager,
        contributor_creds: AgentCredentials,
        mock_base_ops: Mock,
    ) -> None:
        """GIVEN a queue with serialized JSON envelopes
        WHEN popping
        THEN the envelope is deserialized from JSON with task, queued_by, queued_at
        """
        # Given
        task_data = {"type": "analyze", "nested": {"key": "value"}}
        envelope = {
            "task": task_data,
            "queued_by": "agent_contributor",
            "queued_at": "2026-01-01T00:00:00",
        }
        mock_base_ops._client.lpop.return_value = json.dumps(envelope)

        # When
        result = queue_manager.pop("tasks", contributor_creds)

        # Then
        assert result == envelope
        assert isinstance(result, dict)
        assert result["task"] == task_data
        assert result["queued_by"] == "agent_contributor"
        assert "queued_at" in result

    def test_pop_in_mock_mode_uses_mock_lists(
        self,
        queue_manager_mock_mode: QueueManager,
        contributor_creds: AgentCredentials,
    ) -> None:
        """GIVEN a queue manager in mock mode with tasks
        WHEN popping tasks
        THEN tasks are removed from mock_lists and envelope is returned
        """
        # Given
        task1 = {"type": "task1"}
        task2 = {"type": "task2"}
        queue_manager_mock_mode.push("tasks", task1, contributor_creds)
        queue_manager_mock_mode.push("tasks", task2, contributor_creds)

        # When
        result = queue_manager_mock_mode.pop("tasks", contributor_creds)

        # Then
        assert result is not None
        assert result["task"] == task1
        assert result["queued_by"] == "agent_contributor"
        assert "queued_at" in result
        assert len(queue_manager_mock_mode._mock_lists["queue:tasks"]) == 1
